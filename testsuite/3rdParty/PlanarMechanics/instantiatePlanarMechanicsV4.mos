// name: PlanarMechanicsV4.Examples.* [instantiateModel]
// status: correct
// teardown_command: rm -rf *PlanarMechanicsV4.Examples*
// provided by Dirk Zimmer with changes from Francesco Casella
//


loadModel(Modelica, {"3.1"}); getErrorString();
loadFile("PlanarMechanicsV4.mo"); getErrorString();

instantiateModel(PlanarMechanicsV4.Examples.FreeBody); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.Pendulum); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.CraneCrab); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.DoublePendulum); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.PistonEngine); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.KinematicLoop); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.FreeWheel); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.FreeWheelwithFriction); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.TestIdealWheel); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.TestDryFrictionWheel); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.TestSlipBasedWheel); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.WheelBasedCranCrab); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.CounterSpin); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.SingleTrackWithEngine); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.SingleTrackFixedSteering); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.SingleTrackFixedSteeringFriction); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.SimpleCarWithDifferentialGear); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.TwoTrackStaticLoad); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.TwoTrackStaticLoad3D); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.ControlledCraneCrab); getErrorString();
instantiateModel(PlanarMechanicsV4.Examples.InvertedCraneCrab); getErrorString();


// Result:
// true
// ""
// true
// "[PlanarMechanicsV4.mo:4039:24-4039:26:writable] Warning: Treating .8 as 0.8. This is not standard Modelica and only done for compatibility with old code. Support for this feature may be removed in the future.
// [PlanarMechanicsV4.mo:4057:24-4057:26:writable] Warning: Treating .8 as 0.8. This is not standard Modelica and only done for compatibility with old code. Support for this feature may be removed in the future.
// [PlanarMechanicsV4.mo:4475:24-4475:26:writable] Warning: Treating .8 as 0.8. This is not standard Modelica and only done for compatibility with old code. Support for this feature may be removed in the future.
// [PlanarMechanicsV4.mo:4502:24-4502:26:writable] Warning: Treating .8 as 0.8. This is not standard Modelica and only done for compatibility with old code. Support for this feature may be removed in the future.
// [PlanarMechanicsV4.mo:5781:24-5781:26:writable] Warning: Treating .8 as 0.8. This is not standard Modelica and only done for compatibility with old code. Support for this feature may be removed in the future.
// "
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.FreeBody
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   body.frame_a.t = 0.0;
//   body.frame_a.fy = 0.0;
//   body.frame_a.fx = 0.0;
// end PlanarMechanicsV4.Examples.FreeBody;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.Pendulum
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
// end PlanarMechanicsV4.Examples.Pendulum;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.CraneCrab
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.5 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -2.7925268031909;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = -1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0);
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real damper.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real damper.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real damper.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real damper.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real damper.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real damper.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real damper.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real damper.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real damper.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real damper.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real damper.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real damper.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real damper.d(quantity = \"TranslationalDampingConstant\", unit = \"N.s/m\") = 5.0;
//   Real damper.r0[1](quantity = \"Length\", unit = \"m\");
//   Real damper.r0[2](quantity = \"Length\", unit = \"m\");
//   Real damper.d0[1];
//   Real damper.d0[2];
//   Real damper.vx(quantity = \"Velocity\", unit = \"m/s\");
//   Real damper.vy(quantity = \"Velocity\", unit = \"m/s\");
//   Real damper.v(quantity = \"Velocity\", unit = \"m/s\");
//   Real damper.f(quantity = \"Force\", unit = \"N\");
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
//   prismatic.s = prismatic.s_start;
//   prismatic.v = prismatic.v_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.r0[1] = prismatic.s * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]);
//   prismatic.r0[2] = prismatic.s * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]);
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]) + prismatic.frame_a.fy * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   damper.frame_a.x + damper.r0[1] = damper.frame_b.x;
//   damper.frame_b.y + damper.r0[2] = damper.frame_b.y;
//   damper.d0 = Modelica.Math.Vectors.normalize({damper.r0[1],damper.r0[2]},1e-13);
//   der(damper.frame_a.x) + damper.vx = der(damper.frame_b.x);
//   der(damper.frame_a.y) + damper.vy = der(damper.frame_b.y);
//   damper.v = damper.vx * damper.d0[1] + damper.vy * damper.d0[2];
//   damper.f = (-damper.d) * damper.v;
//   damper.frame_a.fx = damper.d0[1] * damper.f;
//   damper.frame_a.fy = damper.d0[2] * damper.f;
//   damper.frame_a.t = 0.0;
//   damper.frame_a.fx + damper.frame_b.fx = 0.0;
//   damper.frame_a.fy + damper.frame_b.fy = 0.0;
//   damper.frame_a.t + damper.frame_b.t = 0.0;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   revolute.frame_a.t + prismatic.frame_b.t + body1.frame_a.t + damper.frame_b.t = 0.0;
//   revolute.frame_a.fy + prismatic.frame_b.fy + body1.frame_a.fy + damper.frame_b.fy = 0.0;
//   revolute.frame_a.fx + prismatic.frame_b.fx + body1.frame_a.fx + damper.frame_b.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   fixed.frame_a.t + prismatic.frame_a.t + damper.frame_a.t = 0.0;
//   fixed.frame_a.fy + prismatic.frame_a.fy + damper.frame_a.fy = 0.0;
//   fixed.frame_a.fx + prismatic.frame_a.fx + damper.frame_a.fx = 0.0;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   damper.frame_a.x = fixed.frame_a.x;
//   damper.frame_a.x = prismatic.frame_a.x;
//   damper.frame_a.y = fixed.frame_a.y;
//   damper.frame_a.y = prismatic.frame_a.y;
//   damper.frame_a.phi = fixed.frame_a.phi;
//   damper.frame_a.phi = prismatic.frame_a.phi;
//   body1.frame_a.x = damper.frame_b.x;
//   body1.frame_a.x = prismatic.frame_b.x;
//   body1.frame_a.x = revolute.frame_a.x;
//   body1.frame_a.y = damper.frame_b.y;
//   body1.frame_a.y = prismatic.frame_b.y;
//   body1.frame_a.y = revolute.frame_a.y;
//   body1.frame_a.phi = damper.frame_b.phi;
//   body1.frame_a.phi = prismatic.frame_b.phi;
//   body1.frame_a.phi = revolute.frame_a.phi;
// end PlanarMechanicsV4.Examples.CraneCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.DoublePendulum
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.2 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.01 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real revolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute1.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute1.animate = true \"enable Animation\";
//   parameter Boolean revolute1.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1],revolute1.cylinder.lengthDirection[2],revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = \"1\") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = \"1\") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = \"1\") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.4 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real body2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body2.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body2.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body2.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body2.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body2.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body2.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body2.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body2.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body2.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body2.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body2.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body2.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body2.animate = true \"enable Animation\";
//   parameter String body2.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body2.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.r[1](quantity = \"Length\", unit = \"m\") = body2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[2](quantity = \"Length\", unit = \"m\") = body2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body2.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body2.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body2.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body2.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body2.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body2.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body2.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body2.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body2.sphere.lengthDirection[1],body2.sphere.lengthDirection[2],body2.sphere.lengthDirection[3]});
//   protected Real body2.sphere.e_x[1](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 1.0 else body2.sphere.lengthDirection[1] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[2](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[2] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[3](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[3] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.n_z_aux[1](unit = \"1\") = body2.sphere.e_x[2] * body2.sphere.widthDirection[3] - body2.sphere.e_x[3] * body2.sphere.widthDirection[2];
//   protected Real body2.sphere.n_z_aux[2](unit = \"1\") = body2.sphere.e_x[3] * body2.sphere.widthDirection[1] - body2.sphere.e_x[1] * body2.sphere.widthDirection[3];
//   protected Real body2.sphere.n_z_aux[3](unit = \"1\") = body2.sphere.e_x[1] * body2.sphere.widthDirection[2] - body2.sphere.e_x[2] * body2.sphere.widthDirection[1];
//   protected Real body2.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[1];
//   protected Real body2.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[2];
//   protected Real body2.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[3];
//   protected output Real body2.sphere.Form;
//   output Real body2.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body2.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.Material;
//   protected output Real body2.sphere.Extra;
//   Real revolute2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute2.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute2.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute2.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute2.animate = true \"enable Animation\";
//   parameter Boolean revolute2.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute2.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute2.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute2.cylinder.lengthDirection[1],revolute2.cylinder.lengthDirection[2],revolute2.cylinder.lengthDirection[3]});
//   protected Real revolute2.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 1.0 else revolute2.cylinder.lengthDirection[1] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 0.0 else revolute2.cylinder.lengthDirection[2] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 0.0 else revolute2.cylinder.lengthDirection[3] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.n_z_aux[1](unit = \"1\") = revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[3] - revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[2];
//   protected Real revolute2.cylinder.n_z_aux[2](unit = \"1\") = revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[1] - revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[3];
//   protected Real revolute2.cylinder.n_z_aux[3](unit = \"1\") = revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[2] - revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[1];
//   protected Real revolute2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[1];
//   protected Real revolute2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[2];
//   protected Real revolute2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[3];
//   protected output Real revolute2.cylinder.Form;
//   output Real revolute2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.Material;
//   protected output Real revolute2.cylinder.Extra;
//   Real fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation2.r[1] ^ 2.0 + fixedTranslation2.r[2] ^ 2.0);
//   parameter String fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation2.r0[1] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation2.r0[2] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation2.l \"Length of visual object\";
//   input Real fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation2.cylinder.lengthDirection[1],fixedTranslation2.cylinder.lengthDirection[2],fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation2.cylinder.lengthDirection[1] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.cylinder.lengthDirection[2] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.cylinder.lengthDirection[3] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[3] - fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[2];
//   protected Real fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[1] - fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[3];
//   protected Real fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[2] - fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[1];
//   protected Real fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation2.cylinder.Form;
//   output Real fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.Material;
//   protected output Real fixedTranslation2.cylinder.Extra;
//   Real fixed1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body3.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.2 \"mass of the body\";
//   parameter Real body3.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.01 \"Inertia of the Body\";
//   parameter Real body3.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body3.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body3.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body3.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body3.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body3.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body3.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body3.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body3.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body3.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body3.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body3.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body3.animate = true \"enable Animation\";
//   parameter String body3.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body3.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.sphere.r[1](quantity = \"Length\", unit = \"m\") = body3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.sphere.r[2](quantity = \"Length\", unit = \"m\") = body3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body3.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body3.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body3.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body3.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body3.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body3.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body3.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body3.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body3.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body3.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body3.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body3.sphere.lengthDirection[1],body3.sphere.lengthDirection[2],body3.sphere.lengthDirection[3]});
//   protected Real body3.sphere.e_x[1](unit = \"1\") = if noEvent(body3.sphere.abs_n_x < 1e-10) then 1.0 else body3.sphere.lengthDirection[1] / body3.sphere.abs_n_x;
//   protected Real body3.sphere.e_x[2](unit = \"1\") = if noEvent(body3.sphere.abs_n_x < 1e-10) then 0.0 else body3.sphere.lengthDirection[2] / body3.sphere.abs_n_x;
//   protected Real body3.sphere.e_x[3](unit = \"1\") = if noEvent(body3.sphere.abs_n_x < 1e-10) then 0.0 else body3.sphere.lengthDirection[3] / body3.sphere.abs_n_x;
//   protected Real body3.sphere.n_z_aux[1](unit = \"1\") = body3.sphere.e_x[2] * body3.sphere.widthDirection[3] - body3.sphere.e_x[3] * body3.sphere.widthDirection[2];
//   protected Real body3.sphere.n_z_aux[2](unit = \"1\") = body3.sphere.e_x[3] * body3.sphere.widthDirection[1] - body3.sphere.e_x[1] * body3.sphere.widthDirection[3];
//   protected Real body3.sphere.n_z_aux[3](unit = \"1\") = body3.sphere.e_x[1] * body3.sphere.widthDirection[2] - body3.sphere.e_x[2] * body3.sphere.widthDirection[1];
//   protected Real body3.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]},if noEvent(body3.sphere.n_z_aux[1] ^ 2.0 + (body3.sphere.n_z_aux[2] ^ 2.0 + body3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.sphere.widthDirection[1],body3.sphere.widthDirection[2],body3.sphere.widthDirection[3]} else if noEvent(abs(body3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]})[1];
//   protected Real body3.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]},if noEvent(body3.sphere.n_z_aux[1] ^ 2.0 + (body3.sphere.n_z_aux[2] ^ 2.0 + body3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.sphere.widthDirection[1],body3.sphere.widthDirection[2],body3.sphere.widthDirection[3]} else if noEvent(abs(body3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]})[2];
//   protected Real body3.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]},if noEvent(body3.sphere.n_z_aux[1] ^ 2.0 + (body3.sphere.n_z_aux[2] ^ 2.0 + body3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.sphere.widthDirection[1],body3.sphere.widthDirection[2],body3.sphere.widthDirection[3]} else if noEvent(abs(body3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]})[3];
//   protected output Real body3.sphere.Form;
//   output Real body3.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body3.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body3.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body3.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.sphere.Material;
//   protected output Real body3.sphere.Extra;
//   Real revolute3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute3.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute3.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 1.7453292519943e-05;
//   parameter Real revolute3.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute3.animate = true \"enable Animation\";
//   parameter Boolean revolute3.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute3.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute3.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute3.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute3.cylinder.lengthDirection[1],revolute3.cylinder.lengthDirection[2],revolute3.cylinder.lengthDirection[3]});
//   protected Real revolute3.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 1e-10) then 1.0 else revolute3.cylinder.lengthDirection[1] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 1e-10) then 0.0 else revolute3.cylinder.lengthDirection[2] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 1e-10) then 0.0 else revolute3.cylinder.lengthDirection[3] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.n_z_aux[1](unit = \"1\") = revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[3] - revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[2];
//   protected Real revolute3.cylinder.n_z_aux[2](unit = \"1\") = revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[1] - revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[3];
//   protected Real revolute3.cylinder.n_z_aux[3](unit = \"1\") = revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[2] - revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[1];
//   protected Real revolute3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[1];
//   protected Real revolute3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[2];
//   protected Real revolute3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[3];
//   protected output Real revolute3.cylinder.Form;
//   output Real revolute3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.Material;
//   protected output Real revolute3.cylinder.Extra;
//   Real fixedTranslation3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation3.r[1](quantity = \"Length\", unit = \"m\") = 0.4 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation3.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation3.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation3.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation3.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation3.r[1] ^ 2.0 + fixedTranslation3.r[2] ^ 2.0);
//   parameter String fixedTranslation3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation3.r0[1] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation3.r0[2] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation3.l \"Length of visual object\";
//   input Real fixedTranslation3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation3.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation3.cylinder.lengthDirection[1],fixedTranslation3.cylinder.lengthDirection[2],fixedTranslation3.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation3.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation3.cylinder.lengthDirection[1] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.cylinder.lengthDirection[2] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.cylinder.lengthDirection[3] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[3] - fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[2];
//   protected Real fixedTranslation3.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[1] - fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[3];
//   protected Real fixedTranslation3.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[2] - fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[1];
//   protected Real fixedTranslation3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation3.cylinder.Form;
//   output Real fixedTranslation3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.Material;
//   protected output Real fixedTranslation3.cylinder.Extra;
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
//   revolute1.phi = revolute1.phi_start;
//   revolute1.w = revolute1.w_start;
//   revolute2.phi = revolute2.phi_start;
//   revolute2.w = revolute2.w_start;
//   revolute3.phi = revolute3.phi_start;
//   revolute3.w = revolute3.w_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1],revolute1.cylinder.R.T[1,2],revolute1.cylinder.R.T[1,3]},{revolute1.cylinder.R.T[2,1],revolute1.cylinder.R.T[2,2],revolute1.cylinder.R.T[2,3]},{revolute1.cylinder.R.T[3,1],revolute1.cylinder.R.T[3,2],revolute1.cylinder.R.T[3,3]}},{revolute1.cylinder.r_shape[1],revolute1.cylinder.r_shape[2],revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0,revolute1.cylinder.color[2] / 255.0,revolute1.cylinder.color[3] / 255.0,revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   revolute1.w = der(revolute1.phi);
//   revolute1.z = der(revolute1.w);
//   revolute1.t = 0.0;
//   revolute1.frame_a.x = revolute1.frame_b.x;
//   revolute1.frame_a.y = revolute1.frame_b.y;
//   revolute1.frame_a.phi + revolute1.phi = revolute1.frame_b.phi;
//   revolute1.frame_a.fx + revolute1.frame_b.fx = 0.0;
//   revolute1.frame_a.fy + revolute1.frame_b.fy = 0.0;
//   revolute1.frame_a.t + revolute1.frame_b.t = 0.0;
//   revolute1.frame_a.t = revolute1.t;
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   body2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.sphere.shapeType);
//   body2.sphere.rxvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_x[1] + body2.sphere.R.T[2,1] * body2.sphere.e_x[2] + body2.sphere.R.T[3,1] * body2.sphere.e_x[3];
//   body2.sphere.rxvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_x[1] + body2.sphere.R.T[2,2] * body2.sphere.e_x[2] + body2.sphere.R.T[3,2] * body2.sphere.e_x[3];
//   body2.sphere.rxvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_x[1] + body2.sphere.R.T[2,3] * body2.sphere.e_x[2] + body2.sphere.R.T[3,3] * body2.sphere.e_x[3];
//   body2.sphere.ryvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_y[1] + body2.sphere.R.T[2,1] * body2.sphere.e_y[2] + body2.sphere.R.T[3,1] * body2.sphere.e_y[3];
//   body2.sphere.ryvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_y[1] + body2.sphere.R.T[2,2] * body2.sphere.e_y[2] + body2.sphere.R.T[3,2] * body2.sphere.e_y[3];
//   body2.sphere.ryvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_y[1] + body2.sphere.R.T[2,3] * body2.sphere.e_y[2] + body2.sphere.R.T[3,3] * body2.sphere.e_y[3];
//   body2.sphere.rvisobj = body2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.sphere.R.T[1,1],body2.sphere.R.T[1,2],body2.sphere.R.T[1,3]},{body2.sphere.R.T[2,1],body2.sphere.R.T[2,2],body2.sphere.R.T[2,3]},{body2.sphere.R.T[3,1],body2.sphere.R.T[3,2],body2.sphere.R.T[3,3]}},{body2.sphere.r_shape[1],body2.sphere.r_shape[2],body2.sphere.r_shape[3]});
//   body2.sphere.size[1] = body2.sphere.length;
//   body2.sphere.size[2] = body2.sphere.width;
//   body2.sphere.size[3] = body2.sphere.height;
//   body2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.sphere.color[1] / 255.0,body2.sphere.color[2] / 255.0,body2.sphere.color[3] / 255.0,body2.sphere.specularCoefficient);
//   body2.sphere.Extra = body2.sphere.extra;
//   body2.r[1] = body2.frame_a.x;
//   body2.r[2] = body2.frame_a.y;
//   body2.v[1] = der(body2.r[1]);
//   body2.v[2] = der(body2.r[2]);
//   body2.w = der(body2.frame_a.phi);
//   body2.a[1] = der(body2.v[1]);
//   body2.a[2] = der(body2.v[2]);
//   body2.z = der(body2.w);
//   body2.f[1] = body2.frame_a.fx;
//   body2.f[2] = body2.frame_a.fy;
//   body2.f[1] + body2.m * body2.g[1] = body2.m * body2.a[1];
//   body2.f[2] + body2.m * body2.g[2] = body2.m * body2.a[2];
//   body2.frame_a.t = body2.I * body2.z;
//   revolute2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute2.cylinder.shapeType);
//   revolute2.cylinder.rxvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.ryvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.rvisobj = revolute2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute2.cylinder.R.T[1,1],revolute2.cylinder.R.T[1,2],revolute2.cylinder.R.T[1,3]},{revolute2.cylinder.R.T[2,1],revolute2.cylinder.R.T[2,2],revolute2.cylinder.R.T[2,3]},{revolute2.cylinder.R.T[3,1],revolute2.cylinder.R.T[3,2],revolute2.cylinder.R.T[3,3]}},{revolute2.cylinder.r_shape[1],revolute2.cylinder.r_shape[2],revolute2.cylinder.r_shape[3]});
//   revolute2.cylinder.size[1] = revolute2.cylinder.length;
//   revolute2.cylinder.size[2] = revolute2.cylinder.width;
//   revolute2.cylinder.size[3] = revolute2.cylinder.height;
//   revolute2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute2.cylinder.color[1] / 255.0,revolute2.cylinder.color[2] / 255.0,revolute2.cylinder.color[3] / 255.0,revolute2.cylinder.specularCoefficient);
//   revolute2.cylinder.Extra = revolute2.cylinder.extra;
//   revolute2.w = der(revolute2.phi);
//   revolute2.z = der(revolute2.w);
//   revolute2.t = 0.0;
//   revolute2.frame_a.x = revolute2.frame_b.x;
//   revolute2.frame_a.y = revolute2.frame_b.y;
//   revolute2.frame_a.phi + revolute2.phi = revolute2.frame_b.phi;
//   revolute2.frame_a.fx + revolute2.frame_b.fx = 0.0;
//   revolute2.frame_a.fy + revolute2.frame_b.fy = 0.0;
//   revolute2.frame_a.t + revolute2.frame_b.t = 0.0;
//   revolute2.frame_a.t = revolute2.t;
//   fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.cylinder.shapeType);
//   fixedTranslation2.cylinder.rxvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.ryvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.rvisobj = fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.cylinder.R.T[1,1],fixedTranslation2.cylinder.R.T[1,2],fixedTranslation2.cylinder.R.T[1,3]},{fixedTranslation2.cylinder.R.T[2,1],fixedTranslation2.cylinder.R.T[2,2],fixedTranslation2.cylinder.R.T[2,3]},{fixedTranslation2.cylinder.R.T[3,1],fixedTranslation2.cylinder.R.T[3,2],fixedTranslation2.cylinder.R.T[3,3]}},{fixedTranslation2.cylinder.r_shape[1],fixedTranslation2.cylinder.r_shape[2],fixedTranslation2.cylinder.r_shape[3]});
//   fixedTranslation2.cylinder.size[1] = fixedTranslation2.cylinder.length;
//   fixedTranslation2.cylinder.size[2] = fixedTranslation2.cylinder.width;
//   fixedTranslation2.cylinder.size[3] = fixedTranslation2.cylinder.height;
//   fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.cylinder.color[1] / 255.0,fixedTranslation2.cylinder.color[2] / 255.0,fixedTranslation2.cylinder.color[3] / 255.0,fixedTranslation2.cylinder.specularCoefficient);
//   fixedTranslation2.cylinder.Extra = fixedTranslation2.cylinder.extra;
//   fixedTranslation2.R[1,1] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[1,2] = sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,1] = -sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,2] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.r0[1] = fixedTranslation2.R[1,1] * fixedTranslation2.r[1] + fixedTranslation2.R[1,2] * fixedTranslation2.r[2];
//   fixedTranslation2.r0[2] = fixedTranslation2.R[2,1] * fixedTranslation2.r[1] + fixedTranslation2.R[2,2] * fixedTranslation2.r[2];
//   fixedTranslation2.frame_a.x + fixedTranslation2.r0[1] = fixedTranslation2.frame_b.x;
//   fixedTranslation2.frame_a.y + fixedTranslation2.r0[2] = fixedTranslation2.frame_b.y;
//   fixedTranslation2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   fixedTranslation2.frame_a.fx + fixedTranslation2.frame_b.fx = 0.0;
//   fixedTranslation2.frame_a.fy + fixedTranslation2.frame_b.fy = 0.0;
//   fixedTranslation2.frame_a.t + (fixedTranslation2.frame_b.t + ((-fixedTranslation2.r0[1]) * fixedTranslation2.frame_b.fy + fixedTranslation2.r0[2] * fixedTranslation2.frame_b.fx)) = 0.0;
//   fixed1.frame_a.x = fixed1.r[1];
//   fixed1.frame_a.y = fixed1.r[2];
//   fixed1.frame_a.phi = fixed1.phi;
//   body3.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body3.sphere.shapeType);
//   body3.sphere.rxvisobj[1] = body3.sphere.R.T[1,1] * body3.sphere.e_x[1] + body3.sphere.R.T[2,1] * body3.sphere.e_x[2] + body3.sphere.R.T[3,1] * body3.sphere.e_x[3];
//   body3.sphere.rxvisobj[2] = body3.sphere.R.T[1,2] * body3.sphere.e_x[1] + body3.sphere.R.T[2,2] * body3.sphere.e_x[2] + body3.sphere.R.T[3,2] * body3.sphere.e_x[3];
//   body3.sphere.rxvisobj[3] = body3.sphere.R.T[1,3] * body3.sphere.e_x[1] + body3.sphere.R.T[2,3] * body3.sphere.e_x[2] + body3.sphere.R.T[3,3] * body3.sphere.e_x[3];
//   body3.sphere.ryvisobj[1] = body3.sphere.R.T[1,1] * body3.sphere.e_y[1] + body3.sphere.R.T[2,1] * body3.sphere.e_y[2] + body3.sphere.R.T[3,1] * body3.sphere.e_y[3];
//   body3.sphere.ryvisobj[2] = body3.sphere.R.T[1,2] * body3.sphere.e_y[1] + body3.sphere.R.T[2,2] * body3.sphere.e_y[2] + body3.sphere.R.T[3,2] * body3.sphere.e_y[3];
//   body3.sphere.ryvisobj[3] = body3.sphere.R.T[1,3] * body3.sphere.e_y[1] + body3.sphere.R.T[2,3] * body3.sphere.e_y[2] + body3.sphere.R.T[3,3] * body3.sphere.e_y[3];
//   body3.sphere.rvisobj = body3.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body3.sphere.R.T[1,1],body3.sphere.R.T[1,2],body3.sphere.R.T[1,3]},{body3.sphere.R.T[2,1],body3.sphere.R.T[2,2],body3.sphere.R.T[2,3]},{body3.sphere.R.T[3,1],body3.sphere.R.T[3,2],body3.sphere.R.T[3,3]}},{body3.sphere.r_shape[1],body3.sphere.r_shape[2],body3.sphere.r_shape[3]});
//   body3.sphere.size[1] = body3.sphere.length;
//   body3.sphere.size[2] = body3.sphere.width;
//   body3.sphere.size[3] = body3.sphere.height;
//   body3.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body3.sphere.color[1] / 255.0,body3.sphere.color[2] / 255.0,body3.sphere.color[3] / 255.0,body3.sphere.specularCoefficient);
//   body3.sphere.Extra = body3.sphere.extra;
//   body3.r[1] = body3.frame_a.x;
//   body3.r[2] = body3.frame_a.y;
//   body3.v[1] = der(body3.r[1]);
//   body3.v[2] = der(body3.r[2]);
//   body3.w = der(body3.frame_a.phi);
//   body3.a[1] = der(body3.v[1]);
//   body3.a[2] = der(body3.v[2]);
//   body3.z = der(body3.w);
//   body3.f[1] = body3.frame_a.fx;
//   body3.f[2] = body3.frame_a.fy;
//   body3.f[1] + body3.m * body3.g[1] = body3.m * body3.a[1];
//   body3.f[2] + body3.m * body3.g[2] = body3.m * body3.a[2];
//   body3.frame_a.t = body3.I * body3.z;
//   revolute3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute3.cylinder.shapeType);
//   revolute3.cylinder.rxvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.ryvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.rvisobj = revolute3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute3.cylinder.R.T[1,1],revolute3.cylinder.R.T[1,2],revolute3.cylinder.R.T[1,3]},{revolute3.cylinder.R.T[2,1],revolute3.cylinder.R.T[2,2],revolute3.cylinder.R.T[2,3]},{revolute3.cylinder.R.T[3,1],revolute3.cylinder.R.T[3,2],revolute3.cylinder.R.T[3,3]}},{revolute3.cylinder.r_shape[1],revolute3.cylinder.r_shape[2],revolute3.cylinder.r_shape[3]});
//   revolute3.cylinder.size[1] = revolute3.cylinder.length;
//   revolute3.cylinder.size[2] = revolute3.cylinder.width;
//   revolute3.cylinder.size[3] = revolute3.cylinder.height;
//   revolute3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute3.cylinder.color[1] / 255.0,revolute3.cylinder.color[2] / 255.0,revolute3.cylinder.color[3] / 255.0,revolute3.cylinder.specularCoefficient);
//   revolute3.cylinder.Extra = revolute3.cylinder.extra;
//   revolute3.w = der(revolute3.phi);
//   revolute3.z = der(revolute3.w);
//   revolute3.t = 0.0;
//   revolute3.frame_a.x = revolute3.frame_b.x;
//   revolute3.frame_a.y = revolute3.frame_b.y;
//   revolute3.frame_a.phi + revolute3.phi = revolute3.frame_b.phi;
//   revolute3.frame_a.fx + revolute3.frame_b.fx = 0.0;
//   revolute3.frame_a.fy + revolute3.frame_b.fy = 0.0;
//   revolute3.frame_a.t + revolute3.frame_b.t = 0.0;
//   revolute3.frame_a.t = revolute3.t;
//   fixedTranslation3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.cylinder.shapeType);
//   fixedTranslation3.cylinder.rxvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.ryvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.rvisobj = fixedTranslation3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.cylinder.R.T[1,1],fixedTranslation3.cylinder.R.T[1,2],fixedTranslation3.cylinder.R.T[1,3]},{fixedTranslation3.cylinder.R.T[2,1],fixedTranslation3.cylinder.R.T[2,2],fixedTranslation3.cylinder.R.T[2,3]},{fixedTranslation3.cylinder.R.T[3,1],fixedTranslation3.cylinder.R.T[3,2],fixedTranslation3.cylinder.R.T[3,3]}},{fixedTranslation3.cylinder.r_shape[1],fixedTranslation3.cylinder.r_shape[2],fixedTranslation3.cylinder.r_shape[3]});
//   fixedTranslation3.cylinder.size[1] = fixedTranslation3.cylinder.length;
//   fixedTranslation3.cylinder.size[2] = fixedTranslation3.cylinder.width;
//   fixedTranslation3.cylinder.size[3] = fixedTranslation3.cylinder.height;
//   fixedTranslation3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.cylinder.color[1] / 255.0,fixedTranslation3.cylinder.color[2] / 255.0,fixedTranslation3.cylinder.color[3] / 255.0,fixedTranslation3.cylinder.specularCoefficient);
//   fixedTranslation3.cylinder.Extra = fixedTranslation3.cylinder.extra;
//   fixedTranslation3.R[1,1] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[1,2] = sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,1] = -sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,2] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.r0[1] = fixedTranslation3.R[1,1] * fixedTranslation3.r[1] + fixedTranslation3.R[1,2] * fixedTranslation3.r[2];
//   fixedTranslation3.r0[2] = fixedTranslation3.R[2,1] * fixedTranslation3.r[1] + fixedTranslation3.R[2,2] * fixedTranslation3.r[2];
//   fixedTranslation3.frame_a.x + fixedTranslation3.r0[1] = fixedTranslation3.frame_b.x;
//   fixedTranslation3.frame_a.y + fixedTranslation3.r0[2] = fixedTranslation3.frame_b.y;
//   fixedTranslation3.frame_a.phi = fixedTranslation3.frame_b.phi;
//   fixedTranslation3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation3.frame_a.t + (fixedTranslation3.frame_b.t + ((-fixedTranslation3.r0[1]) * fixedTranslation3.frame_b.fy + fixedTranslation3.r0[2] * fixedTranslation3.frame_b.fx)) = 0.0;
//   body.frame_a.t + fixedTranslation.frame_b.t + revolute1.frame_a.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy + revolute1.frame_a.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx + revolute1.frame_a.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   body1.frame_a.t + fixedTranslation1.frame_b.t = 0.0;
//   body1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   body1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   revolute1.frame_b.t + fixedTranslation1.frame_a.t = 0.0;
//   revolute1.frame_b.fy + fixedTranslation1.frame_a.fy = 0.0;
//   revolute1.frame_b.fx + fixedTranslation1.frame_a.fx = 0.0;
//   body2.frame_a.t + fixedTranslation2.frame_b.t + revolute3.frame_a.t = 0.0;
//   body2.frame_a.fy + fixedTranslation2.frame_b.fy + revolute3.frame_a.fy = 0.0;
//   body2.frame_a.fx + fixedTranslation2.frame_b.fx + revolute3.frame_a.fx = 0.0;
//   revolute2.frame_a.t + fixed1.frame_a.t = 0.0;
//   revolute2.frame_a.fy + fixed1.frame_a.fy = 0.0;
//   revolute2.frame_a.fx + fixed1.frame_a.fx = 0.0;
//   revolute2.frame_b.t + fixedTranslation2.frame_a.t = 0.0;
//   revolute2.frame_b.fy + fixedTranslation2.frame_a.fy = 0.0;
//   revolute2.frame_b.fx + fixedTranslation2.frame_a.fx = 0.0;
//   body3.frame_a.t + fixedTranslation3.frame_b.t = 0.0;
//   body3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   body3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   revolute3.frame_b.t + fixedTranslation3.frame_a.t = 0.0;
//   revolute3.frame_b.fy + fixedTranslation3.frame_a.fy = 0.0;
//   revolute3.frame_b.fx + fixedTranslation3.frame_a.fx = 0.0;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.x = revolute1.frame_a.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.y = revolute1.frame_a.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   body.frame_a.phi = revolute1.frame_a.phi;
//   fixedTranslation1.frame_a.x = revolute1.frame_b.x;
//   fixedTranslation1.frame_a.y = revolute1.frame_b.y;
//   fixedTranslation1.frame_a.phi = revolute1.frame_b.phi;
//   body1.frame_a.x = fixedTranslation1.frame_b.x;
//   body1.frame_a.y = fixedTranslation1.frame_b.y;
//   body1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixed1.frame_a.x = revolute2.frame_a.x;
//   fixed1.frame_a.y = revolute2.frame_a.y;
//   fixed1.frame_a.phi = revolute2.frame_a.phi;
//   fixedTranslation2.frame_a.x = revolute2.frame_b.x;
//   fixedTranslation2.frame_a.y = revolute2.frame_b.y;
//   fixedTranslation2.frame_a.phi = revolute2.frame_b.phi;
//   body2.frame_a.x = fixedTranslation2.frame_b.x;
//   body2.frame_a.x = revolute3.frame_a.x;
//   body2.frame_a.y = fixedTranslation2.frame_b.y;
//   body2.frame_a.y = revolute3.frame_a.y;
//   body2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   body2.frame_a.phi = revolute3.frame_a.phi;
//   fixedTranslation3.frame_a.x = revolute3.frame_b.x;
//   fixedTranslation3.frame_a.y = revolute3.frame_b.y;
//   fixedTranslation3.frame_a.phi = revolute3.frame_b.phi;
//   body3.frame_a.x = fixedTranslation3.frame_b.x;
//   body3.frame_a.y = fixedTranslation3.frame_b.y;
//   body3.frame_a.phi = fixedTranslation3.frame_b.phi;
// end PlanarMechanicsV4.Examples.DoublePendulum;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.PistonEngine
//   Real bodyDrive.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyDrive.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyDrive.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyDrive.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyDrive.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyDrive.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyDrive.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real bodyDrive.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyDrive.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyDrive.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real bodyDrive.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyDrive.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyDrive.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyDrive.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyDrive.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyDrive.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyDrive.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyDrive.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyDrive.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyDrive.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyDrive.animate = true \"enable Animation\";
//   parameter String bodyDrive.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyDrive.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyDrive.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyDrive.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyDrive.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyDrive.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyDrive.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyDrive.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyDrive.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyDrive.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyDrive.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyDrive.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyDrive.sphere.lengthDirection[1],bodyDrive.sphere.lengthDirection[2],bodyDrive.sphere.lengthDirection[3]});
//   protected Real bodyDrive.sphere.e_x[1](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 1e-10) then 1.0 else bodyDrive.sphere.lengthDirection[1] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.e_x[2](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 1e-10) then 0.0 else bodyDrive.sphere.lengthDirection[2] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.e_x[3](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 1e-10) then 0.0 else bodyDrive.sphere.lengthDirection[3] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.n_z_aux[1](unit = \"1\") = bodyDrive.sphere.e_x[2] * bodyDrive.sphere.widthDirection[3] - bodyDrive.sphere.e_x[3] * bodyDrive.sphere.widthDirection[2];
//   protected Real bodyDrive.sphere.n_z_aux[2](unit = \"1\") = bodyDrive.sphere.e_x[3] * bodyDrive.sphere.widthDirection[1] - bodyDrive.sphere.e_x[1] * bodyDrive.sphere.widthDirection[3];
//   protected Real bodyDrive.sphere.n_z_aux[3](unit = \"1\") = bodyDrive.sphere.e_x[1] * bodyDrive.sphere.widthDirection[2] - bodyDrive.sphere.e_x[2] * bodyDrive.sphere.widthDirection[1];
//   protected Real bodyDrive.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[1];
//   protected Real bodyDrive.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[2];
//   protected Real bodyDrive.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[3];
//   protected output Real bodyDrive.sphere.Form;
//   output Real bodyDrive.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyDrive.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.Material;
//   protected output Real bodyDrive.sphere.Extra;
//   Real revoluteDrive.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDrive.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDrive.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDrive.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDrive.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDrive.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revoluteDrive.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDrive.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDrive.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDrive.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDrive.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDrive.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revoluteDrive.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revoluteDrive.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revoluteDrive.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   parameter Boolean revoluteDrive.animate = true \"enable Animation\";
//   parameter Boolean revoluteDrive.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revoluteDrive.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revoluteDrive.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revoluteDrive.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revoluteDrive.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revoluteDrive.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revoluteDrive.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revoluteDrive.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revoluteDrive.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revoluteDrive.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revoluteDrive.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revoluteDrive.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revoluteDrive.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revoluteDrive.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revoluteDrive.cylinder.lengthDirection[1],revoluteDrive.cylinder.lengthDirection[2],revoluteDrive.cylinder.lengthDirection[3]});
//   protected Real revoluteDrive.cylinder.e_x[1](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 1e-10) then 1.0 else revoluteDrive.cylinder.lengthDirection[1] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.e_x[2](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 1e-10) then 0.0 else revoluteDrive.cylinder.lengthDirection[2] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.e_x[3](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 1e-10) then 0.0 else revoluteDrive.cylinder.lengthDirection[3] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.n_z_aux[1](unit = \"1\") = revoluteDrive.cylinder.e_x[2] * revoluteDrive.cylinder.widthDirection[3] - revoluteDrive.cylinder.e_x[3] * revoluteDrive.cylinder.widthDirection[2];
//   protected Real revoluteDrive.cylinder.n_z_aux[2](unit = \"1\") = revoluteDrive.cylinder.e_x[3] * revoluteDrive.cylinder.widthDirection[1] - revoluteDrive.cylinder.e_x[1] * revoluteDrive.cylinder.widthDirection[3];
//   protected Real revoluteDrive.cylinder.n_z_aux[3](unit = \"1\") = revoluteDrive.cylinder.e_x[1] * revoluteDrive.cylinder.widthDirection[2] - revoluteDrive.cylinder.e_x[2] * revoluteDrive.cylinder.widthDirection[1];
//   protected Real revoluteDrive.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[1];
//   protected Real revoluteDrive.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[2];
//   protected Real revoluteDrive.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[3];
//   protected output Real revoluteDrive.cylinder.Form;
//   output Real revoluteDrive.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revoluteDrive.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.Material;
//   protected output Real revoluteDrive.cylinder.Extra;
//   Real fixedTranslationDisc.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslationDisc.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslationDisc.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslationDisc.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslationDisc.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslationDisc.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslationDisc.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslationDisc.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslationDisc.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslationDisc.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslationDisc.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslationDisc.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslationDisc.r[1](quantity = \"Length\", unit = \"m\") = 0.3 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslationDisc.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslationDisc.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslationDisc.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslationDisc.R[1,1] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[1,2] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[2,1] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslationDisc.animate = true \"enable Animation\";
//   final parameter Real fixedTranslationDisc.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslationDisc.r[1] ^ 2.0 + fixedTranslationDisc.r[2] ^ 2.0);
//   parameter String fixedTranslationDisc.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslationDisc.r0[1] / fixedTranslationDisc.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslationDisc.r0[2] / fixedTranslationDisc.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.l \"Length of visual object\";
//   input Real fixedTranslationDisc.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslationDisc.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslationDisc.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslationDisc.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslationDisc.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslationDisc.cylinder.lengthDirection[1],fixedTranslationDisc.cylinder.lengthDirection[2],fixedTranslationDisc.cylinder.lengthDirection[3]});
//   protected Real fixedTranslationDisc.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslationDisc.cylinder.lengthDirection[1] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslationDisc.cylinder.lengthDirection[2] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslationDisc.cylinder.lengthDirection[3] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[2] * fixedTranslationDisc.cylinder.widthDirection[3] - fixedTranslationDisc.cylinder.e_x[3] * fixedTranslationDisc.cylinder.widthDirection[2];
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[3] * fixedTranslationDisc.cylinder.widthDirection[1] - fixedTranslationDisc.cylinder.e_x[1] * fixedTranslationDisc.cylinder.widthDirection[3];
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[1] * fixedTranslationDisc.cylinder.widthDirection[2] - fixedTranslationDisc.cylinder.e_x[2] * fixedTranslationDisc.cylinder.widthDirection[1];
//   protected Real fixedTranslationDisc.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[1];
//   protected Real fixedTranslationDisc.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[2];
//   protected Real fixedTranslationDisc.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslationDisc.cylinder.Form;
//   output Real fixedTranslationDisc.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslationDisc.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.Material;
//   protected output Real fixedTranslationDisc.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0);
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   Real fixed1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real revoluteDisc.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDisc.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDisc.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDisc.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDisc.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDisc.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revoluteDisc.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDisc.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDisc.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDisc.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDisc.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDisc.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revoluteDisc.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revoluteDisc.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revoluteDisc.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revoluteDisc.animate = true \"enable Animation\";
//   parameter Boolean revoluteDisc.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revoluteDisc.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revoluteDisc.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revoluteDisc.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revoluteDisc.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revoluteDisc.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revoluteDisc.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revoluteDisc.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revoluteDisc.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revoluteDisc.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revoluteDisc.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revoluteDisc.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revoluteDisc.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revoluteDisc.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revoluteDisc.cylinder.lengthDirection[1],revoluteDisc.cylinder.lengthDirection[2],revoluteDisc.cylinder.lengthDirection[3]});
//   protected Real revoluteDisc.cylinder.e_x[1](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 1e-10) then 1.0 else revoluteDisc.cylinder.lengthDirection[1] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.e_x[2](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 1e-10) then 0.0 else revoluteDisc.cylinder.lengthDirection[2] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.e_x[3](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 1e-10) then 0.0 else revoluteDisc.cylinder.lengthDirection[3] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.n_z_aux[1](unit = \"1\") = revoluteDisc.cylinder.e_x[2] * revoluteDisc.cylinder.widthDirection[3] - revoluteDisc.cylinder.e_x[3] * revoluteDisc.cylinder.widthDirection[2];
//   protected Real revoluteDisc.cylinder.n_z_aux[2](unit = \"1\") = revoluteDisc.cylinder.e_x[3] * revoluteDisc.cylinder.widthDirection[1] - revoluteDisc.cylinder.e_x[1] * revoluteDisc.cylinder.widthDirection[3];
//   protected Real revoluteDisc.cylinder.n_z_aux[3](unit = \"1\") = revoluteDisc.cylinder.e_x[1] * revoluteDisc.cylinder.widthDirection[2] - revoluteDisc.cylinder.e_x[2] * revoluteDisc.cylinder.widthDirection[1];
//   protected Real revoluteDisc.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[1];
//   protected Real revoluteDisc.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[2];
//   protected Real revoluteDisc.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[3];
//   protected output Real revoluteDisc.cylinder.Form;
//   output Real revoluteDisc.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revoluteDisc.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.Material;
//   protected output Real revoluteDisc.cylinder.Extra;
//   Real pistonRod.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real pistonRod.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real pistonRod.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real pistonRod.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real pistonRod.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real pistonRod.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real pistonRod.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real pistonRod.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real pistonRod.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real pistonRod.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real pistonRod.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real pistonRod.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real pistonRod.r[1](quantity = \"Length\", unit = \"m\") = 0.8 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real pistonRod.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real pistonRod.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real pistonRod.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real pistonRod.R[1,1] \"Rotation matrix\";
//   Real pistonRod.R[1,2] \"Rotation matrix\";
//   Real pistonRod.R[2,1] \"Rotation matrix\";
//   Real pistonRod.R[2,2] \"Rotation matrix\";
//   parameter Boolean pistonRod.animate = true \"enable Animation\";
//   final parameter Real pistonRod.l(quantity = \"Length\", unit = \"m\") = sqrt(pistonRod.r[1] ^ 2.0 + pistonRod.r[2] ^ 2.0);
//   parameter String pistonRod.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real pistonRod.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.r[1](quantity = \"Length\", unit = \"m\") = pistonRod.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r[2](quantity = \"Length\", unit = \"m\") = pistonRod.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[1](unit = \"1\") = pistonRod.r0[1] / pistonRod.l \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[2](unit = \"1\") = pistonRod.r0[2] / pistonRod.l \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.length(quantity = \"Length\", unit = \"m\") = pistonRod.l \"Length of visual object\";
//   input Real pistonRod.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real pistonRod.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real pistonRod.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real pistonRod.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real pistonRod.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({pistonRod.cylinder.lengthDirection[1],pistonRod.cylinder.lengthDirection[2],pistonRod.cylinder.lengthDirection[3]});
//   protected Real pistonRod.cylinder.e_x[1](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 1e-10) then 1.0 else pistonRod.cylinder.lengthDirection[1] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.e_x[2](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 1e-10) then 0.0 else pistonRod.cylinder.lengthDirection[2] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.e_x[3](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 1e-10) then 0.0 else pistonRod.cylinder.lengthDirection[3] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.n_z_aux[1](unit = \"1\") = pistonRod.cylinder.e_x[2] * pistonRod.cylinder.widthDirection[3] - pistonRod.cylinder.e_x[3] * pistonRod.cylinder.widthDirection[2];
//   protected Real pistonRod.cylinder.n_z_aux[2](unit = \"1\") = pistonRod.cylinder.e_x[3] * pistonRod.cylinder.widthDirection[1] - pistonRod.cylinder.e_x[1] * pistonRod.cylinder.widthDirection[3];
//   protected Real pistonRod.cylinder.n_z_aux[3](unit = \"1\") = pistonRod.cylinder.e_x[1] * pistonRod.cylinder.widthDirection[2] - pistonRod.cylinder.e_x[2] * pistonRod.cylinder.widthDirection[1];
//   protected Real pistonRod.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[1];
//   protected Real pistonRod.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[2];
//   protected Real pistonRod.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[3];
//   protected output Real pistonRod.cylinder.Form;
//   output Real pistonRod.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real pistonRod.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.Material;
//   protected output Real pistonRod.cylinder.Extra;
//   Real bodyPiston.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyPiston.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyPiston.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyPiston.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyPiston.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyPiston.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyPiston.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.0 \"mass of the body\";
//   parameter Real bodyPiston.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyPiston.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyPiston.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real bodyPiston.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyPiston.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyPiston.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyPiston.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyPiston.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyPiston.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyPiston.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyPiston.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyPiston.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyPiston.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyPiston.animate = true \"enable Animation\";
//   parameter String bodyPiston.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyPiston.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyPiston.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyPiston.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyPiston.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyPiston.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyPiston.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyPiston.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyPiston.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyPiston.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyPiston.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyPiston.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyPiston.sphere.lengthDirection[1],bodyPiston.sphere.lengthDirection[2],bodyPiston.sphere.lengthDirection[3]});
//   protected Real bodyPiston.sphere.e_x[1](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 1e-10) then 1.0 else bodyPiston.sphere.lengthDirection[1] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.e_x[2](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 1e-10) then 0.0 else bodyPiston.sphere.lengthDirection[2] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.e_x[3](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 1e-10) then 0.0 else bodyPiston.sphere.lengthDirection[3] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.n_z_aux[1](unit = \"1\") = bodyPiston.sphere.e_x[2] * bodyPiston.sphere.widthDirection[3] - bodyPiston.sphere.e_x[3] * bodyPiston.sphere.widthDirection[2];
//   protected Real bodyPiston.sphere.n_z_aux[2](unit = \"1\") = bodyPiston.sphere.e_x[3] * bodyPiston.sphere.widthDirection[1] - bodyPiston.sphere.e_x[1] * bodyPiston.sphere.widthDirection[3];
//   protected Real bodyPiston.sphere.n_z_aux[3](unit = \"1\") = bodyPiston.sphere.e_x[1] * bodyPiston.sphere.widthDirection[2] - bodyPiston.sphere.e_x[2] * bodyPiston.sphere.widthDirection[1];
//   protected Real bodyPiston.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[1];
//   protected Real bodyPiston.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[2];
//   protected Real bodyPiston.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[3];
//   protected output Real bodyPiston.sphere.Form;
//   output Real bodyPiston.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyPiston.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.Material;
//   protected output Real bodyPiston.sphere.Extra;
//   Real revolutePiston.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolutePiston.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolutePiston.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolutePiston.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolutePiston.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolutePiston.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolutePiston.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolutePiston.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolutePiston.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolutePiston.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolutePiston.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolutePiston.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolutePiston.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolutePiston.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolutePiston.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolutePiston.animate = true \"enable Animation\";
//   parameter Boolean revolutePiston.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolutePiston.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolutePiston.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolutePiston.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolutePiston.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolutePiston.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolutePiston.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolutePiston.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolutePiston.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolutePiston.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolutePiston.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolutePiston.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolutePiston.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolutePiston.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolutePiston.cylinder.lengthDirection[1],revolutePiston.cylinder.lengthDirection[2],revolutePiston.cylinder.lengthDirection[3]});
//   protected Real revolutePiston.cylinder.e_x[1](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 1e-10) then 1.0 else revolutePiston.cylinder.lengthDirection[1] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.e_x[2](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 1e-10) then 0.0 else revolutePiston.cylinder.lengthDirection[2] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.e_x[3](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 1e-10) then 0.0 else revolutePiston.cylinder.lengthDirection[3] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.n_z_aux[1](unit = \"1\") = revolutePiston.cylinder.e_x[2] * revolutePiston.cylinder.widthDirection[3] - revolutePiston.cylinder.e_x[3] * revolutePiston.cylinder.widthDirection[2];
//   protected Real revolutePiston.cylinder.n_z_aux[2](unit = \"1\") = revolutePiston.cylinder.e_x[3] * revolutePiston.cylinder.widthDirection[1] - revolutePiston.cylinder.e_x[1] * revolutePiston.cylinder.widthDirection[3];
//   protected Real revolutePiston.cylinder.n_z_aux[3](unit = \"1\") = revolutePiston.cylinder.e_x[1] * revolutePiston.cylinder.widthDirection[2] - revolutePiston.cylinder.e_x[2] * revolutePiston.cylinder.widthDirection[1];
//   protected Real revolutePiston.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[1];
//   protected Real revolutePiston.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[2];
//   protected Real revolutePiston.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[3];
//   protected output Real revolutePiston.cylinder.Form;
//   output Real revolutePiston.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolutePiston.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.Material;
//   protected output Real revolutePiston.cylinder.Extra;
// initial equation
//   revoluteDrive.phi = revoluteDrive.phi_start;
//   revoluteDrive.w = revoluteDrive.w_start;
// equation
//   bodyDrive.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyDrive.sphere.shapeType);
//   bodyDrive.sphere.rxvisobj[1] = bodyDrive.sphere.R.T[1,1] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,1] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,1] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.rxvisobj[2] = bodyDrive.sphere.R.T[1,2] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,2] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,2] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.rxvisobj[3] = bodyDrive.sphere.R.T[1,3] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,3] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,3] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.ryvisobj[1] = bodyDrive.sphere.R.T[1,1] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,1] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,1] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.ryvisobj[2] = bodyDrive.sphere.R.T[1,2] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,2] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,2] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.ryvisobj[3] = bodyDrive.sphere.R.T[1,3] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,3] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,3] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.rvisobj = bodyDrive.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyDrive.sphere.R.T[1,1],bodyDrive.sphere.R.T[1,2],bodyDrive.sphere.R.T[1,3]},{bodyDrive.sphere.R.T[2,1],bodyDrive.sphere.R.T[2,2],bodyDrive.sphere.R.T[2,3]},{bodyDrive.sphere.R.T[3,1],bodyDrive.sphere.R.T[3,2],bodyDrive.sphere.R.T[3,3]}},{bodyDrive.sphere.r_shape[1],bodyDrive.sphere.r_shape[2],bodyDrive.sphere.r_shape[3]});
//   bodyDrive.sphere.size[1] = bodyDrive.sphere.length;
//   bodyDrive.sphere.size[2] = bodyDrive.sphere.width;
//   bodyDrive.sphere.size[3] = bodyDrive.sphere.height;
//   bodyDrive.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyDrive.sphere.color[1] / 255.0,bodyDrive.sphere.color[2] / 255.0,bodyDrive.sphere.color[3] / 255.0,bodyDrive.sphere.specularCoefficient);
//   bodyDrive.sphere.Extra = bodyDrive.sphere.extra;
//   bodyDrive.r[1] = bodyDrive.frame_a.x;
//   bodyDrive.r[2] = bodyDrive.frame_a.y;
//   bodyDrive.v[1] = der(bodyDrive.r[1]);
//   bodyDrive.v[2] = der(bodyDrive.r[2]);
//   bodyDrive.w = der(bodyDrive.frame_a.phi);
//   bodyDrive.a[1] = der(bodyDrive.v[1]);
//   bodyDrive.a[2] = der(bodyDrive.v[2]);
//   bodyDrive.z = der(bodyDrive.w);
//   bodyDrive.f[1] = bodyDrive.frame_a.fx;
//   bodyDrive.f[2] = bodyDrive.frame_a.fy;
//   bodyDrive.f[1] + bodyDrive.m * bodyDrive.g[1] = bodyDrive.m * bodyDrive.a[1];
//   bodyDrive.f[2] + bodyDrive.m * bodyDrive.g[2] = bodyDrive.m * bodyDrive.a[2];
//   bodyDrive.frame_a.t = bodyDrive.I * bodyDrive.z;
//   revoluteDrive.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revoluteDrive.cylinder.shapeType);
//   revoluteDrive.cylinder.rxvisobj[1] = revoluteDrive.cylinder.R.T[1,1] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,1] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,1] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.rxvisobj[2] = revoluteDrive.cylinder.R.T[1,2] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,2] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,2] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.rxvisobj[3] = revoluteDrive.cylinder.R.T[1,3] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,3] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,3] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.ryvisobj[1] = revoluteDrive.cylinder.R.T[1,1] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,1] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,1] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.ryvisobj[2] = revoluteDrive.cylinder.R.T[1,2] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,2] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,2] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.ryvisobj[3] = revoluteDrive.cylinder.R.T[1,3] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,3] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,3] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.rvisobj = revoluteDrive.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revoluteDrive.cylinder.R.T[1,1],revoluteDrive.cylinder.R.T[1,2],revoluteDrive.cylinder.R.T[1,3]},{revoluteDrive.cylinder.R.T[2,1],revoluteDrive.cylinder.R.T[2,2],revoluteDrive.cylinder.R.T[2,3]},{revoluteDrive.cylinder.R.T[3,1],revoluteDrive.cylinder.R.T[3,2],revoluteDrive.cylinder.R.T[3,3]}},{revoluteDrive.cylinder.r_shape[1],revoluteDrive.cylinder.r_shape[2],revoluteDrive.cylinder.r_shape[3]});
//   revoluteDrive.cylinder.size[1] = revoluteDrive.cylinder.length;
//   revoluteDrive.cylinder.size[2] = revoluteDrive.cylinder.width;
//   revoluteDrive.cylinder.size[3] = revoluteDrive.cylinder.height;
//   revoluteDrive.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revoluteDrive.cylinder.color[1] / 255.0,revoluteDrive.cylinder.color[2] / 255.0,revoluteDrive.cylinder.color[3] / 255.0,revoluteDrive.cylinder.specularCoefficient);
//   revoluteDrive.cylinder.Extra = revoluteDrive.cylinder.extra;
//   revoluteDrive.w = der(revoluteDrive.phi);
//   revoluteDrive.z = der(revoluteDrive.w);
//   revoluteDrive.t = 0.0;
//   revoluteDrive.frame_a.x = revoluteDrive.frame_b.x;
//   revoluteDrive.frame_a.y = revoluteDrive.frame_b.y;
//   revoluteDrive.frame_a.phi + revoluteDrive.phi = revoluteDrive.frame_b.phi;
//   revoluteDrive.frame_a.fx + revoluteDrive.frame_b.fx = 0.0;
//   revoluteDrive.frame_a.fy + revoluteDrive.frame_b.fy = 0.0;
//   revoluteDrive.frame_a.t + revoluteDrive.frame_b.t = 0.0;
//   revoluteDrive.frame_a.t = revoluteDrive.t;
//   fixedTranslationDisc.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslationDisc.cylinder.shapeType);
//   fixedTranslationDisc.cylinder.rxvisobj[1] = fixedTranslationDisc.cylinder.R.T[1,1] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,1] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,1] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.rxvisobj[2] = fixedTranslationDisc.cylinder.R.T[1,2] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,2] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,2] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.rxvisobj[3] = fixedTranslationDisc.cylinder.R.T[1,3] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,3] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,3] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.ryvisobj[1] = fixedTranslationDisc.cylinder.R.T[1,1] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,1] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,1] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.ryvisobj[2] = fixedTranslationDisc.cylinder.R.T[1,2] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,2] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,2] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.ryvisobj[3] = fixedTranslationDisc.cylinder.R.T[1,3] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,3] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,3] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.rvisobj = fixedTranslationDisc.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslationDisc.cylinder.R.T[1,1],fixedTranslationDisc.cylinder.R.T[1,2],fixedTranslationDisc.cylinder.R.T[1,3]},{fixedTranslationDisc.cylinder.R.T[2,1],fixedTranslationDisc.cylinder.R.T[2,2],fixedTranslationDisc.cylinder.R.T[2,3]},{fixedTranslationDisc.cylinder.R.T[3,1],fixedTranslationDisc.cylinder.R.T[3,2],fixedTranslationDisc.cylinder.R.T[3,3]}},{fixedTranslationDisc.cylinder.r_shape[1],fixedTranslationDisc.cylinder.r_shape[2],fixedTranslationDisc.cylinder.r_shape[3]});
//   fixedTranslationDisc.cylinder.size[1] = fixedTranslationDisc.cylinder.length;
//   fixedTranslationDisc.cylinder.size[2] = fixedTranslationDisc.cylinder.width;
//   fixedTranslationDisc.cylinder.size[3] = fixedTranslationDisc.cylinder.height;
//   fixedTranslationDisc.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslationDisc.cylinder.color[1] / 255.0,fixedTranslationDisc.cylinder.color[2] / 255.0,fixedTranslationDisc.cylinder.color[3] / 255.0,fixedTranslationDisc.cylinder.specularCoefficient);
//   fixedTranslationDisc.cylinder.Extra = fixedTranslationDisc.cylinder.extra;
//   fixedTranslationDisc.R[1,1] = cos(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[1,2] = sin(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[2,1] = -sin(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[2,2] = cos(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.r0[1] = fixedTranslationDisc.R[1,1] * fixedTranslationDisc.r[1] + fixedTranslationDisc.R[1,2] * fixedTranslationDisc.r[2];
//   fixedTranslationDisc.r0[2] = fixedTranslationDisc.R[2,1] * fixedTranslationDisc.r[1] + fixedTranslationDisc.R[2,2] * fixedTranslationDisc.r[2];
//   fixedTranslationDisc.frame_a.x + fixedTranslationDisc.r0[1] = fixedTranslationDisc.frame_b.x;
//   fixedTranslationDisc.frame_a.y + fixedTranslationDisc.r0[2] = fixedTranslationDisc.frame_b.y;
//   fixedTranslationDisc.frame_a.phi = fixedTranslationDisc.frame_b.phi;
//   fixedTranslationDisc.frame_a.fx + fixedTranslationDisc.frame_b.fx = 0.0;
//   fixedTranslationDisc.frame_a.fy + fixedTranslationDisc.frame_b.fy = 0.0;
//   fixedTranslationDisc.frame_a.t + (fixedTranslationDisc.frame_b.t + ((-fixedTranslationDisc.r0[1]) * fixedTranslationDisc.frame_b.fy + fixedTranslationDisc.r0[2] * fixedTranslationDisc.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.r0[1] = prismatic.s * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]);
//   prismatic.r0[2] = prismatic.s * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]);
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]) + prismatic.frame_a.fy * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]) = 0.0;
//   fixed1.frame_a.x = fixed1.r[1];
//   fixed1.frame_a.y = fixed1.r[2];
//   fixed1.frame_a.phi = fixed1.phi;
//   revoluteDisc.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revoluteDisc.cylinder.shapeType);
//   revoluteDisc.cylinder.rxvisobj[1] = revoluteDisc.cylinder.R.T[1,1] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,1] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,1] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.rxvisobj[2] = revoluteDisc.cylinder.R.T[1,2] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,2] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,2] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.rxvisobj[3] = revoluteDisc.cylinder.R.T[1,3] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,3] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,3] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.ryvisobj[1] = revoluteDisc.cylinder.R.T[1,1] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,1] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,1] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.ryvisobj[2] = revoluteDisc.cylinder.R.T[1,2] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,2] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,2] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.ryvisobj[3] = revoluteDisc.cylinder.R.T[1,3] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,3] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,3] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.rvisobj = revoluteDisc.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revoluteDisc.cylinder.R.T[1,1],revoluteDisc.cylinder.R.T[1,2],revoluteDisc.cylinder.R.T[1,3]},{revoluteDisc.cylinder.R.T[2,1],revoluteDisc.cylinder.R.T[2,2],revoluteDisc.cylinder.R.T[2,3]},{revoluteDisc.cylinder.R.T[3,1],revoluteDisc.cylinder.R.T[3,2],revoluteDisc.cylinder.R.T[3,3]}},{revoluteDisc.cylinder.r_shape[1],revoluteDisc.cylinder.r_shape[2],revoluteDisc.cylinder.r_shape[3]});
//   revoluteDisc.cylinder.size[1] = revoluteDisc.cylinder.length;
//   revoluteDisc.cylinder.size[2] = revoluteDisc.cylinder.width;
//   revoluteDisc.cylinder.size[3] = revoluteDisc.cylinder.height;
//   revoluteDisc.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revoluteDisc.cylinder.color[1] / 255.0,revoluteDisc.cylinder.color[2] / 255.0,revoluteDisc.cylinder.color[3] / 255.0,revoluteDisc.cylinder.specularCoefficient);
//   revoluteDisc.cylinder.Extra = revoluteDisc.cylinder.extra;
//   revoluteDisc.w = der(revoluteDisc.phi);
//   revoluteDisc.z = der(revoluteDisc.w);
//   revoluteDisc.t = 0.0;
//   revoluteDisc.frame_a.x = revoluteDisc.frame_b.x;
//   revoluteDisc.frame_a.y = revoluteDisc.frame_b.y;
//   revoluteDisc.frame_a.phi + revoluteDisc.phi = revoluteDisc.frame_b.phi;
//   revoluteDisc.frame_a.fx + revoluteDisc.frame_b.fx = 0.0;
//   revoluteDisc.frame_a.fy + revoluteDisc.frame_b.fy = 0.0;
//   revoluteDisc.frame_a.t + revoluteDisc.frame_b.t = 0.0;
//   revoluteDisc.frame_a.t = revoluteDisc.t;
//   pistonRod.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pistonRod.cylinder.shapeType);
//   pistonRod.cylinder.rxvisobj[1] = pistonRod.cylinder.R.T[1,1] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,1] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,1] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.rxvisobj[2] = pistonRod.cylinder.R.T[1,2] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,2] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,2] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.rxvisobj[3] = pistonRod.cylinder.R.T[1,3] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,3] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,3] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.ryvisobj[1] = pistonRod.cylinder.R.T[1,1] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,1] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,1] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.ryvisobj[2] = pistonRod.cylinder.R.T[1,2] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,2] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,2] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.ryvisobj[3] = pistonRod.cylinder.R.T[1,3] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,3] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,3] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.rvisobj = pistonRod.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pistonRod.cylinder.R.T[1,1],pistonRod.cylinder.R.T[1,2],pistonRod.cylinder.R.T[1,3]},{pistonRod.cylinder.R.T[2,1],pistonRod.cylinder.R.T[2,2],pistonRod.cylinder.R.T[2,3]},{pistonRod.cylinder.R.T[3,1],pistonRod.cylinder.R.T[3,2],pistonRod.cylinder.R.T[3,3]}},{pistonRod.cylinder.r_shape[1],pistonRod.cylinder.r_shape[2],pistonRod.cylinder.r_shape[3]});
//   pistonRod.cylinder.size[1] = pistonRod.cylinder.length;
//   pistonRod.cylinder.size[2] = pistonRod.cylinder.width;
//   pistonRod.cylinder.size[3] = pistonRod.cylinder.height;
//   pistonRod.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pistonRod.cylinder.color[1] / 255.0,pistonRod.cylinder.color[2] / 255.0,pistonRod.cylinder.color[3] / 255.0,pistonRod.cylinder.specularCoefficient);
//   pistonRod.cylinder.Extra = pistonRod.cylinder.extra;
//   pistonRod.R[1,1] = cos(pistonRod.frame_a.phi);
//   pistonRod.R[1,2] = sin(pistonRod.frame_a.phi);
//   pistonRod.R[2,1] = -sin(pistonRod.frame_a.phi);
//   pistonRod.R[2,2] = cos(pistonRod.frame_a.phi);
//   pistonRod.r0[1] = pistonRod.R[1,1] * pistonRod.r[1] + pistonRod.R[1,2] * pistonRod.r[2];
//   pistonRod.r0[2] = pistonRod.R[2,1] * pistonRod.r[1] + pistonRod.R[2,2] * pistonRod.r[2];
//   pistonRod.frame_a.x + pistonRod.r0[1] = pistonRod.frame_b.x;
//   pistonRod.frame_a.y + pistonRod.r0[2] = pistonRod.frame_b.y;
//   pistonRod.frame_a.phi = pistonRod.frame_b.phi;
//   pistonRod.frame_a.fx + pistonRod.frame_b.fx = 0.0;
//   pistonRod.frame_a.fy + pistonRod.frame_b.fy = 0.0;
//   pistonRod.frame_a.t + (pistonRod.frame_b.t + ((-pistonRod.r0[1]) * pistonRod.frame_b.fy + pistonRod.r0[2] * pistonRod.frame_b.fx)) = 0.0;
//   bodyPiston.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyPiston.sphere.shapeType);
//   bodyPiston.sphere.rxvisobj[1] = bodyPiston.sphere.R.T[1,1] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,1] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,1] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.rxvisobj[2] = bodyPiston.sphere.R.T[1,2] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,2] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,2] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.rxvisobj[3] = bodyPiston.sphere.R.T[1,3] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,3] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,3] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.ryvisobj[1] = bodyPiston.sphere.R.T[1,1] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,1] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,1] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.ryvisobj[2] = bodyPiston.sphere.R.T[1,2] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,2] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,2] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.ryvisobj[3] = bodyPiston.sphere.R.T[1,3] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,3] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,3] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.rvisobj = bodyPiston.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyPiston.sphere.R.T[1,1],bodyPiston.sphere.R.T[1,2],bodyPiston.sphere.R.T[1,3]},{bodyPiston.sphere.R.T[2,1],bodyPiston.sphere.R.T[2,2],bodyPiston.sphere.R.T[2,3]},{bodyPiston.sphere.R.T[3,1],bodyPiston.sphere.R.T[3,2],bodyPiston.sphere.R.T[3,3]}},{bodyPiston.sphere.r_shape[1],bodyPiston.sphere.r_shape[2],bodyPiston.sphere.r_shape[3]});
//   bodyPiston.sphere.size[1] = bodyPiston.sphere.length;
//   bodyPiston.sphere.size[2] = bodyPiston.sphere.width;
//   bodyPiston.sphere.size[3] = bodyPiston.sphere.height;
//   bodyPiston.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyPiston.sphere.color[1] / 255.0,bodyPiston.sphere.color[2] / 255.0,bodyPiston.sphere.color[3] / 255.0,bodyPiston.sphere.specularCoefficient);
//   bodyPiston.sphere.Extra = bodyPiston.sphere.extra;
//   bodyPiston.r[1] = bodyPiston.frame_a.x;
//   bodyPiston.r[2] = bodyPiston.frame_a.y;
//   bodyPiston.v[1] = der(bodyPiston.r[1]);
//   bodyPiston.v[2] = der(bodyPiston.r[2]);
//   bodyPiston.w = der(bodyPiston.frame_a.phi);
//   bodyPiston.a[1] = der(bodyPiston.v[1]);
//   bodyPiston.a[2] = der(bodyPiston.v[2]);
//   bodyPiston.z = der(bodyPiston.w);
//   bodyPiston.f[1] = bodyPiston.frame_a.fx;
//   bodyPiston.f[2] = bodyPiston.frame_a.fy;
//   bodyPiston.f[1] + bodyPiston.m * bodyPiston.g[1] = bodyPiston.m * bodyPiston.a[1];
//   bodyPiston.f[2] + bodyPiston.m * bodyPiston.g[2] = bodyPiston.m * bodyPiston.a[2];
//   bodyPiston.frame_a.t = bodyPiston.I * bodyPiston.z;
//   revolutePiston.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolutePiston.cylinder.shapeType);
//   revolutePiston.cylinder.rxvisobj[1] = revolutePiston.cylinder.R.T[1,1] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,1] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,1] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.rxvisobj[2] = revolutePiston.cylinder.R.T[1,2] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,2] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,2] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.rxvisobj[3] = revolutePiston.cylinder.R.T[1,3] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,3] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,3] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.ryvisobj[1] = revolutePiston.cylinder.R.T[1,1] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,1] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,1] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.ryvisobj[2] = revolutePiston.cylinder.R.T[1,2] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,2] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,2] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.ryvisobj[3] = revolutePiston.cylinder.R.T[1,3] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,3] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,3] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.rvisobj = revolutePiston.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolutePiston.cylinder.R.T[1,1],revolutePiston.cylinder.R.T[1,2],revolutePiston.cylinder.R.T[1,3]},{revolutePiston.cylinder.R.T[2,1],revolutePiston.cylinder.R.T[2,2],revolutePiston.cylinder.R.T[2,3]},{revolutePiston.cylinder.R.T[3,1],revolutePiston.cylinder.R.T[3,2],revolutePiston.cylinder.R.T[3,3]}},{revolutePiston.cylinder.r_shape[1],revolutePiston.cylinder.r_shape[2],revolutePiston.cylinder.r_shape[3]});
//   revolutePiston.cylinder.size[1] = revolutePiston.cylinder.length;
//   revolutePiston.cylinder.size[2] = revolutePiston.cylinder.width;
//   revolutePiston.cylinder.size[3] = revolutePiston.cylinder.height;
//   revolutePiston.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolutePiston.cylinder.color[1] / 255.0,revolutePiston.cylinder.color[2] / 255.0,revolutePiston.cylinder.color[3] / 255.0,revolutePiston.cylinder.specularCoefficient);
//   revolutePiston.cylinder.Extra = revolutePiston.cylinder.extra;
//   revolutePiston.w = der(revolutePiston.phi);
//   revolutePiston.z = der(revolutePiston.w);
//   revolutePiston.t = 0.0;
//   revolutePiston.frame_a.x = revolutePiston.frame_b.x;
//   revolutePiston.frame_a.y = revolutePiston.frame_b.y;
//   revolutePiston.frame_a.phi + revolutePiston.phi = revolutePiston.frame_b.phi;
//   revolutePiston.frame_a.fx + revolutePiston.frame_b.fx = 0.0;
//   revolutePiston.frame_a.fy + revolutePiston.frame_b.fy = 0.0;
//   revolutePiston.frame_a.t + revolutePiston.frame_b.t = 0.0;
//   revolutePiston.frame_a.t = revolutePiston.t;
//   bodyDrive.frame_a.t + revoluteDrive.frame_b.t + fixedTranslationDisc.frame_a.t = 0.0;
//   bodyDrive.frame_a.fy + revoluteDrive.frame_b.fy + fixedTranslationDisc.frame_a.fy = 0.0;
//   bodyDrive.frame_a.fx + revoluteDrive.frame_b.fx + fixedTranslationDisc.frame_a.fx = 0.0;
//   revoluteDrive.frame_a.t + fixed.frame_a.t = 0.0;
//   revoluteDrive.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revoluteDrive.frame_a.fx + fixed.frame_a.fx = 0.0;
//   fixedTranslationDisc.frame_b.t + revoluteDisc.frame_a.t = 0.0;
//   fixedTranslationDisc.frame_b.fy + revoluteDisc.frame_a.fy = 0.0;
//   fixedTranslationDisc.frame_b.fx + revoluteDisc.frame_a.fx = 0.0;
//   prismatic.frame_a.t + bodyPiston.frame_a.t + revolutePiston.frame_a.t = 0.0;
//   prismatic.frame_a.fy + bodyPiston.frame_a.fy + revolutePiston.frame_a.fy = 0.0;
//   prismatic.frame_a.fx + bodyPiston.frame_a.fx + revolutePiston.frame_a.fx = 0.0;
//   prismatic.frame_b.t + fixed1.frame_a.t = 0.0;
//   prismatic.frame_b.fy + fixed1.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + fixed1.frame_a.fx = 0.0;
//   revoluteDisc.frame_b.t + pistonRod.frame_a.t = 0.0;
//   revoluteDisc.frame_b.fy + pistonRod.frame_a.fy = 0.0;
//   revoluteDisc.frame_b.fx + pistonRod.frame_a.fx = 0.0;
//   pistonRod.frame_b.t + revolutePiston.frame_b.t = 0.0;
//   pistonRod.frame_b.fy + revolutePiston.frame_b.fy = 0.0;
//   pistonRod.frame_b.fx + revolutePiston.frame_b.fx = 0.0;
//   fixed.frame_a.x = revoluteDrive.frame_a.x;
//   fixed.frame_a.y = revoluteDrive.frame_a.y;
//   fixed.frame_a.phi = revoluteDrive.frame_a.phi;
//   bodyDrive.frame_a.x = fixedTranslationDisc.frame_a.x;
//   bodyDrive.frame_a.x = revoluteDrive.frame_b.x;
//   bodyDrive.frame_a.y = fixedTranslationDisc.frame_a.y;
//   bodyDrive.frame_a.y = revoluteDrive.frame_b.y;
//   bodyDrive.frame_a.phi = fixedTranslationDisc.frame_a.phi;
//   bodyDrive.frame_a.phi = revoluteDrive.frame_b.phi;
//   fixed1.frame_a.x = prismatic.frame_b.x;
//   fixed1.frame_a.y = prismatic.frame_b.y;
//   fixed1.frame_a.phi = prismatic.frame_b.phi;
//   fixedTranslationDisc.frame_b.x = revoluteDisc.frame_a.x;
//   fixedTranslationDisc.frame_b.y = revoluteDisc.frame_a.y;
//   fixedTranslationDisc.frame_b.phi = revoluteDisc.frame_a.phi;
//   pistonRod.frame_a.x = revoluteDisc.frame_b.x;
//   pistonRod.frame_a.y = revoluteDisc.frame_b.y;
//   pistonRod.frame_a.phi = revoluteDisc.frame_b.phi;
//   pistonRod.frame_b.x = revolutePiston.frame_b.x;
//   pistonRod.frame_b.y = revolutePiston.frame_b.y;
//   pistonRod.frame_b.phi = revolutePiston.frame_b.phi;
//   bodyPiston.frame_a.x = prismatic.frame_a.x;
//   bodyPiston.frame_a.x = revolutePiston.frame_a.x;
//   bodyPiston.frame_a.y = prismatic.frame_a.y;
//   bodyPiston.frame_a.y = revolutePiston.frame_a.y;
//   bodyPiston.frame_a.phi = prismatic.frame_a.phi;
//   bodyPiston.frame_a.phi = revolutePiston.frame_a.phi;
// end PlanarMechanicsV4.Examples.PistonEngine;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.KinematicLoop
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.always) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.always) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real revolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute1.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute1.animate = true \"enable Animation\";
//   parameter Boolean revolute1.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1],revolute1.cylinder.lengthDirection[2],revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = \"1\") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = \"1\") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = \"1\") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   Real revolute2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute2.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute2.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute2.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute2.animate = true \"enable Animation\";
//   parameter Boolean revolute2.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute2.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute2.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute2.cylinder.lengthDirection[1],revolute2.cylinder.lengthDirection[2],revolute2.cylinder.lengthDirection[3]});
//   protected Real revolute2.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 1.0 else revolute2.cylinder.lengthDirection[1] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 0.0 else revolute2.cylinder.lengthDirection[2] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 0.0 else revolute2.cylinder.lengthDirection[3] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.n_z_aux[1](unit = \"1\") = revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[3] - revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[2];
//   protected Real revolute2.cylinder.n_z_aux[2](unit = \"1\") = revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[1] - revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[3];
//   protected Real revolute2.cylinder.n_z_aux[3](unit = \"1\") = revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[2] - revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[1];
//   protected Real revolute2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[1];
//   protected Real revolute2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[2];
//   protected Real revolute2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[3];
//   protected output Real revolute2.cylinder.Form;
//   output Real revolute2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.Material;
//   protected output Real revolute2.cylinder.Extra;
//   Real revolute3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute3.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute3.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute3.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute3.animate = true \"enable Animation\";
//   parameter Boolean revolute3.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute3.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute3.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute3.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute3.cylinder.lengthDirection[1],revolute3.cylinder.lengthDirection[2],revolute3.cylinder.lengthDirection[3]});
//   protected Real revolute3.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 1e-10) then 1.0 else revolute3.cylinder.lengthDirection[1] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 1e-10) then 0.0 else revolute3.cylinder.lengthDirection[2] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 1e-10) then 0.0 else revolute3.cylinder.lengthDirection[3] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.n_z_aux[1](unit = \"1\") = revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[3] - revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[2];
//   protected Real revolute3.cylinder.n_z_aux[2](unit = \"1\") = revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[1] - revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[3];
//   protected Real revolute3.cylinder.n_z_aux[3](unit = \"1\") = revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[2] - revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[1];
//   protected Real revolute3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[1];
//   protected Real revolute3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[2];
//   protected Real revolute3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[3];
//   protected output Real revolute3.cylinder.Form;
//   output Real revolute3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.Material;
//   protected output Real revolute3.cylinder.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation2.r[1] ^ 2.0 + fixedTranslation2.r[2] ^ 2.0);
//   parameter String fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation2.r0[1] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation2.r0[2] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation2.l \"Length of visual object\";
//   input Real fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation2.cylinder.lengthDirection[1],fixedTranslation2.cylinder.lengthDirection[2],fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation2.cylinder.lengthDirection[1] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.cylinder.lengthDirection[2] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.cylinder.lengthDirection[3] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[3] - fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[2];
//   protected Real fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[1] - fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[3];
//   protected Real fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[2] - fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[1];
//   protected Real fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation2.cylinder.Form;
//   output Real fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.Material;
//   protected output Real fixedTranslation2.cylinder.Extra;
//   Real fixedTranslation3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation3.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation3.r[2](quantity = \"Length\", unit = \"m\") = -0.6 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation3.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation3.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation3.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation3.r[1] ^ 2.0 + fixedTranslation3.r[2] ^ 2.0);
//   parameter String fixedTranslation3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation3.r0[1] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation3.r0[2] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation3.l \"Length of visual object\";
//   input Real fixedTranslation3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation3.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation3.cylinder.lengthDirection[1],fixedTranslation3.cylinder.lengthDirection[2],fixedTranslation3.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation3.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation3.cylinder.lengthDirection[1] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.cylinder.lengthDirection[2] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.cylinder.lengthDirection[3] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[3] - fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[2];
//   protected Real fixedTranslation3.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[1] - fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[3];
//   protected Real fixedTranslation3.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[2] - fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[1];
//   protected Real fixedTranslation3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation3.cylinder.Form;
//   output Real fixedTranslation3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.Material;
//   protected output Real fixedTranslation3.cylinder.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0);
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.4;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   parameter enumeration(never, avoid, default, prefer, always) springDamper.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real springDamper.s_nominal(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0001 \"Nominal value of s_rel (used for scaling)\";
//   Real springDamper.f(quantity = \"Force\", unit = \"N\") \"Forces between flanges (= flange_b.f)\";
//   Real springDamper.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real springDamper.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real springDamper.flange_b.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real springDamper.flange_b.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   parameter Real springDamper.c(quantity = \"TranslationalSpringConstant\", unit = \"N/m\", min = 0.0, start = 1.0) = 10.0 \"spring constant\";
//   parameter Real springDamper.d(quantity = \"TranslationalDampingConstant\", unit = \"N.s/m\", min = 0.0, start = 1.0) = 2.0 \"damping constant\";
//   parameter Real springDamper.s_rel0(quantity = \"Length\", unit = \"m\") = 0.6 \"unstretched spring length\";
//   Real springDamper.v_rel(quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative velocity (= der(s_rel))\";
//   Real springDamper.s_rel(quantity = \"Length\", unit = \"m\", min = 0.0, start = 0.0, nominal = springDamper.s_nominal, StateSelect = StateSelect.prefer) \"Relative distance (= flange_b.s - flange_a.s)\";
//   parameter Real fixed1.s0(quantity = \"Length\", unit = \"m\") = 0.0 \"fixed offset position of housing\";
//   Real fixed1.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real fixed1.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
// initial equation
//   revolute3.phi = revolute3.phi_start;
//   revolute3.w = revolute3.w_start;
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
// equation
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1],revolute1.cylinder.R.T[1,2],revolute1.cylinder.R.T[1,3]},{revolute1.cylinder.R.T[2,1],revolute1.cylinder.R.T[2,2],revolute1.cylinder.R.T[2,3]},{revolute1.cylinder.R.T[3,1],revolute1.cylinder.R.T[3,2],revolute1.cylinder.R.T[3,3]}},{revolute1.cylinder.r_shape[1],revolute1.cylinder.r_shape[2],revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0,revolute1.cylinder.color[2] / 255.0,revolute1.cylinder.color[3] / 255.0,revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   revolute1.w = der(revolute1.phi);
//   revolute1.z = der(revolute1.w);
//   revolute1.t = 0.0;
//   revolute1.frame_a.x = revolute1.frame_b.x;
//   revolute1.frame_a.y = revolute1.frame_b.y;
//   revolute1.frame_a.phi + revolute1.phi = revolute1.frame_b.phi;
//   revolute1.frame_a.fx + revolute1.frame_b.fx = 0.0;
//   revolute1.frame_a.fy + revolute1.frame_b.fy = 0.0;
//   revolute1.frame_a.t + revolute1.frame_b.t = 0.0;
//   revolute1.frame_a.t = revolute1.t;
//   revolute2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute2.cylinder.shapeType);
//   revolute2.cylinder.rxvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.ryvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.rvisobj = revolute2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute2.cylinder.R.T[1,1],revolute2.cylinder.R.T[1,2],revolute2.cylinder.R.T[1,3]},{revolute2.cylinder.R.T[2,1],revolute2.cylinder.R.T[2,2],revolute2.cylinder.R.T[2,3]},{revolute2.cylinder.R.T[3,1],revolute2.cylinder.R.T[3,2],revolute2.cylinder.R.T[3,3]}},{revolute2.cylinder.r_shape[1],revolute2.cylinder.r_shape[2],revolute2.cylinder.r_shape[3]});
//   revolute2.cylinder.size[1] = revolute2.cylinder.length;
//   revolute2.cylinder.size[2] = revolute2.cylinder.width;
//   revolute2.cylinder.size[3] = revolute2.cylinder.height;
//   revolute2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute2.cylinder.color[1] / 255.0,revolute2.cylinder.color[2] / 255.0,revolute2.cylinder.color[3] / 255.0,revolute2.cylinder.specularCoefficient);
//   revolute2.cylinder.Extra = revolute2.cylinder.extra;
//   revolute2.w = der(revolute2.phi);
//   revolute2.z = der(revolute2.w);
//   revolute2.t = 0.0;
//   revolute2.frame_a.x = revolute2.frame_b.x;
//   revolute2.frame_a.y = revolute2.frame_b.y;
//   revolute2.frame_a.phi + revolute2.phi = revolute2.frame_b.phi;
//   revolute2.frame_a.fx + revolute2.frame_b.fx = 0.0;
//   revolute2.frame_a.fy + revolute2.frame_b.fy = 0.0;
//   revolute2.frame_a.t + revolute2.frame_b.t = 0.0;
//   revolute2.frame_a.t = revolute2.t;
//   revolute3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute3.cylinder.shapeType);
//   revolute3.cylinder.rxvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.ryvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.rvisobj = revolute3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute3.cylinder.R.T[1,1],revolute3.cylinder.R.T[1,2],revolute3.cylinder.R.T[1,3]},{revolute3.cylinder.R.T[2,1],revolute3.cylinder.R.T[2,2],revolute3.cylinder.R.T[2,3]},{revolute3.cylinder.R.T[3,1],revolute3.cylinder.R.T[3,2],revolute3.cylinder.R.T[3,3]}},{revolute3.cylinder.r_shape[1],revolute3.cylinder.r_shape[2],revolute3.cylinder.r_shape[3]});
//   revolute3.cylinder.size[1] = revolute3.cylinder.length;
//   revolute3.cylinder.size[2] = revolute3.cylinder.width;
//   revolute3.cylinder.size[3] = revolute3.cylinder.height;
//   revolute3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute3.cylinder.color[1] / 255.0,revolute3.cylinder.color[2] / 255.0,revolute3.cylinder.color[3] / 255.0,revolute3.cylinder.specularCoefficient);
//   revolute3.cylinder.Extra = revolute3.cylinder.extra;
//   revolute3.w = der(revolute3.phi);
//   revolute3.z = der(revolute3.w);
//   revolute3.t = 0.0;
//   revolute3.frame_a.x = revolute3.frame_b.x;
//   revolute3.frame_a.y = revolute3.frame_b.y;
//   revolute3.frame_a.phi + revolute3.phi = revolute3.frame_b.phi;
//   revolute3.frame_a.fx + revolute3.frame_b.fx = 0.0;
//   revolute3.frame_a.fy + revolute3.frame_b.fy = 0.0;
//   revolute3.frame_a.t + revolute3.frame_b.t = 0.0;
//   revolute3.frame_a.t = revolute3.t;
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.cylinder.shapeType);
//   fixedTranslation2.cylinder.rxvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.ryvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.rvisobj = fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.cylinder.R.T[1,1],fixedTranslation2.cylinder.R.T[1,2],fixedTranslation2.cylinder.R.T[1,3]},{fixedTranslation2.cylinder.R.T[2,1],fixedTranslation2.cylinder.R.T[2,2],fixedTranslation2.cylinder.R.T[2,3]},{fixedTranslation2.cylinder.R.T[3,1],fixedTranslation2.cylinder.R.T[3,2],fixedTranslation2.cylinder.R.T[3,3]}},{fixedTranslation2.cylinder.r_shape[1],fixedTranslation2.cylinder.r_shape[2],fixedTranslation2.cylinder.r_shape[3]});
//   fixedTranslation2.cylinder.size[1] = fixedTranslation2.cylinder.length;
//   fixedTranslation2.cylinder.size[2] = fixedTranslation2.cylinder.width;
//   fixedTranslation2.cylinder.size[3] = fixedTranslation2.cylinder.height;
//   fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.cylinder.color[1] / 255.0,fixedTranslation2.cylinder.color[2] / 255.0,fixedTranslation2.cylinder.color[3] / 255.0,fixedTranslation2.cylinder.specularCoefficient);
//   fixedTranslation2.cylinder.Extra = fixedTranslation2.cylinder.extra;
//   fixedTranslation2.R[1,1] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[1,2] = sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,1] = -sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,2] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.r0[1] = fixedTranslation2.R[1,1] * fixedTranslation2.r[1] + fixedTranslation2.R[1,2] * fixedTranslation2.r[2];
//   fixedTranslation2.r0[2] = fixedTranslation2.R[2,1] * fixedTranslation2.r[1] + fixedTranslation2.R[2,2] * fixedTranslation2.r[2];
//   fixedTranslation2.frame_a.x + fixedTranslation2.r0[1] = fixedTranslation2.frame_b.x;
//   fixedTranslation2.frame_a.y + fixedTranslation2.r0[2] = fixedTranslation2.frame_b.y;
//   fixedTranslation2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   fixedTranslation2.frame_a.fx + fixedTranslation2.frame_b.fx = 0.0;
//   fixedTranslation2.frame_a.fy + fixedTranslation2.frame_b.fy = 0.0;
//   fixedTranslation2.frame_a.t + (fixedTranslation2.frame_b.t + ((-fixedTranslation2.r0[1]) * fixedTranslation2.frame_b.fy + fixedTranslation2.r0[2] * fixedTranslation2.frame_b.fx)) = 0.0;
//   fixedTranslation3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.cylinder.shapeType);
//   fixedTranslation3.cylinder.rxvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.ryvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.rvisobj = fixedTranslation3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.cylinder.R.T[1,1],fixedTranslation3.cylinder.R.T[1,2],fixedTranslation3.cylinder.R.T[1,3]},{fixedTranslation3.cylinder.R.T[2,1],fixedTranslation3.cylinder.R.T[2,2],fixedTranslation3.cylinder.R.T[2,3]},{fixedTranslation3.cylinder.R.T[3,1],fixedTranslation3.cylinder.R.T[3,2],fixedTranslation3.cylinder.R.T[3,3]}},{fixedTranslation3.cylinder.r_shape[1],fixedTranslation3.cylinder.r_shape[2],fixedTranslation3.cylinder.r_shape[3]});
//   fixedTranslation3.cylinder.size[1] = fixedTranslation3.cylinder.length;
//   fixedTranslation3.cylinder.size[2] = fixedTranslation3.cylinder.width;
//   fixedTranslation3.cylinder.size[3] = fixedTranslation3.cylinder.height;
//   fixedTranslation3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.cylinder.color[1] / 255.0,fixedTranslation3.cylinder.color[2] / 255.0,fixedTranslation3.cylinder.color[3] / 255.0,fixedTranslation3.cylinder.specularCoefficient);
//   fixedTranslation3.cylinder.Extra = fixedTranslation3.cylinder.extra;
//   fixedTranslation3.R[1,1] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[1,2] = sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,1] = -sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,2] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.r0[1] = fixedTranslation3.R[1,1] * fixedTranslation3.r[1] + fixedTranslation3.R[1,2] * fixedTranslation3.r[2];
//   fixedTranslation3.r0[2] = fixedTranslation3.R[2,1] * fixedTranslation3.r[1] + fixedTranslation3.R[2,2] * fixedTranslation3.r[2];
//   fixedTranslation3.frame_a.x + fixedTranslation3.r0[1] = fixedTranslation3.frame_b.x;
//   fixedTranslation3.frame_a.y + fixedTranslation3.r0[2] = fixedTranslation3.frame_b.y;
//   fixedTranslation3.frame_a.phi = fixedTranslation3.frame_b.phi;
//   fixedTranslation3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation3.frame_a.t + (fixedTranslation3.frame_b.t + ((-fixedTranslation3.r0[1]) * fixedTranslation3.frame_b.fy + fixedTranslation3.r0[2] * fixedTranslation3.frame_b.fx)) = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.r0[1] = actuatedPrismatic.s * (actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2]);
//   actuatedPrismatic.r0[2] = actuatedPrismatic.s * (actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2]);
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * (actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2]) + actuatedPrismatic.frame_a.fy * (actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2]) = actuatedPrismatic.f;
//   springDamper.f = springDamper.c * (springDamper.s_rel - springDamper.s_rel0) + springDamper.d * springDamper.v_rel;
//   springDamper.s_rel = springDamper.flange_b.s - springDamper.flange_a.s;
//   springDamper.v_rel = der(springDamper.s_rel);
//   springDamper.flange_b.f = springDamper.f;
//   springDamper.flange_a.f = -springDamper.f;
//   fixed1.flange.s = fixed1.s0;
//   revolute.frame_a.t + fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation1.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation1.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation1.frame_a.fx = 0.0;
//   revolute1.frame_a.t + actuatedPrismatic.frame_b.t = 0.0;
//   revolute1.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   revolute1.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   revolute1.frame_b.t + fixedTranslation2.frame_a.t = 0.0;
//   revolute1.frame_b.fy + fixedTranslation2.frame_a.fy = 0.0;
//   revolute1.frame_b.fx + fixedTranslation2.frame_a.fx = 0.0;
//   revolute2.frame_a.t + revolute3.frame_a.t + fixedTranslation1.frame_b.t = 0.0;
//   revolute2.frame_a.fy + revolute3.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   revolute2.frame_a.fx + revolute3.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   revolute2.frame_b.t + fixedTranslation2.frame_b.t = 0.0;
//   revolute2.frame_b.fy + fixedTranslation2.frame_b.fy = 0.0;
//   revolute2.frame_b.fx + fixedTranslation2.frame_b.fx = 0.0;
//   revolute3.frame_b.t + fixedTranslation3.frame_a.t = 0.0;
//   revolute3.frame_b.fy + fixedTranslation3.frame_a.fy = 0.0;
//   revolute3.frame_b.fx + fixedTranslation3.frame_a.fx = 0.0;
//   fixedTranslation3.frame_b.t + body.frame_a.t = 0.0;
//   fixedTranslation3.frame_b.fy + body.frame_a.fy = 0.0;
//   fixedTranslation3.frame_b.fx + body.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + springDamper.flange_b.f = 0.0;
//   springDamper.flange_a.f + fixed1.flange.f = 0.0;
//   fixedTranslation1.frame_a.x = revolute.frame_b.x;
//   fixedTranslation1.frame_a.y = revolute.frame_b.y;
//   fixedTranslation1.frame_a.phi = revolute.frame_b.phi;
//   fixedTranslation2.frame_a.x = revolute1.frame_b.x;
//   fixedTranslation2.frame_a.y = revolute1.frame_b.y;
//   fixedTranslation2.frame_a.phi = revolute1.frame_b.phi;
//   fixedTranslation1.frame_b.x = revolute2.frame_a.x;
//   fixedTranslation1.frame_b.x = revolute3.frame_a.x;
//   fixedTranslation1.frame_b.y = revolute2.frame_a.y;
//   fixedTranslation1.frame_b.y = revolute3.frame_a.y;
//   fixedTranslation1.frame_b.phi = revolute2.frame_a.phi;
//   fixedTranslation1.frame_b.phi = revolute3.frame_a.phi;
//   fixedTranslation2.frame_b.x = revolute2.frame_b.x;
//   fixedTranslation2.frame_b.y = revolute2.frame_b.y;
//   fixedTranslation2.frame_b.phi = revolute2.frame_b.phi;
//   fixedTranslation3.frame_a.x = revolute3.frame_b.x;
//   fixedTranslation3.frame_a.y = revolute3.frame_b.y;
//   fixedTranslation3.frame_a.phi = revolute3.frame_b.phi;
//   actuatedPrismatic.frame_b.x = revolute1.frame_a.x;
//   actuatedPrismatic.frame_b.y = revolute1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = revolute1.frame_a.phi;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.x = revolute.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.y = revolute.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_a.phi = revolute.frame_a.phi;
//   actuatedPrismatic.flange_a.s = springDamper.flange_b.s;
//   fixed1.flange.s = springDamper.flange_a.s;
//   body.frame_a.x = fixedTranslation3.frame_b.x;
//   body.frame_a.y = fixedTranslation3.frame_b.y;
//   body.frame_a.phi = fixedTranslation3.frame_b.phi;
// end PlanarMechanicsV4.Examples.KinematicLoop;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.FreeWheel
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real idealWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.2 \"radius of the wheel\";
//   parameter Real idealWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real idealWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelJoint.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean idealWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelJoint.r[1] ^ 2.0 + idealWheelJoint.r[2] ^ 2.0);
//   final parameter Real idealWheelJoint.e[1] = idealWheelJoint.r[1] / idealWheelJoint.l \"normalized direction\";
//   final parameter Real idealWheelJoint.e[2] = idealWheelJoint.r[2] / idealWheelJoint.l \"normalized direction\";
//   parameter String idealWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * idealWheelJoint.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * idealWheelJoint.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = idealWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Width of visual object\";
//   input Real idealWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Height of visual object\";
//   input Real idealWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.cylinder.lengthDirection[1],idealWheelJoint.cylinder.lengthDirection[2],idealWheelJoint.cylinder.lengthDirection[3]});
//   protected Real idealWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.cylinder.lengthDirection[1] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.cylinder.lengthDirection[2] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.cylinder.lengthDirection[3] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[3] - idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[2];
//   protected Real idealWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[1] - idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[3];
//   protected Real idealWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[2] - idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[1];
//   protected Real idealWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[1];
//   protected Real idealWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[2];
//   protected Real idealWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real idealWheelJoint.cylinder.Form;
//   output Real idealWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.Material;
//   protected output Real idealWheelJoint.cylinder.Extra;
//   parameter String idealWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim1.lengthDirection[1],idealWheelJoint.rim1.lengthDirection[2],idealWheelJoint.rim1.lengthDirection[3]});
//   protected Real idealWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.rim1.lengthDirection[1] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim1.lengthDirection[2] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim1.lengthDirection[3] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[3] - idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[2];
//   protected Real idealWheelJoint.rim1.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[1] - idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[3];
//   protected Real idealWheelJoint.rim1.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[2] - idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[1];
//   protected Real idealWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[1];
//   protected Real idealWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[2];
//   protected Real idealWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim1.Form;
//   output Real idealWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.Material;
//   protected output Real idealWheelJoint.rim1.Extra;
//   parameter String idealWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim2.lengthDirection[1],idealWheelJoint.rim2.lengthDirection[2],idealWheelJoint.rim2.lengthDirection[3]});
//   protected Real idealWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.rim2.lengthDirection[1] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim2.lengthDirection[2] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim2.lengthDirection[3] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[3] - idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[2];
//   protected Real idealWheelJoint.rim2.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[1] - idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[3];
//   protected Real idealWheelJoint.rim2.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[2] - idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[1];
//   protected Real idealWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[1];
//   protected Real idealWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[2];
//   protected Real idealWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim2.Form;
//   output Real idealWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.Material;
//   protected output Real idealWheelJoint.rim2.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 0.1 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 5.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   idealWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.cylinder.shapeType);
//   idealWheelJoint.cylinder.rxvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.ryvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.rvisobj = idealWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.cylinder.R.T[1,1],idealWheelJoint.cylinder.R.T[1,2],idealWheelJoint.cylinder.R.T[1,3]},{idealWheelJoint.cylinder.R.T[2,1],idealWheelJoint.cylinder.R.T[2,2],idealWheelJoint.cylinder.R.T[2,3]},{idealWheelJoint.cylinder.R.T[3,1],idealWheelJoint.cylinder.R.T[3,2],idealWheelJoint.cylinder.R.T[3,3]}},{idealWheelJoint.cylinder.r_shape[1],idealWheelJoint.cylinder.r_shape[2],idealWheelJoint.cylinder.r_shape[3]});
//   idealWheelJoint.cylinder.size[1] = idealWheelJoint.cylinder.length;
//   idealWheelJoint.cylinder.size[2] = idealWheelJoint.cylinder.width;
//   idealWheelJoint.cylinder.size[3] = idealWheelJoint.cylinder.height;
//   idealWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.cylinder.color[1] / 255.0,idealWheelJoint.cylinder.color[2] / 255.0,idealWheelJoint.cylinder.color[3] / 255.0,idealWheelJoint.cylinder.specularCoefficient);
//   idealWheelJoint.cylinder.Extra = idealWheelJoint.cylinder.extra;
//   idealWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim1.shapeType);
//   idealWheelJoint.rim1.rxvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.ryvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.rvisobj = idealWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim1.R.T[1,1],idealWheelJoint.rim1.R.T[1,2],idealWheelJoint.rim1.R.T[1,3]},{idealWheelJoint.rim1.R.T[2,1],idealWheelJoint.rim1.R.T[2,2],idealWheelJoint.rim1.R.T[2,3]},{idealWheelJoint.rim1.R.T[3,1],idealWheelJoint.rim1.R.T[3,2],idealWheelJoint.rim1.R.T[3,3]}},{idealWheelJoint.rim1.r_shape[1],idealWheelJoint.rim1.r_shape[2],idealWheelJoint.rim1.r_shape[3]});
//   idealWheelJoint.rim1.size[1] = idealWheelJoint.rim1.length;
//   idealWheelJoint.rim1.size[2] = idealWheelJoint.rim1.width;
//   idealWheelJoint.rim1.size[3] = idealWheelJoint.rim1.height;
//   idealWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim1.color[1] / 255.0,idealWheelJoint.rim1.color[2] / 255.0,idealWheelJoint.rim1.color[3] / 255.0,idealWheelJoint.rim1.specularCoefficient);
//   idealWheelJoint.rim1.Extra = idealWheelJoint.rim1.extra;
//   idealWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},1.5707963267949 + idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim2.shapeType);
//   idealWheelJoint.rim2.rxvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.ryvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.rvisobj = idealWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim2.R.T[1,1],idealWheelJoint.rim2.R.T[1,2],idealWheelJoint.rim2.R.T[1,3]},{idealWheelJoint.rim2.R.T[2,1],idealWheelJoint.rim2.R.T[2,2],idealWheelJoint.rim2.R.T[2,3]},{idealWheelJoint.rim2.R.T[3,1],idealWheelJoint.rim2.R.T[3,2],idealWheelJoint.rim2.R.T[3,3]}},{idealWheelJoint.rim2.r_shape[1],idealWheelJoint.rim2.r_shape[2],idealWheelJoint.rim2.r_shape[3]});
//   idealWheelJoint.rim2.size[1] = idealWheelJoint.rim2.length;
//   idealWheelJoint.rim2.size[2] = idealWheelJoint.rim2.width;
//   idealWheelJoint.rim2.size[3] = idealWheelJoint.rim2.height;
//   idealWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim2.color[1] / 255.0,idealWheelJoint.rim2.color[2] / 255.0,idealWheelJoint.rim2.color[3] / 255.0,idealWheelJoint.rim2.specularCoefficient);
//   idealWheelJoint.rim2.Extra = idealWheelJoint.rim2.extra;
//   idealWheelJoint.R[1,1] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[1,2] = sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,1] = -sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,2] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.e0[1] = idealWheelJoint.R[1,1] * idealWheelJoint.e[1] + idealWheelJoint.R[1,2] * idealWheelJoint.e[2];
//   idealWheelJoint.e0[2] = idealWheelJoint.R[2,1] * idealWheelJoint.e[1] + idealWheelJoint.R[2,2] * idealWheelJoint.e[2];
//   idealWheelJoint.v[1] = der(idealWheelJoint.frame_a.x);
//   idealWheelJoint.v[2] = der(idealWheelJoint.frame_a.y);
//   idealWheelJoint.v[1] = idealWheelJoint.v_long * idealWheelJoint.e0[1];
//   idealWheelJoint.v[2] = idealWheelJoint.v_long * idealWheelJoint.e0[2];
//   idealWheelJoint.w_roll = der(idealWheelJoint.flange_a.phi);
//   idealWheelJoint.v_long = idealWheelJoint.radius * idealWheelJoint.w_roll;
//   idealWheelJoint.a = der(idealWheelJoint.v_long);
//   (-idealWheelJoint.f_long) * idealWheelJoint.radius = idealWheelJoint.flange_a.tau;
//   idealWheelJoint.frame_a.t = 0.0;
//   idealWheelJoint.frame_a.fx * idealWheelJoint.e0[1] + idealWheelJoint.frame_a.fy * idealWheelJoint.e0[2] = idealWheelJoint.f_long;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   body.frame_a.t + idealWheelJoint.frame_a.t = 0.0;
//   body.frame_a.fy + idealWheelJoint.frame_a.fy = 0.0;
//   body.frame_a.fx + idealWheelJoint.frame_a.fx = 0.0;
//   idealWheelJoint.flange_a.tau + inertia.flange_b.tau = 0.0;
//   inertia.flange_a.tau = 0.0;
//   body.frame_a.x = idealWheelJoint.frame_a.x;
//   body.frame_a.y = idealWheelJoint.frame_a.y;
//   body.frame_a.phi = idealWheelJoint.frame_a.phi;
//   idealWheelJoint.flange_a.phi = inertia.flange_b.phi;
// end PlanarMechanicsV4.Examples.FreeWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.FreeWheelwithFriction
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 2.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real DryFrictionWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real DryFrictionWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real DryFrictionWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real DryFrictionWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real DryFrictionWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real DryFrictionWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real DryFrictionWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DryFrictionWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real DryFrictionWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real DryFrictionWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real DryFrictionWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real DryFrictionWheelJoint.N(quantity = \"Force\", unit = \"N\") = 100.0 \"normal force\";
//   parameter Real DryFrictionWheelJoint.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real DryFrictionWheelJoint.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.2 \"sliding velocity\";
//   parameter Real DryFrictionWheelJoint.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real DryFrictionWheelJoint.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real DryFrictionWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real DryFrictionWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real DryFrictionWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real DryFrictionWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real DryFrictionWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real DryFrictionWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real DryFrictionWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real DryFrictionWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real DryFrictionWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real DryFrictionWheelJoint.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real DryFrictionWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real DryFrictionWheelJoint.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real DryFrictionWheelJoint.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real DryFrictionWheelJoint.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real DryFrictionWheelJoint.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real DryFrictionWheelJoint.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real DryFrictionWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean DryFrictionWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean DryFrictionWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real DryFrictionWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(DryFrictionWheelJoint.r[1] ^ 2.0 + DryFrictionWheelJoint.r[2] ^ 2.0);
//   final parameter Real DryFrictionWheelJoint.e[1] = DryFrictionWheelJoint.r[1] / DryFrictionWheelJoint.l \"normalized direction\";
//   final parameter Real DryFrictionWheelJoint.e[2] = DryFrictionWheelJoint.r[2] / DryFrictionWheelJoint.l \"normalized direction\";
//   parameter String DryFrictionWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = DryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = DryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * DryFrictionWheelJoint.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * DryFrictionWheelJoint.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -DryFrictionWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = DryFrictionWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real DryFrictionWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * DryFrictionWheelJoint.radius \"Width of visual object\";
//   input Real DryFrictionWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * DryFrictionWheelJoint.radius \"Height of visual object\";
//   input Real DryFrictionWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real DryFrictionWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real DryFrictionWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({DryFrictionWheelJoint.cylinder.lengthDirection[1],DryFrictionWheelJoint.cylinder.lengthDirection[2],DryFrictionWheelJoint.cylinder.lengthDirection[3]});
//   protected Real DryFrictionWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(DryFrictionWheelJoint.cylinder.abs_n_x < 1e-10) then 1.0 else DryFrictionWheelJoint.cylinder.lengthDirection[1] / DryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real DryFrictionWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(DryFrictionWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else DryFrictionWheelJoint.cylinder.lengthDirection[2] / DryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real DryFrictionWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(DryFrictionWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else DryFrictionWheelJoint.cylinder.lengthDirection[3] / DryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real DryFrictionWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = DryFrictionWheelJoint.cylinder.e_x[2] * DryFrictionWheelJoint.cylinder.widthDirection[3] - DryFrictionWheelJoint.cylinder.e_x[3] * DryFrictionWheelJoint.cylinder.widthDirection[2];
//   protected Real DryFrictionWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = DryFrictionWheelJoint.cylinder.e_x[3] * DryFrictionWheelJoint.cylinder.widthDirection[1] - DryFrictionWheelJoint.cylinder.e_x[1] * DryFrictionWheelJoint.cylinder.widthDirection[3];
//   protected Real DryFrictionWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = DryFrictionWheelJoint.cylinder.e_x[1] * DryFrictionWheelJoint.cylinder.widthDirection[2] - DryFrictionWheelJoint.cylinder.e_x[2] * DryFrictionWheelJoint.cylinder.widthDirection[1];
//   protected Real DryFrictionWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.cylinder.e_x[1],DryFrictionWheelJoint.cylinder.e_x[2],DryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(DryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.cylinder.widthDirection[1],DryFrictionWheelJoint.cylinder.widthDirection[2],DryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.cylinder.e_x[1],DryFrictionWheelJoint.cylinder.e_x[2],DryFrictionWheelJoint.cylinder.e_x[3]})[1];
//   protected Real DryFrictionWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.cylinder.e_x[1],DryFrictionWheelJoint.cylinder.e_x[2],DryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(DryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.cylinder.widthDirection[1],DryFrictionWheelJoint.cylinder.widthDirection[2],DryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.cylinder.e_x[1],DryFrictionWheelJoint.cylinder.e_x[2],DryFrictionWheelJoint.cylinder.e_x[3]})[2];
//   protected Real DryFrictionWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.cylinder.e_x[1],DryFrictionWheelJoint.cylinder.e_x[2],DryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(DryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.cylinder.widthDirection[1],DryFrictionWheelJoint.cylinder.widthDirection[2],DryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.cylinder.e_x[1],DryFrictionWheelJoint.cylinder.e_x[2],DryFrictionWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real DryFrictionWheelJoint.cylinder.Form;
//   output Real DryFrictionWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real DryFrictionWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real DryFrictionWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.cylinder.Material;
//   protected output Real DryFrictionWheelJoint.cylinder.Extra;
//   parameter String DryFrictionWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real DryFrictionWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = DryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = DryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -DryFrictionWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * DryFrictionWheelJoint.radius \"Length of visual object\";
//   input Real DryFrictionWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real DryFrictionWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real DryFrictionWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real DryFrictionWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real DryFrictionWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({DryFrictionWheelJoint.rim1.lengthDirection[1],DryFrictionWheelJoint.rim1.lengthDirection[2],DryFrictionWheelJoint.rim1.lengthDirection[3]});
//   protected Real DryFrictionWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(DryFrictionWheelJoint.rim1.abs_n_x < 1e-10) then 1.0 else DryFrictionWheelJoint.rim1.lengthDirection[1] / DryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real DryFrictionWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(DryFrictionWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else DryFrictionWheelJoint.rim1.lengthDirection[2] / DryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real DryFrictionWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(DryFrictionWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else DryFrictionWheelJoint.rim1.lengthDirection[3] / DryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real DryFrictionWheelJoint.rim1.n_z_aux[1](unit = \"1\") = DryFrictionWheelJoint.rim1.e_x[2] * DryFrictionWheelJoint.rim1.widthDirection[3] - DryFrictionWheelJoint.rim1.e_x[3] * DryFrictionWheelJoint.rim1.widthDirection[2];
//   protected Real DryFrictionWheelJoint.rim1.n_z_aux[2](unit = \"1\") = DryFrictionWheelJoint.rim1.e_x[3] * DryFrictionWheelJoint.rim1.widthDirection[1] - DryFrictionWheelJoint.rim1.e_x[1] * DryFrictionWheelJoint.rim1.widthDirection[3];
//   protected Real DryFrictionWheelJoint.rim1.n_z_aux[3](unit = \"1\") = DryFrictionWheelJoint.rim1.e_x[1] * DryFrictionWheelJoint.rim1.widthDirection[2] - DryFrictionWheelJoint.rim1.e_x[2] * DryFrictionWheelJoint.rim1.widthDirection[1];
//   protected Real DryFrictionWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.rim1.e_x[1],DryFrictionWheelJoint.rim1.e_x[2],DryFrictionWheelJoint.rim1.e_x[3]},if noEvent(DryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.rim1.widthDirection[1],DryFrictionWheelJoint.rim1.widthDirection[2],DryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.rim1.e_x[1],DryFrictionWheelJoint.rim1.e_x[2],DryFrictionWheelJoint.rim1.e_x[3]})[1];
//   protected Real DryFrictionWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.rim1.e_x[1],DryFrictionWheelJoint.rim1.e_x[2],DryFrictionWheelJoint.rim1.e_x[3]},if noEvent(DryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.rim1.widthDirection[1],DryFrictionWheelJoint.rim1.widthDirection[2],DryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.rim1.e_x[1],DryFrictionWheelJoint.rim1.e_x[2],DryFrictionWheelJoint.rim1.e_x[3]})[2];
//   protected Real DryFrictionWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.rim1.e_x[1],DryFrictionWheelJoint.rim1.e_x[2],DryFrictionWheelJoint.rim1.e_x[3]},if noEvent(DryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.rim1.widthDirection[1],DryFrictionWheelJoint.rim1.widthDirection[2],DryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.rim1.e_x[1],DryFrictionWheelJoint.rim1.e_x[2],DryFrictionWheelJoint.rim1.e_x[3]})[3];
//   protected output Real DryFrictionWheelJoint.rim1.Form;
//   output Real DryFrictionWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real DryFrictionWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.rim1.Material;
//   protected output Real DryFrictionWheelJoint.rim1.Extra;
//   parameter String DryFrictionWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real DryFrictionWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real DryFrictionWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = DryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = DryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real DryFrictionWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -DryFrictionWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real DryFrictionWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * DryFrictionWheelJoint.radius \"Length of visual object\";
//   input Real DryFrictionWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real DryFrictionWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real DryFrictionWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real DryFrictionWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real DryFrictionWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real DryFrictionWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({DryFrictionWheelJoint.rim2.lengthDirection[1],DryFrictionWheelJoint.rim2.lengthDirection[2],DryFrictionWheelJoint.rim2.lengthDirection[3]});
//   protected Real DryFrictionWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(DryFrictionWheelJoint.rim2.abs_n_x < 1e-10) then 1.0 else DryFrictionWheelJoint.rim2.lengthDirection[1] / DryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real DryFrictionWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(DryFrictionWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else DryFrictionWheelJoint.rim2.lengthDirection[2] / DryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real DryFrictionWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(DryFrictionWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else DryFrictionWheelJoint.rim2.lengthDirection[3] / DryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real DryFrictionWheelJoint.rim2.n_z_aux[1](unit = \"1\") = DryFrictionWheelJoint.rim2.e_x[2] * DryFrictionWheelJoint.rim2.widthDirection[3] - DryFrictionWheelJoint.rim2.e_x[3] * DryFrictionWheelJoint.rim2.widthDirection[2];
//   protected Real DryFrictionWheelJoint.rim2.n_z_aux[2](unit = \"1\") = DryFrictionWheelJoint.rim2.e_x[3] * DryFrictionWheelJoint.rim2.widthDirection[1] - DryFrictionWheelJoint.rim2.e_x[1] * DryFrictionWheelJoint.rim2.widthDirection[3];
//   protected Real DryFrictionWheelJoint.rim2.n_z_aux[3](unit = \"1\") = DryFrictionWheelJoint.rim2.e_x[1] * DryFrictionWheelJoint.rim2.widthDirection[2] - DryFrictionWheelJoint.rim2.e_x[2] * DryFrictionWheelJoint.rim2.widthDirection[1];
//   protected Real DryFrictionWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.rim2.e_x[1],DryFrictionWheelJoint.rim2.e_x[2],DryFrictionWheelJoint.rim2.e_x[3]},if noEvent(DryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.rim2.widthDirection[1],DryFrictionWheelJoint.rim2.widthDirection[2],DryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.rim2.e_x[1],DryFrictionWheelJoint.rim2.e_x[2],DryFrictionWheelJoint.rim2.e_x[3]})[1];
//   protected Real DryFrictionWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.rim2.e_x[1],DryFrictionWheelJoint.rim2.e_x[2],DryFrictionWheelJoint.rim2.e_x[3]},if noEvent(DryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.rim2.widthDirection[1],DryFrictionWheelJoint.rim2.widthDirection[2],DryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.rim2.e_x[1],DryFrictionWheelJoint.rim2.e_x[2],DryFrictionWheelJoint.rim2.e_x[3]})[2];
//   protected Real DryFrictionWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({DryFrictionWheelJoint.rim2.e_x[1],DryFrictionWheelJoint.rim2.e_x[2],DryFrictionWheelJoint.rim2.e_x[3]},if noEvent(DryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (DryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + DryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {DryFrictionWheelJoint.rim2.widthDirection[1],DryFrictionWheelJoint.rim2.widthDirection[2],DryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(DryFrictionWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{DryFrictionWheelJoint.rim2.e_x[1],DryFrictionWheelJoint.rim2.e_x[2],DryFrictionWheelJoint.rim2.e_x[3]})[3];
//   protected output Real DryFrictionWheelJoint.rim2.Form;
//   output Real DryFrictionWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real DryFrictionWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real DryFrictionWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real DryFrictionWheelJoint.rim2.Material;
//   protected output Real DryFrictionWheelJoint.rim2.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 0.1 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 5.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   DryFrictionWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(DryFrictionWheelJoint.cylinder.shapeType);
//   DryFrictionWheelJoint.cylinder.rxvisobj[1] = DryFrictionWheelJoint.cylinder.R.T[1,1] * DryFrictionWheelJoint.cylinder.e_x[1] + DryFrictionWheelJoint.cylinder.R.T[2,1] * DryFrictionWheelJoint.cylinder.e_x[2] + DryFrictionWheelJoint.cylinder.R.T[3,1] * DryFrictionWheelJoint.cylinder.e_x[3];
//   DryFrictionWheelJoint.cylinder.rxvisobj[2] = DryFrictionWheelJoint.cylinder.R.T[1,2] * DryFrictionWheelJoint.cylinder.e_x[1] + DryFrictionWheelJoint.cylinder.R.T[2,2] * DryFrictionWheelJoint.cylinder.e_x[2] + DryFrictionWheelJoint.cylinder.R.T[3,2] * DryFrictionWheelJoint.cylinder.e_x[3];
//   DryFrictionWheelJoint.cylinder.rxvisobj[3] = DryFrictionWheelJoint.cylinder.R.T[1,3] * DryFrictionWheelJoint.cylinder.e_x[1] + DryFrictionWheelJoint.cylinder.R.T[2,3] * DryFrictionWheelJoint.cylinder.e_x[2] + DryFrictionWheelJoint.cylinder.R.T[3,3] * DryFrictionWheelJoint.cylinder.e_x[3];
//   DryFrictionWheelJoint.cylinder.ryvisobj[1] = DryFrictionWheelJoint.cylinder.R.T[1,1] * DryFrictionWheelJoint.cylinder.e_y[1] + DryFrictionWheelJoint.cylinder.R.T[2,1] * DryFrictionWheelJoint.cylinder.e_y[2] + DryFrictionWheelJoint.cylinder.R.T[3,1] * DryFrictionWheelJoint.cylinder.e_y[3];
//   DryFrictionWheelJoint.cylinder.ryvisobj[2] = DryFrictionWheelJoint.cylinder.R.T[1,2] * DryFrictionWheelJoint.cylinder.e_y[1] + DryFrictionWheelJoint.cylinder.R.T[2,2] * DryFrictionWheelJoint.cylinder.e_y[2] + DryFrictionWheelJoint.cylinder.R.T[3,2] * DryFrictionWheelJoint.cylinder.e_y[3];
//   DryFrictionWheelJoint.cylinder.ryvisobj[3] = DryFrictionWheelJoint.cylinder.R.T[1,3] * DryFrictionWheelJoint.cylinder.e_y[1] + DryFrictionWheelJoint.cylinder.R.T[2,3] * DryFrictionWheelJoint.cylinder.e_y[2] + DryFrictionWheelJoint.cylinder.R.T[3,3] * DryFrictionWheelJoint.cylinder.e_y[3];
//   DryFrictionWheelJoint.cylinder.rvisobj = DryFrictionWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{DryFrictionWheelJoint.cylinder.R.T[1,1],DryFrictionWheelJoint.cylinder.R.T[1,2],DryFrictionWheelJoint.cylinder.R.T[1,3]},{DryFrictionWheelJoint.cylinder.R.T[2,1],DryFrictionWheelJoint.cylinder.R.T[2,2],DryFrictionWheelJoint.cylinder.R.T[2,3]},{DryFrictionWheelJoint.cylinder.R.T[3,1],DryFrictionWheelJoint.cylinder.R.T[3,2],DryFrictionWheelJoint.cylinder.R.T[3,3]}},{DryFrictionWheelJoint.cylinder.r_shape[1],DryFrictionWheelJoint.cylinder.r_shape[2],DryFrictionWheelJoint.cylinder.r_shape[3]});
//   DryFrictionWheelJoint.cylinder.size[1] = DryFrictionWheelJoint.cylinder.length;
//   DryFrictionWheelJoint.cylinder.size[2] = DryFrictionWheelJoint.cylinder.width;
//   DryFrictionWheelJoint.cylinder.size[3] = DryFrictionWheelJoint.cylinder.height;
//   DryFrictionWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(DryFrictionWheelJoint.cylinder.color[1] / 255.0,DryFrictionWheelJoint.cylinder.color[2] / 255.0,DryFrictionWheelJoint.cylinder.color[3] / 255.0,DryFrictionWheelJoint.cylinder.specularCoefficient);
//   DryFrictionWheelJoint.cylinder.Extra = DryFrictionWheelJoint.cylinder.extra;
//   DryFrictionWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-DryFrictionWheelJoint.e0[2],DryFrictionWheelJoint.e0[1],0.0},DryFrictionWheelJoint.flange_a.phi,0.0);
//   DryFrictionWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(DryFrictionWheelJoint.rim1.shapeType);
//   DryFrictionWheelJoint.rim1.rxvisobj[1] = DryFrictionWheelJoint.rim1.R.T[1,1] * DryFrictionWheelJoint.rim1.e_x[1] + DryFrictionWheelJoint.rim1.R.T[2,1] * DryFrictionWheelJoint.rim1.e_x[2] + DryFrictionWheelJoint.rim1.R.T[3,1] * DryFrictionWheelJoint.rim1.e_x[3];
//   DryFrictionWheelJoint.rim1.rxvisobj[2] = DryFrictionWheelJoint.rim1.R.T[1,2] * DryFrictionWheelJoint.rim1.e_x[1] + DryFrictionWheelJoint.rim1.R.T[2,2] * DryFrictionWheelJoint.rim1.e_x[2] + DryFrictionWheelJoint.rim1.R.T[3,2] * DryFrictionWheelJoint.rim1.e_x[3];
//   DryFrictionWheelJoint.rim1.rxvisobj[3] = DryFrictionWheelJoint.rim1.R.T[1,3] * DryFrictionWheelJoint.rim1.e_x[1] + DryFrictionWheelJoint.rim1.R.T[2,3] * DryFrictionWheelJoint.rim1.e_x[2] + DryFrictionWheelJoint.rim1.R.T[3,3] * DryFrictionWheelJoint.rim1.e_x[3];
//   DryFrictionWheelJoint.rim1.ryvisobj[1] = DryFrictionWheelJoint.rim1.R.T[1,1] * DryFrictionWheelJoint.rim1.e_y[1] + DryFrictionWheelJoint.rim1.R.T[2,1] * DryFrictionWheelJoint.rim1.e_y[2] + DryFrictionWheelJoint.rim1.R.T[3,1] * DryFrictionWheelJoint.rim1.e_y[3];
//   DryFrictionWheelJoint.rim1.ryvisobj[2] = DryFrictionWheelJoint.rim1.R.T[1,2] * DryFrictionWheelJoint.rim1.e_y[1] + DryFrictionWheelJoint.rim1.R.T[2,2] * DryFrictionWheelJoint.rim1.e_y[2] + DryFrictionWheelJoint.rim1.R.T[3,2] * DryFrictionWheelJoint.rim1.e_y[3];
//   DryFrictionWheelJoint.rim1.ryvisobj[3] = DryFrictionWheelJoint.rim1.R.T[1,3] * DryFrictionWheelJoint.rim1.e_y[1] + DryFrictionWheelJoint.rim1.R.T[2,3] * DryFrictionWheelJoint.rim1.e_y[2] + DryFrictionWheelJoint.rim1.R.T[3,3] * DryFrictionWheelJoint.rim1.e_y[3];
//   DryFrictionWheelJoint.rim1.rvisobj = DryFrictionWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{DryFrictionWheelJoint.rim1.R.T[1,1],DryFrictionWheelJoint.rim1.R.T[1,2],DryFrictionWheelJoint.rim1.R.T[1,3]},{DryFrictionWheelJoint.rim1.R.T[2,1],DryFrictionWheelJoint.rim1.R.T[2,2],DryFrictionWheelJoint.rim1.R.T[2,3]},{DryFrictionWheelJoint.rim1.R.T[3,1],DryFrictionWheelJoint.rim1.R.T[3,2],DryFrictionWheelJoint.rim1.R.T[3,3]}},{DryFrictionWheelJoint.rim1.r_shape[1],DryFrictionWheelJoint.rim1.r_shape[2],DryFrictionWheelJoint.rim1.r_shape[3]});
//   DryFrictionWheelJoint.rim1.size[1] = DryFrictionWheelJoint.rim1.length;
//   DryFrictionWheelJoint.rim1.size[2] = DryFrictionWheelJoint.rim1.width;
//   DryFrictionWheelJoint.rim1.size[3] = DryFrictionWheelJoint.rim1.height;
//   DryFrictionWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(DryFrictionWheelJoint.rim1.color[1] / 255.0,DryFrictionWheelJoint.rim1.color[2] / 255.0,DryFrictionWheelJoint.rim1.color[3] / 255.0,DryFrictionWheelJoint.rim1.specularCoefficient);
//   DryFrictionWheelJoint.rim1.Extra = DryFrictionWheelJoint.rim1.extra;
//   DryFrictionWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-DryFrictionWheelJoint.e0[2],DryFrictionWheelJoint.e0[1],0.0},1.5707963267949 + DryFrictionWheelJoint.flange_a.phi,0.0);
//   DryFrictionWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(DryFrictionWheelJoint.rim2.shapeType);
//   DryFrictionWheelJoint.rim2.rxvisobj[1] = DryFrictionWheelJoint.rim2.R.T[1,1] * DryFrictionWheelJoint.rim2.e_x[1] + DryFrictionWheelJoint.rim2.R.T[2,1] * DryFrictionWheelJoint.rim2.e_x[2] + DryFrictionWheelJoint.rim2.R.T[3,1] * DryFrictionWheelJoint.rim2.e_x[3];
//   DryFrictionWheelJoint.rim2.rxvisobj[2] = DryFrictionWheelJoint.rim2.R.T[1,2] * DryFrictionWheelJoint.rim2.e_x[1] + DryFrictionWheelJoint.rim2.R.T[2,2] * DryFrictionWheelJoint.rim2.e_x[2] + DryFrictionWheelJoint.rim2.R.T[3,2] * DryFrictionWheelJoint.rim2.e_x[3];
//   DryFrictionWheelJoint.rim2.rxvisobj[3] = DryFrictionWheelJoint.rim2.R.T[1,3] * DryFrictionWheelJoint.rim2.e_x[1] + DryFrictionWheelJoint.rim2.R.T[2,3] * DryFrictionWheelJoint.rim2.e_x[2] + DryFrictionWheelJoint.rim2.R.T[3,3] * DryFrictionWheelJoint.rim2.e_x[3];
//   DryFrictionWheelJoint.rim2.ryvisobj[1] = DryFrictionWheelJoint.rim2.R.T[1,1] * DryFrictionWheelJoint.rim2.e_y[1] + DryFrictionWheelJoint.rim2.R.T[2,1] * DryFrictionWheelJoint.rim2.e_y[2] + DryFrictionWheelJoint.rim2.R.T[3,1] * DryFrictionWheelJoint.rim2.e_y[3];
//   DryFrictionWheelJoint.rim2.ryvisobj[2] = DryFrictionWheelJoint.rim2.R.T[1,2] * DryFrictionWheelJoint.rim2.e_y[1] + DryFrictionWheelJoint.rim2.R.T[2,2] * DryFrictionWheelJoint.rim2.e_y[2] + DryFrictionWheelJoint.rim2.R.T[3,2] * DryFrictionWheelJoint.rim2.e_y[3];
//   DryFrictionWheelJoint.rim2.ryvisobj[3] = DryFrictionWheelJoint.rim2.R.T[1,3] * DryFrictionWheelJoint.rim2.e_y[1] + DryFrictionWheelJoint.rim2.R.T[2,3] * DryFrictionWheelJoint.rim2.e_y[2] + DryFrictionWheelJoint.rim2.R.T[3,3] * DryFrictionWheelJoint.rim2.e_y[3];
//   DryFrictionWheelJoint.rim2.rvisobj = DryFrictionWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{DryFrictionWheelJoint.rim2.R.T[1,1],DryFrictionWheelJoint.rim2.R.T[1,2],DryFrictionWheelJoint.rim2.R.T[1,3]},{DryFrictionWheelJoint.rim2.R.T[2,1],DryFrictionWheelJoint.rim2.R.T[2,2],DryFrictionWheelJoint.rim2.R.T[2,3]},{DryFrictionWheelJoint.rim2.R.T[3,1],DryFrictionWheelJoint.rim2.R.T[3,2],DryFrictionWheelJoint.rim2.R.T[3,3]}},{DryFrictionWheelJoint.rim2.r_shape[1],DryFrictionWheelJoint.rim2.r_shape[2],DryFrictionWheelJoint.rim2.r_shape[3]});
//   DryFrictionWheelJoint.rim2.size[1] = DryFrictionWheelJoint.rim2.length;
//   DryFrictionWheelJoint.rim2.size[2] = DryFrictionWheelJoint.rim2.width;
//   DryFrictionWheelJoint.rim2.size[3] = DryFrictionWheelJoint.rim2.height;
//   DryFrictionWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(DryFrictionWheelJoint.rim2.color[1] / 255.0,DryFrictionWheelJoint.rim2.color[2] / 255.0,DryFrictionWheelJoint.rim2.color[3] / 255.0,DryFrictionWheelJoint.rim2.specularCoefficient);
//   DryFrictionWheelJoint.rim2.Extra = DryFrictionWheelJoint.rim2.extra;
//   DryFrictionWheelJoint.R[1,1] = cos(DryFrictionWheelJoint.frame_a.phi);
//   DryFrictionWheelJoint.R[1,2] = sin(DryFrictionWheelJoint.frame_a.phi);
//   DryFrictionWheelJoint.R[2,1] = -sin(DryFrictionWheelJoint.frame_a.phi);
//   DryFrictionWheelJoint.R[2,2] = cos(DryFrictionWheelJoint.frame_a.phi);
//   DryFrictionWheelJoint.e0[1] = DryFrictionWheelJoint.R[1,1] * DryFrictionWheelJoint.e[1] + DryFrictionWheelJoint.R[1,2] * DryFrictionWheelJoint.e[2];
//   DryFrictionWheelJoint.e0[2] = DryFrictionWheelJoint.R[2,1] * DryFrictionWheelJoint.e[1] + DryFrictionWheelJoint.R[2,2] * DryFrictionWheelJoint.e[2];
//   DryFrictionWheelJoint.v[1] = der(DryFrictionWheelJoint.frame_a.x);
//   DryFrictionWheelJoint.v[2] = der(DryFrictionWheelJoint.frame_a.y);
//   DryFrictionWheelJoint.w_roll = der(DryFrictionWheelJoint.flange_a.phi);
//   DryFrictionWheelJoint.v_long = DryFrictionWheelJoint.v[1] * DryFrictionWheelJoint.e0[1] + DryFrictionWheelJoint.v[2] * DryFrictionWheelJoint.e0[2];
//   DryFrictionWheelJoint.v_lat = (-DryFrictionWheelJoint.v[1]) * DryFrictionWheelJoint.e0[2] + DryFrictionWheelJoint.v[2] * DryFrictionWheelJoint.e0[1];
//   DryFrictionWheelJoint.v_slip_lat = DryFrictionWheelJoint.v_lat;
//   DryFrictionWheelJoint.v_slip_long = DryFrictionWheelJoint.v_long - DryFrictionWheelJoint.radius * DryFrictionWheelJoint.w_roll;
//   DryFrictionWheelJoint.v_slip = 0.0001 + sqrt(DryFrictionWheelJoint.v_slip_long ^ 2.0 + DryFrictionWheelJoint.v_slip_lat ^ 2.0);
//   (-DryFrictionWheelJoint.f_long) * DryFrictionWheelJoint.radius = DryFrictionWheelJoint.flange_a.tau;
//   DryFrictionWheelJoint.frame_a.t = 0.0;
//   DryFrictionWheelJoint.f = DryFrictionWheelJoint.N * PlanarMechanicsV4.Utilities.TripleS_Func(DryFrictionWheelJoint.vAdhesion,DryFrictionWheelJoint.vSlide,DryFrictionWheelJoint.mu_A,DryFrictionWheelJoint.mu_S,DryFrictionWheelJoint.v_slip);
//   DryFrictionWheelJoint.f_long = (DryFrictionWheelJoint.f * DryFrictionWheelJoint.v_slip_long) / DryFrictionWheelJoint.v_slip;
//   DryFrictionWheelJoint.f_lat = (DryFrictionWheelJoint.f * DryFrictionWheelJoint.v_slip_lat) / DryFrictionWheelJoint.v_slip;
//   DryFrictionWheelJoint.f_long = DryFrictionWheelJoint.frame_a.fx * DryFrictionWheelJoint.e0[1] + DryFrictionWheelJoint.frame_a.fy * DryFrictionWheelJoint.e0[2];
//   DryFrictionWheelJoint.f_lat = DryFrictionWheelJoint.frame_a.fy * DryFrictionWheelJoint.e0[1] + (-DryFrictionWheelJoint.frame_a.fx) * DryFrictionWheelJoint.e0[2];
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   body.frame_a.t + DryFrictionWheelJoint.frame_a.t = 0.0;
//   body.frame_a.fy + DryFrictionWheelJoint.frame_a.fy = 0.0;
//   body.frame_a.fx + DryFrictionWheelJoint.frame_a.fx = 0.0;
//   DryFrictionWheelJoint.flange_a.tau + inertia.flange_b.tau = 0.0;
//   inertia.flange_a.tau = 0.0;
//   DryFrictionWheelJoint.frame_a.x = body.frame_a.x;
//   DryFrictionWheelJoint.frame_a.y = body.frame_a.y;
//   DryFrictionWheelJoint.frame_a.phi = body.frame_a.phi;
//   DryFrictionWheelJoint.flange_a.phi = inertia.flange_b.phi;
// end PlanarMechanicsV4.Examples.FreeWheelwithFriction;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.TestIdealWheel
//   Real idealWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real idealWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real idealWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelJoint.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean idealWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelJoint.r[1] ^ 2.0 + idealWheelJoint.r[2] ^ 2.0);
//   final parameter Real idealWheelJoint.e[1] = idealWheelJoint.r[1] / idealWheelJoint.l \"normalized direction\";
//   final parameter Real idealWheelJoint.e[2] = idealWheelJoint.r[2] / idealWheelJoint.l \"normalized direction\";
//   parameter String idealWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * idealWheelJoint.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * idealWheelJoint.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = idealWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Width of visual object\";
//   input Real idealWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Height of visual object\";
//   input Real idealWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.cylinder.lengthDirection[1],idealWheelJoint.cylinder.lengthDirection[2],idealWheelJoint.cylinder.lengthDirection[3]});
//   protected Real idealWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.cylinder.lengthDirection[1] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.cylinder.lengthDirection[2] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.cylinder.lengthDirection[3] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[3] - idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[2];
//   protected Real idealWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[1] - idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[3];
//   protected Real idealWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[2] - idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[1];
//   protected Real idealWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[1];
//   protected Real idealWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[2];
//   protected Real idealWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real idealWheelJoint.cylinder.Form;
//   output Real idealWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.Material;
//   protected output Real idealWheelJoint.cylinder.Extra;
//   parameter String idealWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim1.lengthDirection[1],idealWheelJoint.rim1.lengthDirection[2],idealWheelJoint.rim1.lengthDirection[3]});
//   protected Real idealWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.rim1.lengthDirection[1] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim1.lengthDirection[2] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim1.lengthDirection[3] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[3] - idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[2];
//   protected Real idealWheelJoint.rim1.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[1] - idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[3];
//   protected Real idealWheelJoint.rim1.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[2] - idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[1];
//   protected Real idealWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[1];
//   protected Real idealWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[2];
//   protected Real idealWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim1.Form;
//   output Real idealWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.Material;
//   protected output Real idealWheelJoint.rim1.Extra;
//   parameter String idealWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim2.lengthDirection[1],idealWheelJoint.rim2.lengthDirection[2],idealWheelJoint.rim2.lengthDirection[3]});
//   protected Real idealWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.rim2.lengthDirection[1] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim2.lengthDirection[2] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim2.lengthDirection[3] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[3] - idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[2];
//   protected Real idealWheelJoint.rim2.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[1] - idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[3];
//   protected Real idealWheelJoint.rim2.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[2] - idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[1];
//   protected Real idealWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[1];
//   protected Real idealWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[2];
//   protected Real idealWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim2.Form;
//   output Real idealWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.Material;
//   protected output Real idealWheelJoint.rim2.Extra;
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, start = 1.0);
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
// equation
//   idealWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.cylinder.shapeType);
//   idealWheelJoint.cylinder.rxvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.ryvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.rvisobj = idealWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.cylinder.R.T[1,1],idealWheelJoint.cylinder.R.T[1,2],idealWheelJoint.cylinder.R.T[1,3]},{idealWheelJoint.cylinder.R.T[2,1],idealWheelJoint.cylinder.R.T[2,2],idealWheelJoint.cylinder.R.T[2,3]},{idealWheelJoint.cylinder.R.T[3,1],idealWheelJoint.cylinder.R.T[3,2],idealWheelJoint.cylinder.R.T[3,3]}},{idealWheelJoint.cylinder.r_shape[1],idealWheelJoint.cylinder.r_shape[2],idealWheelJoint.cylinder.r_shape[3]});
//   idealWheelJoint.cylinder.size[1] = idealWheelJoint.cylinder.length;
//   idealWheelJoint.cylinder.size[2] = idealWheelJoint.cylinder.width;
//   idealWheelJoint.cylinder.size[3] = idealWheelJoint.cylinder.height;
//   idealWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.cylinder.color[1] / 255.0,idealWheelJoint.cylinder.color[2] / 255.0,idealWheelJoint.cylinder.color[3] / 255.0,idealWheelJoint.cylinder.specularCoefficient);
//   idealWheelJoint.cylinder.Extra = idealWheelJoint.cylinder.extra;
//   idealWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim1.shapeType);
//   idealWheelJoint.rim1.rxvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.ryvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.rvisobj = idealWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim1.R.T[1,1],idealWheelJoint.rim1.R.T[1,2],idealWheelJoint.rim1.R.T[1,3]},{idealWheelJoint.rim1.R.T[2,1],idealWheelJoint.rim1.R.T[2,2],idealWheelJoint.rim1.R.T[2,3]},{idealWheelJoint.rim1.R.T[3,1],idealWheelJoint.rim1.R.T[3,2],idealWheelJoint.rim1.R.T[3,3]}},{idealWheelJoint.rim1.r_shape[1],idealWheelJoint.rim1.r_shape[2],idealWheelJoint.rim1.r_shape[3]});
//   idealWheelJoint.rim1.size[1] = idealWheelJoint.rim1.length;
//   idealWheelJoint.rim1.size[2] = idealWheelJoint.rim1.width;
//   idealWheelJoint.rim1.size[3] = idealWheelJoint.rim1.height;
//   idealWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim1.color[1] / 255.0,idealWheelJoint.rim1.color[2] / 255.0,idealWheelJoint.rim1.color[3] / 255.0,idealWheelJoint.rim1.specularCoefficient);
//   idealWheelJoint.rim1.Extra = idealWheelJoint.rim1.extra;
//   idealWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},1.5707963267949 + idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim2.shapeType);
//   idealWheelJoint.rim2.rxvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.ryvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.rvisobj = idealWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim2.R.T[1,1],idealWheelJoint.rim2.R.T[1,2],idealWheelJoint.rim2.R.T[1,3]},{idealWheelJoint.rim2.R.T[2,1],idealWheelJoint.rim2.R.T[2,2],idealWheelJoint.rim2.R.T[2,3]},{idealWheelJoint.rim2.R.T[3,1],idealWheelJoint.rim2.R.T[3,2],idealWheelJoint.rim2.R.T[3,3]}},{idealWheelJoint.rim2.r_shape[1],idealWheelJoint.rim2.r_shape[2],idealWheelJoint.rim2.r_shape[3]});
//   idealWheelJoint.rim2.size[1] = idealWheelJoint.rim2.length;
//   idealWheelJoint.rim2.size[2] = idealWheelJoint.rim2.width;
//   idealWheelJoint.rim2.size[3] = idealWheelJoint.rim2.height;
//   idealWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim2.color[1] / 255.0,idealWheelJoint.rim2.color[2] / 255.0,idealWheelJoint.rim2.color[3] / 255.0,idealWheelJoint.rim2.specularCoefficient);
//   idealWheelJoint.rim2.Extra = idealWheelJoint.rim2.extra;
//   idealWheelJoint.R[1,1] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[1,2] = sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,1] = -sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,2] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.e0[1] = idealWheelJoint.R[1,1] * idealWheelJoint.e[1] + idealWheelJoint.R[1,2] * idealWheelJoint.e[2];
//   idealWheelJoint.e0[2] = idealWheelJoint.R[2,1] * idealWheelJoint.e[1] + idealWheelJoint.R[2,2] * idealWheelJoint.e[2];
//   idealWheelJoint.v[1] = der(idealWheelJoint.frame_a.x);
//   idealWheelJoint.v[2] = der(idealWheelJoint.frame_a.y);
//   idealWheelJoint.v[1] = idealWheelJoint.v_long * idealWheelJoint.e0[1];
//   idealWheelJoint.v[2] = idealWheelJoint.v_long * idealWheelJoint.e0[2];
//   idealWheelJoint.w_roll = der(idealWheelJoint.flange_a.phi);
//   idealWheelJoint.v_long = idealWheelJoint.radius * idealWheelJoint.w_roll;
//   idealWheelJoint.a = der(idealWheelJoint.v_long);
//   (-idealWheelJoint.f_long) * idealWheelJoint.radius = idealWheelJoint.flange_a.tau;
//   idealWheelJoint.frame_a.t = 0.0;
//   idealWheelJoint.frame_a.fx * idealWheelJoint.e0[1] + idealWheelJoint.frame_a.fy * idealWheelJoint.e0[2] = idealWheelJoint.f_long;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.r0[1] = prismatic.s * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]);
//   prismatic.r0[2] = prismatic.s * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]);
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]) + prismatic.frame_a.fy * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]) = 0.0;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   idealWheelJoint.frame_a.t + prismatic.frame_b.t + body.frame_a.t = 0.0;
//   idealWheelJoint.frame_a.fy + prismatic.frame_b.fy + body.frame_a.fy = 0.0;
//   idealWheelJoint.frame_a.fx + prismatic.frame_b.fx + body.frame_a.fx = 0.0;
//   idealWheelJoint.flange_a.tau + inertia.flange_b.tau = 0.0;
//   prismatic.frame_a.t + revolute.frame_b.t = 0.0;
//   prismatic.frame_a.fy + revolute.frame_b.fy = 0.0;
//   prismatic.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   engineTorque.flange.tau + inertia.flange_a.tau = 0.0;
//   body.frame_a.x = idealWheelJoint.frame_a.x;
//   body.frame_a.x = prismatic.frame_b.x;
//   body.frame_a.y = idealWheelJoint.frame_a.y;
//   body.frame_a.y = prismatic.frame_b.y;
//   body.frame_a.phi = idealWheelJoint.frame_a.phi;
//   body.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.x = revolute.frame_b.x;
//   prismatic.frame_a.y = revolute.frame_b.y;
//   prismatic.frame_a.phi = revolute.frame_b.phi;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = inertia.flange_a.phi;
//   idealWheelJoint.flange_a.phi = inertia.flange_b.phi;
// end PlanarMechanicsV4.Examples.TestIdealWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.TestDryFrictionWheel
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, start = 1.0);
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real dryFrictionWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real dryFrictionWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real dryFrictionWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real dryFrictionWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real dryFrictionWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real dryFrictionWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real dryFrictionWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real dryFrictionWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real dryFrictionWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real dryFrictionWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint.N(quantity = \"Force\", unit = \"N\") = 100.0 \"normal force\";
//   parameter Real dryFrictionWheelJoint.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real dryFrictionWheelJoint.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real dryFrictionWheelJoint.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real dryFrictionWheelJoint.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real dryFrictionWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real dryFrictionWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real dryFrictionWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real dryFrictionWheelJoint.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real dryFrictionWheelJoint.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean dryFrictionWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean dryFrictionWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real dryFrictionWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(dryFrictionWheelJoint.r[1] ^ 2.0 + dryFrictionWheelJoint.r[2] ^ 2.0);
//   final parameter Real dryFrictionWheelJoint.e[1] = dryFrictionWheelJoint.r[1] / dryFrictionWheelJoint.l \"normalized direction\";
//   final parameter Real dryFrictionWheelJoint.e[2] = dryFrictionWheelJoint.r[2] / dryFrictionWheelJoint.l \"normalized direction\";
//   parameter String dryFrictionWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * dryFrictionWheelJoint.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * dryFrictionWheelJoint.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -dryFrictionWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = dryFrictionWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real dryFrictionWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Width of visual object\";
//   input Real dryFrictionWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Height of visual object\";
//   input Real dryFrictionWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint.cylinder.lengthDirection[1],dryFrictionWheelJoint.cylinder.lengthDirection[2],dryFrictionWheelJoint.cylinder.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint.cylinder.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint.cylinder.lengthDirection[1] / dryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint.cylinder.lengthDirection[2] / dryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint.cylinder.lengthDirection[3] / dryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint.cylinder.e_x[2] * dryFrictionWheelJoint.cylinder.widthDirection[3] - dryFrictionWheelJoint.cylinder.e_x[3] * dryFrictionWheelJoint.cylinder.widthDirection[2];
//   protected Real dryFrictionWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint.cylinder.e_x[3] * dryFrictionWheelJoint.cylinder.widthDirection[1] - dryFrictionWheelJoint.cylinder.e_x[1] * dryFrictionWheelJoint.cylinder.widthDirection[3];
//   protected Real dryFrictionWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint.cylinder.e_x[1] * dryFrictionWheelJoint.cylinder.widthDirection[2] - dryFrictionWheelJoint.cylinder.e_x[2] * dryFrictionWheelJoint.cylinder.widthDirection[1];
//   protected Real dryFrictionWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.cylinder.widthDirection[1],dryFrictionWheelJoint.cylinder.widthDirection[2],dryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.cylinder.widthDirection[1],dryFrictionWheelJoint.cylinder.widthDirection[2],dryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.cylinder.widthDirection[1],dryFrictionWheelJoint.cylinder.widthDirection[2],dryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint.cylinder.Form;
//   output Real dryFrictionWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.cylinder.Material;
//   protected output Real dryFrictionWheelJoint.cylinder.Extra;
//   parameter String dryFrictionWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint.rim1.lengthDirection[1],dryFrictionWheelJoint.rim1.lengthDirection[2],dryFrictionWheelJoint.rim1.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim1.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint.rim1.lengthDirection[1] / dryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint.rim1.lengthDirection[2] / dryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint.rim1.lengthDirection[3] / dryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim1.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint.rim1.e_x[2] * dryFrictionWheelJoint.rim1.widthDirection[3] - dryFrictionWheelJoint.rim1.e_x[3] * dryFrictionWheelJoint.rim1.widthDirection[2];
//   protected Real dryFrictionWheelJoint.rim1.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint.rim1.e_x[3] * dryFrictionWheelJoint.rim1.widthDirection[1] - dryFrictionWheelJoint.rim1.e_x[1] * dryFrictionWheelJoint.rim1.widthDirection[3];
//   protected Real dryFrictionWheelJoint.rim1.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint.rim1.e_x[1] * dryFrictionWheelJoint.rim1.widthDirection[2] - dryFrictionWheelJoint.rim1.e_x[2] * dryFrictionWheelJoint.rim1.widthDirection[1];
//   protected Real dryFrictionWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.rim1.widthDirection[1],dryFrictionWheelJoint.rim1.widthDirection[2],dryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.rim1.widthDirection[1],dryFrictionWheelJoint.rim1.widthDirection[2],dryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.rim1.widthDirection[1],dryFrictionWheelJoint.rim1.widthDirection[2],dryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint.rim1.Form;
//   output Real dryFrictionWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim1.Material;
//   protected output Real dryFrictionWheelJoint.rim1.Extra;
//   parameter String dryFrictionWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint.rim2.lengthDirection[1],dryFrictionWheelJoint.rim2.lengthDirection[2],dryFrictionWheelJoint.rim2.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim2.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint.rim2.lengthDirection[1] / dryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint.rim2.lengthDirection[2] / dryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint.rim2.lengthDirection[3] / dryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim2.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint.rim2.e_x[2] * dryFrictionWheelJoint.rim2.widthDirection[3] - dryFrictionWheelJoint.rim2.e_x[3] * dryFrictionWheelJoint.rim2.widthDirection[2];
//   protected Real dryFrictionWheelJoint.rim2.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint.rim2.e_x[3] * dryFrictionWheelJoint.rim2.widthDirection[1] - dryFrictionWheelJoint.rim2.e_x[1] * dryFrictionWheelJoint.rim2.widthDirection[3];
//   protected Real dryFrictionWheelJoint.rim2.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint.rim2.e_x[1] * dryFrictionWheelJoint.rim2.widthDirection[2] - dryFrictionWheelJoint.rim2.e_x[2] * dryFrictionWheelJoint.rim2.widthDirection[1];
//   protected Real dryFrictionWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.rim2.widthDirection[1],dryFrictionWheelJoint.rim2.widthDirection[2],dryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.rim2.widthDirection[1],dryFrictionWheelJoint.rim2.widthDirection[2],dryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint.rim2.widthDirection[1],dryFrictionWheelJoint.rim2.widthDirection[2],dryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint.rim2.Form;
//   output Real dryFrictionWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim2.Material;
//   protected output Real dryFrictionWheelJoint.rim2.Extra;
// equation
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.r0[1] = prismatic.s * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]);
//   prismatic.r0[2] = prismatic.s * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]);
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]) + prismatic.frame_a.fy * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]) = 0.0;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   dryFrictionWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint.cylinder.shapeType);
//   dryFrictionWheelJoint.cylinder.rxvisobj[1] = dryFrictionWheelJoint.cylinder.R.T[1,1] * dryFrictionWheelJoint.cylinder.e_x[1] + dryFrictionWheelJoint.cylinder.R.T[2,1] * dryFrictionWheelJoint.cylinder.e_x[2] + dryFrictionWheelJoint.cylinder.R.T[3,1] * dryFrictionWheelJoint.cylinder.e_x[3];
//   dryFrictionWheelJoint.cylinder.rxvisobj[2] = dryFrictionWheelJoint.cylinder.R.T[1,2] * dryFrictionWheelJoint.cylinder.e_x[1] + dryFrictionWheelJoint.cylinder.R.T[2,2] * dryFrictionWheelJoint.cylinder.e_x[2] + dryFrictionWheelJoint.cylinder.R.T[3,2] * dryFrictionWheelJoint.cylinder.e_x[3];
//   dryFrictionWheelJoint.cylinder.rxvisobj[3] = dryFrictionWheelJoint.cylinder.R.T[1,3] * dryFrictionWheelJoint.cylinder.e_x[1] + dryFrictionWheelJoint.cylinder.R.T[2,3] * dryFrictionWheelJoint.cylinder.e_x[2] + dryFrictionWheelJoint.cylinder.R.T[3,3] * dryFrictionWheelJoint.cylinder.e_x[3];
//   dryFrictionWheelJoint.cylinder.ryvisobj[1] = dryFrictionWheelJoint.cylinder.R.T[1,1] * dryFrictionWheelJoint.cylinder.e_y[1] + dryFrictionWheelJoint.cylinder.R.T[2,1] * dryFrictionWheelJoint.cylinder.e_y[2] + dryFrictionWheelJoint.cylinder.R.T[3,1] * dryFrictionWheelJoint.cylinder.e_y[3];
//   dryFrictionWheelJoint.cylinder.ryvisobj[2] = dryFrictionWheelJoint.cylinder.R.T[1,2] * dryFrictionWheelJoint.cylinder.e_y[1] + dryFrictionWheelJoint.cylinder.R.T[2,2] * dryFrictionWheelJoint.cylinder.e_y[2] + dryFrictionWheelJoint.cylinder.R.T[3,2] * dryFrictionWheelJoint.cylinder.e_y[3];
//   dryFrictionWheelJoint.cylinder.ryvisobj[3] = dryFrictionWheelJoint.cylinder.R.T[1,3] * dryFrictionWheelJoint.cylinder.e_y[1] + dryFrictionWheelJoint.cylinder.R.T[2,3] * dryFrictionWheelJoint.cylinder.e_y[2] + dryFrictionWheelJoint.cylinder.R.T[3,3] * dryFrictionWheelJoint.cylinder.e_y[3];
//   dryFrictionWheelJoint.cylinder.rvisobj = dryFrictionWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint.cylinder.R.T[1,1],dryFrictionWheelJoint.cylinder.R.T[1,2],dryFrictionWheelJoint.cylinder.R.T[1,3]},{dryFrictionWheelJoint.cylinder.R.T[2,1],dryFrictionWheelJoint.cylinder.R.T[2,2],dryFrictionWheelJoint.cylinder.R.T[2,3]},{dryFrictionWheelJoint.cylinder.R.T[3,1],dryFrictionWheelJoint.cylinder.R.T[3,2],dryFrictionWheelJoint.cylinder.R.T[3,3]}},{dryFrictionWheelJoint.cylinder.r_shape[1],dryFrictionWheelJoint.cylinder.r_shape[2],dryFrictionWheelJoint.cylinder.r_shape[3]});
//   dryFrictionWheelJoint.cylinder.size[1] = dryFrictionWheelJoint.cylinder.length;
//   dryFrictionWheelJoint.cylinder.size[2] = dryFrictionWheelJoint.cylinder.width;
//   dryFrictionWheelJoint.cylinder.size[3] = dryFrictionWheelJoint.cylinder.height;
//   dryFrictionWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint.cylinder.color[1] / 255.0,dryFrictionWheelJoint.cylinder.color[2] / 255.0,dryFrictionWheelJoint.cylinder.color[3] / 255.0,dryFrictionWheelJoint.cylinder.specularCoefficient);
//   dryFrictionWheelJoint.cylinder.Extra = dryFrictionWheelJoint.cylinder.extra;
//   dryFrictionWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint.e0[2],dryFrictionWheelJoint.e0[1],0.0},dryFrictionWheelJoint.flange_a.phi,0.0);
//   dryFrictionWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint.rim1.shapeType);
//   dryFrictionWheelJoint.rim1.rxvisobj[1] = dryFrictionWheelJoint.rim1.R.T[1,1] * dryFrictionWheelJoint.rim1.e_x[1] + dryFrictionWheelJoint.rim1.R.T[2,1] * dryFrictionWheelJoint.rim1.e_x[2] + dryFrictionWheelJoint.rim1.R.T[3,1] * dryFrictionWheelJoint.rim1.e_x[3];
//   dryFrictionWheelJoint.rim1.rxvisobj[2] = dryFrictionWheelJoint.rim1.R.T[1,2] * dryFrictionWheelJoint.rim1.e_x[1] + dryFrictionWheelJoint.rim1.R.T[2,2] * dryFrictionWheelJoint.rim1.e_x[2] + dryFrictionWheelJoint.rim1.R.T[3,2] * dryFrictionWheelJoint.rim1.e_x[3];
//   dryFrictionWheelJoint.rim1.rxvisobj[3] = dryFrictionWheelJoint.rim1.R.T[1,3] * dryFrictionWheelJoint.rim1.e_x[1] + dryFrictionWheelJoint.rim1.R.T[2,3] * dryFrictionWheelJoint.rim1.e_x[2] + dryFrictionWheelJoint.rim1.R.T[3,3] * dryFrictionWheelJoint.rim1.e_x[3];
//   dryFrictionWheelJoint.rim1.ryvisobj[1] = dryFrictionWheelJoint.rim1.R.T[1,1] * dryFrictionWheelJoint.rim1.e_y[1] + dryFrictionWheelJoint.rim1.R.T[2,1] * dryFrictionWheelJoint.rim1.e_y[2] + dryFrictionWheelJoint.rim1.R.T[3,1] * dryFrictionWheelJoint.rim1.e_y[3];
//   dryFrictionWheelJoint.rim1.ryvisobj[2] = dryFrictionWheelJoint.rim1.R.T[1,2] * dryFrictionWheelJoint.rim1.e_y[1] + dryFrictionWheelJoint.rim1.R.T[2,2] * dryFrictionWheelJoint.rim1.e_y[2] + dryFrictionWheelJoint.rim1.R.T[3,2] * dryFrictionWheelJoint.rim1.e_y[3];
//   dryFrictionWheelJoint.rim1.ryvisobj[3] = dryFrictionWheelJoint.rim1.R.T[1,3] * dryFrictionWheelJoint.rim1.e_y[1] + dryFrictionWheelJoint.rim1.R.T[2,3] * dryFrictionWheelJoint.rim1.e_y[2] + dryFrictionWheelJoint.rim1.R.T[3,3] * dryFrictionWheelJoint.rim1.e_y[3];
//   dryFrictionWheelJoint.rim1.rvisobj = dryFrictionWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint.rim1.R.T[1,1],dryFrictionWheelJoint.rim1.R.T[1,2],dryFrictionWheelJoint.rim1.R.T[1,3]},{dryFrictionWheelJoint.rim1.R.T[2,1],dryFrictionWheelJoint.rim1.R.T[2,2],dryFrictionWheelJoint.rim1.R.T[2,3]},{dryFrictionWheelJoint.rim1.R.T[3,1],dryFrictionWheelJoint.rim1.R.T[3,2],dryFrictionWheelJoint.rim1.R.T[3,3]}},{dryFrictionWheelJoint.rim1.r_shape[1],dryFrictionWheelJoint.rim1.r_shape[2],dryFrictionWheelJoint.rim1.r_shape[3]});
//   dryFrictionWheelJoint.rim1.size[1] = dryFrictionWheelJoint.rim1.length;
//   dryFrictionWheelJoint.rim1.size[2] = dryFrictionWheelJoint.rim1.width;
//   dryFrictionWheelJoint.rim1.size[3] = dryFrictionWheelJoint.rim1.height;
//   dryFrictionWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint.rim1.color[1] / 255.0,dryFrictionWheelJoint.rim1.color[2] / 255.0,dryFrictionWheelJoint.rim1.color[3] / 255.0,dryFrictionWheelJoint.rim1.specularCoefficient);
//   dryFrictionWheelJoint.rim1.Extra = dryFrictionWheelJoint.rim1.extra;
//   dryFrictionWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint.e0[2],dryFrictionWheelJoint.e0[1],0.0},1.5707963267949 + dryFrictionWheelJoint.flange_a.phi,0.0);
//   dryFrictionWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint.rim2.shapeType);
//   dryFrictionWheelJoint.rim2.rxvisobj[1] = dryFrictionWheelJoint.rim2.R.T[1,1] * dryFrictionWheelJoint.rim2.e_x[1] + dryFrictionWheelJoint.rim2.R.T[2,1] * dryFrictionWheelJoint.rim2.e_x[2] + dryFrictionWheelJoint.rim2.R.T[3,1] * dryFrictionWheelJoint.rim2.e_x[3];
//   dryFrictionWheelJoint.rim2.rxvisobj[2] = dryFrictionWheelJoint.rim2.R.T[1,2] * dryFrictionWheelJoint.rim2.e_x[1] + dryFrictionWheelJoint.rim2.R.T[2,2] * dryFrictionWheelJoint.rim2.e_x[2] + dryFrictionWheelJoint.rim2.R.T[3,2] * dryFrictionWheelJoint.rim2.e_x[3];
//   dryFrictionWheelJoint.rim2.rxvisobj[3] = dryFrictionWheelJoint.rim2.R.T[1,3] * dryFrictionWheelJoint.rim2.e_x[1] + dryFrictionWheelJoint.rim2.R.T[2,3] * dryFrictionWheelJoint.rim2.e_x[2] + dryFrictionWheelJoint.rim2.R.T[3,3] * dryFrictionWheelJoint.rim2.e_x[3];
//   dryFrictionWheelJoint.rim2.ryvisobj[1] = dryFrictionWheelJoint.rim2.R.T[1,1] * dryFrictionWheelJoint.rim2.e_y[1] + dryFrictionWheelJoint.rim2.R.T[2,1] * dryFrictionWheelJoint.rim2.e_y[2] + dryFrictionWheelJoint.rim2.R.T[3,1] * dryFrictionWheelJoint.rim2.e_y[3];
//   dryFrictionWheelJoint.rim2.ryvisobj[2] = dryFrictionWheelJoint.rim2.R.T[1,2] * dryFrictionWheelJoint.rim2.e_y[1] + dryFrictionWheelJoint.rim2.R.T[2,2] * dryFrictionWheelJoint.rim2.e_y[2] + dryFrictionWheelJoint.rim2.R.T[3,2] * dryFrictionWheelJoint.rim2.e_y[3];
//   dryFrictionWheelJoint.rim2.ryvisobj[3] = dryFrictionWheelJoint.rim2.R.T[1,3] * dryFrictionWheelJoint.rim2.e_y[1] + dryFrictionWheelJoint.rim2.R.T[2,3] * dryFrictionWheelJoint.rim2.e_y[2] + dryFrictionWheelJoint.rim2.R.T[3,3] * dryFrictionWheelJoint.rim2.e_y[3];
//   dryFrictionWheelJoint.rim2.rvisobj = dryFrictionWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint.rim2.R.T[1,1],dryFrictionWheelJoint.rim2.R.T[1,2],dryFrictionWheelJoint.rim2.R.T[1,3]},{dryFrictionWheelJoint.rim2.R.T[2,1],dryFrictionWheelJoint.rim2.R.T[2,2],dryFrictionWheelJoint.rim2.R.T[2,3]},{dryFrictionWheelJoint.rim2.R.T[3,1],dryFrictionWheelJoint.rim2.R.T[3,2],dryFrictionWheelJoint.rim2.R.T[3,3]}},{dryFrictionWheelJoint.rim2.r_shape[1],dryFrictionWheelJoint.rim2.r_shape[2],dryFrictionWheelJoint.rim2.r_shape[3]});
//   dryFrictionWheelJoint.rim2.size[1] = dryFrictionWheelJoint.rim2.length;
//   dryFrictionWheelJoint.rim2.size[2] = dryFrictionWheelJoint.rim2.width;
//   dryFrictionWheelJoint.rim2.size[3] = dryFrictionWheelJoint.rim2.height;
//   dryFrictionWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint.rim2.color[1] / 255.0,dryFrictionWheelJoint.rim2.color[2] / 255.0,dryFrictionWheelJoint.rim2.color[3] / 255.0,dryFrictionWheelJoint.rim2.specularCoefficient);
//   dryFrictionWheelJoint.rim2.Extra = dryFrictionWheelJoint.rim2.extra;
//   dryFrictionWheelJoint.R[1,1] = cos(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.R[1,2] = sin(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.R[2,1] = -sin(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.R[2,2] = cos(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.e0[1] = dryFrictionWheelJoint.R[1,1] * dryFrictionWheelJoint.e[1] + dryFrictionWheelJoint.R[1,2] * dryFrictionWheelJoint.e[2];
//   dryFrictionWheelJoint.e0[2] = dryFrictionWheelJoint.R[2,1] * dryFrictionWheelJoint.e[1] + dryFrictionWheelJoint.R[2,2] * dryFrictionWheelJoint.e[2];
//   dryFrictionWheelJoint.v[1] = der(dryFrictionWheelJoint.frame_a.x);
//   dryFrictionWheelJoint.v[2] = der(dryFrictionWheelJoint.frame_a.y);
//   dryFrictionWheelJoint.w_roll = der(dryFrictionWheelJoint.flange_a.phi);
//   dryFrictionWheelJoint.v_long = dryFrictionWheelJoint.v[1] * dryFrictionWheelJoint.e0[1] + dryFrictionWheelJoint.v[2] * dryFrictionWheelJoint.e0[2];
//   dryFrictionWheelJoint.v_lat = (-dryFrictionWheelJoint.v[1]) * dryFrictionWheelJoint.e0[2] + dryFrictionWheelJoint.v[2] * dryFrictionWheelJoint.e0[1];
//   dryFrictionWheelJoint.v_slip_lat = dryFrictionWheelJoint.v_lat;
//   dryFrictionWheelJoint.v_slip_long = dryFrictionWheelJoint.v_long - dryFrictionWheelJoint.radius * dryFrictionWheelJoint.w_roll;
//   dryFrictionWheelJoint.v_slip = 0.0001 + sqrt(dryFrictionWheelJoint.v_slip_long ^ 2.0 + dryFrictionWheelJoint.v_slip_lat ^ 2.0);
//   (-dryFrictionWheelJoint.f_long) * dryFrictionWheelJoint.radius = dryFrictionWheelJoint.flange_a.tau;
//   dryFrictionWheelJoint.frame_a.t = 0.0;
//   dryFrictionWheelJoint.f = dryFrictionWheelJoint.N * PlanarMechanicsV4.Utilities.TripleS_Func(dryFrictionWheelJoint.vAdhesion,dryFrictionWheelJoint.vSlide,dryFrictionWheelJoint.mu_A,dryFrictionWheelJoint.mu_S,dryFrictionWheelJoint.v_slip);
//   dryFrictionWheelJoint.f_long = (dryFrictionWheelJoint.f * dryFrictionWheelJoint.v_slip_long) / dryFrictionWheelJoint.v_slip;
//   dryFrictionWheelJoint.f_lat = (dryFrictionWheelJoint.f * dryFrictionWheelJoint.v_slip_lat) / dryFrictionWheelJoint.v_slip;
//   dryFrictionWheelJoint.f_long = dryFrictionWheelJoint.frame_a.fx * dryFrictionWheelJoint.e0[1] + dryFrictionWheelJoint.frame_a.fy * dryFrictionWheelJoint.e0[2];
//   dryFrictionWheelJoint.f_lat = dryFrictionWheelJoint.frame_a.fy * dryFrictionWheelJoint.e0[1] + (-dryFrictionWheelJoint.frame_a.fx) * dryFrictionWheelJoint.e0[2];
//   prismatic.frame_a.t + revolute.frame_b.t = 0.0;
//   prismatic.frame_a.fy + revolute.frame_b.fy = 0.0;
//   prismatic.frame_a.fx + revolute.frame_b.fx = 0.0;
//   prismatic.frame_b.t + body.frame_a.t + dryFrictionWheelJoint.frame_a.t = 0.0;
//   prismatic.frame_b.fy + body.frame_a.fy + dryFrictionWheelJoint.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + body.frame_a.fx + dryFrictionWheelJoint.frame_a.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   engineTorque.flange.tau + inertia.flange_a.tau = 0.0;
//   inertia.flange_b.tau + dryFrictionWheelJoint.flange_a.tau = 0.0;
//   prismatic.frame_a.x = revolute.frame_b.x;
//   prismatic.frame_a.y = revolute.frame_b.y;
//   prismatic.frame_a.phi = revolute.frame_b.phi;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = inertia.flange_a.phi;
//   body.frame_a.x = dryFrictionWheelJoint.frame_a.x;
//   body.frame_a.x = prismatic.frame_b.x;
//   body.frame_a.y = dryFrictionWheelJoint.frame_a.y;
//   body.frame_a.y = prismatic.frame_b.y;
//   body.frame_a.phi = dryFrictionWheelJoint.frame_a.phi;
//   body.frame_a.phi = prismatic.frame_b.phi;
//   dryFrictionWheelJoint.flange_a.phi = inertia.flange_b.phi;
// end PlanarMechanicsV4.Examples.TestDryFrictionWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.TestSlipBasedWheel
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, start = 1.0);
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 1e-10) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real slipBasedWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real slipBasedWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real slipBasedWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real slipBasedWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real slipBasedWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real slipBasedWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real slipBasedWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real slipBasedWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real slipBasedWheelJoint.dynamicLoad(unit = \"N\");
//   parameter Real slipBasedWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real slipBasedWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real slipBasedWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real slipBasedWheelJoint.N(quantity = \"Force\", unit = \"N\") = 100.0 \"base normal load\";
//   parameter Real slipBasedWheelJoint.vAdhesion_min(quantity = \"Velocity\", unit = \"m/s\") = 0.05 \"minimum adhesion velocity\";
//   parameter Real slipBasedWheelJoint.vSlide_min(quantity = \"Velocity\", unit = \"m/s\") = 0.15 \"minimum sliding velocity\";
//   parameter Real slipBasedWheelJoint.sAdhesion = 0.04 \"adhesion slippage\";
//   parameter Real slipBasedWheelJoint.sSlide = 0.12 \"sliding slippage\";
//   parameter Real slipBasedWheelJoint.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real slipBasedWheelJoint.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real slipBasedWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real slipBasedWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real slipBasedWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real slipBasedWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real slipBasedWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real slipBasedWheelJoint.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real slipBasedWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real slipBasedWheelJoint.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real slipBasedWheelJoint.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real slipBasedWheelJoint.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real slipBasedWheelJoint.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real slipBasedWheelJoint.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real slipBasedWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real slipBasedWheelJoint.fN(quantity = \"Force\", unit = \"N\") \"base normal load\";
//   Real slipBasedWheelJoint.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") \"adhesion velocity\";
//   Real slipBasedWheelJoint.vSlide(quantity = \"Velocity\", unit = \"m/s\") \"sliding velocity\";
//   parameter Boolean slipBasedWheelJoint.animate = true \"enable Animation\";
//   final parameter Real slipBasedWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(slipBasedWheelJoint.r[1] ^ 2.0 + slipBasedWheelJoint.r[2] ^ 2.0);
//   final parameter Real slipBasedWheelJoint.e[1] = slipBasedWheelJoint.r[1] / slipBasedWheelJoint.l \"normalized direction\";
//   final parameter Real slipBasedWheelJoint.e[2] = slipBasedWheelJoint.r[2] / slipBasedWheelJoint.l \"normalized direction\";
//   parameter String slipBasedWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * slipBasedWheelJoint.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * slipBasedWheelJoint.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -slipBasedWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = slipBasedWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real slipBasedWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Width of visual object\";
//   input Real slipBasedWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Height of visual object\";
//   input Real slipBasedWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedWheelJoint.cylinder.lengthDirection[1],slipBasedWheelJoint.cylinder.lengthDirection[2],slipBasedWheelJoint.cylinder.lengthDirection[3]});
//   protected Real slipBasedWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(slipBasedWheelJoint.cylinder.abs_n_x < 1e-10) then 1.0 else slipBasedWheelJoint.cylinder.lengthDirection[1] / slipBasedWheelJoint.cylinder.abs_n_x;
//   protected Real slipBasedWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(slipBasedWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else slipBasedWheelJoint.cylinder.lengthDirection[2] / slipBasedWheelJoint.cylinder.abs_n_x;
//   protected Real slipBasedWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(slipBasedWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else slipBasedWheelJoint.cylinder.lengthDirection[3] / slipBasedWheelJoint.cylinder.abs_n_x;
//   protected Real slipBasedWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = slipBasedWheelJoint.cylinder.e_x[2] * slipBasedWheelJoint.cylinder.widthDirection[3] - slipBasedWheelJoint.cylinder.e_x[3] * slipBasedWheelJoint.cylinder.widthDirection[2];
//   protected Real slipBasedWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = slipBasedWheelJoint.cylinder.e_x[3] * slipBasedWheelJoint.cylinder.widthDirection[1] - slipBasedWheelJoint.cylinder.e_x[1] * slipBasedWheelJoint.cylinder.widthDirection[3];
//   protected Real slipBasedWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = slipBasedWheelJoint.cylinder.e_x[1] * slipBasedWheelJoint.cylinder.widthDirection[2] - slipBasedWheelJoint.cylinder.e_x[2] * slipBasedWheelJoint.cylinder.widthDirection[1];
//   protected Real slipBasedWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]},if noEvent(slipBasedWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.cylinder.widthDirection[1],slipBasedWheelJoint.cylinder.widthDirection[2],slipBasedWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]})[1];
//   protected Real slipBasedWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]},if noEvent(slipBasedWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.cylinder.widthDirection[1],slipBasedWheelJoint.cylinder.widthDirection[2],slipBasedWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]})[2];
//   protected Real slipBasedWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]},if noEvent(slipBasedWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.cylinder.widthDirection[1],slipBasedWheelJoint.cylinder.widthDirection[2],slipBasedWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real slipBasedWheelJoint.cylinder.Form;
//   output Real slipBasedWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.cylinder.Material;
//   protected output Real slipBasedWheelJoint.cylinder.Extra;
//   parameter String slipBasedWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -slipBasedWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Length of visual object\";
//   input Real slipBasedWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedWheelJoint.rim1.lengthDirection[1],slipBasedWheelJoint.rim1.lengthDirection[2],slipBasedWheelJoint.rim1.lengthDirection[3]});
//   protected Real slipBasedWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim1.abs_n_x < 1e-10) then 1.0 else slipBasedWheelJoint.rim1.lengthDirection[1] / slipBasedWheelJoint.rim1.abs_n_x;
//   protected Real slipBasedWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else slipBasedWheelJoint.rim1.lengthDirection[2] / slipBasedWheelJoint.rim1.abs_n_x;
//   protected Real slipBasedWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else slipBasedWheelJoint.rim1.lengthDirection[3] / slipBasedWheelJoint.rim1.abs_n_x;
//   protected Real slipBasedWheelJoint.rim1.n_z_aux[1](unit = \"1\") = slipBasedWheelJoint.rim1.e_x[2] * slipBasedWheelJoint.rim1.widthDirection[3] - slipBasedWheelJoint.rim1.e_x[3] * slipBasedWheelJoint.rim1.widthDirection[2];
//   protected Real slipBasedWheelJoint.rim1.n_z_aux[2](unit = \"1\") = slipBasedWheelJoint.rim1.e_x[3] * slipBasedWheelJoint.rim1.widthDirection[1] - slipBasedWheelJoint.rim1.e_x[1] * slipBasedWheelJoint.rim1.widthDirection[3];
//   protected Real slipBasedWheelJoint.rim1.n_z_aux[3](unit = \"1\") = slipBasedWheelJoint.rim1.e_x[1] * slipBasedWheelJoint.rim1.widthDirection[2] - slipBasedWheelJoint.rim1.e_x[2] * slipBasedWheelJoint.rim1.widthDirection[1];
//   protected Real slipBasedWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]},if noEvent(slipBasedWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim1.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.rim1.widthDirection[1],slipBasedWheelJoint.rim1.widthDirection[2],slipBasedWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]})[1];
//   protected Real slipBasedWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]},if noEvent(slipBasedWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim1.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.rim1.widthDirection[1],slipBasedWheelJoint.rim1.widthDirection[2],slipBasedWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]})[2];
//   protected Real slipBasedWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]},if noEvent(slipBasedWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim1.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.rim1.widthDirection[1],slipBasedWheelJoint.rim1.widthDirection[2],slipBasedWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]})[3];
//   protected output Real slipBasedWheelJoint.rim1.Form;
//   output Real slipBasedWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim1.Material;
//   protected output Real slipBasedWheelJoint.rim1.Extra;
//   parameter String slipBasedWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -slipBasedWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Length of visual object\";
//   input Real slipBasedWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedWheelJoint.rim2.lengthDirection[1],slipBasedWheelJoint.rim2.lengthDirection[2],slipBasedWheelJoint.rim2.lengthDirection[3]});
//   protected Real slipBasedWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim2.abs_n_x < 1e-10) then 1.0 else slipBasedWheelJoint.rim2.lengthDirection[1] / slipBasedWheelJoint.rim2.abs_n_x;
//   protected Real slipBasedWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else slipBasedWheelJoint.rim2.lengthDirection[2] / slipBasedWheelJoint.rim2.abs_n_x;
//   protected Real slipBasedWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else slipBasedWheelJoint.rim2.lengthDirection[3] / slipBasedWheelJoint.rim2.abs_n_x;
//   protected Real slipBasedWheelJoint.rim2.n_z_aux[1](unit = \"1\") = slipBasedWheelJoint.rim2.e_x[2] * slipBasedWheelJoint.rim2.widthDirection[3] - slipBasedWheelJoint.rim2.e_x[3] * slipBasedWheelJoint.rim2.widthDirection[2];
//   protected Real slipBasedWheelJoint.rim2.n_z_aux[2](unit = \"1\") = slipBasedWheelJoint.rim2.e_x[3] * slipBasedWheelJoint.rim2.widthDirection[1] - slipBasedWheelJoint.rim2.e_x[1] * slipBasedWheelJoint.rim2.widthDirection[3];
//   protected Real slipBasedWheelJoint.rim2.n_z_aux[3](unit = \"1\") = slipBasedWheelJoint.rim2.e_x[1] * slipBasedWheelJoint.rim2.widthDirection[2] - slipBasedWheelJoint.rim2.e_x[2] * slipBasedWheelJoint.rim2.widthDirection[1];
//   protected Real slipBasedWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]},if noEvent(slipBasedWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim2.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.rim2.widthDirection[1],slipBasedWheelJoint.rim2.widthDirection[2],slipBasedWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]})[1];
//   protected Real slipBasedWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]},if noEvent(slipBasedWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim2.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.rim2.widthDirection[1],slipBasedWheelJoint.rim2.widthDirection[2],slipBasedWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]})[2];
//   protected Real slipBasedWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]},if noEvent(slipBasedWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim2.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedWheelJoint.rim2.widthDirection[1],slipBasedWheelJoint.rim2.widthDirection[2],slipBasedWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]})[3];
//   protected output Real slipBasedWheelJoint.rim2.Form;
//   output Real slipBasedWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim2.Material;
//   protected output Real slipBasedWheelJoint.rim2.Extra;
//   output Real const.y \"Connector of Real output signal\";
//   parameter Real const.k(start = 1.0) = 0.0 \"Constant output value\";
// equation
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.r0[1] = prismatic.s * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]);
//   prismatic.r0[2] = prismatic.s * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]);
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * (prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2]) + prismatic.frame_a.fy * (prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2]) = 0.0;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   slipBasedWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedWheelJoint.cylinder.shapeType);
//   slipBasedWheelJoint.cylinder.rxvisobj[1] = slipBasedWheelJoint.cylinder.R.T[1,1] * slipBasedWheelJoint.cylinder.e_x[1] + slipBasedWheelJoint.cylinder.R.T[2,1] * slipBasedWheelJoint.cylinder.e_x[2] + slipBasedWheelJoint.cylinder.R.T[3,1] * slipBasedWheelJoint.cylinder.e_x[3];
//   slipBasedWheelJoint.cylinder.rxvisobj[2] = slipBasedWheelJoint.cylinder.R.T[1,2] * slipBasedWheelJoint.cylinder.e_x[1] + slipBasedWheelJoint.cylinder.R.T[2,2] * slipBasedWheelJoint.cylinder.e_x[2] + slipBasedWheelJoint.cylinder.R.T[3,2] * slipBasedWheelJoint.cylinder.e_x[3];
//   slipBasedWheelJoint.cylinder.rxvisobj[3] = slipBasedWheelJoint.cylinder.R.T[1,3] * slipBasedWheelJoint.cylinder.e_x[1] + slipBasedWheelJoint.cylinder.R.T[2,3] * slipBasedWheelJoint.cylinder.e_x[2] + slipBasedWheelJoint.cylinder.R.T[3,3] * slipBasedWheelJoint.cylinder.e_x[3];
//   slipBasedWheelJoint.cylinder.ryvisobj[1] = slipBasedWheelJoint.cylinder.R.T[1,1] * slipBasedWheelJoint.cylinder.e_y[1] + slipBasedWheelJoint.cylinder.R.T[2,1] * slipBasedWheelJoint.cylinder.e_y[2] + slipBasedWheelJoint.cylinder.R.T[3,1] * slipBasedWheelJoint.cylinder.e_y[3];
//   slipBasedWheelJoint.cylinder.ryvisobj[2] = slipBasedWheelJoint.cylinder.R.T[1,2] * slipBasedWheelJoint.cylinder.e_y[1] + slipBasedWheelJoint.cylinder.R.T[2,2] * slipBasedWheelJoint.cylinder.e_y[2] + slipBasedWheelJoint.cylinder.R.T[3,2] * slipBasedWheelJoint.cylinder.e_y[3];
//   slipBasedWheelJoint.cylinder.ryvisobj[3] = slipBasedWheelJoint.cylinder.R.T[1,3] * slipBasedWheelJoint.cylinder.e_y[1] + slipBasedWheelJoint.cylinder.R.T[2,3] * slipBasedWheelJoint.cylinder.e_y[2] + slipBasedWheelJoint.cylinder.R.T[3,3] * slipBasedWheelJoint.cylinder.e_y[3];
//   slipBasedWheelJoint.cylinder.rvisobj = slipBasedWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedWheelJoint.cylinder.R.T[1,1],slipBasedWheelJoint.cylinder.R.T[1,2],slipBasedWheelJoint.cylinder.R.T[1,3]},{slipBasedWheelJoint.cylinder.R.T[2,1],slipBasedWheelJoint.cylinder.R.T[2,2],slipBasedWheelJoint.cylinder.R.T[2,3]},{slipBasedWheelJoint.cylinder.R.T[3,1],slipBasedWheelJoint.cylinder.R.T[3,2],slipBasedWheelJoint.cylinder.R.T[3,3]}},{slipBasedWheelJoint.cylinder.r_shape[1],slipBasedWheelJoint.cylinder.r_shape[2],slipBasedWheelJoint.cylinder.r_shape[3]});
//   slipBasedWheelJoint.cylinder.size[1] = slipBasedWheelJoint.cylinder.length;
//   slipBasedWheelJoint.cylinder.size[2] = slipBasedWheelJoint.cylinder.width;
//   slipBasedWheelJoint.cylinder.size[3] = slipBasedWheelJoint.cylinder.height;
//   slipBasedWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedWheelJoint.cylinder.color[1] / 255.0,slipBasedWheelJoint.cylinder.color[2] / 255.0,slipBasedWheelJoint.cylinder.color[3] / 255.0,slipBasedWheelJoint.cylinder.specularCoefficient);
//   slipBasedWheelJoint.cylinder.Extra = slipBasedWheelJoint.cylinder.extra;
//   slipBasedWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-slipBasedWheelJoint.e0[2],slipBasedWheelJoint.e0[1],0.0},slipBasedWheelJoint.flange_a.phi,0.0);
//   slipBasedWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedWheelJoint.rim1.shapeType);
//   slipBasedWheelJoint.rim1.rxvisobj[1] = slipBasedWheelJoint.rim1.R.T[1,1] * slipBasedWheelJoint.rim1.e_x[1] + slipBasedWheelJoint.rim1.R.T[2,1] * slipBasedWheelJoint.rim1.e_x[2] + slipBasedWheelJoint.rim1.R.T[3,1] * slipBasedWheelJoint.rim1.e_x[3];
//   slipBasedWheelJoint.rim1.rxvisobj[2] = slipBasedWheelJoint.rim1.R.T[1,2] * slipBasedWheelJoint.rim1.e_x[1] + slipBasedWheelJoint.rim1.R.T[2,2] * slipBasedWheelJoint.rim1.e_x[2] + slipBasedWheelJoint.rim1.R.T[3,2] * slipBasedWheelJoint.rim1.e_x[3];
//   slipBasedWheelJoint.rim1.rxvisobj[3] = slipBasedWheelJoint.rim1.R.T[1,3] * slipBasedWheelJoint.rim1.e_x[1] + slipBasedWheelJoint.rim1.R.T[2,3] * slipBasedWheelJoint.rim1.e_x[2] + slipBasedWheelJoint.rim1.R.T[3,3] * slipBasedWheelJoint.rim1.e_x[3];
//   slipBasedWheelJoint.rim1.ryvisobj[1] = slipBasedWheelJoint.rim1.R.T[1,1] * slipBasedWheelJoint.rim1.e_y[1] + slipBasedWheelJoint.rim1.R.T[2,1] * slipBasedWheelJoint.rim1.e_y[2] + slipBasedWheelJoint.rim1.R.T[3,1] * slipBasedWheelJoint.rim1.e_y[3];
//   slipBasedWheelJoint.rim1.ryvisobj[2] = slipBasedWheelJoint.rim1.R.T[1,2] * slipBasedWheelJoint.rim1.e_y[1] + slipBasedWheelJoint.rim1.R.T[2,2] * slipBasedWheelJoint.rim1.e_y[2] + slipBasedWheelJoint.rim1.R.T[3,2] * slipBasedWheelJoint.rim1.e_y[3];
//   slipBasedWheelJoint.rim1.ryvisobj[3] = slipBasedWheelJoint.rim1.R.T[1,3] * slipBasedWheelJoint.rim1.e_y[1] + slipBasedWheelJoint.rim1.R.T[2,3] * slipBasedWheelJoint.rim1.e_y[2] + slipBasedWheelJoint.rim1.R.T[3,3] * slipBasedWheelJoint.rim1.e_y[3];
//   slipBasedWheelJoint.rim1.rvisobj = slipBasedWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedWheelJoint.rim1.R.T[1,1],slipBasedWheelJoint.rim1.R.T[1,2],slipBasedWheelJoint.rim1.R.T[1,3]},{slipBasedWheelJoint.rim1.R.T[2,1],slipBasedWheelJoint.rim1.R.T[2,2],slipBasedWheelJoint.rim1.R.T[2,3]},{slipBasedWheelJoint.rim1.R.T[3,1],slipBasedWheelJoint.rim1.R.T[3,2],slipBasedWheelJoint.rim1.R.T[3,3]}},{slipBasedWheelJoint.rim1.r_shape[1],slipBasedWheelJoint.rim1.r_shape[2],slipBasedWheelJoint.rim1.r_shape[3]});
//   slipBasedWheelJoint.rim1.size[1] = slipBasedWheelJoint.rim1.length;
//   slipBasedWheelJoint.rim1.size[2] = slipBasedWheelJoint.rim1.width;
//   slipBasedWheelJoint.rim1.size[3] = slipBasedWheelJoint.rim1.height;
//   slipBasedWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedWheelJoint.rim1.color[1] / 255.0,slipBasedWheelJoint.rim1.color[2] / 255.0,slipBasedWheelJoint.rim1.color[3] / 255.0,slipBasedWheelJoint.rim1.specularCoefficient);
//   slipBasedWheelJoint.rim1.Extra = slipBasedWheelJoint.rim1.extra;
//   slipBasedWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-slipBasedWheelJoint.e0[2],slipBasedWheelJoint.e0[1],0.0},1.5707963267949 + slipBasedWheelJoint.flange_a.phi,0.0);
//   slipBasedWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedWheelJoint.rim2.shapeType);
//   slipBasedWheelJoint.rim2.rxvisobj[1] = slipBasedWheelJoint.rim2.R.T[1,1] * slipBasedWheelJoint.rim2.e_x[1] + slipBasedWheelJoint.rim2.R.T[2,1] * slipBasedWheelJoint.rim2.e_x[2] + slipBasedWheelJoint.rim2.R.T[3,1] * slipBasedWheelJoint.rim2.e_x[3];
//   slipBasedWheelJoint.rim2.rxvisobj[2] = slipBasedWheelJoint.rim2.R.T[1,2] * slipBasedWheelJoint.rim2.e_x[1] + slipBasedWheelJoint.rim2.R.T[2,2] * slipBasedWheelJoint.rim2.e_x[2] + slipBasedWheelJoint.rim2.R.T[3,2] * slipBasedWheelJoint.rim2.e_x[3];
//   slipBasedWheelJoint.rim2.rxvisobj[3] = slipBasedWheelJoint.rim2.R.T[1,3] * slipBasedWheelJoint.rim2.e_x[1] + slipBasedWheelJoint.rim2.R.T[2,3] * slipBasedWheelJoint.rim2.e_x[2] + slipBasedWheelJoint.rim2.R.T[3,3] * slipBasedWheelJoint.rim2.e_x[3];
//   slipBasedWheelJoint.rim2.ryvisobj[1] = slipBasedWheelJoint.rim2.R.T[1,1] * slipBasedWheelJoint.rim2.e_y[1] + slipBasedWheelJoint.rim2.R.T[2,1] * slipBasedWheelJoint.rim2.e_y[2] + slipBasedWheelJoint.rim2.R.T[3,1] * slipBasedWheelJoint.rim2.e_y[3];
//   slipBasedWheelJoint.rim2.ryvisobj[2] = slipBasedWheelJoint.rim2.R.T[1,2] * slipBasedWheelJoint.rim2.e_y[1] + slipBasedWheelJoint.rim2.R.T[2,2] * slipBasedWheelJoint.rim2.e_y[2] + slipBasedWheelJoint.rim2.R.T[3,2] * slipBasedWheelJoint.rim2.e_y[3];
//   slipBasedWheelJoint.rim2.ryvisobj[3] = slipBasedWheelJoint.rim2.R.T[1,3] * slipBasedWheelJoint.rim2.e_y[1] + slipBasedWheelJoint.rim2.R.T[2,3] * slipBasedWheelJoint.rim2.e_y[2] + slipBasedWheelJoint.rim2.R.T[3,3] * slipBasedWheelJoint.rim2.e_y[3];
//   slipBasedWheelJoint.rim2.rvisobj = slipBasedWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedWheelJoint.rim2.R.T[1,1],slipBasedWheelJoint.rim2.R.T[1,2],slipBasedWheelJoint.rim2.R.T[1,3]},{slipBasedWheelJoint.rim2.R.T[2,1],slipBasedWheelJoint.rim2.R.T[2,2],slipBasedWheelJoint.rim2.R.T[2,3]},{slipBasedWheelJoint.rim2.R.T[3,1],slipBasedWheelJoint.rim2.R.T[3,2],slipBasedWheelJoint.rim2.R.T[3,3]}},{slipBasedWheelJoint.rim2.r_shape[1],slipBasedWheelJoint.rim2.r_shape[2],slipBasedWheelJoint.rim2.r_shape[3]});
//   slipBasedWheelJoint.rim2.size[1] = slipBasedWheelJoint.rim2.length;
//   slipBasedWheelJoint.rim2.size[2] = slipBasedWheelJoint.rim2.width;
//   slipBasedWheelJoint.rim2.size[3] = slipBasedWheelJoint.rim2.height;
//   slipBasedWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedWheelJoint.rim2.color[1] / 255.0,slipBasedWheelJoint.rim2.color[2] / 255.0,slipBasedWheelJoint.rim2.color[3] / 255.0,slipBasedWheelJoint.rim2.specularCoefficient);
//   slipBasedWheelJoint.rim2.Extra = slipBasedWheelJoint.rim2.extra;
//   slipBasedWheelJoint.R[1,1] = cos(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.R[1,2] = sin(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.R[2,1] = -sin(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.R[2,2] = cos(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.e0[1] = slipBasedWheelJoint.R[1,1] * slipBasedWheelJoint.e[1] + slipBasedWheelJoint.R[1,2] * slipBasedWheelJoint.e[2];
//   slipBasedWheelJoint.e0[2] = slipBasedWheelJoint.R[2,1] * slipBasedWheelJoint.e[1] + slipBasedWheelJoint.R[2,2] * slipBasedWheelJoint.e[2];
//   slipBasedWheelJoint.v[1] = der(slipBasedWheelJoint.frame_a.x);
//   slipBasedWheelJoint.v[2] = der(slipBasedWheelJoint.frame_a.y);
//   slipBasedWheelJoint.w_roll = der(slipBasedWheelJoint.flange_a.phi);
//   slipBasedWheelJoint.v_long = slipBasedWheelJoint.v[1] * slipBasedWheelJoint.e0[1] + slipBasedWheelJoint.v[2] * slipBasedWheelJoint.e0[2];
//   slipBasedWheelJoint.v_lat = (-slipBasedWheelJoint.v[1]) * slipBasedWheelJoint.e0[2] + slipBasedWheelJoint.v[2] * slipBasedWheelJoint.e0[1];
//   slipBasedWheelJoint.v_slip_lat = slipBasedWheelJoint.v_lat;
//   slipBasedWheelJoint.v_slip_long = slipBasedWheelJoint.v_long - slipBasedWheelJoint.radius * slipBasedWheelJoint.w_roll;
//   slipBasedWheelJoint.v_slip = 0.0001 + sqrt(slipBasedWheelJoint.v_slip_long ^ 2.0 + slipBasedWheelJoint.v_slip_lat ^ 2.0);
//   (-slipBasedWheelJoint.f_long) * slipBasedWheelJoint.radius = slipBasedWheelJoint.flange_a.tau;
//   slipBasedWheelJoint.frame_a.t = 0.0;
//   slipBasedWheelJoint.vAdhesion = max(slipBasedWheelJoint.sAdhesion * abs(slipBasedWheelJoint.radius * slipBasedWheelJoint.w_roll),slipBasedWheelJoint.vAdhesion_min);
//   slipBasedWheelJoint.vSlide = max(slipBasedWheelJoint.sSlide * abs(slipBasedWheelJoint.radius * slipBasedWheelJoint.w_roll),slipBasedWheelJoint.vSlide_min);
//   slipBasedWheelJoint.fN = max(0.0,slipBasedWheelJoint.N + slipBasedWheelJoint.dynamicLoad);
//   slipBasedWheelJoint.f = slipBasedWheelJoint.fN * PlanarMechanicsV4.Utilities.TripleS_Func(slipBasedWheelJoint.vAdhesion,slipBasedWheelJoint.vSlide,slipBasedWheelJoint.mu_A,slipBasedWheelJoint.mu_S,slipBasedWheelJoint.v_slip);
//   slipBasedWheelJoint.f_long = (slipBasedWheelJoint.f * slipBasedWheelJoint.v_slip_long) / slipBasedWheelJoint.v_slip;
//   slipBasedWheelJoint.f_lat = (slipBasedWheelJoint.f * slipBasedWheelJoint.v_slip_lat) / slipBasedWheelJoint.v_slip;
//   slipBasedWheelJoint.f_long = slipBasedWheelJoint.frame_a.fx * slipBasedWheelJoint.e0[1] + slipBasedWheelJoint.frame_a.fy * slipBasedWheelJoint.e0[2];
//   slipBasedWheelJoint.f_lat = slipBasedWheelJoint.frame_a.fy * slipBasedWheelJoint.e0[1] + (-slipBasedWheelJoint.frame_a.fx) * slipBasedWheelJoint.e0[2];
//   const.y = const.k;
//   prismatic.frame_a.t + revolute.frame_b.t = 0.0;
//   prismatic.frame_a.fy + revolute.frame_b.fy = 0.0;
//   prismatic.frame_a.fx + revolute.frame_b.fx = 0.0;
//   prismatic.frame_b.t + body.frame_a.t + slipBasedWheelJoint.frame_a.t = 0.0;
//   prismatic.frame_b.fy + body.frame_a.fy + slipBasedWheelJoint.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + body.frame_a.fx + slipBasedWheelJoint.frame_a.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   engineTorque.flange.tau + inertia.flange_a.tau = 0.0;
//   inertia.flange_b.tau + slipBasedWheelJoint.flange_a.tau = 0.0;
//   prismatic.frame_a.x = revolute.frame_b.x;
//   prismatic.frame_a.y = revolute.frame_b.y;
//   prismatic.frame_a.phi = revolute.frame_b.phi;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = inertia.flange_a.phi;
//   body.frame_a.x = prismatic.frame_b.x;
//   body.frame_a.x = slipBasedWheelJoint.frame_a.x;
//   body.frame_a.y = prismatic.frame_b.y;
//   body.frame_a.y = slipBasedWheelJoint.frame_a.y;
//   body.frame_a.phi = prismatic.frame_b.phi;
//   body.frame_a.phi = slipBasedWheelJoint.frame_a.phi;
//   inertia.flange_b.phi = slipBasedWheelJoint.flange_a.phi;
//   const.y = slipBasedWheelJoint.dynamicLoad;
// end PlanarMechanicsV4.Examples.TestSlipBasedWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.WheelBasedCranCrab
//   Real idealRolling.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealRolling.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealRolling.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealRolling.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealRolling.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealRolling.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real idealRolling.R(quantity = \"Length\", unit = \"m\") = 0.3 \"Radius of the wheel\";
//   parameter Boolean idealRolling.initialize = false \"Initialize Position and Velocity\";
//   parameter Real idealRolling.x_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real idealRolling.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real idealRolling.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean idealRolling.animate = true \"enable Animation\";
//   Real idealRolling.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real idealRolling.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real idealRolling.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real idealRolling.vx(quantity = \"Velocity\", unit = \"m/s\") \"Velocity in x-direction\";
//   parameter String idealRolling.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealRolling.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealRolling.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Width of visual object\";
//   input Real idealRolling.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Height of visual object\";
//   input Real idealRolling.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealRolling.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real idealRolling.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real idealRolling.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real idealRolling.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealRolling.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealRolling.cylinder.lengthDirection[1],idealRolling.cylinder.lengthDirection[2],idealRolling.cylinder.lengthDirection[3]});
//   protected Real idealRolling.cylinder.e_x[1](unit = \"1\") = if noEvent(idealRolling.cylinder.abs_n_x < 1e-10) then 1.0 else idealRolling.cylinder.lengthDirection[1] / idealRolling.cylinder.abs_n_x;
//   protected Real idealRolling.cylinder.e_x[2](unit = \"1\") = if noEvent(idealRolling.cylinder.abs_n_x < 1e-10) then 0.0 else idealRolling.cylinder.lengthDirection[2] / idealRolling.cylinder.abs_n_x;
//   protected Real idealRolling.cylinder.e_x[3](unit = \"1\") = if noEvent(idealRolling.cylinder.abs_n_x < 1e-10) then 0.0 else idealRolling.cylinder.lengthDirection[3] / idealRolling.cylinder.abs_n_x;
//   protected Real idealRolling.cylinder.n_z_aux[1](unit = \"1\") = idealRolling.cylinder.e_x[2] * idealRolling.cylinder.widthDirection[3] - idealRolling.cylinder.e_x[3] * idealRolling.cylinder.widthDirection[2];
//   protected Real idealRolling.cylinder.n_z_aux[2](unit = \"1\") = idealRolling.cylinder.e_x[3] * idealRolling.cylinder.widthDirection[1] - idealRolling.cylinder.e_x[1] * idealRolling.cylinder.widthDirection[3];
//   protected Real idealRolling.cylinder.n_z_aux[3](unit = \"1\") = idealRolling.cylinder.e_x[1] * idealRolling.cylinder.widthDirection[2] - idealRolling.cylinder.e_x[2] * idealRolling.cylinder.widthDirection[1];
//   protected Real idealRolling.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]},if noEvent(idealRolling.cylinder.n_z_aux[1] ^ 2.0 + (idealRolling.cylinder.n_z_aux[2] ^ 2.0 + idealRolling.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.cylinder.widthDirection[1],idealRolling.cylinder.widthDirection[2],idealRolling.cylinder.widthDirection[3]} else if noEvent(abs(idealRolling.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]})[1];
//   protected Real idealRolling.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]},if noEvent(idealRolling.cylinder.n_z_aux[1] ^ 2.0 + (idealRolling.cylinder.n_z_aux[2] ^ 2.0 + idealRolling.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.cylinder.widthDirection[1],idealRolling.cylinder.widthDirection[2],idealRolling.cylinder.widthDirection[3]} else if noEvent(abs(idealRolling.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]})[2];
//   protected Real idealRolling.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]},if noEvent(idealRolling.cylinder.n_z_aux[1] ^ 2.0 + (idealRolling.cylinder.n_z_aux[2] ^ 2.0 + idealRolling.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.cylinder.widthDirection[1],idealRolling.cylinder.widthDirection[2],idealRolling.cylinder.widthDirection[3]} else if noEvent(abs(idealRolling.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]})[3];
//   protected output Real idealRolling.cylinder.Form;
//   output Real idealRolling.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealRolling.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.cylinder.Material;
//   protected output Real idealRolling.cylinder.Extra;
//   parameter String idealRolling.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealRolling.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = -idealRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim1.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim1.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim1.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Length of visual object\";
//   input Real idealRolling.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealRolling.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealRolling.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealRolling.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealRolling.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealRolling.rim1.lengthDirection[1],idealRolling.rim1.lengthDirection[2],idealRolling.rim1.lengthDirection[3]});
//   protected Real idealRolling.rim1.e_x[1](unit = \"1\") = if noEvent(idealRolling.rim1.abs_n_x < 1e-10) then 1.0 else idealRolling.rim1.lengthDirection[1] / idealRolling.rim1.abs_n_x;
//   protected Real idealRolling.rim1.e_x[2](unit = \"1\") = if noEvent(idealRolling.rim1.abs_n_x < 1e-10) then 0.0 else idealRolling.rim1.lengthDirection[2] / idealRolling.rim1.abs_n_x;
//   protected Real idealRolling.rim1.e_x[3](unit = \"1\") = if noEvent(idealRolling.rim1.abs_n_x < 1e-10) then 0.0 else idealRolling.rim1.lengthDirection[3] / idealRolling.rim1.abs_n_x;
//   protected Real idealRolling.rim1.n_z_aux[1](unit = \"1\") = idealRolling.rim1.e_x[2] * idealRolling.rim1.widthDirection[3] - idealRolling.rim1.e_x[3] * idealRolling.rim1.widthDirection[2];
//   protected Real idealRolling.rim1.n_z_aux[2](unit = \"1\") = idealRolling.rim1.e_x[3] * idealRolling.rim1.widthDirection[1] - idealRolling.rim1.e_x[1] * idealRolling.rim1.widthDirection[3];
//   protected Real idealRolling.rim1.n_z_aux[3](unit = \"1\") = idealRolling.rim1.e_x[1] * idealRolling.rim1.widthDirection[2] - idealRolling.rim1.e_x[2] * idealRolling.rim1.widthDirection[1];
//   protected Real idealRolling.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]},if noEvent(idealRolling.rim1.n_z_aux[1] ^ 2.0 + (idealRolling.rim1.n_z_aux[2] ^ 2.0 + idealRolling.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.rim1.widthDirection[1],idealRolling.rim1.widthDirection[2],idealRolling.rim1.widthDirection[3]} else if noEvent(abs(idealRolling.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]})[1];
//   protected Real idealRolling.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]},if noEvent(idealRolling.rim1.n_z_aux[1] ^ 2.0 + (idealRolling.rim1.n_z_aux[2] ^ 2.0 + idealRolling.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.rim1.widthDirection[1],idealRolling.rim1.widthDirection[2],idealRolling.rim1.widthDirection[3]} else if noEvent(abs(idealRolling.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]})[2];
//   protected Real idealRolling.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]},if noEvent(idealRolling.rim1.n_z_aux[1] ^ 2.0 + (idealRolling.rim1.n_z_aux[2] ^ 2.0 + idealRolling.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.rim1.widthDirection[1],idealRolling.rim1.widthDirection[2],idealRolling.rim1.widthDirection[3]} else if noEvent(abs(idealRolling.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]})[3];
//   protected output Real idealRolling.rim1.Form;
//   output Real idealRolling.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealRolling.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim1.Material;
//   protected output Real idealRolling.rim1.Extra;
//   parameter String idealRolling.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealRolling.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = -idealRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim2.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim2.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim2.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Length of visual object\";
//   input Real idealRolling.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealRolling.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealRolling.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealRolling.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealRolling.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealRolling.rim2.lengthDirection[1],idealRolling.rim2.lengthDirection[2],idealRolling.rim2.lengthDirection[3]});
//   protected Real idealRolling.rim2.e_x[1](unit = \"1\") = if noEvent(idealRolling.rim2.abs_n_x < 1e-10) then 1.0 else idealRolling.rim2.lengthDirection[1] / idealRolling.rim2.abs_n_x;
//   protected Real idealRolling.rim2.e_x[2](unit = \"1\") = if noEvent(idealRolling.rim2.abs_n_x < 1e-10) then 0.0 else idealRolling.rim2.lengthDirection[2] / idealRolling.rim2.abs_n_x;
//   protected Real idealRolling.rim2.e_x[3](unit = \"1\") = if noEvent(idealRolling.rim2.abs_n_x < 1e-10) then 0.0 else idealRolling.rim2.lengthDirection[3] / idealRolling.rim2.abs_n_x;
//   protected Real idealRolling.rim2.n_z_aux[1](unit = \"1\") = idealRolling.rim2.e_x[2] * idealRolling.rim2.widthDirection[3] - idealRolling.rim2.e_x[3] * idealRolling.rim2.widthDirection[2];
//   protected Real idealRolling.rim2.n_z_aux[2](unit = \"1\") = idealRolling.rim2.e_x[3] * idealRolling.rim2.widthDirection[1] - idealRolling.rim2.e_x[1] * idealRolling.rim2.widthDirection[3];
//   protected Real idealRolling.rim2.n_z_aux[3](unit = \"1\") = idealRolling.rim2.e_x[1] * idealRolling.rim2.widthDirection[2] - idealRolling.rim2.e_x[2] * idealRolling.rim2.widthDirection[1];
//   protected Real idealRolling.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]},if noEvent(idealRolling.rim2.n_z_aux[1] ^ 2.0 + (idealRolling.rim2.n_z_aux[2] ^ 2.0 + idealRolling.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.rim2.widthDirection[1],idealRolling.rim2.widthDirection[2],idealRolling.rim2.widthDirection[3]} else if noEvent(abs(idealRolling.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]})[1];
//   protected Real idealRolling.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]},if noEvent(idealRolling.rim2.n_z_aux[1] ^ 2.0 + (idealRolling.rim2.n_z_aux[2] ^ 2.0 + idealRolling.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.rim2.widthDirection[1],idealRolling.rim2.widthDirection[2],idealRolling.rim2.widthDirection[3]} else if noEvent(abs(idealRolling.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]})[2];
//   protected Real idealRolling.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]},if noEvent(idealRolling.rim2.n_z_aux[1] ^ 2.0 + (idealRolling.rim2.n_z_aux[2] ^ 2.0 + idealRolling.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealRolling.rim2.widthDirection[1],idealRolling.rim2.widthDirection[2],idealRolling.rim2.widthDirection[3]} else if noEvent(abs(idealRolling.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]})[3];
//   protected output Real idealRolling.rim2.Form;
//   output Real idealRolling.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealRolling.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim2.Material;
//   protected output Real idealRolling.rim2.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
// equation
//   idealRolling.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealRolling.cylinder.shapeType);
//   idealRolling.cylinder.rxvisobj[1] = idealRolling.cylinder.R.T[1,1] * idealRolling.cylinder.e_x[1] + idealRolling.cylinder.R.T[2,1] * idealRolling.cylinder.e_x[2] + idealRolling.cylinder.R.T[3,1] * idealRolling.cylinder.e_x[3];
//   idealRolling.cylinder.rxvisobj[2] = idealRolling.cylinder.R.T[1,2] * idealRolling.cylinder.e_x[1] + idealRolling.cylinder.R.T[2,2] * idealRolling.cylinder.e_x[2] + idealRolling.cylinder.R.T[3,2] * idealRolling.cylinder.e_x[3];
//   idealRolling.cylinder.rxvisobj[3] = idealRolling.cylinder.R.T[1,3] * idealRolling.cylinder.e_x[1] + idealRolling.cylinder.R.T[2,3] * idealRolling.cylinder.e_x[2] + idealRolling.cylinder.R.T[3,3] * idealRolling.cylinder.e_x[3];
//   idealRolling.cylinder.ryvisobj[1] = idealRolling.cylinder.R.T[1,1] * idealRolling.cylinder.e_y[1] + idealRolling.cylinder.R.T[2,1] * idealRolling.cylinder.e_y[2] + idealRolling.cylinder.R.T[3,1] * idealRolling.cylinder.e_y[3];
//   idealRolling.cylinder.ryvisobj[2] = idealRolling.cylinder.R.T[1,2] * idealRolling.cylinder.e_y[1] + idealRolling.cylinder.R.T[2,2] * idealRolling.cylinder.e_y[2] + idealRolling.cylinder.R.T[3,2] * idealRolling.cylinder.e_y[3];
//   idealRolling.cylinder.ryvisobj[3] = idealRolling.cylinder.R.T[1,3] * idealRolling.cylinder.e_y[1] + idealRolling.cylinder.R.T[2,3] * idealRolling.cylinder.e_y[2] + idealRolling.cylinder.R.T[3,3] * idealRolling.cylinder.e_y[3];
//   idealRolling.cylinder.rvisobj = idealRolling.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealRolling.cylinder.R.T[1,1],idealRolling.cylinder.R.T[1,2],idealRolling.cylinder.R.T[1,3]},{idealRolling.cylinder.R.T[2,1],idealRolling.cylinder.R.T[2,2],idealRolling.cylinder.R.T[2,3]},{idealRolling.cylinder.R.T[3,1],idealRolling.cylinder.R.T[3,2],idealRolling.cylinder.R.T[3,3]}},{idealRolling.cylinder.r_shape[1],idealRolling.cylinder.r_shape[2],idealRolling.cylinder.r_shape[3]});
//   idealRolling.cylinder.size[1] = idealRolling.cylinder.length;
//   idealRolling.cylinder.size[2] = idealRolling.cylinder.width;
//   idealRolling.cylinder.size[3] = idealRolling.cylinder.height;
//   idealRolling.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealRolling.cylinder.color[1] / 255.0,idealRolling.cylinder.color[2] / 255.0,idealRolling.cylinder.color[3] / 255.0,idealRolling.cylinder.specularCoefficient);
//   idealRolling.cylinder.Extra = idealRolling.cylinder.extra;
//   idealRolling.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},-idealRolling.phi,0.0);
//   idealRolling.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealRolling.rim1.shapeType);
//   idealRolling.rim1.rxvisobj[1] = idealRolling.rim1.R.T[1,1] * idealRolling.rim1.e_x[1] + idealRolling.rim1.R.T[2,1] * idealRolling.rim1.e_x[2] + idealRolling.rim1.R.T[3,1] * idealRolling.rim1.e_x[3];
//   idealRolling.rim1.rxvisobj[2] = idealRolling.rim1.R.T[1,2] * idealRolling.rim1.e_x[1] + idealRolling.rim1.R.T[2,2] * idealRolling.rim1.e_x[2] + idealRolling.rim1.R.T[3,2] * idealRolling.rim1.e_x[3];
//   idealRolling.rim1.rxvisobj[3] = idealRolling.rim1.R.T[1,3] * idealRolling.rim1.e_x[1] + idealRolling.rim1.R.T[2,3] * idealRolling.rim1.e_x[2] + idealRolling.rim1.R.T[3,3] * idealRolling.rim1.e_x[3];
//   idealRolling.rim1.ryvisobj[1] = idealRolling.rim1.R.T[1,1] * idealRolling.rim1.e_y[1] + idealRolling.rim1.R.T[2,1] * idealRolling.rim1.e_y[2] + idealRolling.rim1.R.T[3,1] * idealRolling.rim1.e_y[3];
//   idealRolling.rim1.ryvisobj[2] = idealRolling.rim1.R.T[1,2] * idealRolling.rim1.e_y[1] + idealRolling.rim1.R.T[2,2] * idealRolling.rim1.e_y[2] + idealRolling.rim1.R.T[3,2] * idealRolling.rim1.e_y[3];
//   idealRolling.rim1.ryvisobj[3] = idealRolling.rim1.R.T[1,3] * idealRolling.rim1.e_y[1] + idealRolling.rim1.R.T[2,3] * idealRolling.rim1.e_y[2] + idealRolling.rim1.R.T[3,3] * idealRolling.rim1.e_y[3];
//   idealRolling.rim1.rvisobj = idealRolling.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealRolling.rim1.R.T[1,1],idealRolling.rim1.R.T[1,2],idealRolling.rim1.R.T[1,3]},{idealRolling.rim1.R.T[2,1],idealRolling.rim1.R.T[2,2],idealRolling.rim1.R.T[2,3]},{idealRolling.rim1.R.T[3,1],idealRolling.rim1.R.T[3,2],idealRolling.rim1.R.T[3,3]}},{idealRolling.rim1.r_shape[1],idealRolling.rim1.r_shape[2],idealRolling.rim1.r_shape[3]});
//   idealRolling.rim1.size[1] = idealRolling.rim1.length;
//   idealRolling.rim1.size[2] = idealRolling.rim1.width;
//   idealRolling.rim1.size[3] = idealRolling.rim1.height;
//   idealRolling.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealRolling.rim1.color[1] / 255.0,idealRolling.rim1.color[2] / 255.0,idealRolling.rim1.color[3] / 255.0,idealRolling.rim1.specularCoefficient);
//   idealRolling.rim1.Extra = idealRolling.rim1.extra;
//   idealRolling.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},1.5707963267949 - idealRolling.phi,0.0);
//   idealRolling.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealRolling.rim2.shapeType);
//   idealRolling.rim2.rxvisobj[1] = idealRolling.rim2.R.T[1,1] * idealRolling.rim2.e_x[1] + idealRolling.rim2.R.T[2,1] * idealRolling.rim2.e_x[2] + idealRolling.rim2.R.T[3,1] * idealRolling.rim2.e_x[3];
//   idealRolling.rim2.rxvisobj[2] = idealRolling.rim2.R.T[1,2] * idealRolling.rim2.e_x[1] + idealRolling.rim2.R.T[2,2] * idealRolling.rim2.e_x[2] + idealRolling.rim2.R.T[3,2] * idealRolling.rim2.e_x[3];
//   idealRolling.rim2.rxvisobj[3] = idealRolling.rim2.R.T[1,3] * idealRolling.rim2.e_x[1] + idealRolling.rim2.R.T[2,3] * idealRolling.rim2.e_x[2] + idealRolling.rim2.R.T[3,3] * idealRolling.rim2.e_x[3];
//   idealRolling.rim2.ryvisobj[1] = idealRolling.rim2.R.T[1,1] * idealRolling.rim2.e_y[1] + idealRolling.rim2.R.T[2,1] * idealRolling.rim2.e_y[2] + idealRolling.rim2.R.T[3,1] * idealRolling.rim2.e_y[3];
//   idealRolling.rim2.ryvisobj[2] = idealRolling.rim2.R.T[1,2] * idealRolling.rim2.e_y[1] + idealRolling.rim2.R.T[2,2] * idealRolling.rim2.e_y[2] + idealRolling.rim2.R.T[3,2] * idealRolling.rim2.e_y[3];
//   idealRolling.rim2.ryvisobj[3] = idealRolling.rim2.R.T[1,3] * idealRolling.rim2.e_y[1] + idealRolling.rim2.R.T[2,3] * idealRolling.rim2.e_y[2] + idealRolling.rim2.R.T[3,3] * idealRolling.rim2.e_y[3];
//   idealRolling.rim2.rvisobj = idealRolling.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealRolling.rim2.R.T[1,1],idealRolling.rim2.R.T[1,2],idealRolling.rim2.R.T[1,3]},{idealRolling.rim2.R.T[2,1],idealRolling.rim2.R.T[2,2],idealRolling.rim2.R.T[2,3]},{idealRolling.rim2.R.T[3,1],idealRolling.rim2.R.T[3,2],idealRolling.rim2.R.T[3,3]}},{idealRolling.rim2.r_shape[1],idealRolling.rim2.r_shape[2],idealRolling.rim2.r_shape[3]});
//   idealRolling.rim2.size[1] = idealRolling.rim2.length;
//   idealRolling.rim2.size[2] = idealRolling.rim2.width;
//   idealRolling.rim2.size[3] = idealRolling.rim2.height;
//   idealRolling.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealRolling.rim2.color[1] / 255.0,idealRolling.rim2.color[2] / 255.0,idealRolling.rim2.color[3] / 255.0,idealRolling.rim2.specularCoefficient);
//   idealRolling.rim2.Extra = idealRolling.rim2.extra;
//   idealRolling.phi = idealRolling.frame_a.phi;
//   idealRolling.w = der(idealRolling.phi);
//   idealRolling.z = der(idealRolling.w);
//   idealRolling.vx = der(idealRolling.frame_a.x);
//   idealRolling.frame_a.y = idealRolling.R;
//   idealRolling.vx = idealRolling.w * idealRolling.R;
//   idealRolling.frame_a.fx * idealRolling.R = -idealRolling.frame_a.t;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   idealRolling.frame_a.t + body.frame_a.t + revolute.frame_a.t = 0.0;
//   idealRolling.frame_a.fy + body.frame_a.fy + revolute.frame_a.fy = 0.0;
//   idealRolling.frame_a.fx + body.frame_a.fx + revolute.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   fixedTranslation.frame_b.t + body1.frame_a.t = 0.0;
//   fixedTranslation.frame_b.fy + body1.frame_a.fy = 0.0;
//   fixedTranslation.frame_b.fx + body1.frame_a.fx = 0.0;
//   body.frame_a.x = idealRolling.frame_a.x;
//   body.frame_a.x = revolute.frame_a.x;
//   body.frame_a.y = idealRolling.frame_a.y;
//   body.frame_a.y = revolute.frame_a.y;
//   body.frame_a.phi = idealRolling.frame_a.phi;
//   body.frame_a.phi = revolute.frame_a.phi;
//   body1.frame_a.x = fixedTranslation.frame_b.x;
//   body1.frame_a.y = fixedTranslation.frame_b.y;
//   body1.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
// end PlanarMechanicsV4.Examples.WheelBasedCranCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.CounterSpin
//   Real slipBasedRolling.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real slipBasedRolling.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real slipBasedRolling.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real slipBasedRolling.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real slipBasedRolling.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real slipBasedRolling.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real slipBasedRolling.R(quantity = \"Length\", unit = \"m\") = 0.1 \"Radius of the wheel\";
//   parameter Real slipBasedRolling.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.001 \"adhesion velocity\";
//   parameter Real slipBasedRolling.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.01 \"sliding velocity\";
//   parameter Real slipBasedRolling.mu_A = 0.4 \"friction coefficient at adhesion\";
//   parameter Real slipBasedRolling.mu_S = 0.15 \"friction coefficient at sliding\";
//   parameter Boolean slipBasedRolling.initialize = true \"Initialize Position and Velocity\";
//   parameter Real slipBasedRolling.x_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real slipBasedRolling.vx_start(quantity = \"Velocity\", unit = \"m/s\") = 2.0;
//   parameter Real slipBasedRolling.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real slipBasedRolling.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = -15.0;
//   parameter Boolean slipBasedRolling.animate = true \"enable Animation\";
//   Real slipBasedRolling.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real slipBasedRolling.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real slipBasedRolling.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real slipBasedRolling.vx(quantity = \"Velocity\", unit = \"m/s\") \"Velocity in x-direction\";
//   Real slipBasedRolling.N(quantity = \"Force\", unit = \"N\") \"normal force\";
//   Real slipBasedRolling.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   parameter String slipBasedRolling.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedRolling.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.cylinder.r[1](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.cylinder.r[2](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real slipBasedRolling.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Width of visual object\";
//   input Real slipBasedRolling.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Height of visual object\";
//   input Real slipBasedRolling.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedRolling.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real slipBasedRolling.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real slipBasedRolling.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real slipBasedRolling.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedRolling.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedRolling.cylinder.lengthDirection[1],slipBasedRolling.cylinder.lengthDirection[2],slipBasedRolling.cylinder.lengthDirection[3]});
//   protected Real slipBasedRolling.cylinder.e_x[1](unit = \"1\") = if noEvent(slipBasedRolling.cylinder.abs_n_x < 1e-10) then 1.0 else slipBasedRolling.cylinder.lengthDirection[1] / slipBasedRolling.cylinder.abs_n_x;
//   protected Real slipBasedRolling.cylinder.e_x[2](unit = \"1\") = if noEvent(slipBasedRolling.cylinder.abs_n_x < 1e-10) then 0.0 else slipBasedRolling.cylinder.lengthDirection[2] / slipBasedRolling.cylinder.abs_n_x;
//   protected Real slipBasedRolling.cylinder.e_x[3](unit = \"1\") = if noEvent(slipBasedRolling.cylinder.abs_n_x < 1e-10) then 0.0 else slipBasedRolling.cylinder.lengthDirection[3] / slipBasedRolling.cylinder.abs_n_x;
//   protected Real slipBasedRolling.cylinder.n_z_aux[1](unit = \"1\") = slipBasedRolling.cylinder.e_x[2] * slipBasedRolling.cylinder.widthDirection[3] - slipBasedRolling.cylinder.e_x[3] * slipBasedRolling.cylinder.widthDirection[2];
//   protected Real slipBasedRolling.cylinder.n_z_aux[2](unit = \"1\") = slipBasedRolling.cylinder.e_x[3] * slipBasedRolling.cylinder.widthDirection[1] - slipBasedRolling.cylinder.e_x[1] * slipBasedRolling.cylinder.widthDirection[3];
//   protected Real slipBasedRolling.cylinder.n_z_aux[3](unit = \"1\") = slipBasedRolling.cylinder.e_x[1] * slipBasedRolling.cylinder.widthDirection[2] - slipBasedRolling.cylinder.e_x[2] * slipBasedRolling.cylinder.widthDirection[1];
//   protected Real slipBasedRolling.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]},if noEvent(slipBasedRolling.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedRolling.cylinder.n_z_aux[2] ^ 2.0 + slipBasedRolling.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.cylinder.widthDirection[1],slipBasedRolling.cylinder.widthDirection[2],slipBasedRolling.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedRolling.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]})[1];
//   protected Real slipBasedRolling.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]},if noEvent(slipBasedRolling.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedRolling.cylinder.n_z_aux[2] ^ 2.0 + slipBasedRolling.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.cylinder.widthDirection[1],slipBasedRolling.cylinder.widthDirection[2],slipBasedRolling.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedRolling.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]})[2];
//   protected Real slipBasedRolling.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]},if noEvent(slipBasedRolling.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedRolling.cylinder.n_z_aux[2] ^ 2.0 + slipBasedRolling.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.cylinder.widthDirection[1],slipBasedRolling.cylinder.widthDirection[2],slipBasedRolling.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedRolling.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]})[3];
//   protected output Real slipBasedRolling.cylinder.Form;
//   output Real slipBasedRolling.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedRolling.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.cylinder.Material;
//   protected output Real slipBasedRolling.cylinder.Extra;
//   parameter String slipBasedRolling.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedRolling.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim1.r[1](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim1.r[2](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = -slipBasedRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim1.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Length of visual object\";
//   input Real slipBasedRolling.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedRolling.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedRolling.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedRolling.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedRolling.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedRolling.rim1.lengthDirection[1],slipBasedRolling.rim1.lengthDirection[2],slipBasedRolling.rim1.lengthDirection[3]});
//   protected Real slipBasedRolling.rim1.e_x[1](unit = \"1\") = if noEvent(slipBasedRolling.rim1.abs_n_x < 1e-10) then 1.0 else slipBasedRolling.rim1.lengthDirection[1] / slipBasedRolling.rim1.abs_n_x;
//   protected Real slipBasedRolling.rim1.e_x[2](unit = \"1\") = if noEvent(slipBasedRolling.rim1.abs_n_x < 1e-10) then 0.0 else slipBasedRolling.rim1.lengthDirection[2] / slipBasedRolling.rim1.abs_n_x;
//   protected Real slipBasedRolling.rim1.e_x[3](unit = \"1\") = if noEvent(slipBasedRolling.rim1.abs_n_x < 1e-10) then 0.0 else slipBasedRolling.rim1.lengthDirection[3] / slipBasedRolling.rim1.abs_n_x;
//   protected Real slipBasedRolling.rim1.n_z_aux[1](unit = \"1\") = slipBasedRolling.rim1.e_x[2] * slipBasedRolling.rim1.widthDirection[3] - slipBasedRolling.rim1.e_x[3] * slipBasedRolling.rim1.widthDirection[2];
//   protected Real slipBasedRolling.rim1.n_z_aux[2](unit = \"1\") = slipBasedRolling.rim1.e_x[3] * slipBasedRolling.rim1.widthDirection[1] - slipBasedRolling.rim1.e_x[1] * slipBasedRolling.rim1.widthDirection[3];
//   protected Real slipBasedRolling.rim1.n_z_aux[3](unit = \"1\") = slipBasedRolling.rim1.e_x[1] * slipBasedRolling.rim1.widthDirection[2] - slipBasedRolling.rim1.e_x[2] * slipBasedRolling.rim1.widthDirection[1];
//   protected Real slipBasedRolling.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]},if noEvent(slipBasedRolling.rim1.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim1.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.rim1.widthDirection[1],slipBasedRolling.rim1.widthDirection[2],slipBasedRolling.rim1.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]})[1];
//   protected Real slipBasedRolling.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]},if noEvent(slipBasedRolling.rim1.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim1.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.rim1.widthDirection[1],slipBasedRolling.rim1.widthDirection[2],slipBasedRolling.rim1.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]})[2];
//   protected Real slipBasedRolling.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]},if noEvent(slipBasedRolling.rim1.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim1.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.rim1.widthDirection[1],slipBasedRolling.rim1.widthDirection[2],slipBasedRolling.rim1.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]})[3];
//   protected output Real slipBasedRolling.rim1.Form;
//   output Real slipBasedRolling.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedRolling.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim1.Material;
//   protected output Real slipBasedRolling.rim1.Extra;
//   parameter String slipBasedRolling.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedRolling.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim2.r[1](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim2.r[2](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = -slipBasedRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim2.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Length of visual object\";
//   input Real slipBasedRolling.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedRolling.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedRolling.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedRolling.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedRolling.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedRolling.rim2.lengthDirection[1],slipBasedRolling.rim2.lengthDirection[2],slipBasedRolling.rim2.lengthDirection[3]});
//   protected Real slipBasedRolling.rim2.e_x[1](unit = \"1\") = if noEvent(slipBasedRolling.rim2.abs_n_x < 1e-10) then 1.0 else slipBasedRolling.rim2.lengthDirection[1] / slipBasedRolling.rim2.abs_n_x;
//   protected Real slipBasedRolling.rim2.e_x[2](unit = \"1\") = if noEvent(slipBasedRolling.rim2.abs_n_x < 1e-10) then 0.0 else slipBasedRolling.rim2.lengthDirection[2] / slipBasedRolling.rim2.abs_n_x;
//   protected Real slipBasedRolling.rim2.e_x[3](unit = \"1\") = if noEvent(slipBasedRolling.rim2.abs_n_x < 1e-10) then 0.0 else slipBasedRolling.rim2.lengthDirection[3] / slipBasedRolling.rim2.abs_n_x;
//   protected Real slipBasedRolling.rim2.n_z_aux[1](unit = \"1\") = slipBasedRolling.rim2.e_x[2] * slipBasedRolling.rim2.widthDirection[3] - slipBasedRolling.rim2.e_x[3] * slipBasedRolling.rim2.widthDirection[2];
//   protected Real slipBasedRolling.rim2.n_z_aux[2](unit = \"1\") = slipBasedRolling.rim2.e_x[3] * slipBasedRolling.rim2.widthDirection[1] - slipBasedRolling.rim2.e_x[1] * slipBasedRolling.rim2.widthDirection[3];
//   protected Real slipBasedRolling.rim2.n_z_aux[3](unit = \"1\") = slipBasedRolling.rim2.e_x[1] * slipBasedRolling.rim2.widthDirection[2] - slipBasedRolling.rim2.e_x[2] * slipBasedRolling.rim2.widthDirection[1];
//   protected Real slipBasedRolling.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]},if noEvent(slipBasedRolling.rim2.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim2.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.rim2.widthDirection[1],slipBasedRolling.rim2.widthDirection[2],slipBasedRolling.rim2.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]})[1];
//   protected Real slipBasedRolling.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]},if noEvent(slipBasedRolling.rim2.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim2.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.rim2.widthDirection[1],slipBasedRolling.rim2.widthDirection[2],slipBasedRolling.rim2.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]})[2];
//   protected Real slipBasedRolling.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]},if noEvent(slipBasedRolling.rim2.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim2.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {slipBasedRolling.rim2.widthDirection[1],slipBasedRolling.rim2.widthDirection[2],slipBasedRolling.rim2.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]})[3];
//   protected output Real slipBasedRolling.rim2.Form;
//   output Real slipBasedRolling.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedRolling.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim2.Material;
//   protected output Real slipBasedRolling.rim2.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.01 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.0005 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = false \"enable Animation\";
// initial equation
//   slipBasedRolling.phi = slipBasedRolling.phi_start;
//   slipBasedRolling.w = slipBasedRolling.w_start;
//   slipBasedRolling.frame_a.x = slipBasedRolling.x_start;
//   slipBasedRolling.vx = slipBasedRolling.vx_start;
// equation
//   slipBasedRolling.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedRolling.cylinder.shapeType);
//   slipBasedRolling.cylinder.rxvisobj[1] = slipBasedRolling.cylinder.R.T[1,1] * slipBasedRolling.cylinder.e_x[1] + slipBasedRolling.cylinder.R.T[2,1] * slipBasedRolling.cylinder.e_x[2] + slipBasedRolling.cylinder.R.T[3,1] * slipBasedRolling.cylinder.e_x[3];
//   slipBasedRolling.cylinder.rxvisobj[2] = slipBasedRolling.cylinder.R.T[1,2] * slipBasedRolling.cylinder.e_x[1] + slipBasedRolling.cylinder.R.T[2,2] * slipBasedRolling.cylinder.e_x[2] + slipBasedRolling.cylinder.R.T[3,2] * slipBasedRolling.cylinder.e_x[3];
//   slipBasedRolling.cylinder.rxvisobj[3] = slipBasedRolling.cylinder.R.T[1,3] * slipBasedRolling.cylinder.e_x[1] + slipBasedRolling.cylinder.R.T[2,3] * slipBasedRolling.cylinder.e_x[2] + slipBasedRolling.cylinder.R.T[3,3] * slipBasedRolling.cylinder.e_x[3];
//   slipBasedRolling.cylinder.ryvisobj[1] = slipBasedRolling.cylinder.R.T[1,1] * slipBasedRolling.cylinder.e_y[1] + slipBasedRolling.cylinder.R.T[2,1] * slipBasedRolling.cylinder.e_y[2] + slipBasedRolling.cylinder.R.T[3,1] * slipBasedRolling.cylinder.e_y[3];
//   slipBasedRolling.cylinder.ryvisobj[2] = slipBasedRolling.cylinder.R.T[1,2] * slipBasedRolling.cylinder.e_y[1] + slipBasedRolling.cylinder.R.T[2,2] * slipBasedRolling.cylinder.e_y[2] + slipBasedRolling.cylinder.R.T[3,2] * slipBasedRolling.cylinder.e_y[3];
//   slipBasedRolling.cylinder.ryvisobj[3] = slipBasedRolling.cylinder.R.T[1,3] * slipBasedRolling.cylinder.e_y[1] + slipBasedRolling.cylinder.R.T[2,3] * slipBasedRolling.cylinder.e_y[2] + slipBasedRolling.cylinder.R.T[3,3] * slipBasedRolling.cylinder.e_y[3];
//   slipBasedRolling.cylinder.rvisobj = slipBasedRolling.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedRolling.cylinder.R.T[1,1],slipBasedRolling.cylinder.R.T[1,2],slipBasedRolling.cylinder.R.T[1,3]},{slipBasedRolling.cylinder.R.T[2,1],slipBasedRolling.cylinder.R.T[2,2],slipBasedRolling.cylinder.R.T[2,3]},{slipBasedRolling.cylinder.R.T[3,1],slipBasedRolling.cylinder.R.T[3,2],slipBasedRolling.cylinder.R.T[3,3]}},{slipBasedRolling.cylinder.r_shape[1],slipBasedRolling.cylinder.r_shape[2],slipBasedRolling.cylinder.r_shape[3]});
//   slipBasedRolling.cylinder.size[1] = slipBasedRolling.cylinder.length;
//   slipBasedRolling.cylinder.size[2] = slipBasedRolling.cylinder.width;
//   slipBasedRolling.cylinder.size[3] = slipBasedRolling.cylinder.height;
//   slipBasedRolling.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedRolling.cylinder.color[1] / 255.0,slipBasedRolling.cylinder.color[2] / 255.0,slipBasedRolling.cylinder.color[3] / 255.0,slipBasedRolling.cylinder.specularCoefficient);
//   slipBasedRolling.cylinder.Extra = slipBasedRolling.cylinder.extra;
//   slipBasedRolling.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},-slipBasedRolling.phi,0.0);
//   slipBasedRolling.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedRolling.rim1.shapeType);
//   slipBasedRolling.rim1.rxvisobj[1] = slipBasedRolling.rim1.R.T[1,1] * slipBasedRolling.rim1.e_x[1] + slipBasedRolling.rim1.R.T[2,1] * slipBasedRolling.rim1.e_x[2] + slipBasedRolling.rim1.R.T[3,1] * slipBasedRolling.rim1.e_x[3];
//   slipBasedRolling.rim1.rxvisobj[2] = slipBasedRolling.rim1.R.T[1,2] * slipBasedRolling.rim1.e_x[1] + slipBasedRolling.rim1.R.T[2,2] * slipBasedRolling.rim1.e_x[2] + slipBasedRolling.rim1.R.T[3,2] * slipBasedRolling.rim1.e_x[3];
//   slipBasedRolling.rim1.rxvisobj[3] = slipBasedRolling.rim1.R.T[1,3] * slipBasedRolling.rim1.e_x[1] + slipBasedRolling.rim1.R.T[2,3] * slipBasedRolling.rim1.e_x[2] + slipBasedRolling.rim1.R.T[3,3] * slipBasedRolling.rim1.e_x[3];
//   slipBasedRolling.rim1.ryvisobj[1] = slipBasedRolling.rim1.R.T[1,1] * slipBasedRolling.rim1.e_y[1] + slipBasedRolling.rim1.R.T[2,1] * slipBasedRolling.rim1.e_y[2] + slipBasedRolling.rim1.R.T[3,1] * slipBasedRolling.rim1.e_y[3];
//   slipBasedRolling.rim1.ryvisobj[2] = slipBasedRolling.rim1.R.T[1,2] * slipBasedRolling.rim1.e_y[1] + slipBasedRolling.rim1.R.T[2,2] * slipBasedRolling.rim1.e_y[2] + slipBasedRolling.rim1.R.T[3,2] * slipBasedRolling.rim1.e_y[3];
//   slipBasedRolling.rim1.ryvisobj[3] = slipBasedRolling.rim1.R.T[1,3] * slipBasedRolling.rim1.e_y[1] + slipBasedRolling.rim1.R.T[2,3] * slipBasedRolling.rim1.e_y[2] + slipBasedRolling.rim1.R.T[3,3] * slipBasedRolling.rim1.e_y[3];
//   slipBasedRolling.rim1.rvisobj = slipBasedRolling.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedRolling.rim1.R.T[1,1],slipBasedRolling.rim1.R.T[1,2],slipBasedRolling.rim1.R.T[1,3]},{slipBasedRolling.rim1.R.T[2,1],slipBasedRolling.rim1.R.T[2,2],slipBasedRolling.rim1.R.T[2,3]},{slipBasedRolling.rim1.R.T[3,1],slipBasedRolling.rim1.R.T[3,2],slipBasedRolling.rim1.R.T[3,3]}},{slipBasedRolling.rim1.r_shape[1],slipBasedRolling.rim1.r_shape[2],slipBasedRolling.rim1.r_shape[3]});
//   slipBasedRolling.rim1.size[1] = slipBasedRolling.rim1.length;
//   slipBasedRolling.rim1.size[2] = slipBasedRolling.rim1.width;
//   slipBasedRolling.rim1.size[3] = slipBasedRolling.rim1.height;
//   slipBasedRolling.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedRolling.rim1.color[1] / 255.0,slipBasedRolling.rim1.color[2] / 255.0,slipBasedRolling.rim1.color[3] / 255.0,slipBasedRolling.rim1.specularCoefficient);
//   slipBasedRolling.rim1.Extra = slipBasedRolling.rim1.extra;
//   slipBasedRolling.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},1.5707963267949 - slipBasedRolling.phi,0.0);
//   slipBasedRolling.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedRolling.rim2.shapeType);
//   slipBasedRolling.rim2.rxvisobj[1] = slipBasedRolling.rim2.R.T[1,1] * slipBasedRolling.rim2.e_x[1] + slipBasedRolling.rim2.R.T[2,1] * slipBasedRolling.rim2.e_x[2] + slipBasedRolling.rim2.R.T[3,1] * slipBasedRolling.rim2.e_x[3];
//   slipBasedRolling.rim2.rxvisobj[2] = slipBasedRolling.rim2.R.T[1,2] * slipBasedRolling.rim2.e_x[1] + slipBasedRolling.rim2.R.T[2,2] * slipBasedRolling.rim2.e_x[2] + slipBasedRolling.rim2.R.T[3,2] * slipBasedRolling.rim2.e_x[3];
//   slipBasedRolling.rim2.rxvisobj[3] = slipBasedRolling.rim2.R.T[1,3] * slipBasedRolling.rim2.e_x[1] + slipBasedRolling.rim2.R.T[2,3] * slipBasedRolling.rim2.e_x[2] + slipBasedRolling.rim2.R.T[3,3] * slipBasedRolling.rim2.e_x[3];
//   slipBasedRolling.rim2.ryvisobj[1] = slipBasedRolling.rim2.R.T[1,1] * slipBasedRolling.rim2.e_y[1] + slipBasedRolling.rim2.R.T[2,1] * slipBasedRolling.rim2.e_y[2] + slipBasedRolling.rim2.R.T[3,1] * slipBasedRolling.rim2.e_y[3];
//   slipBasedRolling.rim2.ryvisobj[2] = slipBasedRolling.rim2.R.T[1,2] * slipBasedRolling.rim2.e_y[1] + slipBasedRolling.rim2.R.T[2,2] * slipBasedRolling.rim2.e_y[2] + slipBasedRolling.rim2.R.T[3,2] * slipBasedRolling.rim2.e_y[3];
//   slipBasedRolling.rim2.ryvisobj[3] = slipBasedRolling.rim2.R.T[1,3] * slipBasedRolling.rim2.e_y[1] + slipBasedRolling.rim2.R.T[2,3] * slipBasedRolling.rim2.e_y[2] + slipBasedRolling.rim2.R.T[3,3] * slipBasedRolling.rim2.e_y[3];
//   slipBasedRolling.rim2.rvisobj = slipBasedRolling.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedRolling.rim2.R.T[1,1],slipBasedRolling.rim2.R.T[1,2],slipBasedRolling.rim2.R.T[1,3]},{slipBasedRolling.rim2.R.T[2,1],slipBasedRolling.rim2.R.T[2,2],slipBasedRolling.rim2.R.T[2,3]},{slipBasedRolling.rim2.R.T[3,1],slipBasedRolling.rim2.R.T[3,2],slipBasedRolling.rim2.R.T[3,3]}},{slipBasedRolling.rim2.r_shape[1],slipBasedRolling.rim2.r_shape[2],slipBasedRolling.rim2.r_shape[3]});
//   slipBasedRolling.rim2.size[1] = slipBasedRolling.rim2.length;
//   slipBasedRolling.rim2.size[2] = slipBasedRolling.rim2.width;
//   slipBasedRolling.rim2.size[3] = slipBasedRolling.rim2.height;
//   slipBasedRolling.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedRolling.rim2.color[1] / 255.0,slipBasedRolling.rim2.color[2] / 255.0,slipBasedRolling.rim2.color[3] / 255.0,slipBasedRolling.rim2.specularCoefficient);
//   slipBasedRolling.rim2.Extra = slipBasedRolling.rim2.extra;
//   slipBasedRolling.phi = slipBasedRolling.frame_a.phi;
//   slipBasedRolling.w = der(slipBasedRolling.phi);
//   slipBasedRolling.z = der(slipBasedRolling.w);
//   slipBasedRolling.vx = der(slipBasedRolling.frame_a.x);
//   slipBasedRolling.frame_a.y = slipBasedRolling.R;
//   slipBasedRolling.v_slip = slipBasedRolling.vx - slipBasedRolling.w * slipBasedRolling.R;
//   slipBasedRolling.N = -slipBasedRolling.frame_a.fy;
//   slipBasedRolling.frame_a.fx = slipBasedRolling.N * PlanarMechanicsV4.Utilities.TripleS_Func(slipBasedRolling.vAdhesion,slipBasedRolling.vSlide,slipBasedRolling.mu_A,slipBasedRolling.mu_S,slipBasedRolling.v_slip);
//   slipBasedRolling.frame_a.fx * slipBasedRolling.R = -slipBasedRolling.frame_a.t;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   slipBasedRolling.frame_a.t + body.frame_a.t = 0.0;
//   slipBasedRolling.frame_a.fy + body.frame_a.fy = 0.0;
//   slipBasedRolling.frame_a.fx + body.frame_a.fx = 0.0;
//   body.frame_a.x = slipBasedRolling.frame_a.x;
//   body.frame_a.y = slipBasedRolling.frame_a.y;
//   body.frame_a.phi = slipBasedRolling.frame_a.phi;
// end PlanarMechanicsV4.Examples.CounterSpin;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.SingleTrackWithEngine
//   Real bodyFront.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyFront.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyFront.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyFront.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyFront.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyFront.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyFront.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 2.0 \"mass of the body\";
//   parameter Real bodyFront.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyFront.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyFront.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real bodyFront.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyFront.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyFront.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyFront.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyFront.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyFront.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyFront.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyFront.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyFront.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyFront.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyFront.animate = true \"enable Animation\";
//   parameter String bodyFront.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyFront.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyFront.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyFront.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyFront.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyFront.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyFront.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyFront.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyFront.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyFront.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyFront.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyFront.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyFront.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyFront.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyFront.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyFront.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyFront.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyFront.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyFront.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyFront.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyFront.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyFront.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyFront.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyFront.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyFront.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyFront.sphere.lengthDirection[1],bodyFront.sphere.lengthDirection[2],bodyFront.sphere.lengthDirection[3]});
//   protected Real bodyFront.sphere.e_x[1](unit = \"1\") = if noEvent(bodyFront.sphere.abs_n_x < 1e-10) then 1.0 else bodyFront.sphere.lengthDirection[1] / bodyFront.sphere.abs_n_x;
//   protected Real bodyFront.sphere.e_x[2](unit = \"1\") = if noEvent(bodyFront.sphere.abs_n_x < 1e-10) then 0.0 else bodyFront.sphere.lengthDirection[2] / bodyFront.sphere.abs_n_x;
//   protected Real bodyFront.sphere.e_x[3](unit = \"1\") = if noEvent(bodyFront.sphere.abs_n_x < 1e-10) then 0.0 else bodyFront.sphere.lengthDirection[3] / bodyFront.sphere.abs_n_x;
//   protected Real bodyFront.sphere.n_z_aux[1](unit = \"1\") = bodyFront.sphere.e_x[2] * bodyFront.sphere.widthDirection[3] - bodyFront.sphere.e_x[3] * bodyFront.sphere.widthDirection[2];
//   protected Real bodyFront.sphere.n_z_aux[2](unit = \"1\") = bodyFront.sphere.e_x[3] * bodyFront.sphere.widthDirection[1] - bodyFront.sphere.e_x[1] * bodyFront.sphere.widthDirection[3];
//   protected Real bodyFront.sphere.n_z_aux[3](unit = \"1\") = bodyFront.sphere.e_x[1] * bodyFront.sphere.widthDirection[2] - bodyFront.sphere.e_x[2] * bodyFront.sphere.widthDirection[1];
//   protected Real bodyFront.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]},if noEvent(bodyFront.sphere.n_z_aux[1] ^ 2.0 + (bodyFront.sphere.n_z_aux[2] ^ 2.0 + bodyFront.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyFront.sphere.widthDirection[1],bodyFront.sphere.widthDirection[2],bodyFront.sphere.widthDirection[3]} else if noEvent(abs(bodyFront.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]})[1];
//   protected Real bodyFront.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]},if noEvent(bodyFront.sphere.n_z_aux[1] ^ 2.0 + (bodyFront.sphere.n_z_aux[2] ^ 2.0 + bodyFront.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyFront.sphere.widthDirection[1],bodyFront.sphere.widthDirection[2],bodyFront.sphere.widthDirection[3]} else if noEvent(abs(bodyFront.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]})[2];
//   protected Real bodyFront.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]},if noEvent(bodyFront.sphere.n_z_aux[1] ^ 2.0 + (bodyFront.sphere.n_z_aux[2] ^ 2.0 + bodyFront.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyFront.sphere.widthDirection[1],bodyFront.sphere.widthDirection[2],bodyFront.sphere.widthDirection[3]} else if noEvent(abs(bodyFront.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]})[3];
//   protected output Real bodyFront.sphere.Form;
//   output Real bodyFront.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyFront.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyFront.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyFront.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyFront.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyFront.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyFront.sphere.Material;
//   protected output Real bodyFront.sphere.Extra;
//   Real idealWheelFront.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelFront.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelFront.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelFront.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelFront.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelFront.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelFront.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelFront.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelFront.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real idealWheelFront.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelFront.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelFront.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelFront.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelFront.R[1,1] \"Rotation Matrix\";
//   Real idealWheelFront.R[1,2] \"Rotation Matrix\";
//   Real idealWheelFront.R[2,1] \"Rotation Matrix\";
//   Real idealWheelFront.R[2,2] \"Rotation Matrix\";
//   Real idealWheelFront.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelFront.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelFront.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelFront.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelFront.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelFront.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelFront.animate = true \"enable Animation\";
//   parameter Boolean idealWheelFront.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelFront.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelFront.r[1] ^ 2.0 + idealWheelFront.r[2] ^ 2.0);
//   final parameter Real idealWheelFront.e[1] = idealWheelFront.r[1] / idealWheelFront.l \"normalized direction\";
//   final parameter Real idealWheelFront.e[2] = idealWheelFront.r[2] / idealWheelFront.l \"normalized direction\";
//   parameter String idealWheelFront.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelFront.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * idealWheelFront.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * idealWheelFront.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelFront.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.lengthDirection[2](unit = \"1\") = idealWheelFront.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelFront.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Width of visual object\";
//   input Real idealWheelFront.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Height of visual object\";
//   input Real idealWheelFront.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelFront.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelFront.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelFront.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelFront.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelFront.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelFront.cylinder.lengthDirection[1],idealWheelFront.cylinder.lengthDirection[2],idealWheelFront.cylinder.lengthDirection[3]});
//   protected Real idealWheelFront.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelFront.cylinder.abs_n_x < 1e-10) then 1.0 else idealWheelFront.cylinder.lengthDirection[1] / idealWheelFront.cylinder.abs_n_x;
//   protected Real idealWheelFront.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelFront.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelFront.cylinder.lengthDirection[2] / idealWheelFront.cylinder.abs_n_x;
//   protected Real idealWheelFront.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelFront.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelFront.cylinder.lengthDirection[3] / idealWheelFront.cylinder.abs_n_x;
//   protected Real idealWheelFront.cylinder.n_z_aux[1](unit = \"1\") = idealWheelFront.cylinder.e_x[2] * idealWheelFront.cylinder.widthDirection[3] - idealWheelFront.cylinder.e_x[3] * idealWheelFront.cylinder.widthDirection[2];
//   protected Real idealWheelFront.cylinder.n_z_aux[2](unit = \"1\") = idealWheelFront.cylinder.e_x[3] * idealWheelFront.cylinder.widthDirection[1] - idealWheelFront.cylinder.e_x[1] * idealWheelFront.cylinder.widthDirection[3];
//   protected Real idealWheelFront.cylinder.n_z_aux[3](unit = \"1\") = idealWheelFront.cylinder.e_x[1] * idealWheelFront.cylinder.widthDirection[2] - idealWheelFront.cylinder.e_x[2] * idealWheelFront.cylinder.widthDirection[1];
//   protected Real idealWheelFront.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]},if noEvent(idealWheelFront.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelFront.cylinder.n_z_aux[2] ^ 2.0 + idealWheelFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.cylinder.widthDirection[1],idealWheelFront.cylinder.widthDirection[2],idealWheelFront.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]})[1];
//   protected Real idealWheelFront.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]},if noEvent(idealWheelFront.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelFront.cylinder.n_z_aux[2] ^ 2.0 + idealWheelFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.cylinder.widthDirection[1],idealWheelFront.cylinder.widthDirection[2],idealWheelFront.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]})[2];
//   protected Real idealWheelFront.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]},if noEvent(idealWheelFront.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelFront.cylinder.n_z_aux[2] ^ 2.0 + idealWheelFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.cylinder.widthDirection[1],idealWheelFront.cylinder.widthDirection[2],idealWheelFront.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]})[3];
//   protected output Real idealWheelFront.cylinder.Form;
//   output Real idealWheelFront.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelFront.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.cylinder.Material;
//   protected output Real idealWheelFront.cylinder.Extra;
//   parameter String idealWheelFront.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelFront.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelFront.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Length of visual object\";
//   input Real idealWheelFront.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelFront.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelFront.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelFront.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelFront.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelFront.rim1.lengthDirection[1],idealWheelFront.rim1.lengthDirection[2],idealWheelFront.rim1.lengthDirection[3]});
//   protected Real idealWheelFront.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelFront.rim1.abs_n_x < 1e-10) then 1.0 else idealWheelFront.rim1.lengthDirection[1] / idealWheelFront.rim1.abs_n_x;
//   protected Real idealWheelFront.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelFront.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelFront.rim1.lengthDirection[2] / idealWheelFront.rim1.abs_n_x;
//   protected Real idealWheelFront.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelFront.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelFront.rim1.lengthDirection[3] / idealWheelFront.rim1.abs_n_x;
//   protected Real idealWheelFront.rim1.n_z_aux[1](unit = \"1\") = idealWheelFront.rim1.e_x[2] * idealWheelFront.rim1.widthDirection[3] - idealWheelFront.rim1.e_x[3] * idealWheelFront.rim1.widthDirection[2];
//   protected Real idealWheelFront.rim1.n_z_aux[2](unit = \"1\") = idealWheelFront.rim1.e_x[3] * idealWheelFront.rim1.widthDirection[1] - idealWheelFront.rim1.e_x[1] * idealWheelFront.rim1.widthDirection[3];
//   protected Real idealWheelFront.rim1.n_z_aux[3](unit = \"1\") = idealWheelFront.rim1.e_x[1] * idealWheelFront.rim1.widthDirection[2] - idealWheelFront.rim1.e_x[2] * idealWheelFront.rim1.widthDirection[1];
//   protected Real idealWheelFront.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]},if noEvent(idealWheelFront.rim1.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim1.n_z_aux[2] ^ 2.0 + idealWheelFront.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.rim1.widthDirection[1],idealWheelFront.rim1.widthDirection[2],idealWheelFront.rim1.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]})[1];
//   protected Real idealWheelFront.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]},if noEvent(idealWheelFront.rim1.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim1.n_z_aux[2] ^ 2.0 + idealWheelFront.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.rim1.widthDirection[1],idealWheelFront.rim1.widthDirection[2],idealWheelFront.rim1.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]})[2];
//   protected Real idealWheelFront.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]},if noEvent(idealWheelFront.rim1.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim1.n_z_aux[2] ^ 2.0 + idealWheelFront.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.rim1.widthDirection[1],idealWheelFront.rim1.widthDirection[2],idealWheelFront.rim1.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]})[3];
//   protected output Real idealWheelFront.rim1.Form;
//   output Real idealWheelFront.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelFront.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim1.Material;
//   protected output Real idealWheelFront.rim1.Extra;
//   parameter String idealWheelFront.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelFront.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelFront.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Length of visual object\";
//   input Real idealWheelFront.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelFront.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelFront.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelFront.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelFront.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelFront.rim2.lengthDirection[1],idealWheelFront.rim2.lengthDirection[2],idealWheelFront.rim2.lengthDirection[3]});
//   protected Real idealWheelFront.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelFront.rim2.abs_n_x < 1e-10) then 1.0 else idealWheelFront.rim2.lengthDirection[1] / idealWheelFront.rim2.abs_n_x;
//   protected Real idealWheelFront.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelFront.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelFront.rim2.lengthDirection[2] / idealWheelFront.rim2.abs_n_x;
//   protected Real idealWheelFront.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelFront.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelFront.rim2.lengthDirection[3] / idealWheelFront.rim2.abs_n_x;
//   protected Real idealWheelFront.rim2.n_z_aux[1](unit = \"1\") = idealWheelFront.rim2.e_x[2] * idealWheelFront.rim2.widthDirection[3] - idealWheelFront.rim2.e_x[3] * idealWheelFront.rim2.widthDirection[2];
//   protected Real idealWheelFront.rim2.n_z_aux[2](unit = \"1\") = idealWheelFront.rim2.e_x[3] * idealWheelFront.rim2.widthDirection[1] - idealWheelFront.rim2.e_x[1] * idealWheelFront.rim2.widthDirection[3];
//   protected Real idealWheelFront.rim2.n_z_aux[3](unit = \"1\") = idealWheelFront.rim2.e_x[1] * idealWheelFront.rim2.widthDirection[2] - idealWheelFront.rim2.e_x[2] * idealWheelFront.rim2.widthDirection[1];
//   protected Real idealWheelFront.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]},if noEvent(idealWheelFront.rim2.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim2.n_z_aux[2] ^ 2.0 + idealWheelFront.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.rim2.widthDirection[1],idealWheelFront.rim2.widthDirection[2],idealWheelFront.rim2.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]})[1];
//   protected Real idealWheelFront.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]},if noEvent(idealWheelFront.rim2.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim2.n_z_aux[2] ^ 2.0 + idealWheelFront.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.rim2.widthDirection[1],idealWheelFront.rim2.widthDirection[2],idealWheelFront.rim2.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]})[2];
//   protected Real idealWheelFront.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]},if noEvent(idealWheelFront.rim2.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim2.n_z_aux[2] ^ 2.0 + idealWheelFront.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelFront.rim2.widthDirection[1],idealWheelFront.rim2.widthDirection[2],idealWheelFront.rim2.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]})[3];
//   protected output Real idealWheelFront.rim2.Form;
//   output Real idealWheelFront.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelFront.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim2.Material;
//   protected output Real idealWheelFront.rim2.Extra;
//   Real chassis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real chassis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real chassis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real chassis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real chassis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real chassis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real chassis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real chassis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real chassis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real chassis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real chassis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real chassis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real chassis.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real chassis.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real chassis.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real chassis.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real chassis.R[1,1] \"Rotation matrix\";
//   Real chassis.R[1,2] \"Rotation matrix\";
//   Real chassis.R[2,1] \"Rotation matrix\";
//   Real chassis.R[2,2] \"Rotation matrix\";
//   parameter Boolean chassis.animate = true \"enable Animation\";
//   final parameter Real chassis.l(quantity = \"Length\", unit = \"m\") = sqrt(chassis.r[1] ^ 2.0 + chassis.r[2] ^ 2.0);
//   parameter String chassis.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real chassis.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real chassis.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real chassis.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real chassis.cylinder.r[1](quantity = \"Length\", unit = \"m\") = chassis.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real chassis.cylinder.r[2](quantity = \"Length\", unit = \"m\") = chassis.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real chassis.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real chassis.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real chassis.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real chassis.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real chassis.cylinder.lengthDirection[1](unit = \"1\") = chassis.r0[1] / chassis.l \"Vector in length direction, resolved in object frame\";
//   input Real chassis.cylinder.lengthDirection[2](unit = \"1\") = chassis.r0[2] / chassis.l \"Vector in length direction, resolved in object frame\";
//   input Real chassis.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real chassis.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real chassis.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real chassis.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real chassis.cylinder.length(quantity = \"Length\", unit = \"m\") = chassis.l \"Length of visual object\";
//   input Real chassis.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real chassis.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real chassis.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real chassis.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real chassis.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real chassis.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real chassis.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real chassis.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({chassis.cylinder.lengthDirection[1],chassis.cylinder.lengthDirection[2],chassis.cylinder.lengthDirection[3]});
//   protected Real chassis.cylinder.e_x[1](unit = \"1\") = if noEvent(chassis.cylinder.abs_n_x < 1e-10) then 1.0 else chassis.cylinder.lengthDirection[1] / chassis.cylinder.abs_n_x;
//   protected Real chassis.cylinder.e_x[2](unit = \"1\") = if noEvent(chassis.cylinder.abs_n_x < 1e-10) then 0.0 else chassis.cylinder.lengthDirection[2] / chassis.cylinder.abs_n_x;
//   protected Real chassis.cylinder.e_x[3](unit = \"1\") = if noEvent(chassis.cylinder.abs_n_x < 1e-10) then 0.0 else chassis.cylinder.lengthDirection[3] / chassis.cylinder.abs_n_x;
//   protected Real chassis.cylinder.n_z_aux[1](unit = \"1\") = chassis.cylinder.e_x[2] * chassis.cylinder.widthDirection[3] - chassis.cylinder.e_x[3] * chassis.cylinder.widthDirection[2];
//   protected Real chassis.cylinder.n_z_aux[2](unit = \"1\") = chassis.cylinder.e_x[3] * chassis.cylinder.widthDirection[1] - chassis.cylinder.e_x[1] * chassis.cylinder.widthDirection[3];
//   protected Real chassis.cylinder.n_z_aux[3](unit = \"1\") = chassis.cylinder.e_x[1] * chassis.cylinder.widthDirection[2] - chassis.cylinder.e_x[2] * chassis.cylinder.widthDirection[1];
//   protected Real chassis.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]},if noEvent(chassis.cylinder.n_z_aux[1] ^ 2.0 + (chassis.cylinder.n_z_aux[2] ^ 2.0 + chassis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {chassis.cylinder.widthDirection[1],chassis.cylinder.widthDirection[2],chassis.cylinder.widthDirection[3]} else if noEvent(abs(chassis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]})[1];
//   protected Real chassis.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]},if noEvent(chassis.cylinder.n_z_aux[1] ^ 2.0 + (chassis.cylinder.n_z_aux[2] ^ 2.0 + chassis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {chassis.cylinder.widthDirection[1],chassis.cylinder.widthDirection[2],chassis.cylinder.widthDirection[3]} else if noEvent(abs(chassis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]})[2];
//   protected Real chassis.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]},if noEvent(chassis.cylinder.n_z_aux[1] ^ 2.0 + (chassis.cylinder.n_z_aux[2] ^ 2.0 + chassis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {chassis.cylinder.widthDirection[1],chassis.cylinder.widthDirection[2],chassis.cylinder.widthDirection[3]} else if noEvent(abs(chassis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]})[3];
//   protected output Real chassis.cylinder.Form;
//   output Real chassis.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real chassis.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real chassis.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real chassis.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real chassis.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real chassis.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real chassis.cylinder.Material;
//   protected output Real chassis.cylinder.Extra;
//   Real bodyRear.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyRear.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyRear.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyRear.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyRear.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyRear.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyRear.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real bodyRear.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyRear.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyRear.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real bodyRear.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyRear.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyRear.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyRear.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyRear.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyRear.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyRear.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyRear.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyRear.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyRear.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyRear.animate = true \"enable Animation\";
//   parameter String bodyRear.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyRear.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyRear.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyRear.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyRear.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyRear.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyRear.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyRear.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyRear.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyRear.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyRear.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyRear.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyRear.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyRear.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyRear.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyRear.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyRear.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyRear.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyRear.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyRear.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyRear.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyRear.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyRear.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyRear.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyRear.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyRear.sphere.lengthDirection[1],bodyRear.sphere.lengthDirection[2],bodyRear.sphere.lengthDirection[3]});
//   protected Real bodyRear.sphere.e_x[1](unit = \"1\") = if noEvent(bodyRear.sphere.abs_n_x < 1e-10) then 1.0 else bodyRear.sphere.lengthDirection[1] / bodyRear.sphere.abs_n_x;
//   protected Real bodyRear.sphere.e_x[2](unit = \"1\") = if noEvent(bodyRear.sphere.abs_n_x < 1e-10) then 0.0 else bodyRear.sphere.lengthDirection[2] / bodyRear.sphere.abs_n_x;
//   protected Real bodyRear.sphere.e_x[3](unit = \"1\") = if noEvent(bodyRear.sphere.abs_n_x < 1e-10) then 0.0 else bodyRear.sphere.lengthDirection[3] / bodyRear.sphere.abs_n_x;
//   protected Real bodyRear.sphere.n_z_aux[1](unit = \"1\") = bodyRear.sphere.e_x[2] * bodyRear.sphere.widthDirection[3] - bodyRear.sphere.e_x[3] * bodyRear.sphere.widthDirection[2];
//   protected Real bodyRear.sphere.n_z_aux[2](unit = \"1\") = bodyRear.sphere.e_x[3] * bodyRear.sphere.widthDirection[1] - bodyRear.sphere.e_x[1] * bodyRear.sphere.widthDirection[3];
//   protected Real bodyRear.sphere.n_z_aux[3](unit = \"1\") = bodyRear.sphere.e_x[1] * bodyRear.sphere.widthDirection[2] - bodyRear.sphere.e_x[2] * bodyRear.sphere.widthDirection[1];
//   protected Real bodyRear.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]},if noEvent(bodyRear.sphere.n_z_aux[1] ^ 2.0 + (bodyRear.sphere.n_z_aux[2] ^ 2.0 + bodyRear.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyRear.sphere.widthDirection[1],bodyRear.sphere.widthDirection[2],bodyRear.sphere.widthDirection[3]} else if noEvent(abs(bodyRear.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]})[1];
//   protected Real bodyRear.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]},if noEvent(bodyRear.sphere.n_z_aux[1] ^ 2.0 + (bodyRear.sphere.n_z_aux[2] ^ 2.0 + bodyRear.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyRear.sphere.widthDirection[1],bodyRear.sphere.widthDirection[2],bodyRear.sphere.widthDirection[3]} else if noEvent(abs(bodyRear.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]})[2];
//   protected Real bodyRear.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]},if noEvent(bodyRear.sphere.n_z_aux[1] ^ 2.0 + (bodyRear.sphere.n_z_aux[2] ^ 2.0 + bodyRear.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyRear.sphere.widthDirection[1],bodyRear.sphere.widthDirection[2],bodyRear.sphere.widthDirection[3]} else if noEvent(abs(bodyRear.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]})[3];
//   protected output Real bodyRear.sphere.Form;
//   output Real bodyRear.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyRear.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyRear.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyRear.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyRear.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyRear.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyRear.sphere.Material;
//   protected output Real bodyRear.sphere.Extra;
//   Real idealWheelRear.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelRear.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelRear.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelRear.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelRear.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelRear.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelRear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelRear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelRear.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real idealWheelRear.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelRear.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelRear.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelRear.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelRear.R[1,1] \"Rotation Matrix\";
//   Real idealWheelRear.R[1,2] \"Rotation Matrix\";
//   Real idealWheelRear.R[2,1] \"Rotation Matrix\";
//   Real idealWheelRear.R[2,2] \"Rotation Matrix\";
//   Real idealWheelRear.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelRear.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelRear.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelRear.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelRear.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelRear.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelRear.animate = true \"enable Animation\";
//   parameter Boolean idealWheelRear.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelRear.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelRear.r[1] ^ 2.0 + idealWheelRear.r[2] ^ 2.0);
//   final parameter Real idealWheelRear.e[1] = idealWheelRear.r[1] / idealWheelRear.l \"normalized direction\";
//   final parameter Real idealWheelRear.e[2] = idealWheelRear.r[2] / idealWheelRear.l \"normalized direction\";
//   parameter String idealWheelRear.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelRear.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * idealWheelRear.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * idealWheelRear.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelRear.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.lengthDirection[2](unit = \"1\") = idealWheelRear.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelRear.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Width of visual object\";
//   input Real idealWheelRear.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Height of visual object\";
//   input Real idealWheelRear.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelRear.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelRear.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelRear.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelRear.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelRear.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelRear.cylinder.lengthDirection[1],idealWheelRear.cylinder.lengthDirection[2],idealWheelRear.cylinder.lengthDirection[3]});
//   protected Real idealWheelRear.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelRear.cylinder.abs_n_x < 1e-10) then 1.0 else idealWheelRear.cylinder.lengthDirection[1] / idealWheelRear.cylinder.abs_n_x;
//   protected Real idealWheelRear.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelRear.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelRear.cylinder.lengthDirection[2] / idealWheelRear.cylinder.abs_n_x;
//   protected Real idealWheelRear.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelRear.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelRear.cylinder.lengthDirection[3] / idealWheelRear.cylinder.abs_n_x;
//   protected Real idealWheelRear.cylinder.n_z_aux[1](unit = \"1\") = idealWheelRear.cylinder.e_x[2] * idealWheelRear.cylinder.widthDirection[3] - idealWheelRear.cylinder.e_x[3] * idealWheelRear.cylinder.widthDirection[2];
//   protected Real idealWheelRear.cylinder.n_z_aux[2](unit = \"1\") = idealWheelRear.cylinder.e_x[3] * idealWheelRear.cylinder.widthDirection[1] - idealWheelRear.cylinder.e_x[1] * idealWheelRear.cylinder.widthDirection[3];
//   protected Real idealWheelRear.cylinder.n_z_aux[3](unit = \"1\") = idealWheelRear.cylinder.e_x[1] * idealWheelRear.cylinder.widthDirection[2] - idealWheelRear.cylinder.e_x[2] * idealWheelRear.cylinder.widthDirection[1];
//   protected Real idealWheelRear.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]},if noEvent(idealWheelRear.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelRear.cylinder.n_z_aux[2] ^ 2.0 + idealWheelRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.cylinder.widthDirection[1],idealWheelRear.cylinder.widthDirection[2],idealWheelRear.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]})[1];
//   protected Real idealWheelRear.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]},if noEvent(idealWheelRear.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelRear.cylinder.n_z_aux[2] ^ 2.0 + idealWheelRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.cylinder.widthDirection[1],idealWheelRear.cylinder.widthDirection[2],idealWheelRear.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]})[2];
//   protected Real idealWheelRear.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]},if noEvent(idealWheelRear.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelRear.cylinder.n_z_aux[2] ^ 2.0 + idealWheelRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.cylinder.widthDirection[1],idealWheelRear.cylinder.widthDirection[2],idealWheelRear.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]})[3];
//   protected output Real idealWheelRear.cylinder.Form;
//   output Real idealWheelRear.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelRear.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.cylinder.Material;
//   protected output Real idealWheelRear.cylinder.Extra;
//   parameter String idealWheelRear.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelRear.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelRear.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Length of visual object\";
//   input Real idealWheelRear.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelRear.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelRear.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelRear.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelRear.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelRear.rim1.lengthDirection[1],idealWheelRear.rim1.lengthDirection[2],idealWheelRear.rim1.lengthDirection[3]});
//   protected Real idealWheelRear.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelRear.rim1.abs_n_x < 1e-10) then 1.0 else idealWheelRear.rim1.lengthDirection[1] / idealWheelRear.rim1.abs_n_x;
//   protected Real idealWheelRear.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelRear.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelRear.rim1.lengthDirection[2] / idealWheelRear.rim1.abs_n_x;
//   protected Real idealWheelRear.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelRear.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelRear.rim1.lengthDirection[3] / idealWheelRear.rim1.abs_n_x;
//   protected Real idealWheelRear.rim1.n_z_aux[1](unit = \"1\") = idealWheelRear.rim1.e_x[2] * idealWheelRear.rim1.widthDirection[3] - idealWheelRear.rim1.e_x[3] * idealWheelRear.rim1.widthDirection[2];
//   protected Real idealWheelRear.rim1.n_z_aux[2](unit = \"1\") = idealWheelRear.rim1.e_x[3] * idealWheelRear.rim1.widthDirection[1] - idealWheelRear.rim1.e_x[1] * idealWheelRear.rim1.widthDirection[3];
//   protected Real idealWheelRear.rim1.n_z_aux[3](unit = \"1\") = idealWheelRear.rim1.e_x[1] * idealWheelRear.rim1.widthDirection[2] - idealWheelRear.rim1.e_x[2] * idealWheelRear.rim1.widthDirection[1];
//   protected Real idealWheelRear.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]},if noEvent(idealWheelRear.rim1.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim1.n_z_aux[2] ^ 2.0 + idealWheelRear.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.rim1.widthDirection[1],idealWheelRear.rim1.widthDirection[2],idealWheelRear.rim1.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]})[1];
//   protected Real idealWheelRear.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]},if noEvent(idealWheelRear.rim1.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim1.n_z_aux[2] ^ 2.0 + idealWheelRear.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.rim1.widthDirection[1],idealWheelRear.rim1.widthDirection[2],idealWheelRear.rim1.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]})[2];
//   protected Real idealWheelRear.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]},if noEvent(idealWheelRear.rim1.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim1.n_z_aux[2] ^ 2.0 + idealWheelRear.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.rim1.widthDirection[1],idealWheelRear.rim1.widthDirection[2],idealWheelRear.rim1.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]})[3];
//   protected output Real idealWheelRear.rim1.Form;
//   output Real idealWheelRear.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelRear.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim1.Material;
//   protected output Real idealWheelRear.rim1.Extra;
//   parameter String idealWheelRear.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelRear.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelRear.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Length of visual object\";
//   input Real idealWheelRear.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelRear.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelRear.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelRear.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelRear.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelRear.rim2.lengthDirection[1],idealWheelRear.rim2.lengthDirection[2],idealWheelRear.rim2.lengthDirection[3]});
//   protected Real idealWheelRear.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelRear.rim2.abs_n_x < 1e-10) then 1.0 else idealWheelRear.rim2.lengthDirection[1] / idealWheelRear.rim2.abs_n_x;
//   protected Real idealWheelRear.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelRear.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelRear.rim2.lengthDirection[2] / idealWheelRear.rim2.abs_n_x;
//   protected Real idealWheelRear.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelRear.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelRear.rim2.lengthDirection[3] / idealWheelRear.rim2.abs_n_x;
//   protected Real idealWheelRear.rim2.n_z_aux[1](unit = \"1\") = idealWheelRear.rim2.e_x[2] * idealWheelRear.rim2.widthDirection[3] - idealWheelRear.rim2.e_x[3] * idealWheelRear.rim2.widthDirection[2];
//   protected Real idealWheelRear.rim2.n_z_aux[2](unit = \"1\") = idealWheelRear.rim2.e_x[3] * idealWheelRear.rim2.widthDirection[1] - idealWheelRear.rim2.e_x[1] * idealWheelRear.rim2.widthDirection[3];
//   protected Real idealWheelRear.rim2.n_z_aux[3](unit = \"1\") = idealWheelRear.rim2.e_x[1] * idealWheelRear.rim2.widthDirection[2] - idealWheelRear.rim2.e_x[2] * idealWheelRear.rim2.widthDirection[1];
//   protected Real idealWheelRear.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]},if noEvent(idealWheelRear.rim2.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim2.n_z_aux[2] ^ 2.0 + idealWheelRear.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.rim2.widthDirection[1],idealWheelRear.rim2.widthDirection[2],idealWheelRear.rim2.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]})[1];
//   protected Real idealWheelRear.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]},if noEvent(idealWheelRear.rim2.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim2.n_z_aux[2] ^ 2.0 + idealWheelRear.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.rim2.widthDirection[1],idealWheelRear.rim2.widthDirection[2],idealWheelRear.rim2.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]})[2];
//   protected Real idealWheelRear.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]},if noEvent(idealWheelRear.rim2.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim2.n_z_aux[2] ^ 2.0 + idealWheelRear.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelRear.rim2.widthDirection[1],idealWheelRear.rim2.widthDirection[2],idealWheelRear.rim2.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]})[3];
//   protected output Real idealWheelRear.rim2.Form;
//   output Real idealWheelRear.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelRear.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim2.Material;
//   protected output Real idealWheelRear.rim2.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -0.69813170079773;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 1e-10) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real trail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real trail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real trail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real trail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real trail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real trail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real trail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real trail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real trail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real trail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real trail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real trail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real trail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real trail.r[2](quantity = \"Length\", unit = \"m\") = -0.1 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real trail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real trail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real trail.R[1,1] \"Rotation matrix\";
//   Real trail.R[1,2] \"Rotation matrix\";
//   Real trail.R[2,1] \"Rotation matrix\";
//   Real trail.R[2,2] \"Rotation matrix\";
//   parameter Boolean trail.animate = true \"enable Animation\";
//   final parameter Real trail.l(quantity = \"Length\", unit = \"m\") = sqrt(trail.r[1] ^ 2.0 + trail.r[2] ^ 2.0);
//   parameter String trail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real trail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real trail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real trail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real trail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = trail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real trail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = trail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real trail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real trail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real trail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real trail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real trail.cylinder.lengthDirection[1](unit = \"1\") = trail.r0[1] / trail.l \"Vector in length direction, resolved in object frame\";
//   input Real trail.cylinder.lengthDirection[2](unit = \"1\") = trail.r0[2] / trail.l \"Vector in length direction, resolved in object frame\";
//   input Real trail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real trail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real trail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real trail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real trail.cylinder.length(quantity = \"Length\", unit = \"m\") = trail.l \"Length of visual object\";
//   input Real trail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real trail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real trail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real trail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real trail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real trail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real trail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real trail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({trail.cylinder.lengthDirection[1],trail.cylinder.lengthDirection[2],trail.cylinder.lengthDirection[3]});
//   protected Real trail.cylinder.e_x[1](unit = \"1\") = if noEvent(trail.cylinder.abs_n_x < 1e-10) then 1.0 else trail.cylinder.lengthDirection[1] / trail.cylinder.abs_n_x;
//   protected Real trail.cylinder.e_x[2](unit = \"1\") = if noEvent(trail.cylinder.abs_n_x < 1e-10) then 0.0 else trail.cylinder.lengthDirection[2] / trail.cylinder.abs_n_x;
//   protected Real trail.cylinder.e_x[3](unit = \"1\") = if noEvent(trail.cylinder.abs_n_x < 1e-10) then 0.0 else trail.cylinder.lengthDirection[3] / trail.cylinder.abs_n_x;
//   protected Real trail.cylinder.n_z_aux[1](unit = \"1\") = trail.cylinder.e_x[2] * trail.cylinder.widthDirection[3] - trail.cylinder.e_x[3] * trail.cylinder.widthDirection[2];
//   protected Real trail.cylinder.n_z_aux[2](unit = \"1\") = trail.cylinder.e_x[3] * trail.cylinder.widthDirection[1] - trail.cylinder.e_x[1] * trail.cylinder.widthDirection[3];
//   protected Real trail.cylinder.n_z_aux[3](unit = \"1\") = trail.cylinder.e_x[1] * trail.cylinder.widthDirection[2] - trail.cylinder.e_x[2] * trail.cylinder.widthDirection[1];
//   protected Real trail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]},if noEvent(trail.cylinder.n_z_aux[1] ^ 2.0 + (trail.cylinder.n_z_aux[2] ^ 2.0 + trail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {trail.cylinder.widthDirection[1],trail.cylinder.widthDirection[2],trail.cylinder.widthDirection[3]} else if noEvent(abs(trail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]})[1];
//   protected Real trail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]},if noEvent(trail.cylinder.n_z_aux[1] ^ 2.0 + (trail.cylinder.n_z_aux[2] ^ 2.0 + trail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {trail.cylinder.widthDirection[1],trail.cylinder.widthDirection[2],trail.cylinder.widthDirection[3]} else if noEvent(abs(trail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]})[2];
//   protected Real trail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]},if noEvent(trail.cylinder.n_z_aux[1] ^ 2.0 + (trail.cylinder.n_z_aux[2] ^ 2.0 + trail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {trail.cylinder.widthDirection[1],trail.cylinder.widthDirection[2],trail.cylinder.widthDirection[3]} else if noEvent(abs(trail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]})[3];
//   protected output Real trail.cylinder.Form;
//   output Real trail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real trail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real trail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real trail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real trail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real trail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real trail.cylinder.Material;
//   protected output Real trail.cylinder.Extra;
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
// equation
//   bodyFront.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyFront.sphere.shapeType);
//   bodyFront.sphere.rxvisobj[1] = bodyFront.sphere.R.T[1,1] * bodyFront.sphere.e_x[1] + bodyFront.sphere.R.T[2,1] * bodyFront.sphere.e_x[2] + bodyFront.sphere.R.T[3,1] * bodyFront.sphere.e_x[3];
//   bodyFront.sphere.rxvisobj[2] = bodyFront.sphere.R.T[1,2] * bodyFront.sphere.e_x[1] + bodyFront.sphere.R.T[2,2] * bodyFront.sphere.e_x[2] + bodyFront.sphere.R.T[3,2] * bodyFront.sphere.e_x[3];
//   bodyFront.sphere.rxvisobj[3] = bodyFront.sphere.R.T[1,3] * bodyFront.sphere.e_x[1] + bodyFront.sphere.R.T[2,3] * bodyFront.sphere.e_x[2] + bodyFront.sphere.R.T[3,3] * bodyFront.sphere.e_x[3];
//   bodyFront.sphere.ryvisobj[1] = bodyFront.sphere.R.T[1,1] * bodyFront.sphere.e_y[1] + bodyFront.sphere.R.T[2,1] * bodyFront.sphere.e_y[2] + bodyFront.sphere.R.T[3,1] * bodyFront.sphere.e_y[3];
//   bodyFront.sphere.ryvisobj[2] = bodyFront.sphere.R.T[1,2] * bodyFront.sphere.e_y[1] + bodyFront.sphere.R.T[2,2] * bodyFront.sphere.e_y[2] + bodyFront.sphere.R.T[3,2] * bodyFront.sphere.e_y[3];
//   bodyFront.sphere.ryvisobj[3] = bodyFront.sphere.R.T[1,3] * bodyFront.sphere.e_y[1] + bodyFront.sphere.R.T[2,3] * bodyFront.sphere.e_y[2] + bodyFront.sphere.R.T[3,3] * bodyFront.sphere.e_y[3];
//   bodyFront.sphere.rvisobj = bodyFront.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyFront.sphere.R.T[1,1],bodyFront.sphere.R.T[1,2],bodyFront.sphere.R.T[1,3]},{bodyFront.sphere.R.T[2,1],bodyFront.sphere.R.T[2,2],bodyFront.sphere.R.T[2,3]},{bodyFront.sphere.R.T[3,1],bodyFront.sphere.R.T[3,2],bodyFront.sphere.R.T[3,3]}},{bodyFront.sphere.r_shape[1],bodyFront.sphere.r_shape[2],bodyFront.sphere.r_shape[3]});
//   bodyFront.sphere.size[1] = bodyFront.sphere.length;
//   bodyFront.sphere.size[2] = bodyFront.sphere.width;
//   bodyFront.sphere.size[3] = bodyFront.sphere.height;
//   bodyFront.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyFront.sphere.color[1] / 255.0,bodyFront.sphere.color[2] / 255.0,bodyFront.sphere.color[3] / 255.0,bodyFront.sphere.specularCoefficient);
//   bodyFront.sphere.Extra = bodyFront.sphere.extra;
//   bodyFront.r[1] = bodyFront.frame_a.x;
//   bodyFront.r[2] = bodyFront.frame_a.y;
//   bodyFront.v[1] = der(bodyFront.r[1]);
//   bodyFront.v[2] = der(bodyFront.r[2]);
//   bodyFront.w = der(bodyFront.frame_a.phi);
//   bodyFront.a[1] = der(bodyFront.v[1]);
//   bodyFront.a[2] = der(bodyFront.v[2]);
//   bodyFront.z = der(bodyFront.w);
//   bodyFront.f[1] = bodyFront.frame_a.fx;
//   bodyFront.f[2] = bodyFront.frame_a.fy;
//   bodyFront.f[1] + bodyFront.m * bodyFront.g[1] = bodyFront.m * bodyFront.a[1];
//   bodyFront.f[2] + bodyFront.m * bodyFront.g[2] = bodyFront.m * bodyFront.a[2];
//   bodyFront.frame_a.t = bodyFront.I * bodyFront.z;
//   idealWheelFront.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelFront.cylinder.shapeType);
//   idealWheelFront.cylinder.rxvisobj[1] = idealWheelFront.cylinder.R.T[1,1] * idealWheelFront.cylinder.e_x[1] + idealWheelFront.cylinder.R.T[2,1] * idealWheelFront.cylinder.e_x[2] + idealWheelFront.cylinder.R.T[3,1] * idealWheelFront.cylinder.e_x[3];
//   idealWheelFront.cylinder.rxvisobj[2] = idealWheelFront.cylinder.R.T[1,2] * idealWheelFront.cylinder.e_x[1] + idealWheelFront.cylinder.R.T[2,2] * idealWheelFront.cylinder.e_x[2] + idealWheelFront.cylinder.R.T[3,2] * idealWheelFront.cylinder.e_x[3];
//   idealWheelFront.cylinder.rxvisobj[3] = idealWheelFront.cylinder.R.T[1,3] * idealWheelFront.cylinder.e_x[1] + idealWheelFront.cylinder.R.T[2,3] * idealWheelFront.cylinder.e_x[2] + idealWheelFront.cylinder.R.T[3,3] * idealWheelFront.cylinder.e_x[3];
//   idealWheelFront.cylinder.ryvisobj[1] = idealWheelFront.cylinder.R.T[1,1] * idealWheelFront.cylinder.e_y[1] + idealWheelFront.cylinder.R.T[2,1] * idealWheelFront.cylinder.e_y[2] + idealWheelFront.cylinder.R.T[3,1] * idealWheelFront.cylinder.e_y[3];
//   idealWheelFront.cylinder.ryvisobj[2] = idealWheelFront.cylinder.R.T[1,2] * idealWheelFront.cylinder.e_y[1] + idealWheelFront.cylinder.R.T[2,2] * idealWheelFront.cylinder.e_y[2] + idealWheelFront.cylinder.R.T[3,2] * idealWheelFront.cylinder.e_y[3];
//   idealWheelFront.cylinder.ryvisobj[3] = idealWheelFront.cylinder.R.T[1,3] * idealWheelFront.cylinder.e_y[1] + idealWheelFront.cylinder.R.T[2,3] * idealWheelFront.cylinder.e_y[2] + idealWheelFront.cylinder.R.T[3,3] * idealWheelFront.cylinder.e_y[3];
//   idealWheelFront.cylinder.rvisobj = idealWheelFront.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelFront.cylinder.R.T[1,1],idealWheelFront.cylinder.R.T[1,2],idealWheelFront.cylinder.R.T[1,3]},{idealWheelFront.cylinder.R.T[2,1],idealWheelFront.cylinder.R.T[2,2],idealWheelFront.cylinder.R.T[2,3]},{idealWheelFront.cylinder.R.T[3,1],idealWheelFront.cylinder.R.T[3,2],idealWheelFront.cylinder.R.T[3,3]}},{idealWheelFront.cylinder.r_shape[1],idealWheelFront.cylinder.r_shape[2],idealWheelFront.cylinder.r_shape[3]});
//   idealWheelFront.cylinder.size[1] = idealWheelFront.cylinder.length;
//   idealWheelFront.cylinder.size[2] = idealWheelFront.cylinder.width;
//   idealWheelFront.cylinder.size[3] = idealWheelFront.cylinder.height;
//   idealWheelFront.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelFront.cylinder.color[1] / 255.0,idealWheelFront.cylinder.color[2] / 255.0,idealWheelFront.cylinder.color[3] / 255.0,idealWheelFront.cylinder.specularCoefficient);
//   idealWheelFront.cylinder.Extra = idealWheelFront.cylinder.extra;
//   idealWheelFront.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelFront.e0[2],idealWheelFront.e0[1],0.0},idealWheelFront.flange_a.phi,0.0);
//   idealWheelFront.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelFront.rim1.shapeType);
//   idealWheelFront.rim1.rxvisobj[1] = idealWheelFront.rim1.R.T[1,1] * idealWheelFront.rim1.e_x[1] + idealWheelFront.rim1.R.T[2,1] * idealWheelFront.rim1.e_x[2] + idealWheelFront.rim1.R.T[3,1] * idealWheelFront.rim1.e_x[3];
//   idealWheelFront.rim1.rxvisobj[2] = idealWheelFront.rim1.R.T[1,2] * idealWheelFront.rim1.e_x[1] + idealWheelFront.rim1.R.T[2,2] * idealWheelFront.rim1.e_x[2] + idealWheelFront.rim1.R.T[3,2] * idealWheelFront.rim1.e_x[3];
//   idealWheelFront.rim1.rxvisobj[3] = idealWheelFront.rim1.R.T[1,3] * idealWheelFront.rim1.e_x[1] + idealWheelFront.rim1.R.T[2,3] * idealWheelFront.rim1.e_x[2] + idealWheelFront.rim1.R.T[3,3] * idealWheelFront.rim1.e_x[3];
//   idealWheelFront.rim1.ryvisobj[1] = idealWheelFront.rim1.R.T[1,1] * idealWheelFront.rim1.e_y[1] + idealWheelFront.rim1.R.T[2,1] * idealWheelFront.rim1.e_y[2] + idealWheelFront.rim1.R.T[3,1] * idealWheelFront.rim1.e_y[3];
//   idealWheelFront.rim1.ryvisobj[2] = idealWheelFront.rim1.R.T[1,2] * idealWheelFront.rim1.e_y[1] + idealWheelFront.rim1.R.T[2,2] * idealWheelFront.rim1.e_y[2] + idealWheelFront.rim1.R.T[3,2] * idealWheelFront.rim1.e_y[3];
//   idealWheelFront.rim1.ryvisobj[3] = idealWheelFront.rim1.R.T[1,3] * idealWheelFront.rim1.e_y[1] + idealWheelFront.rim1.R.T[2,3] * idealWheelFront.rim1.e_y[2] + idealWheelFront.rim1.R.T[3,3] * idealWheelFront.rim1.e_y[3];
//   idealWheelFront.rim1.rvisobj = idealWheelFront.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelFront.rim1.R.T[1,1],idealWheelFront.rim1.R.T[1,2],idealWheelFront.rim1.R.T[1,3]},{idealWheelFront.rim1.R.T[2,1],idealWheelFront.rim1.R.T[2,2],idealWheelFront.rim1.R.T[2,3]},{idealWheelFront.rim1.R.T[3,1],idealWheelFront.rim1.R.T[3,2],idealWheelFront.rim1.R.T[3,3]}},{idealWheelFront.rim1.r_shape[1],idealWheelFront.rim1.r_shape[2],idealWheelFront.rim1.r_shape[3]});
//   idealWheelFront.rim1.size[1] = idealWheelFront.rim1.length;
//   idealWheelFront.rim1.size[2] = idealWheelFront.rim1.width;
//   idealWheelFront.rim1.size[3] = idealWheelFront.rim1.height;
//   idealWheelFront.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelFront.rim1.color[1] / 255.0,idealWheelFront.rim1.color[2] / 255.0,idealWheelFront.rim1.color[3] / 255.0,idealWheelFront.rim1.specularCoefficient);
//   idealWheelFront.rim1.Extra = idealWheelFront.rim1.extra;
//   idealWheelFront.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelFront.e0[2],idealWheelFront.e0[1],0.0},1.5707963267949 + idealWheelFront.flange_a.phi,0.0);
//   idealWheelFront.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelFront.rim2.shapeType);
//   idealWheelFront.rim2.rxvisobj[1] = idealWheelFront.rim2.R.T[1,1] * idealWheelFront.rim2.e_x[1] + idealWheelFront.rim2.R.T[2,1] * idealWheelFront.rim2.e_x[2] + idealWheelFront.rim2.R.T[3,1] * idealWheelFront.rim2.e_x[3];
//   idealWheelFront.rim2.rxvisobj[2] = idealWheelFront.rim2.R.T[1,2] * idealWheelFront.rim2.e_x[1] + idealWheelFront.rim2.R.T[2,2] * idealWheelFront.rim2.e_x[2] + idealWheelFront.rim2.R.T[3,2] * idealWheelFront.rim2.e_x[3];
//   idealWheelFront.rim2.rxvisobj[3] = idealWheelFront.rim2.R.T[1,3] * idealWheelFront.rim2.e_x[1] + idealWheelFront.rim2.R.T[2,3] * idealWheelFront.rim2.e_x[2] + idealWheelFront.rim2.R.T[3,3] * idealWheelFront.rim2.e_x[3];
//   idealWheelFront.rim2.ryvisobj[1] = idealWheelFront.rim2.R.T[1,1] * idealWheelFront.rim2.e_y[1] + idealWheelFront.rim2.R.T[2,1] * idealWheelFront.rim2.e_y[2] + idealWheelFront.rim2.R.T[3,1] * idealWheelFront.rim2.e_y[3];
//   idealWheelFront.rim2.ryvisobj[2] = idealWheelFront.rim2.R.T[1,2] * idealWheelFront.rim2.e_y[1] + idealWheelFront.rim2.R.T[2,2] * idealWheelFront.rim2.e_y[2] + idealWheelFront.rim2.R.T[3,2] * idealWheelFront.rim2.e_y[3];
//   idealWheelFront.rim2.ryvisobj[3] = idealWheelFront.rim2.R.T[1,3] * idealWheelFront.rim2.e_y[1] + idealWheelFront.rim2.R.T[2,3] * idealWheelFront.rim2.e_y[2] + idealWheelFront.rim2.R.T[3,3] * idealWheelFront.rim2.e_y[3];
//   idealWheelFront.rim2.rvisobj = idealWheelFront.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelFront.rim2.R.T[1,1],idealWheelFront.rim2.R.T[1,2],idealWheelFront.rim2.R.T[1,3]},{idealWheelFront.rim2.R.T[2,1],idealWheelFront.rim2.R.T[2,2],idealWheelFront.rim2.R.T[2,3]},{idealWheelFront.rim2.R.T[3,1],idealWheelFront.rim2.R.T[3,2],idealWheelFront.rim2.R.T[3,3]}},{idealWheelFront.rim2.r_shape[1],idealWheelFront.rim2.r_shape[2],idealWheelFront.rim2.r_shape[3]});
//   idealWheelFront.rim2.size[1] = idealWheelFront.rim2.length;
//   idealWheelFront.rim2.size[2] = idealWheelFront.rim2.width;
//   idealWheelFront.rim2.size[3] = idealWheelFront.rim2.height;
//   idealWheelFront.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelFront.rim2.color[1] / 255.0,idealWheelFront.rim2.color[2] / 255.0,idealWheelFront.rim2.color[3] / 255.0,idealWheelFront.rim2.specularCoefficient);
//   idealWheelFront.rim2.Extra = idealWheelFront.rim2.extra;
//   idealWheelFront.R[1,1] = cos(idealWheelFront.frame_a.phi);
//   idealWheelFront.R[1,2] = sin(idealWheelFront.frame_a.phi);
//   idealWheelFront.R[2,1] = -sin(idealWheelFront.frame_a.phi);
//   idealWheelFront.R[2,2] = cos(idealWheelFront.frame_a.phi);
//   idealWheelFront.e0[1] = idealWheelFront.R[1,1] * idealWheelFront.e[1] + idealWheelFront.R[1,2] * idealWheelFront.e[2];
//   idealWheelFront.e0[2] = idealWheelFront.R[2,1] * idealWheelFront.e[1] + idealWheelFront.R[2,2] * idealWheelFront.e[2];
//   idealWheelFront.v[1] = der(idealWheelFront.frame_a.x);
//   idealWheelFront.v[2] = der(idealWheelFront.frame_a.y);
//   idealWheelFront.v[1] = idealWheelFront.v_long * idealWheelFront.e0[1];
//   idealWheelFront.v[2] = idealWheelFront.v_long * idealWheelFront.e0[2];
//   idealWheelFront.w_roll = der(idealWheelFront.flange_a.phi);
//   idealWheelFront.v_long = idealWheelFront.radius * idealWheelFront.w_roll;
//   idealWheelFront.a = der(idealWheelFront.v_long);
//   (-idealWheelFront.f_long) * idealWheelFront.radius = idealWheelFront.flange_a.tau;
//   idealWheelFront.frame_a.t = 0.0;
//   idealWheelFront.frame_a.fx * idealWheelFront.e0[1] + idealWheelFront.frame_a.fy * idealWheelFront.e0[2] = idealWheelFront.f_long;
//   chassis.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(chassis.cylinder.shapeType);
//   chassis.cylinder.rxvisobj[1] = chassis.cylinder.R.T[1,1] * chassis.cylinder.e_x[1] + chassis.cylinder.R.T[2,1] * chassis.cylinder.e_x[2] + chassis.cylinder.R.T[3,1] * chassis.cylinder.e_x[3];
//   chassis.cylinder.rxvisobj[2] = chassis.cylinder.R.T[1,2] * chassis.cylinder.e_x[1] + chassis.cylinder.R.T[2,2] * chassis.cylinder.e_x[2] + chassis.cylinder.R.T[3,2] * chassis.cylinder.e_x[3];
//   chassis.cylinder.rxvisobj[3] = chassis.cylinder.R.T[1,3] * chassis.cylinder.e_x[1] + chassis.cylinder.R.T[2,3] * chassis.cylinder.e_x[2] + chassis.cylinder.R.T[3,3] * chassis.cylinder.e_x[3];
//   chassis.cylinder.ryvisobj[1] = chassis.cylinder.R.T[1,1] * chassis.cylinder.e_y[1] + chassis.cylinder.R.T[2,1] * chassis.cylinder.e_y[2] + chassis.cylinder.R.T[3,1] * chassis.cylinder.e_y[3];
//   chassis.cylinder.ryvisobj[2] = chassis.cylinder.R.T[1,2] * chassis.cylinder.e_y[1] + chassis.cylinder.R.T[2,2] * chassis.cylinder.e_y[2] + chassis.cylinder.R.T[3,2] * chassis.cylinder.e_y[3];
//   chassis.cylinder.ryvisobj[3] = chassis.cylinder.R.T[1,3] * chassis.cylinder.e_y[1] + chassis.cylinder.R.T[2,3] * chassis.cylinder.e_y[2] + chassis.cylinder.R.T[3,3] * chassis.cylinder.e_y[3];
//   chassis.cylinder.rvisobj = chassis.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{chassis.cylinder.R.T[1,1],chassis.cylinder.R.T[1,2],chassis.cylinder.R.T[1,3]},{chassis.cylinder.R.T[2,1],chassis.cylinder.R.T[2,2],chassis.cylinder.R.T[2,3]},{chassis.cylinder.R.T[3,1],chassis.cylinder.R.T[3,2],chassis.cylinder.R.T[3,3]}},{chassis.cylinder.r_shape[1],chassis.cylinder.r_shape[2],chassis.cylinder.r_shape[3]});
//   chassis.cylinder.size[1] = chassis.cylinder.length;
//   chassis.cylinder.size[2] = chassis.cylinder.width;
//   chassis.cylinder.size[3] = chassis.cylinder.height;
//   chassis.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(chassis.cylinder.color[1] / 255.0,chassis.cylinder.color[2] / 255.0,chassis.cylinder.color[3] / 255.0,chassis.cylinder.specularCoefficient);
//   chassis.cylinder.Extra = chassis.cylinder.extra;
//   chassis.R[1,1] = cos(chassis.frame_a.phi);
//   chassis.R[1,2] = sin(chassis.frame_a.phi);
//   chassis.R[2,1] = -sin(chassis.frame_a.phi);
//   chassis.R[2,2] = cos(chassis.frame_a.phi);
//   chassis.r0[1] = chassis.R[1,1] * chassis.r[1] + chassis.R[1,2] * chassis.r[2];
//   chassis.r0[2] = chassis.R[2,1] * chassis.r[1] + chassis.R[2,2] * chassis.r[2];
//   chassis.frame_a.x + chassis.r0[1] = chassis.frame_b.x;
//   chassis.frame_a.y + chassis.r0[2] = chassis.frame_b.y;
//   chassis.frame_a.phi = chassis.frame_b.phi;
//   chassis.frame_a.fx + chassis.frame_b.fx = 0.0;
//   chassis.frame_a.fy + chassis.frame_b.fy = 0.0;
//   chassis.frame_a.t + (chassis.frame_b.t + ((-chassis.r0[1]) * chassis.frame_b.fy + chassis.r0[2] * chassis.frame_b.fx)) = 0.0;
//   bodyRear.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyRear.sphere.shapeType);
//   bodyRear.sphere.rxvisobj[1] = bodyRear.sphere.R.T[1,1] * bodyRear.sphere.e_x[1] + bodyRear.sphere.R.T[2,1] * bodyRear.sphere.e_x[2] + bodyRear.sphere.R.T[3,1] * bodyRear.sphere.e_x[3];
//   bodyRear.sphere.rxvisobj[2] = bodyRear.sphere.R.T[1,2] * bodyRear.sphere.e_x[1] + bodyRear.sphere.R.T[2,2] * bodyRear.sphere.e_x[2] + bodyRear.sphere.R.T[3,2] * bodyRear.sphere.e_x[3];
//   bodyRear.sphere.rxvisobj[3] = bodyRear.sphere.R.T[1,3] * bodyRear.sphere.e_x[1] + bodyRear.sphere.R.T[2,3] * bodyRear.sphere.e_x[2] + bodyRear.sphere.R.T[3,3] * bodyRear.sphere.e_x[3];
//   bodyRear.sphere.ryvisobj[1] = bodyRear.sphere.R.T[1,1] * bodyRear.sphere.e_y[1] + bodyRear.sphere.R.T[2,1] * bodyRear.sphere.e_y[2] + bodyRear.sphere.R.T[3,1] * bodyRear.sphere.e_y[3];
//   bodyRear.sphere.ryvisobj[2] = bodyRear.sphere.R.T[1,2] * bodyRear.sphere.e_y[1] + bodyRear.sphere.R.T[2,2] * bodyRear.sphere.e_y[2] + bodyRear.sphere.R.T[3,2] * bodyRear.sphere.e_y[3];
//   bodyRear.sphere.ryvisobj[3] = bodyRear.sphere.R.T[1,3] * bodyRear.sphere.e_y[1] + bodyRear.sphere.R.T[2,3] * bodyRear.sphere.e_y[2] + bodyRear.sphere.R.T[3,3] * bodyRear.sphere.e_y[3];
//   bodyRear.sphere.rvisobj = bodyRear.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyRear.sphere.R.T[1,1],bodyRear.sphere.R.T[1,2],bodyRear.sphere.R.T[1,3]},{bodyRear.sphere.R.T[2,1],bodyRear.sphere.R.T[2,2],bodyRear.sphere.R.T[2,3]},{bodyRear.sphere.R.T[3,1],bodyRear.sphere.R.T[3,2],bodyRear.sphere.R.T[3,3]}},{bodyRear.sphere.r_shape[1],bodyRear.sphere.r_shape[2],bodyRear.sphere.r_shape[3]});
//   bodyRear.sphere.size[1] = bodyRear.sphere.length;
//   bodyRear.sphere.size[2] = bodyRear.sphere.width;
//   bodyRear.sphere.size[3] = bodyRear.sphere.height;
//   bodyRear.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyRear.sphere.color[1] / 255.0,bodyRear.sphere.color[2] / 255.0,bodyRear.sphere.color[3] / 255.0,bodyRear.sphere.specularCoefficient);
//   bodyRear.sphere.Extra = bodyRear.sphere.extra;
//   bodyRear.r[1] = bodyRear.frame_a.x;
//   bodyRear.r[2] = bodyRear.frame_a.y;
//   bodyRear.v[1] = der(bodyRear.r[1]);
//   bodyRear.v[2] = der(bodyRear.r[2]);
//   bodyRear.w = der(bodyRear.frame_a.phi);
//   bodyRear.a[1] = der(bodyRear.v[1]);
//   bodyRear.a[2] = der(bodyRear.v[2]);
//   bodyRear.z = der(bodyRear.w);
//   bodyRear.f[1] = bodyRear.frame_a.fx;
//   bodyRear.f[2] = bodyRear.frame_a.fy;
//   bodyRear.f[1] + bodyRear.m * bodyRear.g[1] = bodyRear.m * bodyRear.a[1];
//   bodyRear.f[2] + bodyRear.m * bodyRear.g[2] = bodyRear.m * bodyRear.a[2];
//   bodyRear.frame_a.t = bodyRear.I * bodyRear.z;
//   idealWheelRear.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelRear.cylinder.shapeType);
//   idealWheelRear.cylinder.rxvisobj[1] = idealWheelRear.cylinder.R.T[1,1] * idealWheelRear.cylinder.e_x[1] + idealWheelRear.cylinder.R.T[2,1] * idealWheelRear.cylinder.e_x[2] + idealWheelRear.cylinder.R.T[3,1] * idealWheelRear.cylinder.e_x[3];
//   idealWheelRear.cylinder.rxvisobj[2] = idealWheelRear.cylinder.R.T[1,2] * idealWheelRear.cylinder.e_x[1] + idealWheelRear.cylinder.R.T[2,2] * idealWheelRear.cylinder.e_x[2] + idealWheelRear.cylinder.R.T[3,2] * idealWheelRear.cylinder.e_x[3];
//   idealWheelRear.cylinder.rxvisobj[3] = idealWheelRear.cylinder.R.T[1,3] * idealWheelRear.cylinder.e_x[1] + idealWheelRear.cylinder.R.T[2,3] * idealWheelRear.cylinder.e_x[2] + idealWheelRear.cylinder.R.T[3,3] * idealWheelRear.cylinder.e_x[3];
//   idealWheelRear.cylinder.ryvisobj[1] = idealWheelRear.cylinder.R.T[1,1] * idealWheelRear.cylinder.e_y[1] + idealWheelRear.cylinder.R.T[2,1] * idealWheelRear.cylinder.e_y[2] + idealWheelRear.cylinder.R.T[3,1] * idealWheelRear.cylinder.e_y[3];
//   idealWheelRear.cylinder.ryvisobj[2] = idealWheelRear.cylinder.R.T[1,2] * idealWheelRear.cylinder.e_y[1] + idealWheelRear.cylinder.R.T[2,2] * idealWheelRear.cylinder.e_y[2] + idealWheelRear.cylinder.R.T[3,2] * idealWheelRear.cylinder.e_y[3];
//   idealWheelRear.cylinder.ryvisobj[3] = idealWheelRear.cylinder.R.T[1,3] * idealWheelRear.cylinder.e_y[1] + idealWheelRear.cylinder.R.T[2,3] * idealWheelRear.cylinder.e_y[2] + idealWheelRear.cylinder.R.T[3,3] * idealWheelRear.cylinder.e_y[3];
//   idealWheelRear.cylinder.rvisobj = idealWheelRear.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelRear.cylinder.R.T[1,1],idealWheelRear.cylinder.R.T[1,2],idealWheelRear.cylinder.R.T[1,3]},{idealWheelRear.cylinder.R.T[2,1],idealWheelRear.cylinder.R.T[2,2],idealWheelRear.cylinder.R.T[2,3]},{idealWheelRear.cylinder.R.T[3,1],idealWheelRear.cylinder.R.T[3,2],idealWheelRear.cylinder.R.T[3,3]}},{idealWheelRear.cylinder.r_shape[1],idealWheelRear.cylinder.r_shape[2],idealWheelRear.cylinder.r_shape[3]});
//   idealWheelRear.cylinder.size[1] = idealWheelRear.cylinder.length;
//   idealWheelRear.cylinder.size[2] = idealWheelRear.cylinder.width;
//   idealWheelRear.cylinder.size[3] = idealWheelRear.cylinder.height;
//   idealWheelRear.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelRear.cylinder.color[1] / 255.0,idealWheelRear.cylinder.color[2] / 255.0,idealWheelRear.cylinder.color[3] / 255.0,idealWheelRear.cylinder.specularCoefficient);
//   idealWheelRear.cylinder.Extra = idealWheelRear.cylinder.extra;
//   idealWheelRear.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelRear.e0[2],idealWheelRear.e0[1],0.0},idealWheelRear.flange_a.phi,0.0);
//   idealWheelRear.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelRear.rim1.shapeType);
//   idealWheelRear.rim1.rxvisobj[1] = idealWheelRear.rim1.R.T[1,1] * idealWheelRear.rim1.e_x[1] + idealWheelRear.rim1.R.T[2,1] * idealWheelRear.rim1.e_x[2] + idealWheelRear.rim1.R.T[3,1] * idealWheelRear.rim1.e_x[3];
//   idealWheelRear.rim1.rxvisobj[2] = idealWheelRear.rim1.R.T[1,2] * idealWheelRear.rim1.e_x[1] + idealWheelRear.rim1.R.T[2,2] * idealWheelRear.rim1.e_x[2] + idealWheelRear.rim1.R.T[3,2] * idealWheelRear.rim1.e_x[3];
//   idealWheelRear.rim1.rxvisobj[3] = idealWheelRear.rim1.R.T[1,3] * idealWheelRear.rim1.e_x[1] + idealWheelRear.rim1.R.T[2,3] * idealWheelRear.rim1.e_x[2] + idealWheelRear.rim1.R.T[3,3] * idealWheelRear.rim1.e_x[3];
//   idealWheelRear.rim1.ryvisobj[1] = idealWheelRear.rim1.R.T[1,1] * idealWheelRear.rim1.e_y[1] + idealWheelRear.rim1.R.T[2,1] * idealWheelRear.rim1.e_y[2] + idealWheelRear.rim1.R.T[3,1] * idealWheelRear.rim1.e_y[3];
//   idealWheelRear.rim1.ryvisobj[2] = idealWheelRear.rim1.R.T[1,2] * idealWheelRear.rim1.e_y[1] + idealWheelRear.rim1.R.T[2,2] * idealWheelRear.rim1.e_y[2] + idealWheelRear.rim1.R.T[3,2] * idealWheelRear.rim1.e_y[3];
//   idealWheelRear.rim1.ryvisobj[3] = idealWheelRear.rim1.R.T[1,3] * idealWheelRear.rim1.e_y[1] + idealWheelRear.rim1.R.T[2,3] * idealWheelRear.rim1.e_y[2] + idealWheelRear.rim1.R.T[3,3] * idealWheelRear.rim1.e_y[3];
//   idealWheelRear.rim1.rvisobj = idealWheelRear.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelRear.rim1.R.T[1,1],idealWheelRear.rim1.R.T[1,2],idealWheelRear.rim1.R.T[1,3]},{idealWheelRear.rim1.R.T[2,1],idealWheelRear.rim1.R.T[2,2],idealWheelRear.rim1.R.T[2,3]},{idealWheelRear.rim1.R.T[3,1],idealWheelRear.rim1.R.T[3,2],idealWheelRear.rim1.R.T[3,3]}},{idealWheelRear.rim1.r_shape[1],idealWheelRear.rim1.r_shape[2],idealWheelRear.rim1.r_shape[3]});
//   idealWheelRear.rim1.size[1] = idealWheelRear.rim1.length;
//   idealWheelRear.rim1.size[2] = idealWheelRear.rim1.width;
//   idealWheelRear.rim1.size[3] = idealWheelRear.rim1.height;
//   idealWheelRear.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelRear.rim1.color[1] / 255.0,idealWheelRear.rim1.color[2] / 255.0,idealWheelRear.rim1.color[3] / 255.0,idealWheelRear.rim1.specularCoefficient);
//   idealWheelRear.rim1.Extra = idealWheelRear.rim1.extra;
//   idealWheelRear.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelRear.e0[2],idealWheelRear.e0[1],0.0},1.5707963267949 + idealWheelRear.flange_a.phi,0.0);
//   idealWheelRear.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelRear.rim2.shapeType);
//   idealWheelRear.rim2.rxvisobj[1] = idealWheelRear.rim2.R.T[1,1] * idealWheelRear.rim2.e_x[1] + idealWheelRear.rim2.R.T[2,1] * idealWheelRear.rim2.e_x[2] + idealWheelRear.rim2.R.T[3,1] * idealWheelRear.rim2.e_x[3];
//   idealWheelRear.rim2.rxvisobj[2] = idealWheelRear.rim2.R.T[1,2] * idealWheelRear.rim2.e_x[1] + idealWheelRear.rim2.R.T[2,2] * idealWheelRear.rim2.e_x[2] + idealWheelRear.rim2.R.T[3,2] * idealWheelRear.rim2.e_x[3];
//   idealWheelRear.rim2.rxvisobj[3] = idealWheelRear.rim2.R.T[1,3] * idealWheelRear.rim2.e_x[1] + idealWheelRear.rim2.R.T[2,3] * idealWheelRear.rim2.e_x[2] + idealWheelRear.rim2.R.T[3,3] * idealWheelRear.rim2.e_x[3];
//   idealWheelRear.rim2.ryvisobj[1] = idealWheelRear.rim2.R.T[1,1] * idealWheelRear.rim2.e_y[1] + idealWheelRear.rim2.R.T[2,1] * idealWheelRear.rim2.e_y[2] + idealWheelRear.rim2.R.T[3,1] * idealWheelRear.rim2.e_y[3];
//   idealWheelRear.rim2.ryvisobj[2] = idealWheelRear.rim2.R.T[1,2] * idealWheelRear.rim2.e_y[1] + idealWheelRear.rim2.R.T[2,2] * idealWheelRear.rim2.e_y[2] + idealWheelRear.rim2.R.T[3,2] * idealWheelRear.rim2.e_y[3];
//   idealWheelRear.rim2.ryvisobj[3] = idealWheelRear.rim2.R.T[1,3] * idealWheelRear.rim2.e_y[1] + idealWheelRear.rim2.R.T[2,3] * idealWheelRear.rim2.e_y[2] + idealWheelRear.rim2.R.T[3,3] * idealWheelRear.rim2.e_y[3];
//   idealWheelRear.rim2.rvisobj = idealWheelRear.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelRear.rim2.R.T[1,1],idealWheelRear.rim2.R.T[1,2],idealWheelRear.rim2.R.T[1,3]},{idealWheelRear.rim2.R.T[2,1],idealWheelRear.rim2.R.T[2,2],idealWheelRear.rim2.R.T[2,3]},{idealWheelRear.rim2.R.T[3,1],idealWheelRear.rim2.R.T[3,2],idealWheelRear.rim2.R.T[3,3]}},{idealWheelRear.rim2.r_shape[1],idealWheelRear.rim2.r_shape[2],idealWheelRear.rim2.r_shape[3]});
//   idealWheelRear.rim2.size[1] = idealWheelRear.rim2.length;
//   idealWheelRear.rim2.size[2] = idealWheelRear.rim2.width;
//   idealWheelRear.rim2.size[3] = idealWheelRear.rim2.height;
//   idealWheelRear.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelRear.rim2.color[1] / 255.0,idealWheelRear.rim2.color[2] / 255.0,idealWheelRear.rim2.color[3] / 255.0,idealWheelRear.rim2.specularCoefficient);
//   idealWheelRear.rim2.Extra = idealWheelRear.rim2.extra;
//   idealWheelRear.R[1,1] = cos(idealWheelRear.frame_a.phi);
//   idealWheelRear.R[1,2] = sin(idealWheelRear.frame_a.phi);
//   idealWheelRear.R[2,1] = -sin(idealWheelRear.frame_a.phi);
//   idealWheelRear.R[2,2] = cos(idealWheelRear.frame_a.phi);
//   idealWheelRear.e0[1] = idealWheelRear.R[1,1] * idealWheelRear.e[1] + idealWheelRear.R[1,2] * idealWheelRear.e[2];
//   idealWheelRear.e0[2] = idealWheelRear.R[2,1] * idealWheelRear.e[1] + idealWheelRear.R[2,2] * idealWheelRear.e[2];
//   idealWheelRear.v[1] = der(idealWheelRear.frame_a.x);
//   idealWheelRear.v[2] = der(idealWheelRear.frame_a.y);
//   idealWheelRear.v[1] = idealWheelRear.v_long * idealWheelRear.e0[1];
//   idealWheelRear.v[2] = idealWheelRear.v_long * idealWheelRear.e0[2];
//   idealWheelRear.w_roll = der(idealWheelRear.flange_a.phi);
//   idealWheelRear.v_long = idealWheelRear.radius * idealWheelRear.w_roll;
//   idealWheelRear.a = der(idealWheelRear.v_long);
//   (-idealWheelRear.f_long) * idealWheelRear.radius = idealWheelRear.flange_a.tau;
//   idealWheelRear.frame_a.t = 0.0;
//   idealWheelRear.frame_a.fx * idealWheelRear.e0[1] + idealWheelRear.frame_a.fy * idealWheelRear.e0[2] = idealWheelRear.f_long;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   trail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(trail.cylinder.shapeType);
//   trail.cylinder.rxvisobj[1] = trail.cylinder.R.T[1,1] * trail.cylinder.e_x[1] + trail.cylinder.R.T[2,1] * trail.cylinder.e_x[2] + trail.cylinder.R.T[3,1] * trail.cylinder.e_x[3];
//   trail.cylinder.rxvisobj[2] = trail.cylinder.R.T[1,2] * trail.cylinder.e_x[1] + trail.cylinder.R.T[2,2] * trail.cylinder.e_x[2] + trail.cylinder.R.T[3,2] * trail.cylinder.e_x[3];
//   trail.cylinder.rxvisobj[3] = trail.cylinder.R.T[1,3] * trail.cylinder.e_x[1] + trail.cylinder.R.T[2,3] * trail.cylinder.e_x[2] + trail.cylinder.R.T[3,3] * trail.cylinder.e_x[3];
//   trail.cylinder.ryvisobj[1] = trail.cylinder.R.T[1,1] * trail.cylinder.e_y[1] + trail.cylinder.R.T[2,1] * trail.cylinder.e_y[2] + trail.cylinder.R.T[3,1] * trail.cylinder.e_y[3];
//   trail.cylinder.ryvisobj[2] = trail.cylinder.R.T[1,2] * trail.cylinder.e_y[1] + trail.cylinder.R.T[2,2] * trail.cylinder.e_y[2] + trail.cylinder.R.T[3,2] * trail.cylinder.e_y[3];
//   trail.cylinder.ryvisobj[3] = trail.cylinder.R.T[1,3] * trail.cylinder.e_y[1] + trail.cylinder.R.T[2,3] * trail.cylinder.e_y[2] + trail.cylinder.R.T[3,3] * trail.cylinder.e_y[3];
//   trail.cylinder.rvisobj = trail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{trail.cylinder.R.T[1,1],trail.cylinder.R.T[1,2],trail.cylinder.R.T[1,3]},{trail.cylinder.R.T[2,1],trail.cylinder.R.T[2,2],trail.cylinder.R.T[2,3]},{trail.cylinder.R.T[3,1],trail.cylinder.R.T[3,2],trail.cylinder.R.T[3,3]}},{trail.cylinder.r_shape[1],trail.cylinder.r_shape[2],trail.cylinder.r_shape[3]});
//   trail.cylinder.size[1] = trail.cylinder.length;
//   trail.cylinder.size[2] = trail.cylinder.width;
//   trail.cylinder.size[3] = trail.cylinder.height;
//   trail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(trail.cylinder.color[1] / 255.0,trail.cylinder.color[2] / 255.0,trail.cylinder.color[3] / 255.0,trail.cylinder.specularCoefficient);
//   trail.cylinder.Extra = trail.cylinder.extra;
//   trail.R[1,1] = cos(trail.frame_a.phi);
//   trail.R[1,2] = sin(trail.frame_a.phi);
//   trail.R[2,1] = -sin(trail.frame_a.phi);
//   trail.R[2,2] = cos(trail.frame_a.phi);
//   trail.r0[1] = trail.R[1,1] * trail.r[1] + trail.R[1,2] * trail.r[2];
//   trail.r0[2] = trail.R[2,1] * trail.r[1] + trail.R[2,2] * trail.r[2];
//   trail.frame_a.x + trail.r0[1] = trail.frame_b.x;
//   trail.frame_a.y + trail.r0[2] = trail.frame_b.y;
//   trail.frame_a.phi = trail.frame_b.phi;
//   trail.frame_a.fx + trail.frame_b.fx = 0.0;
//   trail.frame_a.fy + trail.frame_b.fy = 0.0;
//   trail.frame_a.t + (trail.frame_b.t + ((-trail.r0[1]) * trail.frame_b.fy + trail.r0[2] * trail.frame_b.fx)) = 0.0;
//   bodyFront.frame_a.t + idealWheelFront.frame_a.t + trail.frame_b.t = 0.0;
//   bodyFront.frame_a.fy + idealWheelFront.frame_a.fy + trail.frame_b.fy = 0.0;
//   bodyFront.frame_a.fx + idealWheelFront.frame_a.fx + trail.frame_b.fx = 0.0;
//   idealWheelFront.flange_a.tau = 0.0;
//   chassis.frame_a.t + bodyRear.frame_a.t + idealWheelRear.frame_a.t = 0.0;
//   chassis.frame_a.fy + bodyRear.frame_a.fy + idealWheelRear.frame_a.fy = 0.0;
//   chassis.frame_a.fx + bodyRear.frame_a.fx + idealWheelRear.frame_a.fx = 0.0;
//   chassis.frame_b.t + revolute.frame_a.t = 0.0;
//   chassis.frame_b.fy + revolute.frame_a.fy = 0.0;
//   chassis.frame_b.fx + revolute.frame_a.fx = 0.0;
//   idealWheelRear.flange_a.tau + engineTorque.flange.tau = 0.0;
//   revolute.frame_b.t + trail.frame_a.t = 0.0;
//   revolute.frame_b.fy + trail.frame_a.fy = 0.0;
//   revolute.frame_b.fx + trail.frame_a.fx = 0.0;
//   bodyFront.frame_a.x = idealWheelFront.frame_a.x;
//   bodyFront.frame_a.x = trail.frame_b.x;
//   bodyFront.frame_a.y = idealWheelFront.frame_a.y;
//   bodyFront.frame_a.y = trail.frame_b.y;
//   bodyFront.frame_a.phi = idealWheelFront.frame_a.phi;
//   bodyFront.frame_a.phi = trail.frame_b.phi;
//   bodyRear.frame_a.x = chassis.frame_a.x;
//   bodyRear.frame_a.x = idealWheelRear.frame_a.x;
//   bodyRear.frame_a.y = chassis.frame_a.y;
//   bodyRear.frame_a.y = idealWheelRear.frame_a.y;
//   bodyRear.frame_a.phi = chassis.frame_a.phi;
//   bodyRear.frame_a.phi = idealWheelRear.frame_a.phi;
//   chassis.frame_b.x = revolute.frame_a.x;
//   chassis.frame_b.y = revolute.frame_a.y;
//   chassis.frame_b.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = idealWheelRear.flange_a.phi;
//   revolute.frame_b.x = trail.frame_a.x;
//   revolute.frame_b.y = trail.frame_a.y;
//   revolute.frame_b.phi = trail.frame_a.phi;
// end PlanarMechanicsV4.Examples.SingleTrackWithEngine;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.SingleTrackFixedSteering
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real idealWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.2 \"radius of the wheel\";
//   parameter Real idealWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real idealWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelJoint.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean idealWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelJoint.r[1] ^ 2.0 + idealWheelJoint.r[2] ^ 2.0);
//   final parameter Real idealWheelJoint.e[1] = idealWheelJoint.r[1] / idealWheelJoint.l \"normalized direction\";
//   final parameter Real idealWheelJoint.e[2] = idealWheelJoint.r[2] / idealWheelJoint.l \"normalized direction\";
//   parameter String idealWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * idealWheelJoint.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * idealWheelJoint.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = idealWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Width of visual object\";
//   input Real idealWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Height of visual object\";
//   input Real idealWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.cylinder.lengthDirection[1],idealWheelJoint.cylinder.lengthDirection[2],idealWheelJoint.cylinder.lengthDirection[3]});
//   protected Real idealWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.cylinder.lengthDirection[1] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.cylinder.lengthDirection[2] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.cylinder.lengthDirection[3] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[3] - idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[2];
//   protected Real idealWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[1] - idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[3];
//   protected Real idealWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[2] - idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[1];
//   protected Real idealWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[1];
//   protected Real idealWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[2];
//   protected Real idealWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real idealWheelJoint.cylinder.Form;
//   output Real idealWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.Material;
//   protected output Real idealWheelJoint.cylinder.Extra;
//   parameter String idealWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim1.lengthDirection[1],idealWheelJoint.rim1.lengthDirection[2],idealWheelJoint.rim1.lengthDirection[3]});
//   protected Real idealWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.rim1.lengthDirection[1] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim1.lengthDirection[2] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim1.lengthDirection[3] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[3] - idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[2];
//   protected Real idealWheelJoint.rim1.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[1] - idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[3];
//   protected Real idealWheelJoint.rim1.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[2] - idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[1];
//   protected Real idealWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[1];
//   protected Real idealWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[2];
//   protected Real idealWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim1.Form;
//   output Real idealWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.Material;
//   protected output Real idealWheelJoint.rim1.Extra;
//   parameter String idealWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim2.lengthDirection[1],idealWheelJoint.rim2.lengthDirection[2],idealWheelJoint.rim2.lengthDirection[3]});
//   protected Real idealWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 1.0 else idealWheelJoint.rim2.lengthDirection[1] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim2.lengthDirection[2] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint.rim2.lengthDirection[3] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[3] - idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[2];
//   protected Real idealWheelJoint.rim2.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[1] - idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[3];
//   protected Real idealWheelJoint.rim2.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[2] - idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[1];
//   protected Real idealWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[1];
//   protected Real idealWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[2];
//   protected Real idealWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim2.Form;
//   output Real idealWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.Material;
//   protected output Real idealWheelJoint.rim2.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 0.8 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real idealWheelJoint1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelJoint1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelJoint1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelJoint1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelJoint1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelJoint1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelJoint1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelJoint1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelJoint1.radius(quantity = \"Length\", unit = \"m\") = 0.2 \"radius of the wheel\";
//   parameter Real idealWheelJoint1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelJoint1.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelJoint1.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint1.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint1.R[1,1] \"Rotation Matrix\";
//   Real idealWheelJoint1.R[1,2] \"Rotation Matrix\";
//   Real idealWheelJoint1.R[2,1] \"Rotation Matrix\";
//   Real idealWheelJoint1.R[2,2] \"Rotation Matrix\";
//   Real idealWheelJoint1.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelJoint1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint1.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelJoint1.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelJoint1.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelJoint1.animate = true \"enable Animation\";
//   parameter Boolean idealWheelJoint1.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelJoint1.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelJoint1.r[1] ^ 2.0 + idealWheelJoint1.r[2] ^ 2.0);
//   final parameter Real idealWheelJoint1.e[1] = idealWheelJoint1.r[1] / idealWheelJoint1.l \"normalized direction\";
//   final parameter Real idealWheelJoint1.e[2] = idealWheelJoint1.r[2] / idealWheelJoint1.l \"normalized direction\";
//   parameter String idealWheelJoint1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * idealWheelJoint1.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * idealWheelJoint1.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelJoint1.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.lengthDirection[2](unit = \"1\") = idealWheelJoint1.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelJoint1.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint1.radius \"Width of visual object\";
//   input Real idealWheelJoint1.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint1.radius \"Height of visual object\";
//   input Real idealWheelJoint1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint1.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint1.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint1.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint1.cylinder.lengthDirection[1],idealWheelJoint1.cylinder.lengthDirection[2],idealWheelJoint1.cylinder.lengthDirection[3]});
//   protected Real idealWheelJoint1.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint1.cylinder.abs_n_x < 1e-10) then 1.0 else idealWheelJoint1.cylinder.lengthDirection[1] / idealWheelJoint1.cylinder.abs_n_x;
//   protected Real idealWheelJoint1.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint1.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint1.cylinder.lengthDirection[2] / idealWheelJoint1.cylinder.abs_n_x;
//   protected Real idealWheelJoint1.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint1.cylinder.abs_n_x < 1e-10) then 0.0 else idealWheelJoint1.cylinder.lengthDirection[3] / idealWheelJoint1.cylinder.abs_n_x;
//   protected Real idealWheelJoint1.cylinder.n_z_aux[1](unit = \"1\") = idealWheelJoint1.cylinder.e_x[2] * idealWheelJoint1.cylinder.widthDirection[3] - idealWheelJoint1.cylinder.e_x[3] * idealWheelJoint1.cylinder.widthDirection[2];
//   protected Real idealWheelJoint1.cylinder.n_z_aux[2](unit = \"1\") = idealWheelJoint1.cylinder.e_x[3] * idealWheelJoint1.cylinder.widthDirection[1] - idealWheelJoint1.cylinder.e_x[1] * idealWheelJoint1.cylinder.widthDirection[3];
//   protected Real idealWheelJoint1.cylinder.n_z_aux[3](unit = \"1\") = idealWheelJoint1.cylinder.e_x[1] * idealWheelJoint1.cylinder.widthDirection[2] - idealWheelJoint1.cylinder.e_x[2] * idealWheelJoint1.cylinder.widthDirection[1];
//   protected Real idealWheelJoint1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.cylinder.e_x[1],idealWheelJoint1.cylinder.e_x[2],idealWheelJoint1.cylinder.e_x[3]},if noEvent(idealWheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.cylinder.widthDirection[1],idealWheelJoint1.cylinder.widthDirection[2],idealWheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.cylinder.e_x[1],idealWheelJoint1.cylinder.e_x[2],idealWheelJoint1.cylinder.e_x[3]})[1];
//   protected Real idealWheelJoint1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.cylinder.e_x[1],idealWheelJoint1.cylinder.e_x[2],idealWheelJoint1.cylinder.e_x[3]},if noEvent(idealWheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.cylinder.widthDirection[1],idealWheelJoint1.cylinder.widthDirection[2],idealWheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.cylinder.e_x[1],idealWheelJoint1.cylinder.e_x[2],idealWheelJoint1.cylinder.e_x[3]})[2];
//   protected Real idealWheelJoint1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.cylinder.e_x[1],idealWheelJoint1.cylinder.e_x[2],idealWheelJoint1.cylinder.e_x[3]},if noEvent(idealWheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.cylinder.widthDirection[1],idealWheelJoint1.cylinder.widthDirection[2],idealWheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.cylinder.e_x[1],idealWheelJoint1.cylinder.e_x[2],idealWheelJoint1.cylinder.e_x[3]})[3];
//   protected output Real idealWheelJoint1.cylinder.Form;
//   output Real idealWheelJoint1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.cylinder.Material;
//   protected output Real idealWheelJoint1.cylinder.Extra;
//   parameter String idealWheelJoint1.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint1.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint1.radius \"Length of visual object\";
//   input Real idealWheelJoint1.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint1.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint1.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint1.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint1.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint1.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint1.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint1.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint1.rim1.lengthDirection[1],idealWheelJoint1.rim1.lengthDirection[2],idealWheelJoint1.rim1.lengthDirection[3]});
//   protected Real idealWheelJoint1.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint1.rim1.abs_n_x < 1e-10) then 1.0 else idealWheelJoint1.rim1.lengthDirection[1] / idealWheelJoint1.rim1.abs_n_x;
//   protected Real idealWheelJoint1.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint1.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint1.rim1.lengthDirection[2] / idealWheelJoint1.rim1.abs_n_x;
//   protected Real idealWheelJoint1.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint1.rim1.abs_n_x < 1e-10) then 0.0 else idealWheelJoint1.rim1.lengthDirection[3] / idealWheelJoint1.rim1.abs_n_x;
//   protected Real idealWheelJoint1.rim1.n_z_aux[1](unit = \"1\") = idealWheelJoint1.rim1.e_x[2] * idealWheelJoint1.rim1.widthDirection[3] - idealWheelJoint1.rim1.e_x[3] * idealWheelJoint1.rim1.widthDirection[2];
//   protected Real idealWheelJoint1.rim1.n_z_aux[2](unit = \"1\") = idealWheelJoint1.rim1.e_x[3] * idealWheelJoint1.rim1.widthDirection[1] - idealWheelJoint1.rim1.e_x[1] * idealWheelJoint1.rim1.widthDirection[3];
//   protected Real idealWheelJoint1.rim1.n_z_aux[3](unit = \"1\") = idealWheelJoint1.rim1.e_x[1] * idealWheelJoint1.rim1.widthDirection[2] - idealWheelJoint1.rim1.e_x[2] * idealWheelJoint1.rim1.widthDirection[1];
//   protected Real idealWheelJoint1.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.rim1.e_x[1],idealWheelJoint1.rim1.e_x[2],idealWheelJoint1.rim1.e_x[3]},if noEvent(idealWheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.rim1.widthDirection[1],idealWheelJoint1.rim1.widthDirection[2],idealWheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.rim1.e_x[1],idealWheelJoint1.rim1.e_x[2],idealWheelJoint1.rim1.e_x[3]})[1];
//   protected Real idealWheelJoint1.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.rim1.e_x[1],idealWheelJoint1.rim1.e_x[2],idealWheelJoint1.rim1.e_x[3]},if noEvent(idealWheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.rim1.widthDirection[1],idealWheelJoint1.rim1.widthDirection[2],idealWheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.rim1.e_x[1],idealWheelJoint1.rim1.e_x[2],idealWheelJoint1.rim1.e_x[3]})[2];
//   protected Real idealWheelJoint1.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.rim1.e_x[1],idealWheelJoint1.rim1.e_x[2],idealWheelJoint1.rim1.e_x[3]},if noEvent(idealWheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.rim1.widthDirection[1],idealWheelJoint1.rim1.widthDirection[2],idealWheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.rim1.e_x[1],idealWheelJoint1.rim1.e_x[2],idealWheelJoint1.rim1.e_x[3]})[3];
//   protected output Real idealWheelJoint1.rim1.Form;
//   output Real idealWheelJoint1.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint1.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint1.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.rim1.Material;
//   protected output Real idealWheelJoint1.rim1.Extra;
//   parameter String idealWheelJoint1.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint1.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint1.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint1.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint1.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint1.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint1.radius \"Length of visual object\";
//   input Real idealWheelJoint1.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint1.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint1.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint1.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint1.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint1.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint1.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint1.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint1.rim2.lengthDirection[1],idealWheelJoint1.rim2.lengthDirection[2],idealWheelJoint1.rim2.lengthDirection[3]});
//   protected Real idealWheelJoint1.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint1.rim2.abs_n_x < 1e-10) then 1.0 else idealWheelJoint1.rim2.lengthDirection[1] / idealWheelJoint1.rim2.abs_n_x;
//   protected Real idealWheelJoint1.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint1.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint1.rim2.lengthDirection[2] / idealWheelJoint1.rim2.abs_n_x;
//   protected Real idealWheelJoint1.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint1.rim2.abs_n_x < 1e-10) then 0.0 else idealWheelJoint1.rim2.lengthDirection[3] / idealWheelJoint1.rim2.abs_n_x;
//   protected Real idealWheelJoint1.rim2.n_z_aux[1](unit = \"1\") = idealWheelJoint1.rim2.e_x[2] * idealWheelJoint1.rim2.widthDirection[3] - idealWheelJoint1.rim2.e_x[3] * idealWheelJoint1.rim2.widthDirection[2];
//   protected Real idealWheelJoint1.rim2.n_z_aux[2](unit = \"1\") = idealWheelJoint1.rim2.e_x[3] * idealWheelJoint1.rim2.widthDirection[1] - idealWheelJoint1.rim2.e_x[1] * idealWheelJoint1.rim2.widthDirection[3];
//   protected Real idealWheelJoint1.rim2.n_z_aux[3](unit = \"1\") = idealWheelJoint1.rim2.e_x[1] * idealWheelJoint1.rim2.widthDirection[2] - idealWheelJoint1.rim2.e_x[2] * idealWheelJoint1.rim2.widthDirection[1];
//   protected Real idealWheelJoint1.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.rim2.e_x[1],idealWheelJoint1.rim2.e_x[2],idealWheelJoint1.rim2.e_x[3]},if noEvent(idealWheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.rim2.widthDirection[1],idealWheelJoint1.rim2.widthDirection[2],idealWheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.rim2.e_x[1],idealWheelJoint1.rim2.e_x[2],idealWheelJoint1.rim2.e_x[3]})[1];
//   protected Real idealWheelJoint1.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.rim2.e_x[1],idealWheelJoint1.rim2.e_x[2],idealWheelJoint1.rim2.e_x[3]},if noEvent(idealWheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.rim2.widthDirection[1],idealWheelJoint1.rim2.widthDirection[2],idealWheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.rim2.e_x[1],idealWheelJoint1.rim2.e_x[2],idealWheelJoint1.rim2.e_x[3]})[2];
//   protected Real idealWheelJoint1.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint1.rim2.e_x[1],idealWheelJoint1.rim2.e_x[2],idealWheelJoint1.rim2.e_x[3]},if noEvent(idealWheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint1.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {idealWheelJoint1.rim2.widthDirection[1],idealWheelJoint1.rim2.widthDirection[2],idealWheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{idealWheelJoint1.rim2.e_x[1],idealWheelJoint1.rim2.e_x[2],idealWheelJoint1.rim2.e_x[3]})[3];
//   protected output Real idealWheelJoint1.rim2.Form;
//   output Real idealWheelJoint1.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint1.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint1.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint1.rim2.Material;
//   protected output Real idealWheelJoint1.rim2.Extra;
//   Real fixedRotation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedRotation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedRotation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedRotation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedRotation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedRotation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedRotation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedRotation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedRotation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedRotation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedRotation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedRotation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedRotation.alpha(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -0.13962634015955 \"fixed rotation angle\";
//   parameter Boolean constantTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real constantTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real constantTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real constantTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real constantTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real constantTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real constantTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   parameter Boolean constantTorque1.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real constantTorque1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real constantTorque1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real constantTorque1.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real constantTorque1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real constantTorque1.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 3.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real constantTorque1.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   idealWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.cylinder.shapeType);
//   idealWheelJoint.cylinder.rxvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.ryvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.rvisobj = idealWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.cylinder.R.T[1,1],idealWheelJoint.cylinder.R.T[1,2],idealWheelJoint.cylinder.R.T[1,3]},{idealWheelJoint.cylinder.R.T[2,1],idealWheelJoint.cylinder.R.T[2,2],idealWheelJoint.cylinder.R.T[2,3]},{idealWheelJoint.cylinder.R.T[3,1],idealWheelJoint.cylinder.R.T[3,2],idealWheelJoint.cylinder.R.T[3,3]}},{idealWheelJoint.cylinder.r_shape[1],idealWheelJoint.cylinder.r_shape[2],idealWheelJoint.cylinder.r_shape[3]});
//   idealWheelJoint.cylinder.size[1] = idealWheelJoint.cylinder.length;
//   idealWheelJoint.cylinder.size[2] = idealWheelJoint.cylinder.width;
//   idealWheelJoint.cylinder.size[3] = idealWheelJoint.cylinder.height;
//   idealWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.cylinder.color[1] / 255.0,idealWheelJoint.cylinder.color[2] / 255.0,idealWheelJoint.cylinder.color[3] / 255.0,idealWheelJoint.cylinder.specularCoefficient);
//   idealWheelJoint.cylinder.Extra = idealWheelJoint.cylinder.extra;
//   idealWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim1.shapeType);
//   idealWheelJoint.rim1.rxvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.ryvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.rvisobj = idealWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim1.R.T[1,1],idealWheelJoint.rim1.R.T[1,2],idealWheelJoint.rim1.R.T[1,3]},{idealWheelJoint.rim1.R.T[2,1],idealWheelJoint.rim1.R.T[2,2],idealWheelJoint.rim1.R.T[2,3]},{idealWheelJoint.rim1.R.T[3,1],idealWheelJoint.rim1.R.T[3,2],idealWheelJoint.rim1.R.T[3,3]}},{idealWheelJoint.rim1.r_shape[1],idealWheelJoint.rim1.r_shape[2],idealWheelJoint.rim1.r_shape[3]});
//   idealWheelJoint.rim1.size[1] = idealWheelJoint.rim1.length;
//   idealWheelJoint.rim1.size[2] = idealWheelJoint.rim1.width;
//   idealWheelJoint.rim1.size[3] = idealWheelJoint.rim1.height;
//   idealWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim1.color[1] / 255.0,idealWheelJoint.rim1.color[2] / 255.0,idealWheelJoint.rim1.color[3] / 255.0,idealWheelJoint.rim1.specularCoefficient);
//   idealWheelJoint.rim1.Extra = idealWheelJoint.rim1.extra;
//   idealWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},1.5707963267949 + idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim2.shapeType);
//   idealWheelJoint.rim2.rxvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.ryvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.rvisobj = idealWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim2.R.T[1,1],idealWheelJoint.rim2.R.T[1,2],idealWheelJoint.rim2.R.T[1,3]},{idealWheelJoint.rim2.R.T[2,1],idealWheelJoint.rim2.R.T[2,2],idealWheelJoint.rim2.R.T[2,3]},{idealWheelJoint.rim2.R.T[3,1],idealWheelJoint.rim2.R.T[3,2],idealWheelJoint.rim2.R.T[3,3]}},{idealWheelJoint.rim2.r_shape[1],idealWheelJoint.rim2.r_shape[2],idealWheelJoint.rim2.r_shape[3]});
//   idealWheelJoint.rim2.size[1] = idealWheelJoint.rim2.length;
//   idealWheelJoint.rim2.size[2] = idealWheelJoint.rim2.width;
//   idealWheelJoint.rim2.size[3] = idealWheelJoint.rim2.height;
//   idealWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim2.color[1] / 255.0,idealWheelJoint.rim2.color[2] / 255.0,idealWheelJoint.rim2.color[3] / 255.0,idealWheelJoint.rim2.specularCoefficient);
//   idealWheelJoint.rim2.Extra = idealWheelJoint.rim2.extra;
//   idealWheelJoint.R[1,1] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[1,2] = sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,1] = -sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,2] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.e0[1] = idealWheelJoint.R[1,1] * idealWheelJoint.e[1] + idealWheelJoint.R[1,2] * idealWheelJoint.e[2];
//   idealWheelJoint.e0[2] = idealWheelJoint.R[2,1] * idealWheelJoint.e[1] + idealWheelJoint.R[2,2] * idealWheelJoint.e[2];
//   idealWheelJoint.v[1] = der(idealWheelJoint.frame_a.x);
//   idealWheelJoint.v[2] = der(idealWheelJoint.frame_a.y);
//   idealWheelJoint.v[1] = idealWheelJoint.v_long * idealWheelJoint.e0[1];
//   idealWheelJoint.v[2] = idealWheelJoint.v_long * idealWheelJoint.e0[2];
//   idealWheelJoint.w_roll = der(idealWheelJoint.flange_a.phi);
//   idealWheelJoint.v_long = idealWheelJoint.radius * idealWheelJoint.w_roll;
//   idealWheelJoint.a = der(idealWheelJoint.v_long);
//   (-idealWheelJoint.f_long) * idealWheelJoint.radius = idealWheelJoint.flange_a.tau;
//   idealWheelJoint.frame_a.t = 0.0;
//   idealWheelJoint.frame_a.fx * idealWheelJoint.e0[1] + idealWheelJoint.frame_a.fy * idealWheelJoint.e0[2] = idealWheelJoint.f_long;
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   idealWheelJoint1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint1.cylinder.shapeType);
//   idealWheelJoint1.cylinder.rxvisobj[1] = idealWheelJoint1.cylinder.R.T[1,1] * idealWheelJoint1.cylinder.e_x[1] + idealWheelJoint1.cylinder.R.T[2,1] * idealWheelJoint1.cylinder.e_x[2] + idealWheelJoint1.cylinder.R.T[3,1] * idealWheelJoint1.cylinder.e_x[3];
//   idealWheelJoint1.cylinder.rxvisobj[2] = idealWheelJoint1.cylinder.R.T[1,2] * idealWheelJoint1.cylinder.e_x[1] + idealWheelJoint1.cylinder.R.T[2,2] * idealWheelJoint1.cylinder.e_x[2] + idealWheelJoint1.cylinder.R.T[3,2] * idealWheelJoint1.cylinder.e_x[3];
//   idealWheelJoint1.cylinder.rxvisobj[3] = idealWheelJoint1.cylinder.R.T[1,3] * idealWheelJoint1.cylinder.e_x[1] + idealWheelJoint1.cylinder.R.T[2,3] * idealWheelJoint1.cylinder.e_x[2] + idealWheelJoint1.cylinder.R.T[3,3] * idealWheelJoint1.cylinder.e_x[3];
//   idealWheelJoint1.cylinder.ryvisobj[1] = idealWheelJoint1.cylinder.R.T[1,1] * idealWheelJoint1.cylinder.e_y[1] + idealWheelJoint1.cylinder.R.T[2,1] * idealWheelJoint1.cylinder.e_y[2] + idealWheelJoint1.cylinder.R.T[3,1] * idealWheelJoint1.cylinder.e_y[3];
//   idealWheelJoint1.cylinder.ryvisobj[2] = idealWheelJoint1.cylinder.R.T[1,2] * idealWheelJoint1.cylinder.e_y[1] + idealWheelJoint1.cylinder.R.T[2,2] * idealWheelJoint1.cylinder.e_y[2] + idealWheelJoint1.cylinder.R.T[3,2] * idealWheelJoint1.cylinder.e_y[3];
//   idealWheelJoint1.cylinder.ryvisobj[3] = idealWheelJoint1.cylinder.R.T[1,3] * idealWheelJoint1.cylinder.e_y[1] + idealWheelJoint1.cylinder.R.T[2,3] * idealWheelJoint1.cylinder.e_y[2] + idealWheelJoint1.cylinder.R.T[3,3] * idealWheelJoint1.cylinder.e_y[3];
//   idealWheelJoint1.cylinder.rvisobj = idealWheelJoint1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint1.cylinder.R.T[1,1],idealWheelJoint1.cylinder.R.T[1,2],idealWheelJoint1.cylinder.R.T[1,3]},{idealWheelJoint1.cylinder.R.T[2,1],idealWheelJoint1.cylinder.R.T[2,2],idealWheelJoint1.cylinder.R.T[2,3]},{idealWheelJoint1.cylinder.R.T[3,1],idealWheelJoint1.cylinder.R.T[3,2],idealWheelJoint1.cylinder.R.T[3,3]}},{idealWheelJoint1.cylinder.r_shape[1],idealWheelJoint1.cylinder.r_shape[2],idealWheelJoint1.cylinder.r_shape[3]});
//   idealWheelJoint1.cylinder.size[1] = idealWheelJoint1.cylinder.length;
//   idealWheelJoint1.cylinder.size[2] = idealWheelJoint1.cylinder.width;
//   idealWheelJoint1.cylinder.size[3] = idealWheelJoint1.cylinder.height;
//   idealWheelJoint1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint1.cylinder.color[1] / 255.0,idealWheelJoint1.cylinder.color[2] / 255.0,idealWheelJoint1.cylinder.color[3] / 255.0,idealWheelJoint1.cylinder.specularCoefficient);
//   idealWheelJoint1.cylinder.Extra = idealWheelJoint1.cylinder.extra;
//   idealWheelJoint1.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint1.e0[2],idealWheelJoint1.e0[1],0.0},idealWheelJoint1.flange_a.phi,0.0);
//   idealWheelJoint1.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint1.rim1.shapeType);
//   idealWheelJoint1.rim1.rxvisobj[1] = idealWheelJoint1.rim1.R.T[1,1] * idealWheelJoint1.rim1.e_x[1] + idealWheelJoint1.rim1.R.T[2,1] * idealWheelJoint1.rim1.e_x[2] + idealWheelJoint1.rim1.R.T[3,1] * idealWheelJoint1.rim1.e_x[3];
//   idealWheelJoint1.rim1.rxvisobj[2] = idealWheelJoint1.rim1.R.T[1,2] * idealWheelJoint1.rim1.e_x[1] + idealWheelJoint1.rim1.R.T[2,2] * idealWheelJoint1.rim1.e_x[2] + idealWheelJoint1.rim1.R.T[3,2] * idealWheelJoint1.rim1.e_x[3];
//   idealWheelJoint1.rim1.rxvisobj[3] = idealWheelJoint1.rim1.R.T[1,3] * idealWheelJoint1.rim1.e_x[1] + idealWheelJoint1.rim1.R.T[2,3] * idealWheelJoint1.rim1.e_x[2] + idealWheelJoint1.rim1.R.T[3,3] * idealWheelJoint1.rim1.e_x[3];
//   idealWheelJoint1.rim1.ryvisobj[1] = idealWheelJoint1.rim1.R.T[1,1] * idealWheelJoint1.rim1.e_y[1] + idealWheelJoint1.rim1.R.T[2,1] * idealWheelJoint1.rim1.e_y[2] + idealWheelJoint1.rim1.R.T[3,1] * idealWheelJoint1.rim1.e_y[3];
//   idealWheelJoint1.rim1.ryvisobj[2] = idealWheelJoint1.rim1.R.T[1,2] * idealWheelJoint1.rim1.e_y[1] + idealWheelJoint1.rim1.R.T[2,2] * idealWheelJoint1.rim1.e_y[2] + idealWheelJoint1.rim1.R.T[3,2] * idealWheelJoint1.rim1.e_y[3];
//   idealWheelJoint1.rim1.ryvisobj[3] = idealWheelJoint1.rim1.R.T[1,3] * idealWheelJoint1.rim1.e_y[1] + idealWheelJoint1.rim1.R.T[2,3] * idealWheelJoint1.rim1.e_y[2] + idealWheelJoint1.rim1.R.T[3,3] * idealWheelJoint1.rim1.e_y[3];
//   idealWheelJoint1.rim1.rvisobj = idealWheelJoint1.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint1.rim1.R.T[1,1],idealWheelJoint1.rim1.R.T[1,2],idealWheelJoint1.rim1.R.T[1,3]},{idealWheelJoint1.rim1.R.T[2,1],idealWheelJoint1.rim1.R.T[2,2],idealWheelJoint1.rim1.R.T[2,3]},{idealWheelJoint1.rim1.R.T[3,1],idealWheelJoint1.rim1.R.T[3,2],idealWheelJoint1.rim1.R.T[3,3]}},{idealWheelJoint1.rim1.r_shape[1],idealWheelJoint1.rim1.r_shape[2],idealWheelJoint1.rim1.r_shape[3]});
//   idealWheelJoint1.rim1.size[1] = idealWheelJoint1.rim1.length;
//   idealWheelJoint1.rim1.size[2] = idealWheelJoint1.rim1.width;
//   idealWheelJoint1.rim1.size[3] = idealWheelJoint1.rim1.height;
//   idealWheelJoint1.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint1.rim1.color[1] / 255.0,idealWheelJoint1.rim1.color[2] / 255.0,idealWheelJoint1.rim1.color[3] / 255.0,idealWheelJoint1.rim1.specularCoefficient);
//   idealWheelJoint1.rim1.Extra = idealWheelJoint1.rim1.extra;
//   idealWheelJoint1.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint1.e0[2],idealWheelJoint1.e0[1],0.0},1.5707963267949 + idealWheelJoint1.flange_a.phi,0.0);
//   idealWheelJoint1.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint1.rim2.shapeType);
//   idealWheelJoint1.rim2.rxvisobj[1] = idealWheelJoint1.rim2.R.T[1,1] * idealWheelJoint1.rim2.e_x[1] + idealWheelJoint1.rim2.R.T[2,1] * idealWheelJoint1.rim2.e_x[2] + idealWheelJoint1.rim2.R.T[3,1] * idealWheelJoint1.rim2.e_x[3];
//   idealWheelJoint1.rim2.rxvisobj[2] = idealWheelJoint1.rim2.R.T[1,2] * idealWheelJoint1.rim2.e_x[1] + idealWheelJoint1.rim2.R.T[2,2] * idealWheelJoint1.rim2.e_x[2] + idealWheelJoint1.rim2.R.T[3,2] * idealWheelJoint1.rim2.e_x[3];
//   idealWheelJoint1.rim2.rxvisobj[3] = idealWheelJoint1.rim2.R.T[1,3] * idealWheelJoint1.rim2.e_x[1] + idealWheelJoint1.rim2.R.T[2,3] * idealWheelJoint1.rim2.e_x[2] + idealWheelJoint1.rim2.R.T[3,3] * idealWheelJoint1.rim2.e_x[3];
//   idealWheelJoint1.rim2.ryvisobj[1] = idealWheelJoint1.rim2.R.T[1,1] * idealWheelJoint1.rim2.e_y[1] + idealWheelJoint1.rim2.R.T[2,1] * idealWheelJoint1.rim2.e_y[2] + idealWheelJoint1.rim2.R.T[3,1] * idealWheelJoint1.rim2.e_y[3];
//   idealWheelJoint1.rim2.ryvisobj[2] = idealWheelJoint1.rim2.R.T[1,2] * idealWheelJoint1.rim2.e_y[1] + idealWheelJoint1.rim2.R.T[2,2] * idealWheelJoint1.rim2.e_y[2] + idealWheelJoint1.rim2.R.T[3,2] * idealWheelJoint1.rim2.e_y[3];
//   idealWheelJoint1.rim2.ryvisobj[3] = idealWheelJoint1.rim2.R.T[1,3] * idealWheelJoint1.rim2.e_y[1] + idealWheelJoint1.rim2.R.T[2,3] * idealWheelJoint1.rim2.e_y[2] + idealWheelJoint1.rim2.R.T[3,3] * idealWheelJoint1.rim2.e_y[3];
//   idealWheelJoint1.rim2.rvisobj = idealWheelJoint1.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint1.rim2.R.T[1,1],idealWheelJoint1.rim2.R.T[1,2],idealWheelJoint1.rim2.R.T[1,3]},{idealWheelJoint1.rim2.R.T[2,1],idealWheelJoint1.rim2.R.T[2,2],idealWheelJoint1.rim2.R.T[2,3]},{idealWheelJoint1.rim2.R.T[3,1],idealWheelJoint1.rim2.R.T[3,2],idealWheelJoint1.rim2.R.T[3,3]}},{idealWheelJoint1.rim2.r_shape[1],idealWheelJoint1.rim2.r_shape[2],idealWheelJoint1.rim2.r_shape[3]});
//   idealWheelJoint1.rim2.size[1] = idealWheelJoint1.rim2.length;
//   idealWheelJoint1.rim2.size[2] = idealWheelJoint1.rim2.width;
//   idealWheelJoint1.rim2.size[3] = idealWheelJoint1.rim2.height;
//   idealWheelJoint1.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint1.rim2.color[1] / 255.0,idealWheelJoint1.rim2.color[2] / 255.0,idealWheelJoint1.rim2.color[3] / 255.0,idealWheelJoint1.rim2.specularCoefficient);
//   idealWheelJoint1.rim2.Extra = idealWheelJoint1.rim2.extra;
//   idealWheelJoint1.R[1,1] = cos(idealWheelJoint1.frame_a.phi);
//   idealWheelJoint1.R[1,2] = sin(idealWheelJoint1.frame_a.phi);
//   idealWheelJoint1.R[2,1] = -sin(idealWheelJoint1.frame_a.phi);
//   idealWheelJoint1.R[2,2] = cos(idealWheelJoint1.frame_a.phi);
//   idealWheelJoint1.e0[1] = idealWheelJoint1.R[1,1] * idealWheelJoint1.e[1] + idealWheelJoint1.R[1,2] * idealWheelJoint1.e[2];
//   idealWheelJoint1.e0[2] = idealWheelJoint1.R[2,1] * idealWheelJoint1.e[1] + idealWheelJoint1.R[2,2] * idealWheelJoint1.e[2];
//   idealWheelJoint1.v[1] = der(idealWheelJoint1.frame_a.x);
//   idealWheelJoint1.v[2] = der(idealWheelJoint1.frame_a.y);
//   idealWheelJoint1.v[1] = idealWheelJoint1.v_long * idealWheelJoint1.e0[1];
//   idealWheelJoint1.v[2] = idealWheelJoint1.v_long * idealWheelJoint1.e0[2];
//   idealWheelJoint1.w_roll = der(idealWheelJoint1.flange_a.phi);
//   idealWheelJoint1.v_long = idealWheelJoint1.radius * idealWheelJoint1.w_roll;
//   idealWheelJoint1.a = der(idealWheelJoint1.v_long);
//   (-idealWheelJoint1.f_long) * idealWheelJoint1.radius = idealWheelJoint1.flange_a.tau;
//   idealWheelJoint1.frame_a.t = 0.0;
//   idealWheelJoint1.frame_a.fx * idealWheelJoint1.e0[1] + idealWheelJoint1.frame_a.fy * idealWheelJoint1.e0[2] = idealWheelJoint1.f_long;
//   fixedRotation.frame_a.x = fixedRotation.frame_b.x;
//   fixedRotation.frame_a.y = fixedRotation.frame_b.y;
//   fixedRotation.frame_a.phi + fixedRotation.alpha = fixedRotation.frame_b.phi;
//   fixedRotation.frame_a.fx + fixedRotation.frame_b.fx = 0.0;
//   fixedRotation.frame_a.fy + fixedRotation.frame_b.fy = 0.0;
//   fixedRotation.frame_a.t + fixedRotation.frame_b.t = 0.0;
//   constantTorque.tau = -constantTorque.flange.tau;
//   constantTorque.tau = constantTorque.tau_constant;
//   constantTorque.phi = constantTorque.flange.phi - constantTorque.phi_support;
//   constantTorque.phi_support = 0.0;
//   constantTorque1.tau = -constantTorque1.flange.tau;
//   constantTorque1.tau = constantTorque1.tau_constant;
//   constantTorque1.phi = constantTorque1.flange.phi - constantTorque1.phi_support;
//   constantTorque1.phi_support = 0.0;
//   body.frame_a.t + idealWheelJoint.frame_a.t + fixedRotation.frame_a.t = 0.0;
//   body.frame_a.fy + idealWheelJoint.frame_a.fy + fixedRotation.frame_a.fy = 0.0;
//   body.frame_a.fx + idealWheelJoint.frame_a.fx + fixedRotation.frame_a.fx = 0.0;
//   idealWheelJoint.flange_a.tau + constantTorque.flange.tau = 0.0;
//   fixedTranslation1.frame_a.t + body1.frame_a.t + idealWheelJoint1.frame_a.t = 0.0;
//   fixedTranslation1.frame_a.fy + body1.frame_a.fy + idealWheelJoint1.frame_a.fy = 0.0;
//   fixedTranslation1.frame_a.fx + body1.frame_a.fx + idealWheelJoint1.frame_a.fx = 0.0;
//   fixedTranslation1.frame_b.t + fixedRotation.frame_b.t = 0.0;
//   fixedTranslation1.frame_b.fy + fixedRotation.frame_b.fy = 0.0;
//   fixedTranslation1.frame_b.fx + fixedRotation.frame_b.fx = 0.0;
//   idealWheelJoint1.flange_a.tau + constantTorque1.flange.tau = 0.0;
//   body.frame_a.x = fixedRotation.frame_a.x;
//   body.frame_a.x = idealWheelJoint.frame_a.x;
//   body.frame_a.y = fixedRotation.frame_a.y;
//   body.frame_a.y = idealWheelJoint.frame_a.y;
//   body.frame_a.phi = fixedRotation.frame_a.phi;
//   body.frame_a.phi = idealWheelJoint.frame_a.phi;
//   body1.frame_a.x = fixedTranslation1.frame_a.x;
//   body1.frame_a.x = idealWheelJoint1.frame_a.x;
//   body1.frame_a.y = fixedTranslation1.frame_a.y;
//   body1.frame_a.y = idealWheelJoint1.frame_a.y;
//   body1.frame_a.phi = fixedTranslation1.frame_a.phi;
//   body1.frame_a.phi = idealWheelJoint1.frame_a.phi;
//   fixedRotation.frame_b.x = fixedTranslation1.frame_b.x;
//   fixedRotation.frame_b.y = fixedTranslation1.frame_b.y;
//   fixedRotation.frame_b.phi = fixedTranslation1.frame_b.phi;
//   constantTorque1.flange.phi = idealWheelJoint1.flange_a.phi;
//   constantTorque.flange.phi = idealWheelJoint.flange_a.phi;
// end PlanarMechanicsV4.Examples.SingleTrackFixedSteering;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.SingleTrackFixedSteeringFriction
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real dryFrictionWheelJoint1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real dryFrictionWheelJoint1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real dryFrictionWheelJoint1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real dryFrictionWheelJoint1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real dryFrictionWheelJoint1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real dryFrictionWheelJoint1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real dryFrictionWheelJoint1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real dryFrictionWheelJoint1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real dryFrictionWheelJoint1.radius(quantity = \"Length\", unit = \"m\") = 0.2 \"radius of the wheel\";
//   parameter Real dryFrictionWheelJoint1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint1.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint1.N(quantity = \"Force\", unit = \"N\") = 20.0 \"normal force\";
//   parameter Real dryFrictionWheelJoint1.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real dryFrictionWheelJoint1.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.2 \"sliding velocity\";
//   parameter Real dryFrictionWheelJoint1.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real dryFrictionWheelJoint1.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real dryFrictionWheelJoint1.e0[1] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint1.e0[2] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint1.R[1,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint1.R[1,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint1.R[2,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint1.R[2,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint1.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real dryFrictionWheelJoint1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint1.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real dryFrictionWheelJoint1.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint1.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint1.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real dryFrictionWheelJoint1.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real dryFrictionWheelJoint1.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint1.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint1.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean dryFrictionWheelJoint1.animate = true \"enable Animation\";
//   parameter Boolean dryFrictionWheelJoint1.SimVis = false \"perform animation with SimVis\";
//   final parameter Real dryFrictionWheelJoint1.l(quantity = \"Length\", unit = \"m\") = sqrt(dryFrictionWheelJoint1.r[1] ^ 2.0 + dryFrictionWheelJoint1.r[2] ^ 2.0);
//   final parameter Real dryFrictionWheelJoint1.e[1] = dryFrictionWheelJoint1.r[1] / dryFrictionWheelJoint1.l \"normalized direction\";
//   final parameter Real dryFrictionWheelJoint1.e[2] = dryFrictionWheelJoint1.r[2] / dryFrictionWheelJoint1.l \"normalized direction\";
//   parameter String dryFrictionWheelJoint1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * dryFrictionWheelJoint1.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * dryFrictionWheelJoint1.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.lengthDirection[1](unit = \"1\") = -dryFrictionWheelJoint1.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.lengthDirection[2](unit = \"1\") = dryFrictionWheelJoint1.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real dryFrictionWheelJoint1.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint1.radius \"Width of visual object\";
//   input Real dryFrictionWheelJoint1.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint1.radius \"Height of visual object\";
//   input Real dryFrictionWheelJoint1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint1.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint1.cylinder.lengthDirection[1],dryFrictionWheelJoint1.cylinder.lengthDirection[2],dryFrictionWheelJoint1.cylinder.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint1.cylinder.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.cylinder.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint1.cylinder.lengthDirection[1] / dryFrictionWheelJoint1.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint1.cylinder.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.cylinder.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint1.cylinder.lengthDirection[2] / dryFrictionWheelJoint1.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint1.cylinder.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.cylinder.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint1.cylinder.lengthDirection[3] / dryFrictionWheelJoint1.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint1.cylinder.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint1.cylinder.e_x[2] * dryFrictionWheelJoint1.cylinder.widthDirection[3] - dryFrictionWheelJoint1.cylinder.e_x[3] * dryFrictionWheelJoint1.cylinder.widthDirection[2];
//   protected Real dryFrictionWheelJoint1.cylinder.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint1.cylinder.e_x[3] * dryFrictionWheelJoint1.cylinder.widthDirection[1] - dryFrictionWheelJoint1.cylinder.e_x[1] * dryFrictionWheelJoint1.cylinder.widthDirection[3];
//   protected Real dryFrictionWheelJoint1.cylinder.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint1.cylinder.e_x[1] * dryFrictionWheelJoint1.cylinder.widthDirection[2] - dryFrictionWheelJoint1.cylinder.e_x[2] * dryFrictionWheelJoint1.cylinder.widthDirection[1];
//   protected Real dryFrictionWheelJoint1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.cylinder.e_x[1],dryFrictionWheelJoint1.cylinder.e_x[2],dryFrictionWheelJoint1.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.cylinder.widthDirection[1],dryFrictionWheelJoint1.cylinder.widthDirection[2],dryFrictionWheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.cylinder.e_x[1],dryFrictionWheelJoint1.cylinder.e_x[2],dryFrictionWheelJoint1.cylinder.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.cylinder.e_x[1],dryFrictionWheelJoint1.cylinder.e_x[2],dryFrictionWheelJoint1.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.cylinder.widthDirection[1],dryFrictionWheelJoint1.cylinder.widthDirection[2],dryFrictionWheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.cylinder.e_x[1],dryFrictionWheelJoint1.cylinder.e_x[2],dryFrictionWheelJoint1.cylinder.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.cylinder.e_x[1],dryFrictionWheelJoint1.cylinder.e_x[2],dryFrictionWheelJoint1.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.cylinder.widthDirection[1],dryFrictionWheelJoint1.cylinder.widthDirection[2],dryFrictionWheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.cylinder.e_x[1],dryFrictionWheelJoint1.cylinder.e_x[2],dryFrictionWheelJoint1.cylinder.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint1.cylinder.Form;
//   output Real dryFrictionWheelJoint1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.cylinder.Material;
//   protected output Real dryFrictionWheelJoint1.cylinder.Extra;
//   parameter String dryFrictionWheelJoint1.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.rim1.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.rim1.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint1.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint1.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint1.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint1.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint1.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint1.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint1.rim1.lengthDirection[1],dryFrictionWheelJoint1.rim1.lengthDirection[2],dryFrictionWheelJoint1.rim1.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint1.rim1.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.rim1.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint1.rim1.lengthDirection[1] / dryFrictionWheelJoint1.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint1.rim1.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.rim1.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint1.rim1.lengthDirection[2] / dryFrictionWheelJoint1.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint1.rim1.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.rim1.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint1.rim1.lengthDirection[3] / dryFrictionWheelJoint1.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint1.rim1.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint1.rim1.e_x[2] * dryFrictionWheelJoint1.rim1.widthDirection[3] - dryFrictionWheelJoint1.rim1.e_x[3] * dryFrictionWheelJoint1.rim1.widthDirection[2];
//   protected Real dryFrictionWheelJoint1.rim1.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint1.rim1.e_x[3] * dryFrictionWheelJoint1.rim1.widthDirection[1] - dryFrictionWheelJoint1.rim1.e_x[1] * dryFrictionWheelJoint1.rim1.widthDirection[3];
//   protected Real dryFrictionWheelJoint1.rim1.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint1.rim1.e_x[1] * dryFrictionWheelJoint1.rim1.widthDirection[2] - dryFrictionWheelJoint1.rim1.e_x[2] * dryFrictionWheelJoint1.rim1.widthDirection[1];
//   protected Real dryFrictionWheelJoint1.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.rim1.e_x[1],dryFrictionWheelJoint1.rim1.e_x[2],dryFrictionWheelJoint1.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.rim1.widthDirection[1],dryFrictionWheelJoint1.rim1.widthDirection[2],dryFrictionWheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.rim1.e_x[1],dryFrictionWheelJoint1.rim1.e_x[2],dryFrictionWheelJoint1.rim1.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint1.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.rim1.e_x[1],dryFrictionWheelJoint1.rim1.e_x[2],dryFrictionWheelJoint1.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.rim1.widthDirection[1],dryFrictionWheelJoint1.rim1.widthDirection[2],dryFrictionWheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.rim1.e_x[1],dryFrictionWheelJoint1.rim1.e_x[2],dryFrictionWheelJoint1.rim1.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint1.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.rim1.e_x[1],dryFrictionWheelJoint1.rim1.e_x[2],dryFrictionWheelJoint1.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.rim1.widthDirection[1],dryFrictionWheelJoint1.rim1.widthDirection[2],dryFrictionWheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.rim1.e_x[1],dryFrictionWheelJoint1.rim1.e_x[2],dryFrictionWheelJoint1.rim1.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint1.rim1.Form;
//   output Real dryFrictionWheelJoint1.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint1.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.rim1.Material;
//   protected output Real dryFrictionWheelJoint1.rim1.Extra;
//   parameter String dryFrictionWheelJoint1.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint1.rim2.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.rim2.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint1.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint1.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint1.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint1.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint1.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint1.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint1.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint1.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint1.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint1.rim2.lengthDirection[1],dryFrictionWheelJoint1.rim2.lengthDirection[2],dryFrictionWheelJoint1.rim2.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint1.rim2.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.rim2.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint1.rim2.lengthDirection[1] / dryFrictionWheelJoint1.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint1.rim2.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.rim2.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint1.rim2.lengthDirection[2] / dryFrictionWheelJoint1.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint1.rim2.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint1.rim2.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint1.rim2.lengthDirection[3] / dryFrictionWheelJoint1.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint1.rim2.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint1.rim2.e_x[2] * dryFrictionWheelJoint1.rim2.widthDirection[3] - dryFrictionWheelJoint1.rim2.e_x[3] * dryFrictionWheelJoint1.rim2.widthDirection[2];
//   protected Real dryFrictionWheelJoint1.rim2.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint1.rim2.e_x[3] * dryFrictionWheelJoint1.rim2.widthDirection[1] - dryFrictionWheelJoint1.rim2.e_x[1] * dryFrictionWheelJoint1.rim2.widthDirection[3];
//   protected Real dryFrictionWheelJoint1.rim2.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint1.rim2.e_x[1] * dryFrictionWheelJoint1.rim2.widthDirection[2] - dryFrictionWheelJoint1.rim2.e_x[2] * dryFrictionWheelJoint1.rim2.widthDirection[1];
//   protected Real dryFrictionWheelJoint1.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.rim2.e_x[1],dryFrictionWheelJoint1.rim2.e_x[2],dryFrictionWheelJoint1.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.rim2.widthDirection[1],dryFrictionWheelJoint1.rim2.widthDirection[2],dryFrictionWheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.rim2.e_x[1],dryFrictionWheelJoint1.rim2.e_x[2],dryFrictionWheelJoint1.rim2.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint1.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.rim2.e_x[1],dryFrictionWheelJoint1.rim2.e_x[2],dryFrictionWheelJoint1.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.rim2.widthDirection[1],dryFrictionWheelJoint1.rim2.widthDirection[2],dryFrictionWheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.rim2.e_x[1],dryFrictionWheelJoint1.rim2.e_x[2],dryFrictionWheelJoint1.rim2.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint1.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint1.rim2.e_x[1],dryFrictionWheelJoint1.rim2.e_x[2],dryFrictionWheelJoint1.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint1.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint1.rim2.widthDirection[1],dryFrictionWheelJoint1.rim2.widthDirection[2],dryFrictionWheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint1.rim2.e_x[1],dryFrictionWheelJoint1.rim2.e_x[2],dryFrictionWheelJoint1.rim2.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint1.rim2.Form;
//   output Real dryFrictionWheelJoint1.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint1.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint1.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint1.rim2.Material;
//   protected output Real dryFrictionWheelJoint1.rim2.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 0.8 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real dryFrictionWheelJoint2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real dryFrictionWheelJoint2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real dryFrictionWheelJoint2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real dryFrictionWheelJoint2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real dryFrictionWheelJoint2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real dryFrictionWheelJoint2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real dryFrictionWheelJoint2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real dryFrictionWheelJoint2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real dryFrictionWheelJoint2.radius(quantity = \"Length\", unit = \"m\") = 0.2 \"radius of the wheel\";
//   parameter Real dryFrictionWheelJoint2.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint2.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint2.N(quantity = \"Force\", unit = \"N\") = 100.0 \"normal force\";
//   parameter Real dryFrictionWheelJoint2.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real dryFrictionWheelJoint2.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.2 \"sliding velocity\";
//   parameter Real dryFrictionWheelJoint2.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real dryFrictionWheelJoint2.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real dryFrictionWheelJoint2.e0[1] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint2.e0[2] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint2.R[1,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint2.R[1,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint2.R[2,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint2.R[2,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint2.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real dryFrictionWheelJoint2.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint2.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint2.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real dryFrictionWheelJoint2.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint2.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint2.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real dryFrictionWheelJoint2.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real dryFrictionWheelJoint2.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint2.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint2.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean dryFrictionWheelJoint2.animate = true \"enable Animation\";
//   parameter Boolean dryFrictionWheelJoint2.SimVis = false \"perform animation with SimVis\";
//   final parameter Real dryFrictionWheelJoint2.l(quantity = \"Length\", unit = \"m\") = sqrt(dryFrictionWheelJoint2.r[1] ^ 2.0 + dryFrictionWheelJoint2.r[2] ^ 2.0);
//   final parameter Real dryFrictionWheelJoint2.e[1] = dryFrictionWheelJoint2.r[1] / dryFrictionWheelJoint2.l \"normalized direction\";
//   final parameter Real dryFrictionWheelJoint2.e[2] = dryFrictionWheelJoint2.r[2] / dryFrictionWheelJoint2.l \"normalized direction\";
//   parameter String dryFrictionWheelJoint2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * dryFrictionWheelJoint2.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * dryFrictionWheelJoint2.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.lengthDirection[1](unit = \"1\") = -dryFrictionWheelJoint2.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.lengthDirection[2](unit = \"1\") = dryFrictionWheelJoint2.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real dryFrictionWheelJoint2.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint2.radius \"Width of visual object\";
//   input Real dryFrictionWheelJoint2.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint2.radius \"Height of visual object\";
//   input Real dryFrictionWheelJoint2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint2.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint2.cylinder.lengthDirection[1],dryFrictionWheelJoint2.cylinder.lengthDirection[2],dryFrictionWheelJoint2.cylinder.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint2.cylinder.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.cylinder.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint2.cylinder.lengthDirection[1] / dryFrictionWheelJoint2.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint2.cylinder.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.cylinder.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint2.cylinder.lengthDirection[2] / dryFrictionWheelJoint2.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint2.cylinder.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.cylinder.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint2.cylinder.lengthDirection[3] / dryFrictionWheelJoint2.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint2.cylinder.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint2.cylinder.e_x[2] * dryFrictionWheelJoint2.cylinder.widthDirection[3] - dryFrictionWheelJoint2.cylinder.e_x[3] * dryFrictionWheelJoint2.cylinder.widthDirection[2];
//   protected Real dryFrictionWheelJoint2.cylinder.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint2.cylinder.e_x[3] * dryFrictionWheelJoint2.cylinder.widthDirection[1] - dryFrictionWheelJoint2.cylinder.e_x[1] * dryFrictionWheelJoint2.cylinder.widthDirection[3];
//   protected Real dryFrictionWheelJoint2.cylinder.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint2.cylinder.e_x[1] * dryFrictionWheelJoint2.cylinder.widthDirection[2] - dryFrictionWheelJoint2.cylinder.e_x[2] * dryFrictionWheelJoint2.cylinder.widthDirection[1];
//   protected Real dryFrictionWheelJoint2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.cylinder.e_x[1],dryFrictionWheelJoint2.cylinder.e_x[2],dryFrictionWheelJoint2.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.cylinder.widthDirection[1],dryFrictionWheelJoint2.cylinder.widthDirection[2],dryFrictionWheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.cylinder.e_x[1],dryFrictionWheelJoint2.cylinder.e_x[2],dryFrictionWheelJoint2.cylinder.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.cylinder.e_x[1],dryFrictionWheelJoint2.cylinder.e_x[2],dryFrictionWheelJoint2.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.cylinder.widthDirection[1],dryFrictionWheelJoint2.cylinder.widthDirection[2],dryFrictionWheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.cylinder.e_x[1],dryFrictionWheelJoint2.cylinder.e_x[2],dryFrictionWheelJoint2.cylinder.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.cylinder.e_x[1],dryFrictionWheelJoint2.cylinder.e_x[2],dryFrictionWheelJoint2.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.cylinder.widthDirection[1],dryFrictionWheelJoint2.cylinder.widthDirection[2],dryFrictionWheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.cylinder.e_x[1],dryFrictionWheelJoint2.cylinder.e_x[2],dryFrictionWheelJoint2.cylinder.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint2.cylinder.Form;
//   output Real dryFrictionWheelJoint2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.cylinder.Material;
//   protected output Real dryFrictionWheelJoint2.cylinder.Extra;
//   parameter String dryFrictionWheelJoint2.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.rim1.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.rim1.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint2.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint2.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint2.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint2.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint2.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint2.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint2.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint2.rim1.lengthDirection[1],dryFrictionWheelJoint2.rim1.lengthDirection[2],dryFrictionWheelJoint2.rim1.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint2.rim1.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.rim1.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint2.rim1.lengthDirection[1] / dryFrictionWheelJoint2.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint2.rim1.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.rim1.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint2.rim1.lengthDirection[2] / dryFrictionWheelJoint2.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint2.rim1.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.rim1.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint2.rim1.lengthDirection[3] / dryFrictionWheelJoint2.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint2.rim1.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint2.rim1.e_x[2] * dryFrictionWheelJoint2.rim1.widthDirection[3] - dryFrictionWheelJoint2.rim1.e_x[3] * dryFrictionWheelJoint2.rim1.widthDirection[2];
//   protected Real dryFrictionWheelJoint2.rim1.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint2.rim1.e_x[3] * dryFrictionWheelJoint2.rim1.widthDirection[1] - dryFrictionWheelJoint2.rim1.e_x[1] * dryFrictionWheelJoint2.rim1.widthDirection[3];
//   protected Real dryFrictionWheelJoint2.rim1.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint2.rim1.e_x[1] * dryFrictionWheelJoint2.rim1.widthDirection[2] - dryFrictionWheelJoint2.rim1.e_x[2] * dryFrictionWheelJoint2.rim1.widthDirection[1];
//   protected Real dryFrictionWheelJoint2.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.rim1.e_x[1],dryFrictionWheelJoint2.rim1.e_x[2],dryFrictionWheelJoint2.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.rim1.widthDirection[1],dryFrictionWheelJoint2.rim1.widthDirection[2],dryFrictionWheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.rim1.e_x[1],dryFrictionWheelJoint2.rim1.e_x[2],dryFrictionWheelJoint2.rim1.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint2.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.rim1.e_x[1],dryFrictionWheelJoint2.rim1.e_x[2],dryFrictionWheelJoint2.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.rim1.widthDirection[1],dryFrictionWheelJoint2.rim1.widthDirection[2],dryFrictionWheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.rim1.e_x[1],dryFrictionWheelJoint2.rim1.e_x[2],dryFrictionWheelJoint2.rim1.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint2.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.rim1.e_x[1],dryFrictionWheelJoint2.rim1.e_x[2],dryFrictionWheelJoint2.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.rim1.widthDirection[1],dryFrictionWheelJoint2.rim1.widthDirection[2],dryFrictionWheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.rim1.e_x[1],dryFrictionWheelJoint2.rim1.e_x[2],dryFrictionWheelJoint2.rim1.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint2.rim1.Form;
//   output Real dryFrictionWheelJoint2.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint2.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.rim1.Material;
//   protected output Real dryFrictionWheelJoint2.rim1.Extra;
//   parameter String dryFrictionWheelJoint2.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint2.rim2.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.rim2.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint2.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint2.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint2.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint2.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint2.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint2.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint2.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint2.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint2.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint2.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint2.rim2.lengthDirection[1],dryFrictionWheelJoint2.rim2.lengthDirection[2],dryFrictionWheelJoint2.rim2.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint2.rim2.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.rim2.abs_n_x < 1e-10) then 1.0 else dryFrictionWheelJoint2.rim2.lengthDirection[1] / dryFrictionWheelJoint2.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint2.rim2.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.rim2.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint2.rim2.lengthDirection[2] / dryFrictionWheelJoint2.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint2.rim2.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint2.rim2.abs_n_x < 1e-10) then 0.0 else dryFrictionWheelJoint2.rim2.lengthDirection[3] / dryFrictionWheelJoint2.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint2.rim2.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint2.rim2.e_x[2] * dryFrictionWheelJoint2.rim2.widthDirection[3] - dryFrictionWheelJoint2.rim2.e_x[3] * dryFrictionWheelJoint2.rim2.widthDirection[2];
//   protected Real dryFrictionWheelJoint2.rim2.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint2.rim2.e_x[3] * dryFrictionWheelJoint2.rim2.widthDirection[1] - dryFrictionWheelJoint2.rim2.e_x[1] * dryFrictionWheelJoint2.rim2.widthDirection[3];
//   protected Real dryFrictionWheelJoint2.rim2.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint2.rim2.e_x[1] * dryFrictionWheelJoint2.rim2.widthDirection[2] - dryFrictionWheelJoint2.rim2.e_x[2] * dryFrictionWheelJoint2.rim2.widthDirection[1];
//   protected Real dryFrictionWheelJoint2.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.rim2.e_x[1],dryFrictionWheelJoint2.rim2.e_x[2],dryFrictionWheelJoint2.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.rim2.widthDirection[1],dryFrictionWheelJoint2.rim2.widthDirection[2],dryFrictionWheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.rim2.e_x[1],dryFrictionWheelJoint2.rim2.e_x[2],dryFrictionWheelJoint2.rim2.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint2.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.rim2.e_x[1],dryFrictionWheelJoint2.rim2.e_x[2],dryFrictionWheelJoint2.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.rim2.widthDirection[1],dryFrictionWheelJoint2.rim2.widthDirection[2],dryFrictionWheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.rim2.e_x[1],dryFrictionWheelJoint2.rim2.e_x[2],dryFrictionWheelJoint2.rim2.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint2.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint2.rim2.e_x[1],dryFrictionWheelJoint2.rim2.e_x[2],dryFrictionWheelJoint2.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint2.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {dryFrictionWheelJoint2.rim2.widthDirection[1],dryFrictionWheelJoint2.rim2.widthDirection[2],dryFrictionWheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint2.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{dryFrictionWheelJoint2.rim2.e_x[1],dryFrictionWheelJoint2.rim2.e_x[2],dryFrictionWheelJoint2.rim2.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint2.rim2.Form;
//   output Real dryFrictionWheelJoint2.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint2.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint2.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint2.rim2.Material;
//   protected output Real dryFrictionWheelJoint2.rim2.Extra;
//   Real fixedRotation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedRotation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedRotation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedRotation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedRotation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedRotation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedRotation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedRotation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedRotation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedRotation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedRotation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedRotation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedRotation.alpha(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -0.2090729910964 \"fixed rotation angle\";
//   parameter Boolean constantTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real constantTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real constantTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real constantTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real constantTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real constantTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real constantTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   parameter Boolean constantTorque1.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real constantTorque1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real constantTorque1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real constantTorque1.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real constantTorque1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real constantTorque1.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 3.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real constantTorque1.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   dryFrictionWheelJoint1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint1.cylinder.shapeType);
//   dryFrictionWheelJoint1.cylinder.rxvisobj[1] = dryFrictionWheelJoint1.cylinder.R.T[1,1] * dryFrictionWheelJoint1.cylinder.e_x[1] + dryFrictionWheelJoint1.cylinder.R.T[2,1] * dryFrictionWheelJoint1.cylinder.e_x[2] + dryFrictionWheelJoint1.cylinder.R.T[3,1] * dryFrictionWheelJoint1.cylinder.e_x[3];
//   dryFrictionWheelJoint1.cylinder.rxvisobj[2] = dryFrictionWheelJoint1.cylinder.R.T[1,2] * dryFrictionWheelJoint1.cylinder.e_x[1] + dryFrictionWheelJoint1.cylinder.R.T[2,2] * dryFrictionWheelJoint1.cylinder.e_x[2] + dryFrictionWheelJoint1.cylinder.R.T[3,2] * dryFrictionWheelJoint1.cylinder.e_x[3];
//   dryFrictionWheelJoint1.cylinder.rxvisobj[3] = dryFrictionWheelJoint1.cylinder.R.T[1,3] * dryFrictionWheelJoint1.cylinder.e_x[1] + dryFrictionWheelJoint1.cylinder.R.T[2,3] * dryFrictionWheelJoint1.cylinder.e_x[2] + dryFrictionWheelJoint1.cylinder.R.T[3,3] * dryFrictionWheelJoint1.cylinder.e_x[3];
//   dryFrictionWheelJoint1.cylinder.ryvisobj[1] = dryFrictionWheelJoint1.cylinder.R.T[1,1] * dryFrictionWheelJoint1.cylinder.e_y[1] + dryFrictionWheelJoint1.cylinder.R.T[2,1] * dryFrictionWheelJoint1.cylinder.e_y[2] + dryFrictionWheelJoint1.cylinder.R.T[3,1] * dryFrictionWheelJoint1.cylinder.e_y[3];
//   dryFrictionWheelJoint1.cylinder.ryvisobj[2] = dryFrictionWheelJoint1.cylinder.R.T[1,2] * dryFrictionWheelJoint1.cylinder.e_y[1] + dryFrictionWheelJoint1.cylinder.R.T[2,2] * dryFrictionWheelJoint1.cylinder.e_y[2] + dryFrictionWheelJoint1.cylinder.R.T[3,2] * dryFrictionWheelJoint1.cylinder.e_y[3];
//   dryFrictionWheelJoint1.cylinder.ryvisobj[3] = dryFrictionWheelJoint1.cylinder.R.T[1,3] * dryFrictionWheelJoint1.cylinder.e_y[1] + dryFrictionWheelJoint1.cylinder.R.T[2,3] * dryFrictionWheelJoint1.cylinder.e_y[2] + dryFrictionWheelJoint1.cylinder.R.T[3,3] * dryFrictionWheelJoint1.cylinder.e_y[3];
//   dryFrictionWheelJoint1.cylinder.rvisobj = dryFrictionWheelJoint1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint1.cylinder.R.T[1,1],dryFrictionWheelJoint1.cylinder.R.T[1,2],dryFrictionWheelJoint1.cylinder.R.T[1,3]},{dryFrictionWheelJoint1.cylinder.R.T[2,1],dryFrictionWheelJoint1.cylinder.R.T[2,2],dryFrictionWheelJoint1.cylinder.R.T[2,3]},{dryFrictionWheelJoint1.cylinder.R.T[3,1],dryFrictionWheelJoint1.cylinder.R.T[3,2],dryFrictionWheelJoint1.cylinder.R.T[3,3]}},{dryFrictionWheelJoint1.cylinder.r_shape[1],dryFrictionWheelJoint1.cylinder.r_shape[2],dryFrictionWheelJoint1.cylinder.r_shape[3]});
//   dryFrictionWheelJoint1.cylinder.size[1] = dryFrictionWheelJoint1.cylinder.length;
//   dryFrictionWheelJoint1.cylinder.size[2] = dryFrictionWheelJoint1.cylinder.width;
//   dryFrictionWheelJoint1.cylinder.size[3] = dryFrictionWheelJoint1.cylinder.height;
//   dryFrictionWheelJoint1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint1.cylinder.color[1] / 255.0,dryFrictionWheelJoint1.cylinder.color[2] / 255.0,dryFrictionWheelJoint1.cylinder.color[3] / 255.0,dryFrictionWheelJoint1.cylinder.specularCoefficient);
//   dryFrictionWheelJoint1.cylinder.Extra = dryFrictionWheelJoint1.cylinder.extra;
//   dryFrictionWheelJoint1.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint1.e0[2],dryFrictionWheelJoint1.e0[1],0.0},dryFrictionWheelJoint1.flange_a.phi,0.0);
//   dryFrictionWheelJoint1.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint1.rim1.shapeType);
//   dryFrictionWheelJoint1.rim1.rxvisobj[1] = dryFrictionWheelJoint1.rim1.R.T[1,1] * dryFrictionWheelJoint1.rim1.e_x[1] + dryFrictionWheelJoint1.rim1.R.T[2,1] * dryFrictionWheelJoint1.rim1.e_x[2] + dryFrictionWheelJoint1.rim1.R.T[3,1] * dryFrictionWheelJoint1.rim1.e_x[3];
//   dryFrictionWheelJoint1.rim1.rxvisobj[2] = dryFrictionWheelJoint1.rim1.R.T[1,2] * dryFrictionWheelJoint1.rim1.e_x[1] + dryFrictionWheelJoint1.rim1.R.T[2,2] * dryFrictionWheelJoint1.rim1.e_x[2] + dryFrictionWheelJoint1.rim1.R.T[3,2] * dryFrictionWheelJoint1.rim1.e_x[3];
//   dryFrictionWheelJoint1.rim1.rxvisobj[3] = dryFrictionWheelJoint1.rim1.R.T[1,3] * dryFrictionWheelJoint1.rim1.e_x[1] + dryFrictionWheelJoint1.rim1.R.T[2,3] * dryFrictionWheelJoint1.rim1.e_x[2] + dryFrictionWheelJoint1.rim1.R.T[3,3] * dryFrictionWheelJoint1.rim1.e_x[3];
//   dryFrictionWheelJoint1.rim1.ryvisobj[1] = dryFrictionWheelJoint1.rim1.R.T[1,1] * dryFrictionWheelJoint1.rim1.e_y[1] + dryFrictionWheelJoint1.rim1.R.T[2,1] * dryFrictionWheelJoint1.rim1.e_y[2] + dryFrictionWheelJoint1.rim1.R.T[3,1] * dryFrictionWheelJoint1.rim1.e_y[3];
//   dryFrictionWheelJoint1.rim1.ryvisobj[2] = dryFrictionWheelJoint1.rim1.R.T[1,2] * dryFrictionWheelJoint1.rim1.e_y[1] + dryFrictionWheelJoint1.rim1.R.T[2,2] * dryFrictionWheelJoint1.rim1.e_y[2] + dryFrictionWheelJoint1.rim1.R.T[3,2] * dryFrictionWheelJoint1.rim1.e_y[3];
//   dryFrictionWheelJoint1.rim1.ryvisobj[3] = dryFrictionWheelJoint1.rim1.R.T[1,3] * dryFrictionWheelJoint1.rim1.e_y[1] + dryFrictionWheelJoint1.rim1.R.T[2,3] * dryFrictionWheelJoint1.rim1.e_y[2] + dryFrictionWheelJoint1.rim1.R.T[3,3] * dryFrictionWheelJoint1.rim1.e_y[3];
//   dryFrictionWheelJoint1.rim1.rvisobj = dryFrictionWheelJoint1.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint1.rim1.R.T[1,1],dryFrictionWheelJoint1.rim1.R.T[1,2],dryFrictionWheelJoint1.rim1.R.T[1,3]},{dryFrictionWheelJoint1.rim1.R.T[2,1],dryFrictionWheelJoint1.rim1.R.T[2,2],dryFrictionWheelJoint1.rim1.R.T[2,3]},{dryFrictionWheelJoint1.rim1.R.T[3,1],dryFrictionWheelJoint1.rim1.R.T[3,2],dryFrictionWheelJoint1.rim1.R.T[3,3]}},{dryFrictionWheelJoint1.rim1.r_shape[1],dryFrictionWheelJoint1.rim1.r_shape[2],dryFrictionWheelJoint1.rim1.r_shape[3]});
//   dryFrictionWheelJoint1.rim1.size[1] = dryFrictionWheelJoint1.rim1.length;
//   dryFrictionWheelJoint1.rim1.size[2] = dryFrictionWheelJoint1.rim1.width;
//   dryFrictionWheelJoint1.rim1.size[3] = dryFrictionWheelJoint1.rim1.height;
//   dryFrictionWheelJoint1.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint1.rim1.color[1] / 255.0,dryFrictionWheelJoint1.rim1.color[2] / 255.0,dryFrictionWheelJoint1.rim1.color[3] / 255.0,dryFrictionWheelJoint1.rim1.specularCoefficient);
//   dryFrictionWheelJoint1.rim1.Extra = dryFrictionWheelJoint1.rim1.extra;
//   dryFrictionWheelJoint1.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint1.e0[2],dryFrictionWheelJoint1.e0[1],0.0},1.5707963267949 + dryFrictionWheelJoint1.flange_a.phi,0.0);
//   dryFrictionWheelJoint1.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint1.rim2.shapeType);
//   dryFrictionWheelJoint1.rim2.rxvisobj[1] = dryFrictionWheelJoint1.rim2.R.T[1,1] * dryFrictionWheelJoint1.rim2.e_x[1] + dryFrictionWheelJoint1.rim2.R.T[2,1] * dryFrictionWheelJoint1.rim2.e_x[2] + dryFrictionWheelJoint1.rim2.R.T[3,1] * dryFrictionWheelJoint1.rim2.e_x[3];
//   dryFrictionWheelJoint1.rim2.rxvisobj[2] = dryFrictionWheelJoint1.rim2.R.T[1,2] * dryFrictionWheelJoint1.rim2.e_x[1] + dryFrictionWheelJoint1.rim2.R.T[2,2] * dryFrictionWheelJoint1.rim2.e_x[2] + dryFrictionWheelJoint1.rim2.R.T[3,2] * dryFrictionWheelJoint1.rim2.e_x[3];
//   dryFrictionWheelJoint1.rim2.rxvisobj[3] = dryFrictionWheelJoint1.rim2.R.T[1,3] * dryFrictionWheelJoint1.rim2.e_x[1] + dryFrictionWheelJoint1.rim2.R.T[2,3] * dryFrictionWheelJoint1.rim2.e_x[2] + dryFrictionWheelJoint1.rim2.R.T[3,3] * dryFrictionWheelJoint1.rim2.e_x[3];
//   dryFrictionWheelJoint1.rim2.ryvisobj[1] = dryFrictionWheelJoint1.rim2.R.T[1,1] * dryFrictionWheelJoint1.rim2.e_y[1] + dryFrictionWheelJoint1.rim2.R.T[2,1] * dryFrictionWheelJoint1.rim2.e_y[2] + dryFrictionWheelJoint1.rim2.R.T[3,1] * dryFrictionWheelJoint1.rim2.e_y[3];
//   dryFrictionWheelJoint1.rim2.ryvisobj[2] = dryFrictionWheelJoint1.rim2.R.T[1,2] * dryFrictionWheelJoint1.rim2.e_y[1] + dryFrictionWheelJoint1.rim2.R.T[2,2] * dryFrictionWheelJoint1.rim2.e_y[2] + dryFrictionWheelJoint1.rim2.R.T[3,2] * dryFrictionWheelJoint1.rim2.e_y[3];
//   dryFrictionWheelJoint1.rim2.ryvisobj[3] = dryFrictionWheelJoint1.rim2.R.T[1,3] * dryFrictionWheelJoint1.rim2.e_y[1] + dryFrictionWheelJoint1.rim2.R.T[2,3] * dryFrictionWheelJoint1.rim2.e_y[2] + dryFrictionWheelJoint1.rim2.R.T[3,3] * dryFrictionWheelJoint1.rim2.e_y[3];
//   dryFrictionWheelJoint1.rim2.rvisobj = dryFrictionWheelJoint1.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint1.rim2.R.T[1,1],dryFrictionWheelJoint1.rim2.R.T[1,2],dryFrictionWheelJoint1.rim2.R.T[1,3]},{dryFrictionWheelJoint1.rim2.R.T[2,1],dryFrictionWheelJoint1.rim2.R.T[2,2],dryFrictionWheelJoint1.rim2.R.T[2,3]},{dryFrictionWheelJoint1.rim2.R.T[3,1],dryFrictionWheelJoint1.rim2.R.T[3,2],dryFrictionWheelJoint1.rim2.R.T[3,3]}},{dryFrictionWheelJoint1.rim2.r_shape[1],dryFrictionWheelJoint1.rim2.r_shape[2],dryFrictionWheelJoint1.rim2.r_shape[3]});
//   dryFrictionWheelJoint1.rim2.size[1] = dryFrictionWheelJoint1.rim2.length;
//   dryFrictionWheelJoint1.rim2.size[2] = dryFrictionWheelJoint1.rim2.width;
//   dryFrictionWheelJoint1.rim2.size[3] = dryFrictionWheelJoint1.rim2.height;
//   dryFrictionWheelJoint1.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint1.rim2.color[1] / 255.0,dryFrictionWheelJoint1.rim2.color[2] / 255.0,dryFrictionWheelJoint1.rim2.color[3] / 255.0,dryFrictionWheelJoint1.rim2.specularCoefficient);
//   dryFrictionWheelJoint1.rim2.Extra = dryFrictionWheelJoint1.rim2.extra;
//   dryFrictionWheelJoint1.R[1,1] = cos(dryFrictionWheelJoint1.frame_a.phi);
//   dryFrictionWheelJoint1.R[1,2] = sin(dryFrictionWheelJoint1.frame_a.phi);
//   dryFrictionWheelJoint1.R[2,1] = -sin(dryFrictionWheelJoint1.frame_a.phi);
//   dryFrictionWheelJoint1.R[2,2] = cos(dryFrictionWheelJoint1.frame_a.phi);
//   dryFrictionWheelJoint1.e0[1] = dryFrictionWheelJoint1.R[1,1] * dryFrictionWheelJoint1.e[1] + dryFrictionWheelJoint1.R[1,2] * dryFrictionWheelJoint1.e[2];
//   dryFrictionWheelJoint1.e0[2] = dryFrictionWheelJoint1.R[2,1] * dryFrictionWheelJoint1.e[1] + dryFrictionWheelJoint1.R[2,2] * dryFrictionWheelJoint1.e[2];
//   dryFrictionWheelJoint1.v[1] = der(dryFrictionWheelJoint1.frame_a.x);
//   dryFrictionWheelJoint1.v[2] = der(dryFrictionWheelJoint1.frame_a.y);
//   dryFrictionWheelJoint1.w_roll = der(dryFrictionWheelJoint1.flange_a.phi);
//   dryFrictionWheelJoint1.v_long = dryFrictionWheelJoint1.v[1] * dryFrictionWheelJoint1.e0[1] + dryFrictionWheelJoint1.v[2] * dryFrictionWheelJoint1.e0[2];
//   dryFrictionWheelJoint1.v_lat = (-dryFrictionWheelJoint1.v[1]) * dryFrictionWheelJoint1.e0[2] + dryFrictionWheelJoint1.v[2] * dryFrictionWheelJoint1.e0[1];
//   dryFrictionWheelJoint1.v_slip_lat = dryFrictionWheelJoint1.v_lat;
//   dryFrictionWheelJoint1.v_slip_long = dryFrictionWheelJoint1.v_long - dryFrictionWheelJoint1.radius * dryFrictionWheelJoint1.w_roll;
//   dryFrictionWheelJoint1.v_slip = 0.0001 + sqrt(dryFrictionWheelJoint1.v_slip_long ^ 2.0 + dryFrictionWheelJoint1.v_slip_lat ^ 2.0);
//   (-dryFrictionWheelJoint1.f_long) * dryFrictionWheelJoint1.radius = dryFrictionWheelJoint1.flange_a.tau;
//   dryFrictionWheelJoint1.frame_a.t = 0.0;
//   dryFrictionWheelJoint1.f = dryFrictionWheelJoint1.N * PlanarMechanicsV4.Utilities.TripleS_Func(dryFrictionWheelJoint1.vAdhesion,dryFrictionWheelJoint1.vSlide,dryFrictionWheelJoint1.mu_A,dryFrictionWheelJoint1.mu_S,dryFrictionWheelJoint1.v_slip);
//   dryFrictionWheelJoint1.f_long = (dryFrictionWheelJoint1.f * dryFrictionWheelJoint1.v_slip_long) / dryFrictionWheelJoint1.v_slip;
//   dryFrictionWheelJoint1.f_lat = (dryFrictionWheelJoint1.f * dryFrictionWheelJoint1.v_slip_lat) / dryFrictionWheelJoint1.v_slip;
//   dryFrictionWheelJoint1.f_long = dryFrictionWheelJoint1.frame_a.fx * dryFrictionWheelJoint1.e0[1] + dryFrictionWheelJoint1.frame_a.fy * dryFrictionWheelJoint1.e0[2];
//   dryFrictionWheelJoint1.f_lat = dryFrictionWheelJoint1.frame_a.fy * dryFrictionWheelJoint1.e0[1] + (-dryFrictionWheelJoint1.frame_a.fx) * dryFrictionWheelJoint1.e0[2];
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   dryFrictionWheelJoint2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint2.cylinder.shapeType);
//   dryFrictionWheelJoint2.cylinder.rxvisobj[1] = dryFrictionWheelJoint2.cylinder.R.T[1,1] * dryFrictionWheelJoint2.cylinder.e_x[1] + dryFrictionWheelJoint2.cylinder.R.T[2,1] * dryFrictionWheelJoint2.cylinder.e_x[2] + dryFrictionWheelJoint2.cylinder.R.T[3,1] * dryFrictionWheelJoint2.cylinder.e_x[3];
//   dryFrictionWheelJoint2.cylinder.rxvisobj[2] = dryFrictionWheelJoint2.cylinder.R.T[1,2] * dryFrictionWheelJoint2.cylinder.e_x[1] + dryFrictionWheelJoint2.cylinder.R.T[2,2] * dryFrictionWheelJoint2.cylinder.e_x[2] + dryFrictionWheelJoint2.cylinder.R.T[3,2] * dryFrictionWheelJoint2.cylinder.e_x[3];
//   dryFrictionWheelJoint2.cylinder.rxvisobj[3] = dryFrictionWheelJoint2.cylinder.R.T[1,3] * dryFrictionWheelJoint2.cylinder.e_x[1] + dryFrictionWheelJoint2.cylinder.R.T[2,3] * dryFrictionWheelJoint2.cylinder.e_x[2] + dryFrictionWheelJoint2.cylinder.R.T[3,3] * dryFrictionWheelJoint2.cylinder.e_x[3];
//   dryFrictionWheelJoint2.cylinder.ryvisobj[1] = dryFrictionWheelJoint2.cylinder.R.T[1,1] * dryFrictionWheelJoint2.cylinder.e_y[1] + dryFrictionWheelJoint2.cylinder.R.T[2,1] * dryFrictionWheelJoint2.cylinder.e_y[2] + dryFrictionWheelJoint2.cylinder.R.T[3,1] * dryFrictionWheelJoint2.cylinder.e_y[3];
//   dryFrictionWheelJoint2.cylinder.ryvisobj[2] = dryFrictionWheelJoint2.cylinder.R.T[1,2] * dryFrictionWheelJoint2.cylinder.e_y[1] + dryFrictionWheelJoint2.cylinder.R.T[2,2] * dryFrictionWheelJoint2.cylinder.e_y[2] + dryFrictionWheelJoint2.cylinder.R.T[3,2] * dryFrictionWheelJoint2.cylinder.e_y[3];
//   dryFrictionWheelJoint2.cylinder.ryvisobj[3] = dryFrictionWheelJoint2.cylinder.R.T[1,3] * dryFrictionWheelJoint2.cylinder.e_y[1] + dryFrictionWheelJoint2.cylinder.R.T[2,3] * dryFrictionWheelJoint2.cylinder.e_y[2] + dryFrictionWheelJoint2.cylinder.R.T[3,3] * dryFrictionWheelJoint2.cylinder.e_y[3];
//   dryFrictionWheelJoint2.cylinder.rvisobj = dryFrictionWheelJoint2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint2.cylinder.R.T[1,1],dryFrictionWheelJoint2.cylinder.R.T[1,2],dryFrictionWheelJoint2.cylinder.R.T[1,3]},{dryFrictionWheelJoint2.cylinder.R.T[2,1],dryFrictionWheelJoint2.cylinder.R.T[2,2],dryFrictionWheelJoint2.cylinder.R.T[2,3]},{dryFrictionWheelJoint2.cylinder.R.T[3,1],dryFrictionWheelJoint2.cylinder.R.T[3,2],dryFrictionWheelJoint2.cylinder.R.T[3,3]}},{dryFrictionWheelJoint2.cylinder.r_shape[1],dryFrictionWheelJoint2.cylinder.r_shape[2],dryFrictionWheelJoint2.cylinder.r_shape[3]});
//   dryFrictionWheelJoint2.cylinder.size[1] = dryFrictionWheelJoint2.cylinder.length;
//   dryFrictionWheelJoint2.cylinder.size[2] = dryFrictionWheelJoint2.cylinder.width;
//   dryFrictionWheelJoint2.cylinder.size[3] = dryFrictionWheelJoint2.cylinder.height;
//   dryFrictionWheelJoint2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint2.cylinder.color[1] / 255.0,dryFrictionWheelJoint2.cylinder.color[2] / 255.0,dryFrictionWheelJoint2.cylinder.color[3] / 255.0,dryFrictionWheelJoint2.cylinder.specularCoefficient);
//   dryFrictionWheelJoint2.cylinder.Extra = dryFrictionWheelJoint2.cylinder.extra;
//   dryFrictionWheelJoint2.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint2.e0[2],dryFrictionWheelJoint2.e0[1],0.0},dryFrictionWheelJoint2.flange_a.phi,0.0);
//   dryFrictionWheelJoint2.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint2.rim1.shapeType);
//   dryFrictionWheelJoint2.rim1.rxvisobj[1] = dryFrictionWheelJoint2.rim1.R.T[1,1] * dryFrictionWheelJoint2.rim1.e_x[1] + dryFrictionWheelJoint2.rim1.R.T[2,1] * dryFrictionWheelJoint2.rim1.e_x[2] + dryFrictionWheelJoint2.rim1.R.T[3,1] * dryFrictionWheelJoint2.rim1.e_x[3];
//   dryFrictionWheelJoint2.rim1.rxvisobj[2] = dryFrictionWheelJoint2.rim1.R.T[1,2] * dryFrictionWheelJoint2.rim1.e_x[1] + dryFrictionWheelJoint2.rim1.R.T[2,2] * dryFrictionWheelJoint2.rim1.e_x[2] + dryFrictionWheelJoint2.rim1.R.T[3,2] * dryFrictionWheelJoint2.rim1.e_x[3];
//   dryFrictionWheelJoint2.rim1.rxvisobj[3] = dryFrictionWheelJoint2.rim1.R.T[1,3] * dryFrictionWheelJoint2.rim1.e_x[1] + dryFrictionWheelJoint2.rim1.R.T[2,3] * dryFrictionWheelJoint2.rim1.e_x[2] + dryFrictionWheelJoint2.rim1.R.T[3,3] * dryFrictionWheelJoint2.rim1.e_x[3];
//   dryFrictionWheelJoint2.rim1.ryvisobj[1] = dryFrictionWheelJoint2.rim1.R.T[1,1] * dryFrictionWheelJoint2.rim1.e_y[1] + dryFrictionWheelJoint2.rim1.R.T[2,1] * dryFrictionWheelJoint2.rim1.e_y[2] + dryFrictionWheelJoint2.rim1.R.T[3,1] * dryFrictionWheelJoint2.rim1.e_y[3];
//   dryFrictionWheelJoint2.rim1.ryvisobj[2] = dryFrictionWheelJoint2.rim1.R.T[1,2] * dryFrictionWheelJoint2.rim1.e_y[1] + dryFrictionWheelJoint2.rim1.R.T[2,2] * dryFrictionWheelJoint2.rim1.e_y[2] + dryFrictionWheelJoint2.rim1.R.T[3,2] * dryFrictionWheelJoint2.rim1.e_y[3];
//   dryFrictionWheelJoint2.rim1.ryvisobj[3] = dryFrictionWheelJoint2.rim1.R.T[1,3] * dryFrictionWheelJoint2.rim1.e_y[1] + dryFrictionWheelJoint2.rim1.R.T[2,3] * dryFrictionWheelJoint2.rim1.e_y[2] + dryFrictionWheelJoint2.rim1.R.T[3,3] * dryFrictionWheelJoint2.rim1.e_y[3];
//   dryFrictionWheelJoint2.rim1.rvisobj = dryFrictionWheelJoint2.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint2.rim1.R.T[1,1],dryFrictionWheelJoint2.rim1.R.T[1,2],dryFrictionWheelJoint2.rim1.R.T[1,3]},{dryFrictionWheelJoint2.rim1.R.T[2,1],dryFrictionWheelJoint2.rim1.R.T[2,2],dryFrictionWheelJoint2.rim1.R.T[2,3]},{dryFrictionWheelJoint2.rim1.R.T[3,1],dryFrictionWheelJoint2.rim1.R.T[3,2],dryFrictionWheelJoint2.rim1.R.T[3,3]}},{dryFrictionWheelJoint2.rim1.r_shape[1],dryFrictionWheelJoint2.rim1.r_shape[2],dryFrictionWheelJoint2.rim1.r_shape[3]});
//   dryFrictionWheelJoint2.rim1.size[1] = dryFrictionWheelJoint2.rim1.length;
//   dryFrictionWheelJoint2.rim1.size[2] = dryFrictionWheelJoint2.rim1.width;
//   dryFrictionWheelJoint2.rim1.size[3] = dryFrictionWheelJoint2.rim1.height;
//   dryFrictionWheelJoint2.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint2.rim1.color[1] / 255.0,dryFrictionWheelJoint2.rim1.color[2] / 255.0,dryFrictionWheelJoint2.rim1.color[3] / 255.0,dryFrictionWheelJoint2.rim1.specularCoefficient);
//   dryFrictionWheelJoint2.rim1.Extra = dryFrictionWheelJoint2.rim1.extra;
//   dryFrictionWheelJoint2.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint2.e0[2],dryFrictionWheelJoint2.e0[1],0.0},1.5707963267949 + dryFrictionWheelJoint2.flange_a.phi,0.0);
//   dryFrictionWheelJoint2.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint2.rim2.shapeType);
//   dryFrictionWheelJoint2.rim2.rxvisobj[1] = dryFrictionWheelJoint2.rim2.R.T[1,1] * dryFrictionWheelJoint2.rim2.e_x[1] + dryFrictionWheelJoint2.rim2.R.T[2,1] * dryFrictionWheelJoint2.rim2.e_x[2] + dryFrictionWheelJoint2.rim2.R.T[3,1] * dryFrictionWheelJoint2.rim2.e_x[3];
//   dryFrictionWheelJoint2.rim2.rxvisobj[2] = dryFrictionWheelJoint2.rim2.R.T[1,2] * dryFrictionWheelJoint2.rim2.e_x[1] + dryFrictionWheelJoint2.rim2.R.T[2,2] * dryFrictionWheelJoint2.rim2.e_x[2] + dryFrictionWheelJoint2.rim2.R.T[3,2] * dryFrictionWheelJoint2.rim2.e_x[3];
//   dryFrictionWheelJoint2.rim2.rxvisobj[3] = dryFrictionWheelJoint2.rim2.R.T[1,3] * dryFrictionWheelJoint2.rim2.e_x[1] + dryFrictionWheelJoint2.rim2.R.T[2,3] * dryFrictionWheelJoint2.rim2.e_x[2] + dryFrictionWheelJoint2.rim2.R.T[3,3] * dryFrictionWheelJoint2.rim2.e_x[3];
//   dryFrictionWheelJoint2.rim2.ryvisobj[1] = dryFrictionWheelJoint2.rim2.R.T[1,1] * dryFrictionWheelJoint2.rim2.e_y[1] + dryFrictionWheelJoint2.rim2.R.T[2,1] * dryFrictionWheelJoint2.rim2.e_y[2] + dryFrictionWheelJoint2.rim2.R.T[3,1] * dryFrictionWheelJoint2.rim2.e_y[3];
//   dryFrictionWheelJoint2.rim2.ryvisobj[2] = dryFrictionWheelJoint2.rim2.R.T[1,2] * dryFrictionWheelJoint2.rim2.e_y[1] + dryFrictionWheelJoint2.rim2.R.T[2,2] * dryFrictionWheelJoint2.rim2.e_y[2] + dryFrictionWheelJoint2.rim2.R.T[3,2] * dryFrictionWheelJoint2.rim2.e_y[3];
//   dryFrictionWheelJoint2.rim2.ryvisobj[3] = dryFrictionWheelJoint2.rim2.R.T[1,3] * dryFrictionWheelJoint2.rim2.e_y[1] + dryFrictionWheelJoint2.rim2.R.T[2,3] * dryFrictionWheelJoint2.rim2.e_y[2] + dryFrictionWheelJoint2.rim2.R.T[3,3] * dryFrictionWheelJoint2.rim2.e_y[3];
//   dryFrictionWheelJoint2.rim2.rvisobj = dryFrictionWheelJoint2.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint2.rim2.R.T[1,1],dryFrictionWheelJoint2.rim2.R.T[1,2],dryFrictionWheelJoint2.rim2.R.T[1,3]},{dryFrictionWheelJoint2.rim2.R.T[2,1],dryFrictionWheelJoint2.rim2.R.T[2,2],dryFrictionWheelJoint2.rim2.R.T[2,3]},{dryFrictionWheelJoint2.rim2.R.T[3,1],dryFrictionWheelJoint2.rim2.R.T[3,2],dryFrictionWheelJoint2.rim2.R.T[3,3]}},{dryFrictionWheelJoint2.rim2.r_shape[1],dryFrictionWheelJoint2.rim2.r_shape[2],dryFrictionWheelJoint2.rim2.r_shape[3]});
//   dryFrictionWheelJoint2.rim2.size[1] = dryFrictionWheelJoint2.rim2.length;
//   dryFrictionWheelJoint2.rim2.size[2] = dryFrictionWheelJoint2.rim2.width;
//   dryFrictionWheelJoint2.rim2.size[3] = dryFrictionWheelJoint2.rim2.height;
//   dryFrictionWheelJoint2.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint2.rim2.color[1] / 255.0,dryFrictionWheelJoint2.rim2.color[2] / 255.0,dryFrictionWheelJoint2.rim2.color[3] / 255.0,dryFrictionWheelJoint2.rim2.specularCoefficient);
//   dryFrictionWheelJoint2.rim2.Extra = dryFrictionWheelJoint2.rim2.extra;
//   dryFrictionWheelJoint2.R[1,1] = cos(dryFrictionWheelJoint2.frame_a.phi);
//   dryFrictionWheelJoint2.R[1,2] = sin(dryFrictionWheelJoint2.frame_a.phi);
//   dryFrictionWheelJoint2.R[2,1] = -sin(dryFrictionWheelJoint2.frame_a.phi);
//   dryFrictionWheelJoint2.R[2,2] = cos(dryFrictionWheelJoint2.frame_a.phi);
//   dryFrictionWheelJoint2.e0[1] = dryFrictionWheelJoint2.R[1,1] * dryFrictionWheelJoint2.e[1] + dryFrictionWheelJoint2.R[1,2] * dryFrictionWheelJoint2.e[2];
//   dryFrictionWheelJoint2.e0[2] = dryFrictionWheelJoint2.R[2,1] * dryFrictionWheelJoint2.e[1] + dryFrictionWheelJoint2.R[2,2] * dryFrictionWheelJoint2.e[2];
//   dryFrictionWheelJoint2.v[1] = der(dryFrictionWheelJoint2.frame_a.x);
//   dryFrictionWheelJoint2.v[2] = der(dryFrictionWheelJoint2.frame_a.y);
//   dryFrictionWheelJoint2.w_roll = der(dryFrictionWheelJoint2.flange_a.phi);
//   dryFrictionWheelJoint2.v_long = dryFrictionWheelJoint2.v[1] * dryFrictionWheelJoint2.e0[1] + dryFrictionWheelJoint2.v[2] * dryFrictionWheelJoint2.e0[2];
//   dryFrictionWheelJoint2.v_lat = (-dryFrictionWheelJoint2.v[1]) * dryFrictionWheelJoint2.e0[2] + dryFrictionWheelJoint2.v[2] * dryFrictionWheelJoint2.e0[1];
//   dryFrictionWheelJoint2.v_slip_lat = dryFrictionWheelJoint2.v_lat;
//   dryFrictionWheelJoint2.v_slip_long = dryFrictionWheelJoint2.v_long - dryFrictionWheelJoint2.radius * dryFrictionWheelJoint2.w_roll;
//   dryFrictionWheelJoint2.v_slip = 0.0001 + sqrt(dryFrictionWheelJoint2.v_slip_long ^ 2.0 + dryFrictionWheelJoint2.v_slip_lat ^ 2.0);
//   (-dryFrictionWheelJoint2.f_long) * dryFrictionWheelJoint2.radius = dryFrictionWheelJoint2.flange_a.tau;
//   dryFrictionWheelJoint2.frame_a.t = 0.0;
//   dryFrictionWheelJoint2.f = dryFrictionWheelJoint2.N * PlanarMechanicsV4.Utilities.TripleS_Func(dryFrictionWheelJoint2.vAdhesion,dryFrictionWheelJoint2.vSlide,dryFrictionWheelJoint2.mu_A,dryFrictionWheelJoint2.mu_S,dryFrictionWheelJoint2.v_slip);
//   dryFrictionWheelJoint2.f_long = (dryFrictionWheelJoint2.f * dryFrictionWheelJoint2.v_slip_long) / dryFrictionWheelJoint2.v_slip;
//   dryFrictionWheelJoint2.f_lat = (dryFrictionWheelJoint2.f * dryFrictionWheelJoint2.v_slip_lat) / dryFrictionWheelJoint2.v_slip;
//   dryFrictionWheelJoint2.f_long = dryFrictionWheelJoint2.frame_a.fx * dryFrictionWheelJoint2.e0[1] + dryFrictionWheelJoint2.frame_a.fy * dryFrictionWheelJoint2.e0[2];
//   dryFrictionWheelJoint2.f_lat = dryFrictionWheelJoint2.frame_a.fy * dryFrictionWheelJoint2.e0[1] + (-dryFrictionWheelJoint2.frame_a.fx) * dryFrictionWheelJoint2.e0[2];
//   fixedRotation.frame_a.x = fixedRotation.frame_b.x;
//   fixedRotation.frame_a.y = fixedRotation.frame_b.y;
//   fixedRotation.frame_a.phi + fixedRotation.alpha = fixedRotation.frame_b.phi;
//   fixedRotation.frame_a.fx + fixedRotation.frame_b.fx = 0.0;
//   fixedRotation.frame_a.fy + fixedRotation.frame_b.fy = 0.0;
//   fixedRotation.frame_a.t + fixedRotation.frame_b.t = 0.0;
//   constantTorque.tau = -constantTorque.flange.tau;
//   constantTorque.tau = constantTorque.tau_constant;
//   constantTorque.phi = constantTorque.flange.phi - constantTorque.phi_support;
//   constantTorque.phi_support = 0.0;
//   constantTorque1.tau = -constantTorque1.flange.tau;
//   constantTorque1.tau = constantTorque1.tau_constant;
//   constantTorque1.phi = constantTorque1.flange.phi - constantTorque1.phi_support;
//   constantTorque1.phi_support = 0.0;
//   body.frame_a.t + dryFrictionWheelJoint1.frame_a.t + fixedRotation.frame_a.t = 0.0;
//   body.frame_a.fy + dryFrictionWheelJoint1.frame_a.fy + fixedRotation.frame_a.fy = 0.0;
//   body.frame_a.fx + dryFrictionWheelJoint1.frame_a.fx + fixedRotation.frame_a.fx = 0.0;
//   dryFrictionWheelJoint1.flange_a.tau + constantTorque.flange.tau = 0.0;
//   fixedTranslation1.frame_a.t + body1.frame_a.t + dryFrictionWheelJoint2.frame_a.t = 0.0;
//   fixedTranslation1.frame_a.fy + body1.frame_a.fy + dryFrictionWheelJoint2.frame_a.fy = 0.0;
//   fixedTranslation1.frame_a.fx + body1.frame_a.fx + dryFrictionWheelJoint2.frame_a.fx = 0.0;
//   fixedTranslation1.frame_b.t + fixedRotation.frame_b.t = 0.0;
//   fixedTranslation1.frame_b.fy + fixedRotation.frame_b.fy = 0.0;
//   fixedTranslation1.frame_b.fx + fixedRotation.frame_b.fx = 0.0;
//   dryFrictionWheelJoint2.flange_a.tau + constantTorque1.flange.tau = 0.0;
//   body1.frame_a.x = dryFrictionWheelJoint2.frame_a.x;
//   body1.frame_a.x = fixedTranslation1.frame_a.x;
//   body1.frame_a.y = dryFrictionWheelJoint2.frame_a.y;
//   body1.frame_a.y = fixedTranslation1.frame_a.y;
//   body1.frame_a.phi = dryFrictionWheelJoint2.frame_a.phi;
//   body1.frame_a.phi = fixedTranslation1.frame_a.phi;
//   fixedRotation.frame_b.x = fixedTranslation1.frame_b.x;
//   fixedRotation.frame_b.y = fixedTranslation1.frame_b.y;
//   fixedRotation.frame_b.phi = fixedTranslation1.frame_b.phi;
//   body.frame_a.x = dryFrictionWheelJoint1.frame_a.x;
//   body.frame_a.x = fixedRotation.frame_a.x;
//   body.frame_a.y = dryFrictionWheelJoint1.frame_a.y;
//   body.frame_a.y = fixedRotation.frame_a.y;
//   body.frame_a.phi = dryFrictionWheelJoint1.frame_a.phi;
//   body.frame_a.phi = fixedRotation.frame_a.phi;
//   constantTorque1.flange.phi = dryFrictionWheelJoint2.flange_a.phi;
//   constantTorque.flange.phi = dryFrictionWheelJoint1.flange_a.phi;
// end PlanarMechanicsV4.Examples.SingleTrackFixedSteeringFriction;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.SimpleCarWithDifferentialGear
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 100.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real WheelJoint1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint1.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint1.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint1.N(quantity = \"Force\", unit = \"N\") = 1000.0 \"normal force\";
//   parameter Real WheelJoint1.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint1.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint1.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint1.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint1.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint1.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint1.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint1.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint1.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint1.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint1.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint1.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint1.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint1.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint1.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint1.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint1.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint1.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint1.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint1.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint1.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint1.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint1.r[1] ^ 2.0 + WheelJoint1.r[2] ^ 2.0);
//   final parameter Real WheelJoint1.e[1] = WheelJoint1.r[1] / WheelJoint1.l \"normalized direction\";
//   final parameter Real WheelJoint1.e[2] = WheelJoint1.r[2] / WheelJoint1.l \"normalized direction\";
//   parameter String WheelJoint1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * WheelJoint1.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * WheelJoint1.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint1.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint1.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint1.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Width of visual object\";
//   input Real WheelJoint1.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Height of visual object\";
//   input Real WheelJoint1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint1.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint1.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint1.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint1.cylinder.lengthDirection[1],WheelJoint1.cylinder.lengthDirection[2],WheelJoint1.cylinder.lengthDirection[3]});
//   protected Real WheelJoint1.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint1.cylinder.abs_n_x < 1e-10) then 1.0 else WheelJoint1.cylinder.lengthDirection[1] / WheelJoint1.cylinder.abs_n_x;
//   protected Real WheelJoint1.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint1.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint1.cylinder.lengthDirection[2] / WheelJoint1.cylinder.abs_n_x;
//   protected Real WheelJoint1.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint1.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint1.cylinder.lengthDirection[3] / WheelJoint1.cylinder.abs_n_x;
//   protected Real WheelJoint1.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint1.cylinder.e_x[2] * WheelJoint1.cylinder.widthDirection[3] - WheelJoint1.cylinder.e_x[3] * WheelJoint1.cylinder.widthDirection[2];
//   protected Real WheelJoint1.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint1.cylinder.e_x[3] * WheelJoint1.cylinder.widthDirection[1] - WheelJoint1.cylinder.e_x[1] * WheelJoint1.cylinder.widthDirection[3];
//   protected Real WheelJoint1.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint1.cylinder.e_x[1] * WheelJoint1.cylinder.widthDirection[2] - WheelJoint1.cylinder.e_x[2] * WheelJoint1.cylinder.widthDirection[1];
//   protected Real WheelJoint1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]},if noEvent(WheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.cylinder.widthDirection[1],WheelJoint1.cylinder.widthDirection[2],WheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]})[1];
//   protected Real WheelJoint1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]},if noEvent(WheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.cylinder.widthDirection[1],WheelJoint1.cylinder.widthDirection[2],WheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]})[2];
//   protected Real WheelJoint1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]},if noEvent(WheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.cylinder.widthDirection[1],WheelJoint1.cylinder.widthDirection[2],WheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint1.cylinder.Form;
//   output Real WheelJoint1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.cylinder.Material;
//   protected output Real WheelJoint1.cylinder.Extra;
//   parameter String WheelJoint1.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint1.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Length of visual object\";
//   input Real WheelJoint1.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint1.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint1.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint1.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint1.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint1.rim1.lengthDirection[1],WheelJoint1.rim1.lengthDirection[2],WheelJoint1.rim1.lengthDirection[3]});
//   protected Real WheelJoint1.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint1.rim1.abs_n_x < 1e-10) then 1.0 else WheelJoint1.rim1.lengthDirection[1] / WheelJoint1.rim1.abs_n_x;
//   protected Real WheelJoint1.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint1.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint1.rim1.lengthDirection[2] / WheelJoint1.rim1.abs_n_x;
//   protected Real WheelJoint1.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint1.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint1.rim1.lengthDirection[3] / WheelJoint1.rim1.abs_n_x;
//   protected Real WheelJoint1.rim1.n_z_aux[1](unit = \"1\") = WheelJoint1.rim1.e_x[2] * WheelJoint1.rim1.widthDirection[3] - WheelJoint1.rim1.e_x[3] * WheelJoint1.rim1.widthDirection[2];
//   protected Real WheelJoint1.rim1.n_z_aux[2](unit = \"1\") = WheelJoint1.rim1.e_x[3] * WheelJoint1.rim1.widthDirection[1] - WheelJoint1.rim1.e_x[1] * WheelJoint1.rim1.widthDirection[3];
//   protected Real WheelJoint1.rim1.n_z_aux[3](unit = \"1\") = WheelJoint1.rim1.e_x[1] * WheelJoint1.rim1.widthDirection[2] - WheelJoint1.rim1.e_x[2] * WheelJoint1.rim1.widthDirection[1];
//   protected Real WheelJoint1.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]},if noEvent(WheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim1.n_z_aux[2] ^ 2.0 + WheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.rim1.widthDirection[1],WheelJoint1.rim1.widthDirection[2],WheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]})[1];
//   protected Real WheelJoint1.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]},if noEvent(WheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim1.n_z_aux[2] ^ 2.0 + WheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.rim1.widthDirection[1],WheelJoint1.rim1.widthDirection[2],WheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]})[2];
//   protected Real WheelJoint1.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]},if noEvent(WheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim1.n_z_aux[2] ^ 2.0 + WheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.rim1.widthDirection[1],WheelJoint1.rim1.widthDirection[2],WheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]})[3];
//   protected output Real WheelJoint1.rim1.Form;
//   output Real WheelJoint1.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint1.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim1.Material;
//   protected output Real WheelJoint1.rim1.Extra;
//   parameter String WheelJoint1.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint1.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Length of visual object\";
//   input Real WheelJoint1.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint1.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint1.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint1.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint1.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint1.rim2.lengthDirection[1],WheelJoint1.rim2.lengthDirection[2],WheelJoint1.rim2.lengthDirection[3]});
//   protected Real WheelJoint1.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint1.rim2.abs_n_x < 1e-10) then 1.0 else WheelJoint1.rim2.lengthDirection[1] / WheelJoint1.rim2.abs_n_x;
//   protected Real WheelJoint1.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint1.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint1.rim2.lengthDirection[2] / WheelJoint1.rim2.abs_n_x;
//   protected Real WheelJoint1.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint1.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint1.rim2.lengthDirection[3] / WheelJoint1.rim2.abs_n_x;
//   protected Real WheelJoint1.rim2.n_z_aux[1](unit = \"1\") = WheelJoint1.rim2.e_x[2] * WheelJoint1.rim2.widthDirection[3] - WheelJoint1.rim2.e_x[3] * WheelJoint1.rim2.widthDirection[2];
//   protected Real WheelJoint1.rim2.n_z_aux[2](unit = \"1\") = WheelJoint1.rim2.e_x[3] * WheelJoint1.rim2.widthDirection[1] - WheelJoint1.rim2.e_x[1] * WheelJoint1.rim2.widthDirection[3];
//   protected Real WheelJoint1.rim2.n_z_aux[3](unit = \"1\") = WheelJoint1.rim2.e_x[1] * WheelJoint1.rim2.widthDirection[2] - WheelJoint1.rim2.e_x[2] * WheelJoint1.rim2.widthDirection[1];
//   protected Real WheelJoint1.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]},if noEvent(WheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim2.n_z_aux[2] ^ 2.0 + WheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.rim2.widthDirection[1],WheelJoint1.rim2.widthDirection[2],WheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]})[1];
//   protected Real WheelJoint1.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]},if noEvent(WheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim2.n_z_aux[2] ^ 2.0 + WheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.rim2.widthDirection[1],WheelJoint1.rim2.widthDirection[2],WheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]})[2];
//   protected Real WheelJoint1.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]},if noEvent(WheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim2.n_z_aux[2] ^ 2.0 + WheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint1.rim2.widthDirection[1],WheelJoint1.rim2.widthDirection[2],WheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]})[3];
//   protected output Real WheelJoint1.rim2.Form;
//   output Real WheelJoint1.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint1.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim2.Material;
//   protected output Real WheelJoint1.rim2.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 300.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real WheelJoint2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint2.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint2.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint2.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint2.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real WheelJoint2.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint2.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint2.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint2.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint2.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint2.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint2.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint2.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint2.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint2.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint2.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint2.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint2.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint2.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint2.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint2.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint2.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint2.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint2.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint2.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint2.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint2.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint2.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint2.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint2.r[1] ^ 2.0 + WheelJoint2.r[2] ^ 2.0);
//   final parameter Real WheelJoint2.e[1] = WheelJoint2.r[1] / WheelJoint2.l \"normalized direction\";
//   final parameter Real WheelJoint2.e[2] = WheelJoint2.r[2] / WheelJoint2.l \"normalized direction\";
//   parameter String WheelJoint2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * WheelJoint2.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * WheelJoint2.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint2.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint2.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint2.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Width of visual object\";
//   input Real WheelJoint2.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Height of visual object\";
//   input Real WheelJoint2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint2.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint2.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint2.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint2.cylinder.lengthDirection[1],WheelJoint2.cylinder.lengthDirection[2],WheelJoint2.cylinder.lengthDirection[3]});
//   protected Real WheelJoint2.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint2.cylinder.abs_n_x < 1e-10) then 1.0 else WheelJoint2.cylinder.lengthDirection[1] / WheelJoint2.cylinder.abs_n_x;
//   protected Real WheelJoint2.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint2.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint2.cylinder.lengthDirection[2] / WheelJoint2.cylinder.abs_n_x;
//   protected Real WheelJoint2.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint2.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint2.cylinder.lengthDirection[3] / WheelJoint2.cylinder.abs_n_x;
//   protected Real WheelJoint2.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint2.cylinder.e_x[2] * WheelJoint2.cylinder.widthDirection[3] - WheelJoint2.cylinder.e_x[3] * WheelJoint2.cylinder.widthDirection[2];
//   protected Real WheelJoint2.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint2.cylinder.e_x[3] * WheelJoint2.cylinder.widthDirection[1] - WheelJoint2.cylinder.e_x[1] * WheelJoint2.cylinder.widthDirection[3];
//   protected Real WheelJoint2.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint2.cylinder.e_x[1] * WheelJoint2.cylinder.widthDirection[2] - WheelJoint2.cylinder.e_x[2] * WheelJoint2.cylinder.widthDirection[1];
//   protected Real WheelJoint2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]},if noEvent(WheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.cylinder.widthDirection[1],WheelJoint2.cylinder.widthDirection[2],WheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]})[1];
//   protected Real WheelJoint2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]},if noEvent(WheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.cylinder.widthDirection[1],WheelJoint2.cylinder.widthDirection[2],WheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]})[2];
//   protected Real WheelJoint2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]},if noEvent(WheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.cylinder.widthDirection[1],WheelJoint2.cylinder.widthDirection[2],WheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint2.cylinder.Form;
//   output Real WheelJoint2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.cylinder.Material;
//   protected output Real WheelJoint2.cylinder.Extra;
//   parameter String WheelJoint2.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint2.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint2.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Length of visual object\";
//   input Real WheelJoint2.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint2.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint2.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint2.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint2.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint2.rim1.lengthDirection[1],WheelJoint2.rim1.lengthDirection[2],WheelJoint2.rim1.lengthDirection[3]});
//   protected Real WheelJoint2.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint2.rim1.abs_n_x < 1e-10) then 1.0 else WheelJoint2.rim1.lengthDirection[1] / WheelJoint2.rim1.abs_n_x;
//   protected Real WheelJoint2.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint2.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint2.rim1.lengthDirection[2] / WheelJoint2.rim1.abs_n_x;
//   protected Real WheelJoint2.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint2.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint2.rim1.lengthDirection[3] / WheelJoint2.rim1.abs_n_x;
//   protected Real WheelJoint2.rim1.n_z_aux[1](unit = \"1\") = WheelJoint2.rim1.e_x[2] * WheelJoint2.rim1.widthDirection[3] - WheelJoint2.rim1.e_x[3] * WheelJoint2.rim1.widthDirection[2];
//   protected Real WheelJoint2.rim1.n_z_aux[2](unit = \"1\") = WheelJoint2.rim1.e_x[3] * WheelJoint2.rim1.widthDirection[1] - WheelJoint2.rim1.e_x[1] * WheelJoint2.rim1.widthDirection[3];
//   protected Real WheelJoint2.rim1.n_z_aux[3](unit = \"1\") = WheelJoint2.rim1.e_x[1] * WheelJoint2.rim1.widthDirection[2] - WheelJoint2.rim1.e_x[2] * WheelJoint2.rim1.widthDirection[1];
//   protected Real WheelJoint2.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]},if noEvent(WheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim1.n_z_aux[2] ^ 2.0 + WheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.rim1.widthDirection[1],WheelJoint2.rim1.widthDirection[2],WheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]})[1];
//   protected Real WheelJoint2.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]},if noEvent(WheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim1.n_z_aux[2] ^ 2.0 + WheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.rim1.widthDirection[1],WheelJoint2.rim1.widthDirection[2],WheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]})[2];
//   protected Real WheelJoint2.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]},if noEvent(WheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim1.n_z_aux[2] ^ 2.0 + WheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.rim1.widthDirection[1],WheelJoint2.rim1.widthDirection[2],WheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]})[3];
//   protected output Real WheelJoint2.rim1.Form;
//   output Real WheelJoint2.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint2.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim1.Material;
//   protected output Real WheelJoint2.rim1.Extra;
//   parameter String WheelJoint2.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint2.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint2.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Length of visual object\";
//   input Real WheelJoint2.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint2.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint2.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint2.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint2.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint2.rim2.lengthDirection[1],WheelJoint2.rim2.lengthDirection[2],WheelJoint2.rim2.lengthDirection[3]});
//   protected Real WheelJoint2.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint2.rim2.abs_n_x < 1e-10) then 1.0 else WheelJoint2.rim2.lengthDirection[1] / WheelJoint2.rim2.abs_n_x;
//   protected Real WheelJoint2.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint2.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint2.rim2.lengthDirection[2] / WheelJoint2.rim2.abs_n_x;
//   protected Real WheelJoint2.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint2.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint2.rim2.lengthDirection[3] / WheelJoint2.rim2.abs_n_x;
//   protected Real WheelJoint2.rim2.n_z_aux[1](unit = \"1\") = WheelJoint2.rim2.e_x[2] * WheelJoint2.rim2.widthDirection[3] - WheelJoint2.rim2.e_x[3] * WheelJoint2.rim2.widthDirection[2];
//   protected Real WheelJoint2.rim2.n_z_aux[2](unit = \"1\") = WheelJoint2.rim2.e_x[3] * WheelJoint2.rim2.widthDirection[1] - WheelJoint2.rim2.e_x[1] * WheelJoint2.rim2.widthDirection[3];
//   protected Real WheelJoint2.rim2.n_z_aux[3](unit = \"1\") = WheelJoint2.rim2.e_x[1] * WheelJoint2.rim2.widthDirection[2] - WheelJoint2.rim2.e_x[2] * WheelJoint2.rim2.widthDirection[1];
//   protected Real WheelJoint2.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]},if noEvent(WheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim2.n_z_aux[2] ^ 2.0 + WheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.rim2.widthDirection[1],WheelJoint2.rim2.widthDirection[2],WheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]})[1];
//   protected Real WheelJoint2.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]},if noEvent(WheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim2.n_z_aux[2] ^ 2.0 + WheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.rim2.widthDirection[1],WheelJoint2.rim2.widthDirection[2],WheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]})[2];
//   protected Real WheelJoint2.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]},if noEvent(WheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim2.n_z_aux[2] ^ 2.0 + WheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint2.rim2.widthDirection[1],WheelJoint2.rim2.widthDirection[2],WheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]})[3];
//   protected output Real WheelJoint2.rim2.Form;
//   output Real WheelJoint2.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint2.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim2.Material;
//   protected output Real WheelJoint2.rim2.Extra;
//   parameter Boolean constantTorque1.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real constantTorque1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real constantTorque1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real constantTorque1.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real constantTorque1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real constantTorque1.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 25.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real constantTorque1.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real inertia1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia1.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia1.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia1.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia1.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = 0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation2.r[1] ^ 2.0 + fixedTranslation2.r[2] ^ 2.0);
//   parameter String fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation2.r0[1] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation2.r0[2] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation2.l \"Length of visual object\";
//   input Real fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation2.cylinder.lengthDirection[1],fixedTranslation2.cylinder.lengthDirection[2],fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation2.cylinder.lengthDirection[1] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.cylinder.lengthDirection[2] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.cylinder.lengthDirection[3] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[3] - fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[2];
//   protected Real fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[1] - fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[3];
//   protected Real fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[2] - fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[1];
//   protected Real fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation2.cylinder.Form;
//   output Real fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.Material;
//   protected output Real fixedTranslation2.cylinder.Extra;
//   Real fixedTranslation3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation3.r[1](quantity = \"Length\", unit = \"m\") = -0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation3.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation3.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation3.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation3.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation3.r[1] ^ 2.0 + fixedTranslation3.r[2] ^ 2.0);
//   parameter String fixedTranslation3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation3.r0[1] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation3.r0[2] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation3.l \"Length of visual object\";
//   input Real fixedTranslation3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation3.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation3.cylinder.lengthDirection[1],fixedTranslation3.cylinder.lengthDirection[2],fixedTranslation3.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation3.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation3.cylinder.lengthDirection[1] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.cylinder.lengthDirection[2] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.cylinder.lengthDirection[3] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[3] - fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[2];
//   protected Real fixedTranslation3.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[1] - fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[3];
//   protected Real fixedTranslation3.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[2] - fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[1];
//   protected Real fixedTranslation3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation3.cylinder.Form;
//   output Real fixedTranslation3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.Material;
//   protected output Real fixedTranslation3.cylinder.Extra;
//   Real WheelJoint3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint3.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint3.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint3.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint3.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint3.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint3.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real WheelJoint3.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint3.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint3.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint3.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint3.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint3.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint3.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint3.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint3.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint3.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint3.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint3.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint3.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint3.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint3.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint3.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint3.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint3.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint3.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint3.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint3.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint3.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint3.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint3.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint3.r[1] ^ 2.0 + WheelJoint3.r[2] ^ 2.0);
//   final parameter Real WheelJoint3.e[1] = WheelJoint3.r[1] / WheelJoint3.l \"normalized direction\";
//   final parameter Real WheelJoint3.e[2] = WheelJoint3.r[2] / WheelJoint3.l \"normalized direction\";
//   parameter String WheelJoint3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * WheelJoint3.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * WheelJoint3.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint3.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint3.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint3.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Width of visual object\";
//   input Real WheelJoint3.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Height of visual object\";
//   input Real WheelJoint3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint3.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint3.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint3.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint3.cylinder.lengthDirection[1],WheelJoint3.cylinder.lengthDirection[2],WheelJoint3.cylinder.lengthDirection[3]});
//   protected Real WheelJoint3.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint3.cylinder.abs_n_x < 1e-10) then 1.0 else WheelJoint3.cylinder.lengthDirection[1] / WheelJoint3.cylinder.abs_n_x;
//   protected Real WheelJoint3.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint3.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint3.cylinder.lengthDirection[2] / WheelJoint3.cylinder.abs_n_x;
//   protected Real WheelJoint3.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint3.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint3.cylinder.lengthDirection[3] / WheelJoint3.cylinder.abs_n_x;
//   protected Real WheelJoint3.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint3.cylinder.e_x[2] * WheelJoint3.cylinder.widthDirection[3] - WheelJoint3.cylinder.e_x[3] * WheelJoint3.cylinder.widthDirection[2];
//   protected Real WheelJoint3.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint3.cylinder.e_x[3] * WheelJoint3.cylinder.widthDirection[1] - WheelJoint3.cylinder.e_x[1] * WheelJoint3.cylinder.widthDirection[3];
//   protected Real WheelJoint3.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint3.cylinder.e_x[1] * WheelJoint3.cylinder.widthDirection[2] - WheelJoint3.cylinder.e_x[2] * WheelJoint3.cylinder.widthDirection[1];
//   protected Real WheelJoint3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]},if noEvent(WheelJoint3.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint3.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.cylinder.widthDirection[1],WheelJoint3.cylinder.widthDirection[2],WheelJoint3.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]})[1];
//   protected Real WheelJoint3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]},if noEvent(WheelJoint3.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint3.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.cylinder.widthDirection[1],WheelJoint3.cylinder.widthDirection[2],WheelJoint3.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]})[2];
//   protected Real WheelJoint3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]},if noEvent(WheelJoint3.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint3.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.cylinder.widthDirection[1],WheelJoint3.cylinder.widthDirection[2],WheelJoint3.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint3.cylinder.Form;
//   output Real WheelJoint3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.cylinder.Material;
//   protected output Real WheelJoint3.cylinder.Extra;
//   parameter String WheelJoint3.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint3.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint3.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Length of visual object\";
//   input Real WheelJoint3.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint3.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint3.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint3.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint3.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint3.rim1.lengthDirection[1],WheelJoint3.rim1.lengthDirection[2],WheelJoint3.rim1.lengthDirection[3]});
//   protected Real WheelJoint3.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint3.rim1.abs_n_x < 1e-10) then 1.0 else WheelJoint3.rim1.lengthDirection[1] / WheelJoint3.rim1.abs_n_x;
//   protected Real WheelJoint3.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint3.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint3.rim1.lengthDirection[2] / WheelJoint3.rim1.abs_n_x;
//   protected Real WheelJoint3.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint3.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint3.rim1.lengthDirection[3] / WheelJoint3.rim1.abs_n_x;
//   protected Real WheelJoint3.rim1.n_z_aux[1](unit = \"1\") = WheelJoint3.rim1.e_x[2] * WheelJoint3.rim1.widthDirection[3] - WheelJoint3.rim1.e_x[3] * WheelJoint3.rim1.widthDirection[2];
//   protected Real WheelJoint3.rim1.n_z_aux[2](unit = \"1\") = WheelJoint3.rim1.e_x[3] * WheelJoint3.rim1.widthDirection[1] - WheelJoint3.rim1.e_x[1] * WheelJoint3.rim1.widthDirection[3];
//   protected Real WheelJoint3.rim1.n_z_aux[3](unit = \"1\") = WheelJoint3.rim1.e_x[1] * WheelJoint3.rim1.widthDirection[2] - WheelJoint3.rim1.e_x[2] * WheelJoint3.rim1.widthDirection[1];
//   protected Real WheelJoint3.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]},if noEvent(WheelJoint3.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim1.n_z_aux[2] ^ 2.0 + WheelJoint3.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.rim1.widthDirection[1],WheelJoint3.rim1.widthDirection[2],WheelJoint3.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]})[1];
//   protected Real WheelJoint3.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]},if noEvent(WheelJoint3.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim1.n_z_aux[2] ^ 2.0 + WheelJoint3.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.rim1.widthDirection[1],WheelJoint3.rim1.widthDirection[2],WheelJoint3.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]})[2];
//   protected Real WheelJoint3.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]},if noEvent(WheelJoint3.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim1.n_z_aux[2] ^ 2.0 + WheelJoint3.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.rim1.widthDirection[1],WheelJoint3.rim1.widthDirection[2],WheelJoint3.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]})[3];
//   protected output Real WheelJoint3.rim1.Form;
//   output Real WheelJoint3.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint3.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim1.Material;
//   protected output Real WheelJoint3.rim1.Extra;
//   parameter String WheelJoint3.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint3.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint3.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Length of visual object\";
//   input Real WheelJoint3.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint3.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint3.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint3.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint3.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint3.rim2.lengthDirection[1],WheelJoint3.rim2.lengthDirection[2],WheelJoint3.rim2.lengthDirection[3]});
//   protected Real WheelJoint3.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint3.rim2.abs_n_x < 1e-10) then 1.0 else WheelJoint3.rim2.lengthDirection[1] / WheelJoint3.rim2.abs_n_x;
//   protected Real WheelJoint3.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint3.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint3.rim2.lengthDirection[2] / WheelJoint3.rim2.abs_n_x;
//   protected Real WheelJoint3.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint3.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint3.rim2.lengthDirection[3] / WheelJoint3.rim2.abs_n_x;
//   protected Real WheelJoint3.rim2.n_z_aux[1](unit = \"1\") = WheelJoint3.rim2.e_x[2] * WheelJoint3.rim2.widthDirection[3] - WheelJoint3.rim2.e_x[3] * WheelJoint3.rim2.widthDirection[2];
//   protected Real WheelJoint3.rim2.n_z_aux[2](unit = \"1\") = WheelJoint3.rim2.e_x[3] * WheelJoint3.rim2.widthDirection[1] - WheelJoint3.rim2.e_x[1] * WheelJoint3.rim2.widthDirection[3];
//   protected Real WheelJoint3.rim2.n_z_aux[3](unit = \"1\") = WheelJoint3.rim2.e_x[1] * WheelJoint3.rim2.widthDirection[2] - WheelJoint3.rim2.e_x[2] * WheelJoint3.rim2.widthDirection[1];
//   protected Real WheelJoint3.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]},if noEvent(WheelJoint3.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim2.n_z_aux[2] ^ 2.0 + WheelJoint3.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.rim2.widthDirection[1],WheelJoint3.rim2.widthDirection[2],WheelJoint3.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]})[1];
//   protected Real WheelJoint3.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]},if noEvent(WheelJoint3.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim2.n_z_aux[2] ^ 2.0 + WheelJoint3.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.rim2.widthDirection[1],WheelJoint3.rim2.widthDirection[2],WheelJoint3.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]})[2];
//   protected Real WheelJoint3.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]},if noEvent(WheelJoint3.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim2.n_z_aux[2] ^ 2.0 + WheelJoint3.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint3.rim2.widthDirection[1],WheelJoint3.rim2.widthDirection[2],WheelJoint3.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]})[3];
//   protected output Real WheelJoint3.rim2.Form;
//   output Real WheelJoint3.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint3.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim2.Material;
//   protected output Real WheelJoint3.rim2.Extra;
//   Real inertia2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia2.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia2.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia2.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia2.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia2.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real fixedTranslation4.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation4.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation4.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation4.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation4.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation4.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation4.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation4.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation4.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation4.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation4.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation4.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation4.r[1](quantity = \"Length\", unit = \"m\") = 0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation4.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation4.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation4.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation4.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation4.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation4.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation4.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation4.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation4.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation4.r[1] ^ 2.0 + fixedTranslation4.r[2] ^ 2.0);
//   parameter String fixedTranslation4.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation4.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation4.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation4.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation4.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation4.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation4.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation4.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation4.r0[1] / fixedTranslation4.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation4.r0[2] / fixedTranslation4.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation4.l \"Length of visual object\";
//   input Real fixedTranslation4.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation4.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation4.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation4.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation4.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation4.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation4.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation4.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation4.cylinder.lengthDirection[1],fixedTranslation4.cylinder.lengthDirection[2],fixedTranslation4.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation4.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation4.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation4.cylinder.lengthDirection[1] / fixedTranslation4.cylinder.abs_n_x;
//   protected Real fixedTranslation4.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation4.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation4.cylinder.lengthDirection[2] / fixedTranslation4.cylinder.abs_n_x;
//   protected Real fixedTranslation4.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation4.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation4.cylinder.lengthDirection[3] / fixedTranslation4.cylinder.abs_n_x;
//   protected Real fixedTranslation4.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation4.cylinder.e_x[2] * fixedTranslation4.cylinder.widthDirection[3] - fixedTranslation4.cylinder.e_x[3] * fixedTranslation4.cylinder.widthDirection[2];
//   protected Real fixedTranslation4.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation4.cylinder.e_x[3] * fixedTranslation4.cylinder.widthDirection[1] - fixedTranslation4.cylinder.e_x[1] * fixedTranslation4.cylinder.widthDirection[3];
//   protected Real fixedTranslation4.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation4.cylinder.e_x[1] * fixedTranslation4.cylinder.widthDirection[2] - fixedTranslation4.cylinder.e_x[2] * fixedTranslation4.cylinder.widthDirection[1];
//   protected Real fixedTranslation4.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]},if noEvent(fixedTranslation4.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation4.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation4.cylinder.widthDirection[1],fixedTranslation4.cylinder.widthDirection[2],fixedTranslation4.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation4.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]},if noEvent(fixedTranslation4.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation4.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation4.cylinder.widthDirection[1],fixedTranslation4.cylinder.widthDirection[2],fixedTranslation4.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation4.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]},if noEvent(fixedTranslation4.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation4.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation4.cylinder.widthDirection[1],fixedTranslation4.cylinder.widthDirection[2],fixedTranslation4.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation4.cylinder.Form;
//   output Real fixedTranslation4.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation4.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation4.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation4.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation4.cylinder.Material;
//   protected output Real fixedTranslation4.cylinder.Extra;
//   Real fixedTranslation5.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation5.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation5.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation5.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation5.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation5.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation5.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation5.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation5.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation5.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation5.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation5.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation5.r[1](quantity = \"Length\", unit = \"m\") = -0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation5.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation5.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation5.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation5.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation5.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation5.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation5.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation5.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation5.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation5.r[1] ^ 2.0 + fixedTranslation5.r[2] ^ 2.0);
//   parameter String fixedTranslation5.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation5.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation5.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation5.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation5.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation5.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation5.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation5.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation5.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation5.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation5.r0[1] / fixedTranslation5.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation5.r0[2] / fixedTranslation5.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation5.l \"Length of visual object\";
//   input Real fixedTranslation5.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation5.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation5.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation5.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation5.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation5.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation5.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation5.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation5.cylinder.lengthDirection[1],fixedTranslation5.cylinder.lengthDirection[2],fixedTranslation5.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation5.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation5.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation5.cylinder.lengthDirection[1] / fixedTranslation5.cylinder.abs_n_x;
//   protected Real fixedTranslation5.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation5.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation5.cylinder.lengthDirection[2] / fixedTranslation5.cylinder.abs_n_x;
//   protected Real fixedTranslation5.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation5.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation5.cylinder.lengthDirection[3] / fixedTranslation5.cylinder.abs_n_x;
//   protected Real fixedTranslation5.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation5.cylinder.e_x[2] * fixedTranslation5.cylinder.widthDirection[3] - fixedTranslation5.cylinder.e_x[3] * fixedTranslation5.cylinder.widthDirection[2];
//   protected Real fixedTranslation5.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation5.cylinder.e_x[3] * fixedTranslation5.cylinder.widthDirection[1] - fixedTranslation5.cylinder.e_x[1] * fixedTranslation5.cylinder.widthDirection[3];
//   protected Real fixedTranslation5.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation5.cylinder.e_x[1] * fixedTranslation5.cylinder.widthDirection[2] - fixedTranslation5.cylinder.e_x[2] * fixedTranslation5.cylinder.widthDirection[1];
//   protected Real fixedTranslation5.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]},if noEvent(fixedTranslation5.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation5.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation5.cylinder.widthDirection[1],fixedTranslation5.cylinder.widthDirection[2],fixedTranslation5.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation5.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]},if noEvent(fixedTranslation5.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation5.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation5.cylinder.widthDirection[1],fixedTranslation5.cylinder.widthDirection[2],fixedTranslation5.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation5.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]},if noEvent(fixedTranslation5.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation5.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation5.cylinder.widthDirection[1],fixedTranslation5.cylinder.widthDirection[2],fixedTranslation5.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation5.cylinder.Form;
//   output Real fixedTranslation5.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation5.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation5.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation5.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation5.cylinder.Material;
//   protected output Real fixedTranslation5.cylinder.Extra;
//   Real WheelJoint4.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint4.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint4.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint4.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint4.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint4.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint4.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint4.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint4.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint4.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint4.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint4.N(quantity = \"Force\", unit = \"N\") = 1000.0 \"normal force\";
//   parameter Real WheelJoint4.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint4.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint4.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint4.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint4.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint4.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint4.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint4.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint4.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint4.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint4.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint4.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint4.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint4.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint4.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint4.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint4.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint4.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint4.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint4.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint4.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint4.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint4.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint4.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint4.r[1] ^ 2.0 + WheelJoint4.r[2] ^ 2.0);
//   final parameter Real WheelJoint4.e[1] = WheelJoint4.r[1] / WheelJoint4.l \"normalized direction\";
//   final parameter Real WheelJoint4.e[2] = WheelJoint4.r[2] / WheelJoint4.l \"normalized direction\";
//   parameter String WheelJoint4.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint4.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * WheelJoint4.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * WheelJoint4.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint4.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint4.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint4.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Width of visual object\";
//   input Real WheelJoint4.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Height of visual object\";
//   input Real WheelJoint4.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint4.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint4.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint4.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint4.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint4.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint4.cylinder.lengthDirection[1],WheelJoint4.cylinder.lengthDirection[2],WheelJoint4.cylinder.lengthDirection[3]});
//   protected Real WheelJoint4.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint4.cylinder.abs_n_x < 1e-10) then 1.0 else WheelJoint4.cylinder.lengthDirection[1] / WheelJoint4.cylinder.abs_n_x;
//   protected Real WheelJoint4.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint4.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint4.cylinder.lengthDirection[2] / WheelJoint4.cylinder.abs_n_x;
//   protected Real WheelJoint4.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint4.cylinder.abs_n_x < 1e-10) then 0.0 else WheelJoint4.cylinder.lengthDirection[3] / WheelJoint4.cylinder.abs_n_x;
//   protected Real WheelJoint4.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint4.cylinder.e_x[2] * WheelJoint4.cylinder.widthDirection[3] - WheelJoint4.cylinder.e_x[3] * WheelJoint4.cylinder.widthDirection[2];
//   protected Real WheelJoint4.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint4.cylinder.e_x[3] * WheelJoint4.cylinder.widthDirection[1] - WheelJoint4.cylinder.e_x[1] * WheelJoint4.cylinder.widthDirection[3];
//   protected Real WheelJoint4.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint4.cylinder.e_x[1] * WheelJoint4.cylinder.widthDirection[2] - WheelJoint4.cylinder.e_x[2] * WheelJoint4.cylinder.widthDirection[1];
//   protected Real WheelJoint4.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]},if noEvent(WheelJoint4.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint4.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.cylinder.widthDirection[1],WheelJoint4.cylinder.widthDirection[2],WheelJoint4.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]})[1];
//   protected Real WheelJoint4.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]},if noEvent(WheelJoint4.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint4.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.cylinder.widthDirection[1],WheelJoint4.cylinder.widthDirection[2],WheelJoint4.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]})[2];
//   protected Real WheelJoint4.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]},if noEvent(WheelJoint4.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint4.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.cylinder.widthDirection[1],WheelJoint4.cylinder.widthDirection[2],WheelJoint4.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint4.cylinder.Form;
//   output Real WheelJoint4.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint4.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.cylinder.Material;
//   protected output Real WheelJoint4.cylinder.Extra;
//   parameter String WheelJoint4.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint4.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint4.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Length of visual object\";
//   input Real WheelJoint4.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint4.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint4.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint4.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint4.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint4.rim1.lengthDirection[1],WheelJoint4.rim1.lengthDirection[2],WheelJoint4.rim1.lengthDirection[3]});
//   protected Real WheelJoint4.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint4.rim1.abs_n_x < 1e-10) then 1.0 else WheelJoint4.rim1.lengthDirection[1] / WheelJoint4.rim1.abs_n_x;
//   protected Real WheelJoint4.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint4.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint4.rim1.lengthDirection[2] / WheelJoint4.rim1.abs_n_x;
//   protected Real WheelJoint4.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint4.rim1.abs_n_x < 1e-10) then 0.0 else WheelJoint4.rim1.lengthDirection[3] / WheelJoint4.rim1.abs_n_x;
//   protected Real WheelJoint4.rim1.n_z_aux[1](unit = \"1\") = WheelJoint4.rim1.e_x[2] * WheelJoint4.rim1.widthDirection[3] - WheelJoint4.rim1.e_x[3] * WheelJoint4.rim1.widthDirection[2];
//   protected Real WheelJoint4.rim1.n_z_aux[2](unit = \"1\") = WheelJoint4.rim1.e_x[3] * WheelJoint4.rim1.widthDirection[1] - WheelJoint4.rim1.e_x[1] * WheelJoint4.rim1.widthDirection[3];
//   protected Real WheelJoint4.rim1.n_z_aux[3](unit = \"1\") = WheelJoint4.rim1.e_x[1] * WheelJoint4.rim1.widthDirection[2] - WheelJoint4.rim1.e_x[2] * WheelJoint4.rim1.widthDirection[1];
//   protected Real WheelJoint4.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]},if noEvent(WheelJoint4.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim1.n_z_aux[2] ^ 2.0 + WheelJoint4.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.rim1.widthDirection[1],WheelJoint4.rim1.widthDirection[2],WheelJoint4.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]})[1];
//   protected Real WheelJoint4.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]},if noEvent(WheelJoint4.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim1.n_z_aux[2] ^ 2.0 + WheelJoint4.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.rim1.widthDirection[1],WheelJoint4.rim1.widthDirection[2],WheelJoint4.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]})[2];
//   protected Real WheelJoint4.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]},if noEvent(WheelJoint4.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim1.n_z_aux[2] ^ 2.0 + WheelJoint4.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.rim1.widthDirection[1],WheelJoint4.rim1.widthDirection[2],WheelJoint4.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]})[3];
//   protected output Real WheelJoint4.rim1.Form;
//   output Real WheelJoint4.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint4.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim1.Material;
//   protected output Real WheelJoint4.rim1.Extra;
//   parameter String WheelJoint4.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint4.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint4.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Length of visual object\";
//   input Real WheelJoint4.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint4.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint4.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint4.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint4.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint4.rim2.lengthDirection[1],WheelJoint4.rim2.lengthDirection[2],WheelJoint4.rim2.lengthDirection[3]});
//   protected Real WheelJoint4.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint4.rim2.abs_n_x < 1e-10) then 1.0 else WheelJoint4.rim2.lengthDirection[1] / WheelJoint4.rim2.abs_n_x;
//   protected Real WheelJoint4.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint4.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint4.rim2.lengthDirection[2] / WheelJoint4.rim2.abs_n_x;
//   protected Real WheelJoint4.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint4.rim2.abs_n_x < 1e-10) then 0.0 else WheelJoint4.rim2.lengthDirection[3] / WheelJoint4.rim2.abs_n_x;
//   protected Real WheelJoint4.rim2.n_z_aux[1](unit = \"1\") = WheelJoint4.rim2.e_x[2] * WheelJoint4.rim2.widthDirection[3] - WheelJoint4.rim2.e_x[3] * WheelJoint4.rim2.widthDirection[2];
//   protected Real WheelJoint4.rim2.n_z_aux[2](unit = \"1\") = WheelJoint4.rim2.e_x[3] * WheelJoint4.rim2.widthDirection[1] - WheelJoint4.rim2.e_x[1] * WheelJoint4.rim2.widthDirection[3];
//   protected Real WheelJoint4.rim2.n_z_aux[3](unit = \"1\") = WheelJoint4.rim2.e_x[1] * WheelJoint4.rim2.widthDirection[2] - WheelJoint4.rim2.e_x[2] * WheelJoint4.rim2.widthDirection[1];
//   protected Real WheelJoint4.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]},if noEvent(WheelJoint4.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim2.n_z_aux[2] ^ 2.0 + WheelJoint4.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.rim2.widthDirection[1],WheelJoint4.rim2.widthDirection[2],WheelJoint4.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]})[1];
//   protected Real WheelJoint4.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]},if noEvent(WheelJoint4.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim2.n_z_aux[2] ^ 2.0 + WheelJoint4.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.rim2.widthDirection[1],WheelJoint4.rim2.widthDirection[2],WheelJoint4.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]})[2];
//   protected Real WheelJoint4.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]},if noEvent(WheelJoint4.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim2.n_z_aux[2] ^ 2.0 + WheelJoint4.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {WheelJoint4.rim2.widthDirection[1],WheelJoint4.rim2.widthDirection[2],WheelJoint4.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]})[3];
//   protected output Real WheelJoint4.rim2.Form;
//   output Real WheelJoint4.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint4.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim2.Material;
//   protected output Real WheelJoint4.rim2.Extra;
//   Real inertia3.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia3.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia3.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia3.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia3.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia3.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia3.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real body2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 100.0 \"mass of the body\";
//   parameter Real body2.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body2.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body2.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body2.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body2.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body2.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body2.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body2.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body2.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body2.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body2.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body2.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body2.animate = true \"enable Animation\";
//   parameter String body2.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body2.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.r[1](quantity = \"Length\", unit = \"m\") = body2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[2](quantity = \"Length\", unit = \"m\") = body2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body2.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body2.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body2.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body2.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body2.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body2.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body2.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body2.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body2.sphere.lengthDirection[1],body2.sphere.lengthDirection[2],body2.sphere.lengthDirection[3]});
//   protected Real body2.sphere.e_x[1](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 1.0 else body2.sphere.lengthDirection[1] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[2](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[2] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[3](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[3] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.n_z_aux[1](unit = \"1\") = body2.sphere.e_x[2] * body2.sphere.widthDirection[3] - body2.sphere.e_x[3] * body2.sphere.widthDirection[2];
//   protected Real body2.sphere.n_z_aux[2](unit = \"1\") = body2.sphere.e_x[3] * body2.sphere.widthDirection[1] - body2.sphere.e_x[1] * body2.sphere.widthDirection[3];
//   protected Real body2.sphere.n_z_aux[3](unit = \"1\") = body2.sphere.e_x[1] * body2.sphere.widthDirection[2] - body2.sphere.e_x[2] * body2.sphere.widthDirection[1];
//   protected Real body2.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[1];
//   protected Real body2.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[2];
//   protected Real body2.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[3];
//   protected output Real body2.sphere.Form;
//   output Real body2.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body2.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.Material;
//   protected output Real body2.sphere.Extra;
//   Real actuatedRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.43633231299858;
//   parameter Real actuatedRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real actuatedRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real actuatedRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute.animate = true \"enable Animation\";
//   Real actuatedRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute.cylinder.lengthDirection[1],actuatedRevolute.cylinder.lengthDirection[2],actuatedRevolute.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else actuatedRevolute.cylinder.lengthDirection[1] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute.cylinder.lengthDirection[2] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute.cylinder.lengthDirection[3] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[3] - actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[2];
//   protected Real actuatedRevolute.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[1] - actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[3];
//   protected Real actuatedRevolute.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[2] - actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[1];
//   protected Real actuatedRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute.cylinder.Form;
//   output Real actuatedRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.Material;
//   protected output Real actuatedRevolute.cylinder.Extra;
//   Real actuatedRevolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute1.initialize = false \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real actuatedRevolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real actuatedRevolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real actuatedRevolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute1.animate = true \"enable Animation\";
//   Real actuatedRevolute1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute1.cylinder.lengthDirection[1],actuatedRevolute1.cylinder.lengthDirection[2],actuatedRevolute1.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute1.cylinder.abs_n_x < 1e-10) then 1.0 else actuatedRevolute1.cylinder.lengthDirection[1] / actuatedRevolute1.cylinder.abs_n_x;
//   protected Real actuatedRevolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute1.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute1.cylinder.lengthDirection[2] / actuatedRevolute1.cylinder.abs_n_x;
//   protected Real actuatedRevolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute1.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute1.cylinder.lengthDirection[3] / actuatedRevolute1.cylinder.abs_n_x;
//   protected Real actuatedRevolute1.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute1.cylinder.e_x[2] * actuatedRevolute1.cylinder.widthDirection[3] - actuatedRevolute1.cylinder.e_x[3] * actuatedRevolute1.cylinder.widthDirection[2];
//   protected Real actuatedRevolute1.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute1.cylinder.e_x[3] * actuatedRevolute1.cylinder.widthDirection[1] - actuatedRevolute1.cylinder.e_x[1] * actuatedRevolute1.cylinder.widthDirection[3];
//   protected Real actuatedRevolute1.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute1.cylinder.e_x[1] * actuatedRevolute1.cylinder.widthDirection[2] - actuatedRevolute1.cylinder.e_x[2] * actuatedRevolute1.cylinder.widthDirection[1];
//   protected Real actuatedRevolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]},if noEvent(actuatedRevolute1.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute1.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute1.cylinder.widthDirection[1],actuatedRevolute1.cylinder.widthDirection[2],actuatedRevolute1.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]},if noEvent(actuatedRevolute1.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute1.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute1.cylinder.widthDirection[1],actuatedRevolute1.cylinder.widthDirection[2],actuatedRevolute1.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]},if noEvent(actuatedRevolute1.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute1.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute1.cylinder.widthDirection[1],actuatedRevolute1.cylinder.widthDirection[2],actuatedRevolute1.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute1.cylinder.Form;
//   output Real actuatedRevolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute1.cylinder.Material;
//   protected output Real actuatedRevolute1.cylinder.Extra;
//   parameter Boolean torque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   input Real torque.tau \"Accelerating torque acting at flange (= -flange.tau)\";
//   output Real pulse.y \"Connector of Real output signal\";
//   parameter Real pulse.amplitude = 1.0 \"Amplitude of pulse\";
//   parameter Real pulse.width(min = 1e-60, max = 100.0) = 30.0 \"Width of pulse in % of period\";
//   parameter Real pulse.period(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = 2.0 \"Time for one period\";
//   parameter Real pulse.offset = 0.0 \"Offset of output signals\";
//   parameter Real pulse.startTime(quantity = \"Time\", unit = \"s\") = 1.0 \"Output = offset for time < startTime\";
//   protected Real pulse.T_width(quantity = \"Time\", unit = \"s\") = (pulse.period * pulse.width) / 100.0;
//   protected Real pulse.T0(quantity = \"Time\", unit = \"s\", start = pulse.startTime) \"Start time of current period\";
//   parameter Real differentialGear.idealPlanetary.ratio(start = 2.0) = -2.0 \"number of ring_teeth/sun_teeth (e.g. ratio=100/50)\";
//   Real differentialGear.idealPlanetary.sun.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.idealPlanetary.sun.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.idealPlanetary.carrier.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.idealPlanetary.carrier.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.idealPlanetary.ring.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.idealPlanetary.ring.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.flange_left.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.flange_left.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.flange_right.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.flange_right.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real leftTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real leftTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real leftTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real leftTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real leftTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real leftTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real leftTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real leftTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real leftTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real leftTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real leftTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real leftTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real leftTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real leftTrail.r[2](quantity = \"Length\", unit = \"m\") = -0.05 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real leftTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real leftTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real leftTrail.R[1,1] \"Rotation matrix\";
//   Real leftTrail.R[1,2] \"Rotation matrix\";
//   Real leftTrail.R[2,1] \"Rotation matrix\";
//   Real leftTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean leftTrail.animate = true \"enable Animation\";
//   final parameter Real leftTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(leftTrail.r[1] ^ 2.0 + leftTrail.r[2] ^ 2.0);
//   parameter String leftTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real leftTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real leftTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real leftTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real leftTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = leftTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real leftTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = leftTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real leftTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real leftTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real leftTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real leftTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real leftTrail.cylinder.lengthDirection[1](unit = \"1\") = leftTrail.r0[1] / leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real leftTrail.cylinder.lengthDirection[2](unit = \"1\") = leftTrail.r0[2] / leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real leftTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real leftTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real leftTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real leftTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real leftTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = leftTrail.l \"Length of visual object\";
//   input Real leftTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real leftTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real leftTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real leftTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real leftTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real leftTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real leftTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real leftTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({leftTrail.cylinder.lengthDirection[1],leftTrail.cylinder.lengthDirection[2],leftTrail.cylinder.lengthDirection[3]});
//   protected Real leftTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(leftTrail.cylinder.abs_n_x < 1e-10) then 1.0 else leftTrail.cylinder.lengthDirection[1] / leftTrail.cylinder.abs_n_x;
//   protected Real leftTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(leftTrail.cylinder.abs_n_x < 1e-10) then 0.0 else leftTrail.cylinder.lengthDirection[2] / leftTrail.cylinder.abs_n_x;
//   protected Real leftTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(leftTrail.cylinder.abs_n_x < 1e-10) then 0.0 else leftTrail.cylinder.lengthDirection[3] / leftTrail.cylinder.abs_n_x;
//   protected Real leftTrail.cylinder.n_z_aux[1](unit = \"1\") = leftTrail.cylinder.e_x[2] * leftTrail.cylinder.widthDirection[3] - leftTrail.cylinder.e_x[3] * leftTrail.cylinder.widthDirection[2];
//   protected Real leftTrail.cylinder.n_z_aux[2](unit = \"1\") = leftTrail.cylinder.e_x[3] * leftTrail.cylinder.widthDirection[1] - leftTrail.cylinder.e_x[1] * leftTrail.cylinder.widthDirection[3];
//   protected Real leftTrail.cylinder.n_z_aux[3](unit = \"1\") = leftTrail.cylinder.e_x[1] * leftTrail.cylinder.widthDirection[2] - leftTrail.cylinder.e_x[2] * leftTrail.cylinder.widthDirection[1];
//   protected Real leftTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]},if noEvent(leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (leftTrail.cylinder.n_z_aux[2] ^ 2.0 + leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {leftTrail.cylinder.widthDirection[1],leftTrail.cylinder.widthDirection[2],leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]})[1];
//   protected Real leftTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]},if noEvent(leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (leftTrail.cylinder.n_z_aux[2] ^ 2.0 + leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {leftTrail.cylinder.widthDirection[1],leftTrail.cylinder.widthDirection[2],leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]})[2];
//   protected Real leftTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]},if noEvent(leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (leftTrail.cylinder.n_z_aux[2] ^ 2.0 + leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {leftTrail.cylinder.widthDirection[1],leftTrail.cylinder.widthDirection[2],leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]})[3];
//   protected output Real leftTrail.cylinder.Form;
//   output Real leftTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real leftTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real leftTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real leftTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real leftTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real leftTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real leftTrail.cylinder.Material;
//   protected output Real leftTrail.cylinder.Extra;
//   Real rightTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rightTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rightTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rightTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rightTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rightTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rightTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rightTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rightTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rightTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rightTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rightTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rightTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real rightTrail.r[2](quantity = \"Length\", unit = \"m\") = -0.05 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real rightTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rightTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rightTrail.R[1,1] \"Rotation matrix\";
//   Real rightTrail.R[1,2] \"Rotation matrix\";
//   Real rightTrail.R[2,1] \"Rotation matrix\";
//   Real rightTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean rightTrail.animate = true \"enable Animation\";
//   final parameter Real rightTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(rightTrail.r[1] ^ 2.0 + rightTrail.r[2] ^ 2.0);
//   parameter String rightTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rightTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rightTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rightTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rightTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rightTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rightTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rightTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rightTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rightTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rightTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rightTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rightTrail.cylinder.lengthDirection[1](unit = \"1\") = rightTrail.r0[1] / rightTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real rightTrail.cylinder.lengthDirection[2](unit = \"1\") = rightTrail.r0[2] / rightTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real rightTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rightTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rightTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rightTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rightTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = rightTrail.l \"Length of visual object\";
//   input Real rightTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rightTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rightTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rightTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real rightTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real rightTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real rightTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rightTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rightTrail.cylinder.lengthDirection[1],rightTrail.cylinder.lengthDirection[2],rightTrail.cylinder.lengthDirection[3]});
//   protected Real rightTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(rightTrail.cylinder.abs_n_x < 1e-10) then 1.0 else rightTrail.cylinder.lengthDirection[1] / rightTrail.cylinder.abs_n_x;
//   protected Real rightTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(rightTrail.cylinder.abs_n_x < 1e-10) then 0.0 else rightTrail.cylinder.lengthDirection[2] / rightTrail.cylinder.abs_n_x;
//   protected Real rightTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(rightTrail.cylinder.abs_n_x < 1e-10) then 0.0 else rightTrail.cylinder.lengthDirection[3] / rightTrail.cylinder.abs_n_x;
//   protected Real rightTrail.cylinder.n_z_aux[1](unit = \"1\") = rightTrail.cylinder.e_x[2] * rightTrail.cylinder.widthDirection[3] - rightTrail.cylinder.e_x[3] * rightTrail.cylinder.widthDirection[2];
//   protected Real rightTrail.cylinder.n_z_aux[2](unit = \"1\") = rightTrail.cylinder.e_x[3] * rightTrail.cylinder.widthDirection[1] - rightTrail.cylinder.e_x[1] * rightTrail.cylinder.widthDirection[3];
//   protected Real rightTrail.cylinder.n_z_aux[3](unit = \"1\") = rightTrail.cylinder.e_x[1] * rightTrail.cylinder.widthDirection[2] - rightTrail.cylinder.e_x[2] * rightTrail.cylinder.widthDirection[1];
//   protected Real rightTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]},if noEvent(rightTrail.cylinder.n_z_aux[1] ^ 2.0 + (rightTrail.cylinder.n_z_aux[2] ^ 2.0 + rightTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rightTrail.cylinder.widthDirection[1],rightTrail.cylinder.widthDirection[2],rightTrail.cylinder.widthDirection[3]} else if noEvent(abs(rightTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]})[1];
//   protected Real rightTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]},if noEvent(rightTrail.cylinder.n_z_aux[1] ^ 2.0 + (rightTrail.cylinder.n_z_aux[2] ^ 2.0 + rightTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rightTrail.cylinder.widthDirection[1],rightTrail.cylinder.widthDirection[2],rightTrail.cylinder.widthDirection[3]} else if noEvent(abs(rightTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]})[2];
//   protected Real rightTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]},if noEvent(rightTrail.cylinder.n_z_aux[1] ^ 2.0 + (rightTrail.cylinder.n_z_aux[2] ^ 2.0 + rightTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rightTrail.cylinder.widthDirection[1],rightTrail.cylinder.widthDirection[2],rightTrail.cylinder.widthDirection[3]} else if noEvent(abs(rightTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]})[3];
//   protected output Real rightTrail.cylinder.Form;
//   output Real rightTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rightTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rightTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rightTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rightTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rightTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rightTrail.cylinder.Material;
//   protected output Real rightTrail.cylinder.Extra;
// initial equation
//   actuatedRevolute.phi = actuatedRevolute.phi_start;
//   actuatedRevolute.w = actuatedRevolute.w_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   WheelJoint1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint1.cylinder.shapeType);
//   WheelJoint1.cylinder.rxvisobj[1] = WheelJoint1.cylinder.R.T[1,1] * WheelJoint1.cylinder.e_x[1] + WheelJoint1.cylinder.R.T[2,1] * WheelJoint1.cylinder.e_x[2] + WheelJoint1.cylinder.R.T[3,1] * WheelJoint1.cylinder.e_x[3];
//   WheelJoint1.cylinder.rxvisobj[2] = WheelJoint1.cylinder.R.T[1,2] * WheelJoint1.cylinder.e_x[1] + WheelJoint1.cylinder.R.T[2,2] * WheelJoint1.cylinder.e_x[2] + WheelJoint1.cylinder.R.T[3,2] * WheelJoint1.cylinder.e_x[3];
//   WheelJoint1.cylinder.rxvisobj[3] = WheelJoint1.cylinder.R.T[1,3] * WheelJoint1.cylinder.e_x[1] + WheelJoint1.cylinder.R.T[2,3] * WheelJoint1.cylinder.e_x[2] + WheelJoint1.cylinder.R.T[3,3] * WheelJoint1.cylinder.e_x[3];
//   WheelJoint1.cylinder.ryvisobj[1] = WheelJoint1.cylinder.R.T[1,1] * WheelJoint1.cylinder.e_y[1] + WheelJoint1.cylinder.R.T[2,1] * WheelJoint1.cylinder.e_y[2] + WheelJoint1.cylinder.R.T[3,1] * WheelJoint1.cylinder.e_y[3];
//   WheelJoint1.cylinder.ryvisobj[2] = WheelJoint1.cylinder.R.T[1,2] * WheelJoint1.cylinder.e_y[1] + WheelJoint1.cylinder.R.T[2,2] * WheelJoint1.cylinder.e_y[2] + WheelJoint1.cylinder.R.T[3,2] * WheelJoint1.cylinder.e_y[3];
//   WheelJoint1.cylinder.ryvisobj[3] = WheelJoint1.cylinder.R.T[1,3] * WheelJoint1.cylinder.e_y[1] + WheelJoint1.cylinder.R.T[2,3] * WheelJoint1.cylinder.e_y[2] + WheelJoint1.cylinder.R.T[3,3] * WheelJoint1.cylinder.e_y[3];
//   WheelJoint1.cylinder.rvisobj = WheelJoint1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint1.cylinder.R.T[1,1],WheelJoint1.cylinder.R.T[1,2],WheelJoint1.cylinder.R.T[1,3]},{WheelJoint1.cylinder.R.T[2,1],WheelJoint1.cylinder.R.T[2,2],WheelJoint1.cylinder.R.T[2,3]},{WheelJoint1.cylinder.R.T[3,1],WheelJoint1.cylinder.R.T[3,2],WheelJoint1.cylinder.R.T[3,3]}},{WheelJoint1.cylinder.r_shape[1],WheelJoint1.cylinder.r_shape[2],WheelJoint1.cylinder.r_shape[3]});
//   WheelJoint1.cylinder.size[1] = WheelJoint1.cylinder.length;
//   WheelJoint1.cylinder.size[2] = WheelJoint1.cylinder.width;
//   WheelJoint1.cylinder.size[3] = WheelJoint1.cylinder.height;
//   WheelJoint1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint1.cylinder.color[1] / 255.0,WheelJoint1.cylinder.color[2] / 255.0,WheelJoint1.cylinder.color[3] / 255.0,WheelJoint1.cylinder.specularCoefficient);
//   WheelJoint1.cylinder.Extra = WheelJoint1.cylinder.extra;
//   WheelJoint1.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint1.e0[2],WheelJoint1.e0[1],0.0},WheelJoint1.flange_a.phi,0.0);
//   WheelJoint1.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint1.rim1.shapeType);
//   WheelJoint1.rim1.rxvisobj[1] = WheelJoint1.rim1.R.T[1,1] * WheelJoint1.rim1.e_x[1] + WheelJoint1.rim1.R.T[2,1] * WheelJoint1.rim1.e_x[2] + WheelJoint1.rim1.R.T[3,1] * WheelJoint1.rim1.e_x[3];
//   WheelJoint1.rim1.rxvisobj[2] = WheelJoint1.rim1.R.T[1,2] * WheelJoint1.rim1.e_x[1] + WheelJoint1.rim1.R.T[2,2] * WheelJoint1.rim1.e_x[2] + WheelJoint1.rim1.R.T[3,2] * WheelJoint1.rim1.e_x[3];
//   WheelJoint1.rim1.rxvisobj[3] = WheelJoint1.rim1.R.T[1,3] * WheelJoint1.rim1.e_x[1] + WheelJoint1.rim1.R.T[2,3] * WheelJoint1.rim1.e_x[2] + WheelJoint1.rim1.R.T[3,3] * WheelJoint1.rim1.e_x[3];
//   WheelJoint1.rim1.ryvisobj[1] = WheelJoint1.rim1.R.T[1,1] * WheelJoint1.rim1.e_y[1] + WheelJoint1.rim1.R.T[2,1] * WheelJoint1.rim1.e_y[2] + WheelJoint1.rim1.R.T[3,1] * WheelJoint1.rim1.e_y[3];
//   WheelJoint1.rim1.ryvisobj[2] = WheelJoint1.rim1.R.T[1,2] * WheelJoint1.rim1.e_y[1] + WheelJoint1.rim1.R.T[2,2] * WheelJoint1.rim1.e_y[2] + WheelJoint1.rim1.R.T[3,2] * WheelJoint1.rim1.e_y[3];
//   WheelJoint1.rim1.ryvisobj[3] = WheelJoint1.rim1.R.T[1,3] * WheelJoint1.rim1.e_y[1] + WheelJoint1.rim1.R.T[2,3] * WheelJoint1.rim1.e_y[2] + WheelJoint1.rim1.R.T[3,3] * WheelJoint1.rim1.e_y[3];
//   WheelJoint1.rim1.rvisobj = WheelJoint1.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint1.rim1.R.T[1,1],WheelJoint1.rim1.R.T[1,2],WheelJoint1.rim1.R.T[1,3]},{WheelJoint1.rim1.R.T[2,1],WheelJoint1.rim1.R.T[2,2],WheelJoint1.rim1.R.T[2,3]},{WheelJoint1.rim1.R.T[3,1],WheelJoint1.rim1.R.T[3,2],WheelJoint1.rim1.R.T[3,3]}},{WheelJoint1.rim1.r_shape[1],WheelJoint1.rim1.r_shape[2],WheelJoint1.rim1.r_shape[3]});
//   WheelJoint1.rim1.size[1] = WheelJoint1.rim1.length;
//   WheelJoint1.rim1.size[2] = WheelJoint1.rim1.width;
//   WheelJoint1.rim1.size[3] = WheelJoint1.rim1.height;
//   WheelJoint1.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint1.rim1.color[1] / 255.0,WheelJoint1.rim1.color[2] / 255.0,WheelJoint1.rim1.color[3] / 255.0,WheelJoint1.rim1.specularCoefficient);
//   WheelJoint1.rim1.Extra = WheelJoint1.rim1.extra;
//   WheelJoint1.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint1.e0[2],WheelJoint1.e0[1],0.0},1.5707963267949 + WheelJoint1.flange_a.phi,0.0);
//   WheelJoint1.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint1.rim2.shapeType);
//   WheelJoint1.rim2.rxvisobj[1] = WheelJoint1.rim2.R.T[1,1] * WheelJoint1.rim2.e_x[1] + WheelJoint1.rim2.R.T[2,1] * WheelJoint1.rim2.e_x[2] + WheelJoint1.rim2.R.T[3,1] * WheelJoint1.rim2.e_x[3];
//   WheelJoint1.rim2.rxvisobj[2] = WheelJoint1.rim2.R.T[1,2] * WheelJoint1.rim2.e_x[1] + WheelJoint1.rim2.R.T[2,2] * WheelJoint1.rim2.e_x[2] + WheelJoint1.rim2.R.T[3,2] * WheelJoint1.rim2.e_x[3];
//   WheelJoint1.rim2.rxvisobj[3] = WheelJoint1.rim2.R.T[1,3] * WheelJoint1.rim2.e_x[1] + WheelJoint1.rim2.R.T[2,3] * WheelJoint1.rim2.e_x[2] + WheelJoint1.rim2.R.T[3,3] * WheelJoint1.rim2.e_x[3];
//   WheelJoint1.rim2.ryvisobj[1] = WheelJoint1.rim2.R.T[1,1] * WheelJoint1.rim2.e_y[1] + WheelJoint1.rim2.R.T[2,1] * WheelJoint1.rim2.e_y[2] + WheelJoint1.rim2.R.T[3,1] * WheelJoint1.rim2.e_y[3];
//   WheelJoint1.rim2.ryvisobj[2] = WheelJoint1.rim2.R.T[1,2] * WheelJoint1.rim2.e_y[1] + WheelJoint1.rim2.R.T[2,2] * WheelJoint1.rim2.e_y[2] + WheelJoint1.rim2.R.T[3,2] * WheelJoint1.rim2.e_y[3];
//   WheelJoint1.rim2.ryvisobj[3] = WheelJoint1.rim2.R.T[1,3] * WheelJoint1.rim2.e_y[1] + WheelJoint1.rim2.R.T[2,3] * WheelJoint1.rim2.e_y[2] + WheelJoint1.rim2.R.T[3,3] * WheelJoint1.rim2.e_y[3];
//   WheelJoint1.rim2.rvisobj = WheelJoint1.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint1.rim2.R.T[1,1],WheelJoint1.rim2.R.T[1,2],WheelJoint1.rim2.R.T[1,3]},{WheelJoint1.rim2.R.T[2,1],WheelJoint1.rim2.R.T[2,2],WheelJoint1.rim2.R.T[2,3]},{WheelJoint1.rim2.R.T[3,1],WheelJoint1.rim2.R.T[3,2],WheelJoint1.rim2.R.T[3,3]}},{WheelJoint1.rim2.r_shape[1],WheelJoint1.rim2.r_shape[2],WheelJoint1.rim2.r_shape[3]});
//   WheelJoint1.rim2.size[1] = WheelJoint1.rim2.length;
//   WheelJoint1.rim2.size[2] = WheelJoint1.rim2.width;
//   WheelJoint1.rim2.size[3] = WheelJoint1.rim2.height;
//   WheelJoint1.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint1.rim2.color[1] / 255.0,WheelJoint1.rim2.color[2] / 255.0,WheelJoint1.rim2.color[3] / 255.0,WheelJoint1.rim2.specularCoefficient);
//   WheelJoint1.rim2.Extra = WheelJoint1.rim2.extra;
//   WheelJoint1.R[1,1] = cos(WheelJoint1.frame_a.phi);
//   WheelJoint1.R[1,2] = sin(WheelJoint1.frame_a.phi);
//   WheelJoint1.R[2,1] = -sin(WheelJoint1.frame_a.phi);
//   WheelJoint1.R[2,2] = cos(WheelJoint1.frame_a.phi);
//   WheelJoint1.e0[1] = WheelJoint1.R[1,1] * WheelJoint1.e[1] + WheelJoint1.R[1,2] * WheelJoint1.e[2];
//   WheelJoint1.e0[2] = WheelJoint1.R[2,1] * WheelJoint1.e[1] + WheelJoint1.R[2,2] * WheelJoint1.e[2];
//   WheelJoint1.v[1] = der(WheelJoint1.frame_a.x);
//   WheelJoint1.v[2] = der(WheelJoint1.frame_a.y);
//   WheelJoint1.w_roll = der(WheelJoint1.flange_a.phi);
//   WheelJoint1.v_long = WheelJoint1.v[1] * WheelJoint1.e0[1] + WheelJoint1.v[2] * WheelJoint1.e0[2];
//   WheelJoint1.v_lat = (-WheelJoint1.v[1]) * WheelJoint1.e0[2] + WheelJoint1.v[2] * WheelJoint1.e0[1];
//   WheelJoint1.v_slip_lat = WheelJoint1.v_lat;
//   WheelJoint1.v_slip_long = WheelJoint1.v_long - WheelJoint1.radius * WheelJoint1.w_roll;
//   WheelJoint1.v_slip = 0.0001 + sqrt(WheelJoint1.v_slip_long ^ 2.0 + WheelJoint1.v_slip_lat ^ 2.0);
//   (-WheelJoint1.f_long) * WheelJoint1.radius = WheelJoint1.flange_a.tau;
//   WheelJoint1.frame_a.t = 0.0;
//   WheelJoint1.f = WheelJoint1.N * PlanarMechanicsV4.Utilities.TripleS_Func(WheelJoint1.vAdhesion,WheelJoint1.vSlide,WheelJoint1.mu_A,WheelJoint1.mu_S,WheelJoint1.v_slip);
//   WheelJoint1.f_long = (WheelJoint1.f * WheelJoint1.v_slip_long) / WheelJoint1.v_slip;
//   WheelJoint1.f_lat = (WheelJoint1.f * WheelJoint1.v_slip_lat) / WheelJoint1.v_slip;
//   WheelJoint1.f_long = WheelJoint1.frame_a.fx * WheelJoint1.e0[1] + WheelJoint1.frame_a.fy * WheelJoint1.e0[2];
//   WheelJoint1.f_lat = WheelJoint1.frame_a.fy * WheelJoint1.e0[1] + (-WheelJoint1.frame_a.fx) * WheelJoint1.e0[2];
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   WheelJoint2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint2.cylinder.shapeType);
//   WheelJoint2.cylinder.rxvisobj[1] = WheelJoint2.cylinder.R.T[1,1] * WheelJoint2.cylinder.e_x[1] + WheelJoint2.cylinder.R.T[2,1] * WheelJoint2.cylinder.e_x[2] + WheelJoint2.cylinder.R.T[3,1] * WheelJoint2.cylinder.e_x[3];
//   WheelJoint2.cylinder.rxvisobj[2] = WheelJoint2.cylinder.R.T[1,2] * WheelJoint2.cylinder.e_x[1] + WheelJoint2.cylinder.R.T[2,2] * WheelJoint2.cylinder.e_x[2] + WheelJoint2.cylinder.R.T[3,2] * WheelJoint2.cylinder.e_x[3];
//   WheelJoint2.cylinder.rxvisobj[3] = WheelJoint2.cylinder.R.T[1,3] * WheelJoint2.cylinder.e_x[1] + WheelJoint2.cylinder.R.T[2,3] * WheelJoint2.cylinder.e_x[2] + WheelJoint2.cylinder.R.T[3,3] * WheelJoint2.cylinder.e_x[3];
//   WheelJoint2.cylinder.ryvisobj[1] = WheelJoint2.cylinder.R.T[1,1] * WheelJoint2.cylinder.e_y[1] + WheelJoint2.cylinder.R.T[2,1] * WheelJoint2.cylinder.e_y[2] + WheelJoint2.cylinder.R.T[3,1] * WheelJoint2.cylinder.e_y[3];
//   WheelJoint2.cylinder.ryvisobj[2] = WheelJoint2.cylinder.R.T[1,2] * WheelJoint2.cylinder.e_y[1] + WheelJoint2.cylinder.R.T[2,2] * WheelJoint2.cylinder.e_y[2] + WheelJoint2.cylinder.R.T[3,2] * WheelJoint2.cylinder.e_y[3];
//   WheelJoint2.cylinder.ryvisobj[3] = WheelJoint2.cylinder.R.T[1,3] * WheelJoint2.cylinder.e_y[1] + WheelJoint2.cylinder.R.T[2,3] * WheelJoint2.cylinder.e_y[2] + WheelJoint2.cylinder.R.T[3,3] * WheelJoint2.cylinder.e_y[3];
//   WheelJoint2.cylinder.rvisobj = WheelJoint2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint2.cylinder.R.T[1,1],WheelJoint2.cylinder.R.T[1,2],WheelJoint2.cylinder.R.T[1,3]},{WheelJoint2.cylinder.R.T[2,1],WheelJoint2.cylinder.R.T[2,2],WheelJoint2.cylinder.R.T[2,3]},{WheelJoint2.cylinder.R.T[3,1],WheelJoint2.cylinder.R.T[3,2],WheelJoint2.cylinder.R.T[3,3]}},{WheelJoint2.cylinder.r_shape[1],WheelJoint2.cylinder.r_shape[2],WheelJoint2.cylinder.r_shape[3]});
//   WheelJoint2.cylinder.size[1] = WheelJoint2.cylinder.length;
//   WheelJoint2.cylinder.size[2] = WheelJoint2.cylinder.width;
//   WheelJoint2.cylinder.size[3] = WheelJoint2.cylinder.height;
//   WheelJoint2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint2.cylinder.color[1] / 255.0,WheelJoint2.cylinder.color[2] / 255.0,WheelJoint2.cylinder.color[3] / 255.0,WheelJoint2.cylinder.specularCoefficient);
//   WheelJoint2.cylinder.Extra = WheelJoint2.cylinder.extra;
//   WheelJoint2.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint2.e0[2],WheelJoint2.e0[1],0.0},WheelJoint2.flange_a.phi,0.0);
//   WheelJoint2.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint2.rim1.shapeType);
//   WheelJoint2.rim1.rxvisobj[1] = WheelJoint2.rim1.R.T[1,1] * WheelJoint2.rim1.e_x[1] + WheelJoint2.rim1.R.T[2,1] * WheelJoint2.rim1.e_x[2] + WheelJoint2.rim1.R.T[3,1] * WheelJoint2.rim1.e_x[3];
//   WheelJoint2.rim1.rxvisobj[2] = WheelJoint2.rim1.R.T[1,2] * WheelJoint2.rim1.e_x[1] + WheelJoint2.rim1.R.T[2,2] * WheelJoint2.rim1.e_x[2] + WheelJoint2.rim1.R.T[3,2] * WheelJoint2.rim1.e_x[3];
//   WheelJoint2.rim1.rxvisobj[3] = WheelJoint2.rim1.R.T[1,3] * WheelJoint2.rim1.e_x[1] + WheelJoint2.rim1.R.T[2,3] * WheelJoint2.rim1.e_x[2] + WheelJoint2.rim1.R.T[3,3] * WheelJoint2.rim1.e_x[3];
//   WheelJoint2.rim1.ryvisobj[1] = WheelJoint2.rim1.R.T[1,1] * WheelJoint2.rim1.e_y[1] + WheelJoint2.rim1.R.T[2,1] * WheelJoint2.rim1.e_y[2] + WheelJoint2.rim1.R.T[3,1] * WheelJoint2.rim1.e_y[3];
//   WheelJoint2.rim1.ryvisobj[2] = WheelJoint2.rim1.R.T[1,2] * WheelJoint2.rim1.e_y[1] + WheelJoint2.rim1.R.T[2,2] * WheelJoint2.rim1.e_y[2] + WheelJoint2.rim1.R.T[3,2] * WheelJoint2.rim1.e_y[3];
//   WheelJoint2.rim1.ryvisobj[3] = WheelJoint2.rim1.R.T[1,3] * WheelJoint2.rim1.e_y[1] + WheelJoint2.rim1.R.T[2,3] * WheelJoint2.rim1.e_y[2] + WheelJoint2.rim1.R.T[3,3] * WheelJoint2.rim1.e_y[3];
//   WheelJoint2.rim1.rvisobj = WheelJoint2.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint2.rim1.R.T[1,1],WheelJoint2.rim1.R.T[1,2],WheelJoint2.rim1.R.T[1,3]},{WheelJoint2.rim1.R.T[2,1],WheelJoint2.rim1.R.T[2,2],WheelJoint2.rim1.R.T[2,3]},{WheelJoint2.rim1.R.T[3,1],WheelJoint2.rim1.R.T[3,2],WheelJoint2.rim1.R.T[3,3]}},{WheelJoint2.rim1.r_shape[1],WheelJoint2.rim1.r_shape[2],WheelJoint2.rim1.r_shape[3]});
//   WheelJoint2.rim1.size[1] = WheelJoint2.rim1.length;
//   WheelJoint2.rim1.size[2] = WheelJoint2.rim1.width;
//   WheelJoint2.rim1.size[3] = WheelJoint2.rim1.height;
//   WheelJoint2.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint2.rim1.color[1] / 255.0,WheelJoint2.rim1.color[2] / 255.0,WheelJoint2.rim1.color[3] / 255.0,WheelJoint2.rim1.specularCoefficient);
//   WheelJoint2.rim1.Extra = WheelJoint2.rim1.extra;
//   WheelJoint2.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint2.e0[2],WheelJoint2.e0[1],0.0},1.5707963267949 + WheelJoint2.flange_a.phi,0.0);
//   WheelJoint2.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint2.rim2.shapeType);
//   WheelJoint2.rim2.rxvisobj[1] = WheelJoint2.rim2.R.T[1,1] * WheelJoint2.rim2.e_x[1] + WheelJoint2.rim2.R.T[2,1] * WheelJoint2.rim2.e_x[2] + WheelJoint2.rim2.R.T[3,1] * WheelJoint2.rim2.e_x[3];
//   WheelJoint2.rim2.rxvisobj[2] = WheelJoint2.rim2.R.T[1,2] * WheelJoint2.rim2.e_x[1] + WheelJoint2.rim2.R.T[2,2] * WheelJoint2.rim2.e_x[2] + WheelJoint2.rim2.R.T[3,2] * WheelJoint2.rim2.e_x[3];
//   WheelJoint2.rim2.rxvisobj[3] = WheelJoint2.rim2.R.T[1,3] * WheelJoint2.rim2.e_x[1] + WheelJoint2.rim2.R.T[2,3] * WheelJoint2.rim2.e_x[2] + WheelJoint2.rim2.R.T[3,3] * WheelJoint2.rim2.e_x[3];
//   WheelJoint2.rim2.ryvisobj[1] = WheelJoint2.rim2.R.T[1,1] * WheelJoint2.rim2.e_y[1] + WheelJoint2.rim2.R.T[2,1] * WheelJoint2.rim2.e_y[2] + WheelJoint2.rim2.R.T[3,1] * WheelJoint2.rim2.e_y[3];
//   WheelJoint2.rim2.ryvisobj[2] = WheelJoint2.rim2.R.T[1,2] * WheelJoint2.rim2.e_y[1] + WheelJoint2.rim2.R.T[2,2] * WheelJoint2.rim2.e_y[2] + WheelJoint2.rim2.R.T[3,2] * WheelJoint2.rim2.e_y[3];
//   WheelJoint2.rim2.ryvisobj[3] = WheelJoint2.rim2.R.T[1,3] * WheelJoint2.rim2.e_y[1] + WheelJoint2.rim2.R.T[2,3] * WheelJoint2.rim2.e_y[2] + WheelJoint2.rim2.R.T[3,3] * WheelJoint2.rim2.e_y[3];
//   WheelJoint2.rim2.rvisobj = WheelJoint2.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint2.rim2.R.T[1,1],WheelJoint2.rim2.R.T[1,2],WheelJoint2.rim2.R.T[1,3]},{WheelJoint2.rim2.R.T[2,1],WheelJoint2.rim2.R.T[2,2],WheelJoint2.rim2.R.T[2,3]},{WheelJoint2.rim2.R.T[3,1],WheelJoint2.rim2.R.T[3,2],WheelJoint2.rim2.R.T[3,3]}},{WheelJoint2.rim2.r_shape[1],WheelJoint2.rim2.r_shape[2],WheelJoint2.rim2.r_shape[3]});
//   WheelJoint2.rim2.size[1] = WheelJoint2.rim2.length;
//   WheelJoint2.rim2.size[2] = WheelJoint2.rim2.width;
//   WheelJoint2.rim2.size[3] = WheelJoint2.rim2.height;
//   WheelJoint2.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint2.rim2.color[1] / 255.0,WheelJoint2.rim2.color[2] / 255.0,WheelJoint2.rim2.color[3] / 255.0,WheelJoint2.rim2.specularCoefficient);
//   WheelJoint2.rim2.Extra = WheelJoint2.rim2.extra;
//   WheelJoint2.R[1,1] = cos(WheelJoint2.frame_a.phi);
//   WheelJoint2.R[1,2] = sin(WheelJoint2.frame_a.phi);
//   WheelJoint2.R[2,1] = -sin(WheelJoint2.frame_a.phi);
//   WheelJoint2.R[2,2] = cos(WheelJoint2.frame_a.phi);
//   WheelJoint2.e0[1] = WheelJoint2.R[1,1] * WheelJoint2.e[1] + WheelJoint2.R[1,2] * WheelJoint2.e[2];
//   WheelJoint2.e0[2] = WheelJoint2.R[2,1] * WheelJoint2.e[1] + WheelJoint2.R[2,2] * WheelJoint2.e[2];
//   WheelJoint2.v[1] = der(WheelJoint2.frame_a.x);
//   WheelJoint2.v[2] = der(WheelJoint2.frame_a.y);
//   WheelJoint2.w_roll = der(WheelJoint2.flange_a.phi);
//   WheelJoint2.v_long = WheelJoint2.v[1] * WheelJoint2.e0[1] + WheelJoint2.v[2] * WheelJoint2.e0[2];
//   WheelJoint2.v_lat = (-WheelJoint2.v[1]) * WheelJoint2.e0[2] + WheelJoint2.v[2] * WheelJoint2.e0[1];
//   WheelJoint2.v_slip_lat = WheelJoint2.v_lat;
//   WheelJoint2.v_slip_long = WheelJoint2.v_long - WheelJoint2.radius * WheelJoint2.w_roll;
//   WheelJoint2.v_slip = 0.0001 + sqrt(WheelJoint2.v_slip_long ^ 2.0 + WheelJoint2.v_slip_lat ^ 2.0);
//   (-WheelJoint2.f_long) * WheelJoint2.radius = WheelJoint2.flange_a.tau;
//   WheelJoint2.frame_a.t = 0.0;
//   WheelJoint2.f = WheelJoint2.N * PlanarMechanicsV4.Utilities.TripleS_Func(WheelJoint2.vAdhesion,WheelJoint2.vSlide,WheelJoint2.mu_A,WheelJoint2.mu_S,WheelJoint2.v_slip);
//   WheelJoint2.f_long = (WheelJoint2.f * WheelJoint2.v_slip_long) / WheelJoint2.v_slip;
//   WheelJoint2.f_lat = (WheelJoint2.f * WheelJoint2.v_slip_lat) / WheelJoint2.v_slip;
//   WheelJoint2.f_long = WheelJoint2.frame_a.fx * WheelJoint2.e0[1] + WheelJoint2.frame_a.fy * WheelJoint2.e0[2];
//   WheelJoint2.f_lat = WheelJoint2.frame_a.fy * WheelJoint2.e0[1] + (-WheelJoint2.frame_a.fx) * WheelJoint2.e0[2];
//   constantTorque1.tau = -constantTorque1.flange.tau;
//   constantTorque1.tau = constantTorque1.tau_constant;
//   constantTorque1.phi = constantTorque1.flange.phi - constantTorque1.phi_support;
//   constantTorque1.phi_support = 0.0;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   inertia1.phi = inertia1.flange_a.phi;
//   inertia1.phi = inertia1.flange_b.phi;
//   inertia1.w = der(inertia1.phi);
//   inertia1.a = der(inertia1.w);
//   inertia1.J * inertia1.a = inertia1.flange_a.tau + inertia1.flange_b.tau;
//   fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.cylinder.shapeType);
//   fixedTranslation2.cylinder.rxvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.ryvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.rvisobj = fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.cylinder.R.T[1,1],fixedTranslation2.cylinder.R.T[1,2],fixedTranslation2.cylinder.R.T[1,3]},{fixedTranslation2.cylinder.R.T[2,1],fixedTranslation2.cylinder.R.T[2,2],fixedTranslation2.cylinder.R.T[2,3]},{fixedTranslation2.cylinder.R.T[3,1],fixedTranslation2.cylinder.R.T[3,2],fixedTranslation2.cylinder.R.T[3,3]}},{fixedTranslation2.cylinder.r_shape[1],fixedTranslation2.cylinder.r_shape[2],fixedTranslation2.cylinder.r_shape[3]});
//   fixedTranslation2.cylinder.size[1] = fixedTranslation2.cylinder.length;
//   fixedTranslation2.cylinder.size[2] = fixedTranslation2.cylinder.width;
//   fixedTranslation2.cylinder.size[3] = fixedTranslation2.cylinder.height;
//   fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.cylinder.color[1] / 255.0,fixedTranslation2.cylinder.color[2] / 255.0,fixedTranslation2.cylinder.color[3] / 255.0,fixedTranslation2.cylinder.specularCoefficient);
//   fixedTranslation2.cylinder.Extra = fixedTranslation2.cylinder.extra;
//   fixedTranslation2.R[1,1] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[1,2] = sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,1] = -sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,2] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.r0[1] = fixedTranslation2.R[1,1] * fixedTranslation2.r[1] + fixedTranslation2.R[1,2] * fixedTranslation2.r[2];
//   fixedTranslation2.r0[2] = fixedTranslation2.R[2,1] * fixedTranslation2.r[1] + fixedTranslation2.R[2,2] * fixedTranslation2.r[2];
//   fixedTranslation2.frame_a.x + fixedTranslation2.r0[1] = fixedTranslation2.frame_b.x;
//   fixedTranslation2.frame_a.y + fixedTranslation2.r0[2] = fixedTranslation2.frame_b.y;
//   fixedTranslation2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   fixedTranslation2.frame_a.fx + fixedTranslation2.frame_b.fx = 0.0;
//   fixedTranslation2.frame_a.fy + fixedTranslation2.frame_b.fy = 0.0;
//   fixedTranslation2.frame_a.t + (fixedTranslation2.frame_b.t + ((-fixedTranslation2.r0[1]) * fixedTranslation2.frame_b.fy + fixedTranslation2.r0[2] * fixedTranslation2.frame_b.fx)) = 0.0;
//   fixedTranslation3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.cylinder.shapeType);
//   fixedTranslation3.cylinder.rxvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.ryvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.rvisobj = fixedTranslation3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.cylinder.R.T[1,1],fixedTranslation3.cylinder.R.T[1,2],fixedTranslation3.cylinder.R.T[1,3]},{fixedTranslation3.cylinder.R.T[2,1],fixedTranslation3.cylinder.R.T[2,2],fixedTranslation3.cylinder.R.T[2,3]},{fixedTranslation3.cylinder.R.T[3,1],fixedTranslation3.cylinder.R.T[3,2],fixedTranslation3.cylinder.R.T[3,3]}},{fixedTranslation3.cylinder.r_shape[1],fixedTranslation3.cylinder.r_shape[2],fixedTranslation3.cylinder.r_shape[3]});
//   fixedTranslation3.cylinder.size[1] = fixedTranslation3.cylinder.length;
//   fixedTranslation3.cylinder.size[2] = fixedTranslation3.cylinder.width;
//   fixedTranslation3.cylinder.size[3] = fixedTranslation3.cylinder.height;
//   fixedTranslation3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.cylinder.color[1] / 255.0,fixedTranslation3.cylinder.color[2] / 255.0,fixedTranslation3.cylinder.color[3] / 255.0,fixedTranslation3.cylinder.specularCoefficient);
//   fixedTranslation3.cylinder.Extra = fixedTranslation3.cylinder.extra;
//   fixedTranslation3.R[1,1] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[1,2] = sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,1] = -sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,2] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.r0[1] = fixedTranslation3.R[1,1] * fixedTranslation3.r[1] + fixedTranslation3.R[1,2] * fixedTranslation3.r[2];
//   fixedTranslation3.r0[2] = fixedTranslation3.R[2,1] * fixedTranslation3.r[1] + fixedTranslation3.R[2,2] * fixedTranslation3.r[2];
//   fixedTranslation3.frame_a.x + fixedTranslation3.r0[1] = fixedTranslation3.frame_b.x;
//   fixedTranslation3.frame_a.y + fixedTranslation3.r0[2] = fixedTranslation3.frame_b.y;
//   fixedTranslation3.frame_a.phi = fixedTranslation3.frame_b.phi;
//   fixedTranslation3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation3.frame_a.t + (fixedTranslation3.frame_b.t + ((-fixedTranslation3.r0[1]) * fixedTranslation3.frame_b.fy + fixedTranslation3.r0[2] * fixedTranslation3.frame_b.fx)) = 0.0;
//   WheelJoint3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint3.cylinder.shapeType);
//   WheelJoint3.cylinder.rxvisobj[1] = WheelJoint3.cylinder.R.T[1,1] * WheelJoint3.cylinder.e_x[1] + WheelJoint3.cylinder.R.T[2,1] * WheelJoint3.cylinder.e_x[2] + WheelJoint3.cylinder.R.T[3,1] * WheelJoint3.cylinder.e_x[3];
//   WheelJoint3.cylinder.rxvisobj[2] = WheelJoint3.cylinder.R.T[1,2] * WheelJoint3.cylinder.e_x[1] + WheelJoint3.cylinder.R.T[2,2] * WheelJoint3.cylinder.e_x[2] + WheelJoint3.cylinder.R.T[3,2] * WheelJoint3.cylinder.e_x[3];
//   WheelJoint3.cylinder.rxvisobj[3] = WheelJoint3.cylinder.R.T[1,3] * WheelJoint3.cylinder.e_x[1] + WheelJoint3.cylinder.R.T[2,3] * WheelJoint3.cylinder.e_x[2] + WheelJoint3.cylinder.R.T[3,3] * WheelJoint3.cylinder.e_x[3];
//   WheelJoint3.cylinder.ryvisobj[1] = WheelJoint3.cylinder.R.T[1,1] * WheelJoint3.cylinder.e_y[1] + WheelJoint3.cylinder.R.T[2,1] * WheelJoint3.cylinder.e_y[2] + WheelJoint3.cylinder.R.T[3,1] * WheelJoint3.cylinder.e_y[3];
//   WheelJoint3.cylinder.ryvisobj[2] = WheelJoint3.cylinder.R.T[1,2] * WheelJoint3.cylinder.e_y[1] + WheelJoint3.cylinder.R.T[2,2] * WheelJoint3.cylinder.e_y[2] + WheelJoint3.cylinder.R.T[3,2] * WheelJoint3.cylinder.e_y[3];
//   WheelJoint3.cylinder.ryvisobj[3] = WheelJoint3.cylinder.R.T[1,3] * WheelJoint3.cylinder.e_y[1] + WheelJoint3.cylinder.R.T[2,3] * WheelJoint3.cylinder.e_y[2] + WheelJoint3.cylinder.R.T[3,3] * WheelJoint3.cylinder.e_y[3];
//   WheelJoint3.cylinder.rvisobj = WheelJoint3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint3.cylinder.R.T[1,1],WheelJoint3.cylinder.R.T[1,2],WheelJoint3.cylinder.R.T[1,3]},{WheelJoint3.cylinder.R.T[2,1],WheelJoint3.cylinder.R.T[2,2],WheelJoint3.cylinder.R.T[2,3]},{WheelJoint3.cylinder.R.T[3,1],WheelJoint3.cylinder.R.T[3,2],WheelJoint3.cylinder.R.T[3,3]}},{WheelJoint3.cylinder.r_shape[1],WheelJoint3.cylinder.r_shape[2],WheelJoint3.cylinder.r_shape[3]});
//   WheelJoint3.cylinder.size[1] = WheelJoint3.cylinder.length;
//   WheelJoint3.cylinder.size[2] = WheelJoint3.cylinder.width;
//   WheelJoint3.cylinder.size[3] = WheelJoint3.cylinder.height;
//   WheelJoint3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint3.cylinder.color[1] / 255.0,WheelJoint3.cylinder.color[2] / 255.0,WheelJoint3.cylinder.color[3] / 255.0,WheelJoint3.cylinder.specularCoefficient);
//   WheelJoint3.cylinder.Extra = WheelJoint3.cylinder.extra;
//   WheelJoint3.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint3.e0[2],WheelJoint3.e0[1],0.0},WheelJoint3.flange_a.phi,0.0);
//   WheelJoint3.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint3.rim1.shapeType);
//   WheelJoint3.rim1.rxvisobj[1] = WheelJoint3.rim1.R.T[1,1] * WheelJoint3.rim1.e_x[1] + WheelJoint3.rim1.R.T[2,1] * WheelJoint3.rim1.e_x[2] + WheelJoint3.rim1.R.T[3,1] * WheelJoint3.rim1.e_x[3];
//   WheelJoint3.rim1.rxvisobj[2] = WheelJoint3.rim1.R.T[1,2] * WheelJoint3.rim1.e_x[1] + WheelJoint3.rim1.R.T[2,2] * WheelJoint3.rim1.e_x[2] + WheelJoint3.rim1.R.T[3,2] * WheelJoint3.rim1.e_x[3];
//   WheelJoint3.rim1.rxvisobj[3] = WheelJoint3.rim1.R.T[1,3] * WheelJoint3.rim1.e_x[1] + WheelJoint3.rim1.R.T[2,3] * WheelJoint3.rim1.e_x[2] + WheelJoint3.rim1.R.T[3,3] * WheelJoint3.rim1.e_x[3];
//   WheelJoint3.rim1.ryvisobj[1] = WheelJoint3.rim1.R.T[1,1] * WheelJoint3.rim1.e_y[1] + WheelJoint3.rim1.R.T[2,1] * WheelJoint3.rim1.e_y[2] + WheelJoint3.rim1.R.T[3,1] * WheelJoint3.rim1.e_y[3];
//   WheelJoint3.rim1.ryvisobj[2] = WheelJoint3.rim1.R.T[1,2] * WheelJoint3.rim1.e_y[1] + WheelJoint3.rim1.R.T[2,2] * WheelJoint3.rim1.e_y[2] + WheelJoint3.rim1.R.T[3,2] * WheelJoint3.rim1.e_y[3];
//   WheelJoint3.rim1.ryvisobj[3] = WheelJoint3.rim1.R.T[1,3] * WheelJoint3.rim1.e_y[1] + WheelJoint3.rim1.R.T[2,3] * WheelJoint3.rim1.e_y[2] + WheelJoint3.rim1.R.T[3,3] * WheelJoint3.rim1.e_y[3];
//   WheelJoint3.rim1.rvisobj = WheelJoint3.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint3.rim1.R.T[1,1],WheelJoint3.rim1.R.T[1,2],WheelJoint3.rim1.R.T[1,3]},{WheelJoint3.rim1.R.T[2,1],WheelJoint3.rim1.R.T[2,2],WheelJoint3.rim1.R.T[2,3]},{WheelJoint3.rim1.R.T[3,1],WheelJoint3.rim1.R.T[3,2],WheelJoint3.rim1.R.T[3,3]}},{WheelJoint3.rim1.r_shape[1],WheelJoint3.rim1.r_shape[2],WheelJoint3.rim1.r_shape[3]});
//   WheelJoint3.rim1.size[1] = WheelJoint3.rim1.length;
//   WheelJoint3.rim1.size[2] = WheelJoint3.rim1.width;
//   WheelJoint3.rim1.size[3] = WheelJoint3.rim1.height;
//   WheelJoint3.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint3.rim1.color[1] / 255.0,WheelJoint3.rim1.color[2] / 255.0,WheelJoint3.rim1.color[3] / 255.0,WheelJoint3.rim1.specularCoefficient);
//   WheelJoint3.rim1.Extra = WheelJoint3.rim1.extra;
//   WheelJoint3.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint3.e0[2],WheelJoint3.e0[1],0.0},1.5707963267949 + WheelJoint3.flange_a.phi,0.0);
//   WheelJoint3.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint3.rim2.shapeType);
//   WheelJoint3.rim2.rxvisobj[1] = WheelJoint3.rim2.R.T[1,1] * WheelJoint3.rim2.e_x[1] + WheelJoint3.rim2.R.T[2,1] * WheelJoint3.rim2.e_x[2] + WheelJoint3.rim2.R.T[3,1] * WheelJoint3.rim2.e_x[3];
//   WheelJoint3.rim2.rxvisobj[2] = WheelJoint3.rim2.R.T[1,2] * WheelJoint3.rim2.e_x[1] + WheelJoint3.rim2.R.T[2,2] * WheelJoint3.rim2.e_x[2] + WheelJoint3.rim2.R.T[3,2] * WheelJoint3.rim2.e_x[3];
//   WheelJoint3.rim2.rxvisobj[3] = WheelJoint3.rim2.R.T[1,3] * WheelJoint3.rim2.e_x[1] + WheelJoint3.rim2.R.T[2,3] * WheelJoint3.rim2.e_x[2] + WheelJoint3.rim2.R.T[3,3] * WheelJoint3.rim2.e_x[3];
//   WheelJoint3.rim2.ryvisobj[1] = WheelJoint3.rim2.R.T[1,1] * WheelJoint3.rim2.e_y[1] + WheelJoint3.rim2.R.T[2,1] * WheelJoint3.rim2.e_y[2] + WheelJoint3.rim2.R.T[3,1] * WheelJoint3.rim2.e_y[3];
//   WheelJoint3.rim2.ryvisobj[2] = WheelJoint3.rim2.R.T[1,2] * WheelJoint3.rim2.e_y[1] + WheelJoint3.rim2.R.T[2,2] * WheelJoint3.rim2.e_y[2] + WheelJoint3.rim2.R.T[3,2] * WheelJoint3.rim2.e_y[3];
//   WheelJoint3.rim2.ryvisobj[3] = WheelJoint3.rim2.R.T[1,3] * WheelJoint3.rim2.e_y[1] + WheelJoint3.rim2.R.T[2,3] * WheelJoint3.rim2.e_y[2] + WheelJoint3.rim2.R.T[3,3] * WheelJoint3.rim2.e_y[3];
//   WheelJoint3.rim2.rvisobj = WheelJoint3.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint3.rim2.R.T[1,1],WheelJoint3.rim2.R.T[1,2],WheelJoint3.rim2.R.T[1,3]},{WheelJoint3.rim2.R.T[2,1],WheelJoint3.rim2.R.T[2,2],WheelJoint3.rim2.R.T[2,3]},{WheelJoint3.rim2.R.T[3,1],WheelJoint3.rim2.R.T[3,2],WheelJoint3.rim2.R.T[3,3]}},{WheelJoint3.rim2.r_shape[1],WheelJoint3.rim2.r_shape[2],WheelJoint3.rim2.r_shape[3]});
//   WheelJoint3.rim2.size[1] = WheelJoint3.rim2.length;
//   WheelJoint3.rim2.size[2] = WheelJoint3.rim2.width;
//   WheelJoint3.rim2.size[3] = WheelJoint3.rim2.height;
//   WheelJoint3.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint3.rim2.color[1] / 255.0,WheelJoint3.rim2.color[2] / 255.0,WheelJoint3.rim2.color[3] / 255.0,WheelJoint3.rim2.specularCoefficient);
//   WheelJoint3.rim2.Extra = WheelJoint3.rim2.extra;
//   WheelJoint3.R[1,1] = cos(WheelJoint3.frame_a.phi);
//   WheelJoint3.R[1,2] = sin(WheelJoint3.frame_a.phi);
//   WheelJoint3.R[2,1] = -sin(WheelJoint3.frame_a.phi);
//   WheelJoint3.R[2,2] = cos(WheelJoint3.frame_a.phi);
//   WheelJoint3.e0[1] = WheelJoint3.R[1,1] * WheelJoint3.e[1] + WheelJoint3.R[1,2] * WheelJoint3.e[2];
//   WheelJoint3.e0[2] = WheelJoint3.R[2,1] * WheelJoint3.e[1] + WheelJoint3.R[2,2] * WheelJoint3.e[2];
//   WheelJoint3.v[1] = der(WheelJoint3.frame_a.x);
//   WheelJoint3.v[2] = der(WheelJoint3.frame_a.y);
//   WheelJoint3.w_roll = der(WheelJoint3.flange_a.phi);
//   WheelJoint3.v_long = WheelJoint3.v[1] * WheelJoint3.e0[1] + WheelJoint3.v[2] * WheelJoint3.e0[2];
//   WheelJoint3.v_lat = (-WheelJoint3.v[1]) * WheelJoint3.e0[2] + WheelJoint3.v[2] * WheelJoint3.e0[1];
//   WheelJoint3.v_slip_lat = WheelJoint3.v_lat;
//   WheelJoint3.v_slip_long = WheelJoint3.v_long - WheelJoint3.radius * WheelJoint3.w_roll;
//   WheelJoint3.v_slip = 0.0001 + sqrt(WheelJoint3.v_slip_long ^ 2.0 + WheelJoint3.v_slip_lat ^ 2.0);
//   (-WheelJoint3.f_long) * WheelJoint3.radius = WheelJoint3.flange_a.tau;
//   WheelJoint3.frame_a.t = 0.0;
//   WheelJoint3.f = WheelJoint3.N * PlanarMechanicsV4.Utilities.TripleS_Func(WheelJoint3.vAdhesion,WheelJoint3.vSlide,WheelJoint3.mu_A,WheelJoint3.mu_S,WheelJoint3.v_slip);
//   WheelJoint3.f_long = (WheelJoint3.f * WheelJoint3.v_slip_long) / WheelJoint3.v_slip;
//   WheelJoint3.f_lat = (WheelJoint3.f * WheelJoint3.v_slip_lat) / WheelJoint3.v_slip;
//   WheelJoint3.f_long = WheelJoint3.frame_a.fx * WheelJoint3.e0[1] + WheelJoint3.frame_a.fy * WheelJoint3.e0[2];
//   WheelJoint3.f_lat = WheelJoint3.frame_a.fy * WheelJoint3.e0[1] + (-WheelJoint3.frame_a.fx) * WheelJoint3.e0[2];
//   inertia2.phi = inertia2.flange_a.phi;
//   inertia2.phi = inertia2.flange_b.phi;
//   inertia2.w = der(inertia2.phi);
//   inertia2.a = der(inertia2.w);
//   inertia2.J * inertia2.a = inertia2.flange_a.tau + inertia2.flange_b.tau;
//   fixedTranslation4.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation4.cylinder.shapeType);
//   fixedTranslation4.cylinder.rxvisobj[1] = fixedTranslation4.cylinder.R.T[1,1] * fixedTranslation4.cylinder.e_x[1] + fixedTranslation4.cylinder.R.T[2,1] * fixedTranslation4.cylinder.e_x[2] + fixedTranslation4.cylinder.R.T[3,1] * fixedTranslation4.cylinder.e_x[3];
//   fixedTranslation4.cylinder.rxvisobj[2] = fixedTranslation4.cylinder.R.T[1,2] * fixedTranslation4.cylinder.e_x[1] + fixedTranslation4.cylinder.R.T[2,2] * fixedTranslation4.cylinder.e_x[2] + fixedTranslation4.cylinder.R.T[3,2] * fixedTranslation4.cylinder.e_x[3];
//   fixedTranslation4.cylinder.rxvisobj[3] = fixedTranslation4.cylinder.R.T[1,3] * fixedTranslation4.cylinder.e_x[1] + fixedTranslation4.cylinder.R.T[2,3] * fixedTranslation4.cylinder.e_x[2] + fixedTranslation4.cylinder.R.T[3,3] * fixedTranslation4.cylinder.e_x[3];
//   fixedTranslation4.cylinder.ryvisobj[1] = fixedTranslation4.cylinder.R.T[1,1] * fixedTranslation4.cylinder.e_y[1] + fixedTranslation4.cylinder.R.T[2,1] * fixedTranslation4.cylinder.e_y[2] + fixedTranslation4.cylinder.R.T[3,1] * fixedTranslation4.cylinder.e_y[3];
//   fixedTranslation4.cylinder.ryvisobj[2] = fixedTranslation4.cylinder.R.T[1,2] * fixedTranslation4.cylinder.e_y[1] + fixedTranslation4.cylinder.R.T[2,2] * fixedTranslation4.cylinder.e_y[2] + fixedTranslation4.cylinder.R.T[3,2] * fixedTranslation4.cylinder.e_y[3];
//   fixedTranslation4.cylinder.ryvisobj[3] = fixedTranslation4.cylinder.R.T[1,3] * fixedTranslation4.cylinder.e_y[1] + fixedTranslation4.cylinder.R.T[2,3] * fixedTranslation4.cylinder.e_y[2] + fixedTranslation4.cylinder.R.T[3,3] * fixedTranslation4.cylinder.e_y[3];
//   fixedTranslation4.cylinder.rvisobj = fixedTranslation4.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation4.cylinder.R.T[1,1],fixedTranslation4.cylinder.R.T[1,2],fixedTranslation4.cylinder.R.T[1,3]},{fixedTranslation4.cylinder.R.T[2,1],fixedTranslation4.cylinder.R.T[2,2],fixedTranslation4.cylinder.R.T[2,3]},{fixedTranslation4.cylinder.R.T[3,1],fixedTranslation4.cylinder.R.T[3,2],fixedTranslation4.cylinder.R.T[3,3]}},{fixedTranslation4.cylinder.r_shape[1],fixedTranslation4.cylinder.r_shape[2],fixedTranslation4.cylinder.r_shape[3]});
//   fixedTranslation4.cylinder.size[1] = fixedTranslation4.cylinder.length;
//   fixedTranslation4.cylinder.size[2] = fixedTranslation4.cylinder.width;
//   fixedTranslation4.cylinder.size[3] = fixedTranslation4.cylinder.height;
//   fixedTranslation4.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation4.cylinder.color[1] / 255.0,fixedTranslation4.cylinder.color[2] / 255.0,fixedTranslation4.cylinder.color[3] / 255.0,fixedTranslation4.cylinder.specularCoefficient);
//   fixedTranslation4.cylinder.Extra = fixedTranslation4.cylinder.extra;
//   fixedTranslation4.R[1,1] = cos(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.R[1,2] = sin(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.R[2,1] = -sin(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.R[2,2] = cos(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.r0[1] = fixedTranslation4.R[1,1] * fixedTranslation4.r[1] + fixedTranslation4.R[1,2] * fixedTranslation4.r[2];
//   fixedTranslation4.r0[2] = fixedTranslation4.R[2,1] * fixedTranslation4.r[1] + fixedTranslation4.R[2,2] * fixedTranslation4.r[2];
//   fixedTranslation4.frame_a.x + fixedTranslation4.r0[1] = fixedTranslation4.frame_b.x;
//   fixedTranslation4.frame_a.y + fixedTranslation4.r0[2] = fixedTranslation4.frame_b.y;
//   fixedTranslation4.frame_a.phi = fixedTranslation4.frame_b.phi;
//   fixedTranslation4.frame_a.fx + fixedTranslation4.frame_b.fx = 0.0;
//   fixedTranslation4.frame_a.fy + fixedTranslation4.frame_b.fy = 0.0;
//   fixedTranslation4.frame_a.t + (fixedTranslation4.frame_b.t + ((-fixedTranslation4.r0[1]) * fixedTranslation4.frame_b.fy + fixedTranslation4.r0[2] * fixedTranslation4.frame_b.fx)) = 0.0;
//   fixedTranslation5.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation5.cylinder.shapeType);
//   fixedTranslation5.cylinder.rxvisobj[1] = fixedTranslation5.cylinder.R.T[1,1] * fixedTranslation5.cylinder.e_x[1] + fixedTranslation5.cylinder.R.T[2,1] * fixedTranslation5.cylinder.e_x[2] + fixedTranslation5.cylinder.R.T[3,1] * fixedTranslation5.cylinder.e_x[3];
//   fixedTranslation5.cylinder.rxvisobj[2] = fixedTranslation5.cylinder.R.T[1,2] * fixedTranslation5.cylinder.e_x[1] + fixedTranslation5.cylinder.R.T[2,2] * fixedTranslation5.cylinder.e_x[2] + fixedTranslation5.cylinder.R.T[3,2] * fixedTranslation5.cylinder.e_x[3];
//   fixedTranslation5.cylinder.rxvisobj[3] = fixedTranslation5.cylinder.R.T[1,3] * fixedTranslation5.cylinder.e_x[1] + fixedTranslation5.cylinder.R.T[2,3] * fixedTranslation5.cylinder.e_x[2] + fixedTranslation5.cylinder.R.T[3,3] * fixedTranslation5.cylinder.e_x[3];
//   fixedTranslation5.cylinder.ryvisobj[1] = fixedTranslation5.cylinder.R.T[1,1] * fixedTranslation5.cylinder.e_y[1] + fixedTranslation5.cylinder.R.T[2,1] * fixedTranslation5.cylinder.e_y[2] + fixedTranslation5.cylinder.R.T[3,1] * fixedTranslation5.cylinder.e_y[3];
//   fixedTranslation5.cylinder.ryvisobj[2] = fixedTranslation5.cylinder.R.T[1,2] * fixedTranslation5.cylinder.e_y[1] + fixedTranslation5.cylinder.R.T[2,2] * fixedTranslation5.cylinder.e_y[2] + fixedTranslation5.cylinder.R.T[3,2] * fixedTranslation5.cylinder.e_y[3];
//   fixedTranslation5.cylinder.ryvisobj[3] = fixedTranslation5.cylinder.R.T[1,3] * fixedTranslation5.cylinder.e_y[1] + fixedTranslation5.cylinder.R.T[2,3] * fixedTranslation5.cylinder.e_y[2] + fixedTranslation5.cylinder.R.T[3,3] * fixedTranslation5.cylinder.e_y[3];
//   fixedTranslation5.cylinder.rvisobj = fixedTranslation5.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation5.cylinder.R.T[1,1],fixedTranslation5.cylinder.R.T[1,2],fixedTranslation5.cylinder.R.T[1,3]},{fixedTranslation5.cylinder.R.T[2,1],fixedTranslation5.cylinder.R.T[2,2],fixedTranslation5.cylinder.R.T[2,3]},{fixedTranslation5.cylinder.R.T[3,1],fixedTranslation5.cylinder.R.T[3,2],fixedTranslation5.cylinder.R.T[3,3]}},{fixedTranslation5.cylinder.r_shape[1],fixedTranslation5.cylinder.r_shape[2],fixedTranslation5.cylinder.r_shape[3]});
//   fixedTranslation5.cylinder.size[1] = fixedTranslation5.cylinder.length;
//   fixedTranslation5.cylinder.size[2] = fixedTranslation5.cylinder.width;
//   fixedTranslation5.cylinder.size[3] = fixedTranslation5.cylinder.height;
//   fixedTranslation5.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation5.cylinder.color[1] / 255.0,fixedTranslation5.cylinder.color[2] / 255.0,fixedTranslation5.cylinder.color[3] / 255.0,fixedTranslation5.cylinder.specularCoefficient);
//   fixedTranslation5.cylinder.Extra = fixedTranslation5.cylinder.extra;
//   fixedTranslation5.R[1,1] = cos(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.R[1,2] = sin(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.R[2,1] = -sin(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.R[2,2] = cos(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.r0[1] = fixedTranslation5.R[1,1] * fixedTranslation5.r[1] + fixedTranslation5.R[1,2] * fixedTranslation5.r[2];
//   fixedTranslation5.r0[2] = fixedTranslation5.R[2,1] * fixedTranslation5.r[1] + fixedTranslation5.R[2,2] * fixedTranslation5.r[2];
//   fixedTranslation5.frame_a.x + fixedTranslation5.r0[1] = fixedTranslation5.frame_b.x;
//   fixedTranslation5.frame_a.y + fixedTranslation5.r0[2] = fixedTranslation5.frame_b.y;
//   fixedTranslation5.frame_a.phi = fixedTranslation5.frame_b.phi;
//   fixedTranslation5.frame_a.fx + fixedTranslation5.frame_b.fx = 0.0;
//   fixedTranslation5.frame_a.fy + fixedTranslation5.frame_b.fy = 0.0;
//   fixedTranslation5.frame_a.t + (fixedTranslation5.frame_b.t + ((-fixedTranslation5.r0[1]) * fixedTranslation5.frame_b.fy + fixedTranslation5.r0[2] * fixedTranslation5.frame_b.fx)) = 0.0;
//   WheelJoint4.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint4.cylinder.shapeType);
//   WheelJoint4.cylinder.rxvisobj[1] = WheelJoint4.cylinder.R.T[1,1] * WheelJoint4.cylinder.e_x[1] + WheelJoint4.cylinder.R.T[2,1] * WheelJoint4.cylinder.e_x[2] + WheelJoint4.cylinder.R.T[3,1] * WheelJoint4.cylinder.e_x[3];
//   WheelJoint4.cylinder.rxvisobj[2] = WheelJoint4.cylinder.R.T[1,2] * WheelJoint4.cylinder.e_x[1] + WheelJoint4.cylinder.R.T[2,2] * WheelJoint4.cylinder.e_x[2] + WheelJoint4.cylinder.R.T[3,2] * WheelJoint4.cylinder.e_x[3];
//   WheelJoint4.cylinder.rxvisobj[3] = WheelJoint4.cylinder.R.T[1,3] * WheelJoint4.cylinder.e_x[1] + WheelJoint4.cylinder.R.T[2,3] * WheelJoint4.cylinder.e_x[2] + WheelJoint4.cylinder.R.T[3,3] * WheelJoint4.cylinder.e_x[3];
//   WheelJoint4.cylinder.ryvisobj[1] = WheelJoint4.cylinder.R.T[1,1] * WheelJoint4.cylinder.e_y[1] + WheelJoint4.cylinder.R.T[2,1] * WheelJoint4.cylinder.e_y[2] + WheelJoint4.cylinder.R.T[3,1] * WheelJoint4.cylinder.e_y[3];
//   WheelJoint4.cylinder.ryvisobj[2] = WheelJoint4.cylinder.R.T[1,2] * WheelJoint4.cylinder.e_y[1] + WheelJoint4.cylinder.R.T[2,2] * WheelJoint4.cylinder.e_y[2] + WheelJoint4.cylinder.R.T[3,2] * WheelJoint4.cylinder.e_y[3];
//   WheelJoint4.cylinder.ryvisobj[3] = WheelJoint4.cylinder.R.T[1,3] * WheelJoint4.cylinder.e_y[1] + WheelJoint4.cylinder.R.T[2,3] * WheelJoint4.cylinder.e_y[2] + WheelJoint4.cylinder.R.T[3,3] * WheelJoint4.cylinder.e_y[3];
//   WheelJoint4.cylinder.rvisobj = WheelJoint4.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint4.cylinder.R.T[1,1],WheelJoint4.cylinder.R.T[1,2],WheelJoint4.cylinder.R.T[1,3]},{WheelJoint4.cylinder.R.T[2,1],WheelJoint4.cylinder.R.T[2,2],WheelJoint4.cylinder.R.T[2,3]},{WheelJoint4.cylinder.R.T[3,1],WheelJoint4.cylinder.R.T[3,2],WheelJoint4.cylinder.R.T[3,3]}},{WheelJoint4.cylinder.r_shape[1],WheelJoint4.cylinder.r_shape[2],WheelJoint4.cylinder.r_shape[3]});
//   WheelJoint4.cylinder.size[1] = WheelJoint4.cylinder.length;
//   WheelJoint4.cylinder.size[2] = WheelJoint4.cylinder.width;
//   WheelJoint4.cylinder.size[3] = WheelJoint4.cylinder.height;
//   WheelJoint4.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint4.cylinder.color[1] / 255.0,WheelJoint4.cylinder.color[2] / 255.0,WheelJoint4.cylinder.color[3] / 255.0,WheelJoint4.cylinder.specularCoefficient);
//   WheelJoint4.cylinder.Extra = WheelJoint4.cylinder.extra;
//   WheelJoint4.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint4.e0[2],WheelJoint4.e0[1],0.0},WheelJoint4.flange_a.phi,0.0);
//   WheelJoint4.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint4.rim1.shapeType);
//   WheelJoint4.rim1.rxvisobj[1] = WheelJoint4.rim1.R.T[1,1] * WheelJoint4.rim1.e_x[1] + WheelJoint4.rim1.R.T[2,1] * WheelJoint4.rim1.e_x[2] + WheelJoint4.rim1.R.T[3,1] * WheelJoint4.rim1.e_x[3];
//   WheelJoint4.rim1.rxvisobj[2] = WheelJoint4.rim1.R.T[1,2] * WheelJoint4.rim1.e_x[1] + WheelJoint4.rim1.R.T[2,2] * WheelJoint4.rim1.e_x[2] + WheelJoint4.rim1.R.T[3,2] * WheelJoint4.rim1.e_x[3];
//   WheelJoint4.rim1.rxvisobj[3] = WheelJoint4.rim1.R.T[1,3] * WheelJoint4.rim1.e_x[1] + WheelJoint4.rim1.R.T[2,3] * WheelJoint4.rim1.e_x[2] + WheelJoint4.rim1.R.T[3,3] * WheelJoint4.rim1.e_x[3];
//   WheelJoint4.rim1.ryvisobj[1] = WheelJoint4.rim1.R.T[1,1] * WheelJoint4.rim1.e_y[1] + WheelJoint4.rim1.R.T[2,1] * WheelJoint4.rim1.e_y[2] + WheelJoint4.rim1.R.T[3,1] * WheelJoint4.rim1.e_y[3];
//   WheelJoint4.rim1.ryvisobj[2] = WheelJoint4.rim1.R.T[1,2] * WheelJoint4.rim1.e_y[1] + WheelJoint4.rim1.R.T[2,2] * WheelJoint4.rim1.e_y[2] + WheelJoint4.rim1.R.T[3,2] * WheelJoint4.rim1.e_y[3];
//   WheelJoint4.rim1.ryvisobj[3] = WheelJoint4.rim1.R.T[1,3] * WheelJoint4.rim1.e_y[1] + WheelJoint4.rim1.R.T[2,3] * WheelJoint4.rim1.e_y[2] + WheelJoint4.rim1.R.T[3,3] * WheelJoint4.rim1.e_y[3];
//   WheelJoint4.rim1.rvisobj = WheelJoint4.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint4.rim1.R.T[1,1],WheelJoint4.rim1.R.T[1,2],WheelJoint4.rim1.R.T[1,3]},{WheelJoint4.rim1.R.T[2,1],WheelJoint4.rim1.R.T[2,2],WheelJoint4.rim1.R.T[2,3]},{WheelJoint4.rim1.R.T[3,1],WheelJoint4.rim1.R.T[3,2],WheelJoint4.rim1.R.T[3,3]}},{WheelJoint4.rim1.r_shape[1],WheelJoint4.rim1.r_shape[2],WheelJoint4.rim1.r_shape[3]});
//   WheelJoint4.rim1.size[1] = WheelJoint4.rim1.length;
//   WheelJoint4.rim1.size[2] = WheelJoint4.rim1.width;
//   WheelJoint4.rim1.size[3] = WheelJoint4.rim1.height;
//   WheelJoint4.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint4.rim1.color[1] / 255.0,WheelJoint4.rim1.color[2] / 255.0,WheelJoint4.rim1.color[3] / 255.0,WheelJoint4.rim1.specularCoefficient);
//   WheelJoint4.rim1.Extra = WheelJoint4.rim1.extra;
//   WheelJoint4.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint4.e0[2],WheelJoint4.e0[1],0.0},1.5707963267949 + WheelJoint4.flange_a.phi,0.0);
//   WheelJoint4.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint4.rim2.shapeType);
//   WheelJoint4.rim2.rxvisobj[1] = WheelJoint4.rim2.R.T[1,1] * WheelJoint4.rim2.e_x[1] + WheelJoint4.rim2.R.T[2,1] * WheelJoint4.rim2.e_x[2] + WheelJoint4.rim2.R.T[3,1] * WheelJoint4.rim2.e_x[3];
//   WheelJoint4.rim2.rxvisobj[2] = WheelJoint4.rim2.R.T[1,2] * WheelJoint4.rim2.e_x[1] + WheelJoint4.rim2.R.T[2,2] * WheelJoint4.rim2.e_x[2] + WheelJoint4.rim2.R.T[3,2] * WheelJoint4.rim2.e_x[3];
//   WheelJoint4.rim2.rxvisobj[3] = WheelJoint4.rim2.R.T[1,3] * WheelJoint4.rim2.e_x[1] + WheelJoint4.rim2.R.T[2,3] * WheelJoint4.rim2.e_x[2] + WheelJoint4.rim2.R.T[3,3] * WheelJoint4.rim2.e_x[3];
//   WheelJoint4.rim2.ryvisobj[1] = WheelJoint4.rim2.R.T[1,1] * WheelJoint4.rim2.e_y[1] + WheelJoint4.rim2.R.T[2,1] * WheelJoint4.rim2.e_y[2] + WheelJoint4.rim2.R.T[3,1] * WheelJoint4.rim2.e_y[3];
//   WheelJoint4.rim2.ryvisobj[2] = WheelJoint4.rim2.R.T[1,2] * WheelJoint4.rim2.e_y[1] + WheelJoint4.rim2.R.T[2,2] * WheelJoint4.rim2.e_y[2] + WheelJoint4.rim2.R.T[3,2] * WheelJoint4.rim2.e_y[3];
//   WheelJoint4.rim2.ryvisobj[3] = WheelJoint4.rim2.R.T[1,3] * WheelJoint4.rim2.e_y[1] + WheelJoint4.rim2.R.T[2,3] * WheelJoint4.rim2.e_y[2] + WheelJoint4.rim2.R.T[3,3] * WheelJoint4.rim2.e_y[3];
//   WheelJoint4.rim2.rvisobj = WheelJoint4.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint4.rim2.R.T[1,1],WheelJoint4.rim2.R.T[1,2],WheelJoint4.rim2.R.T[1,3]},{WheelJoint4.rim2.R.T[2,1],WheelJoint4.rim2.R.T[2,2],WheelJoint4.rim2.R.T[2,3]},{WheelJoint4.rim2.R.T[3,1],WheelJoint4.rim2.R.T[3,2],WheelJoint4.rim2.R.T[3,3]}},{WheelJoint4.rim2.r_shape[1],WheelJoint4.rim2.r_shape[2],WheelJoint4.rim2.r_shape[3]});
//   WheelJoint4.rim2.size[1] = WheelJoint4.rim2.length;
//   WheelJoint4.rim2.size[2] = WheelJoint4.rim2.width;
//   WheelJoint4.rim2.size[3] = WheelJoint4.rim2.height;
//   WheelJoint4.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint4.rim2.color[1] / 255.0,WheelJoint4.rim2.color[2] / 255.0,WheelJoint4.rim2.color[3] / 255.0,WheelJoint4.rim2.specularCoefficient);
//   WheelJoint4.rim2.Extra = WheelJoint4.rim2.extra;
//   WheelJoint4.R[1,1] = cos(WheelJoint4.frame_a.phi);
//   WheelJoint4.R[1,2] = sin(WheelJoint4.frame_a.phi);
//   WheelJoint4.R[2,1] = -sin(WheelJoint4.frame_a.phi);
//   WheelJoint4.R[2,2] = cos(WheelJoint4.frame_a.phi);
//   WheelJoint4.e0[1] = WheelJoint4.R[1,1] * WheelJoint4.e[1] + WheelJoint4.R[1,2] * WheelJoint4.e[2];
//   WheelJoint4.e0[2] = WheelJoint4.R[2,1] * WheelJoint4.e[1] + WheelJoint4.R[2,2] * WheelJoint4.e[2];
//   WheelJoint4.v[1] = der(WheelJoint4.frame_a.x);
//   WheelJoint4.v[2] = der(WheelJoint4.frame_a.y);
//   WheelJoint4.w_roll = der(WheelJoint4.flange_a.phi);
//   WheelJoint4.v_long = WheelJoint4.v[1] * WheelJoint4.e0[1] + WheelJoint4.v[2] * WheelJoint4.e0[2];
//   WheelJoint4.v_lat = (-WheelJoint4.v[1]) * WheelJoint4.e0[2] + WheelJoint4.v[2] * WheelJoint4.e0[1];
//   WheelJoint4.v_slip_lat = WheelJoint4.v_lat;
//   WheelJoint4.v_slip_long = WheelJoint4.v_long - WheelJoint4.radius * WheelJoint4.w_roll;
//   WheelJoint4.v_slip = 0.0001 + sqrt(WheelJoint4.v_slip_long ^ 2.0 + WheelJoint4.v_slip_lat ^ 2.0);
//   (-WheelJoint4.f_long) * WheelJoint4.radius = WheelJoint4.flange_a.tau;
//   WheelJoint4.frame_a.t = 0.0;
//   WheelJoint4.f = WheelJoint4.N * PlanarMechanicsV4.Utilities.TripleS_Func(WheelJoint4.vAdhesion,WheelJoint4.vSlide,WheelJoint4.mu_A,WheelJoint4.mu_S,WheelJoint4.v_slip);
//   WheelJoint4.f_long = (WheelJoint4.f * WheelJoint4.v_slip_long) / WheelJoint4.v_slip;
//   WheelJoint4.f_lat = (WheelJoint4.f * WheelJoint4.v_slip_lat) / WheelJoint4.v_slip;
//   WheelJoint4.f_long = WheelJoint4.frame_a.fx * WheelJoint4.e0[1] + WheelJoint4.frame_a.fy * WheelJoint4.e0[2];
//   WheelJoint4.f_lat = WheelJoint4.frame_a.fy * WheelJoint4.e0[1] + (-WheelJoint4.frame_a.fx) * WheelJoint4.e0[2];
//   inertia3.phi = inertia3.flange_a.phi;
//   inertia3.phi = inertia3.flange_b.phi;
//   inertia3.w = der(inertia3.phi);
//   inertia3.a = der(inertia3.w);
//   inertia3.J * inertia3.a = inertia3.flange_a.tau + inertia3.flange_b.tau;
//   body2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.sphere.shapeType);
//   body2.sphere.rxvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_x[1] + body2.sphere.R.T[2,1] * body2.sphere.e_x[2] + body2.sphere.R.T[3,1] * body2.sphere.e_x[3];
//   body2.sphere.rxvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_x[1] + body2.sphere.R.T[2,2] * body2.sphere.e_x[2] + body2.sphere.R.T[3,2] * body2.sphere.e_x[3];
//   body2.sphere.rxvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_x[1] + body2.sphere.R.T[2,3] * body2.sphere.e_x[2] + body2.sphere.R.T[3,3] * body2.sphere.e_x[3];
//   body2.sphere.ryvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_y[1] + body2.sphere.R.T[2,1] * body2.sphere.e_y[2] + body2.sphere.R.T[3,1] * body2.sphere.e_y[3];
//   body2.sphere.ryvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_y[1] + body2.sphere.R.T[2,2] * body2.sphere.e_y[2] + body2.sphere.R.T[3,2] * body2.sphere.e_y[3];
//   body2.sphere.ryvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_y[1] + body2.sphere.R.T[2,3] * body2.sphere.e_y[2] + body2.sphere.R.T[3,3] * body2.sphere.e_y[3];
//   body2.sphere.rvisobj = body2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.sphere.R.T[1,1],body2.sphere.R.T[1,2],body2.sphere.R.T[1,3]},{body2.sphere.R.T[2,1],body2.sphere.R.T[2,2],body2.sphere.R.T[2,3]},{body2.sphere.R.T[3,1],body2.sphere.R.T[3,2],body2.sphere.R.T[3,3]}},{body2.sphere.r_shape[1],body2.sphere.r_shape[2],body2.sphere.r_shape[3]});
//   body2.sphere.size[1] = body2.sphere.length;
//   body2.sphere.size[2] = body2.sphere.width;
//   body2.sphere.size[3] = body2.sphere.height;
//   body2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.sphere.color[1] / 255.0,body2.sphere.color[2] / 255.0,body2.sphere.color[3] / 255.0,body2.sphere.specularCoefficient);
//   body2.sphere.Extra = body2.sphere.extra;
//   body2.r[1] = body2.frame_a.x;
//   body2.r[2] = body2.frame_a.y;
//   body2.v[1] = der(body2.r[1]);
//   body2.v[2] = der(body2.r[2]);
//   body2.w = der(body2.frame_a.phi);
//   body2.a[1] = der(body2.v[1]);
//   body2.a[2] = der(body2.v[2]);
//   body2.z = der(body2.w);
//   body2.f[1] = body2.frame_a.fx;
//   body2.f[2] = body2.frame_a.fy;
//   body2.f[1] + body2.m * body2.g[1] = body2.m * body2.a[1];
//   body2.f[2] + body2.m * body2.g[2] = body2.m * body2.a[2];
//   body2.frame_a.t = body2.I * body2.z;
//   actuatedRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute.cylinder.shapeType);
//   actuatedRevolute.cylinder.rxvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.ryvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.rvisobj = actuatedRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute.cylinder.R.T[1,1],actuatedRevolute.cylinder.R.T[1,2],actuatedRevolute.cylinder.R.T[1,3]},{actuatedRevolute.cylinder.R.T[2,1],actuatedRevolute.cylinder.R.T[2,2],actuatedRevolute.cylinder.R.T[2,3]},{actuatedRevolute.cylinder.R.T[3,1],actuatedRevolute.cylinder.R.T[3,2],actuatedRevolute.cylinder.R.T[3,3]}},{actuatedRevolute.cylinder.r_shape[1],actuatedRevolute.cylinder.r_shape[2],actuatedRevolute.cylinder.r_shape[3]});
//   actuatedRevolute.cylinder.size[1] = actuatedRevolute.cylinder.length;
//   actuatedRevolute.cylinder.size[2] = actuatedRevolute.cylinder.width;
//   actuatedRevolute.cylinder.size[3] = actuatedRevolute.cylinder.height;
//   actuatedRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute.cylinder.color[1] / 255.0,actuatedRevolute.cylinder.color[2] / 255.0,actuatedRevolute.cylinder.color[3] / 255.0,actuatedRevolute.cylinder.specularCoefficient);
//   actuatedRevolute.cylinder.Extra = actuatedRevolute.cylinder.extra;
//   actuatedRevolute.phi = actuatedRevolute.flange_a.phi;
//   actuatedRevolute.w = der(actuatedRevolute.phi);
//   actuatedRevolute.z = der(actuatedRevolute.w);
//   actuatedRevolute.t = actuatedRevolute.flange_a.tau;
//   actuatedRevolute.frame_a.x = actuatedRevolute.frame_b.x;
//   actuatedRevolute.frame_a.y = actuatedRevolute.frame_b.y;
//   actuatedRevolute.frame_a.phi + actuatedRevolute.phi = actuatedRevolute.frame_b.phi;
//   actuatedRevolute.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   actuatedRevolute.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   actuatedRevolute.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   actuatedRevolute.frame_a.t = actuatedRevolute.t;
//   actuatedRevolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute1.cylinder.shapeType);
//   actuatedRevolute1.cylinder.rxvisobj[1] = actuatedRevolute1.cylinder.R.T[1,1] * actuatedRevolute1.cylinder.e_x[1] + actuatedRevolute1.cylinder.R.T[2,1] * actuatedRevolute1.cylinder.e_x[2] + actuatedRevolute1.cylinder.R.T[3,1] * actuatedRevolute1.cylinder.e_x[3];
//   actuatedRevolute1.cylinder.rxvisobj[2] = actuatedRevolute1.cylinder.R.T[1,2] * actuatedRevolute1.cylinder.e_x[1] + actuatedRevolute1.cylinder.R.T[2,2] * actuatedRevolute1.cylinder.e_x[2] + actuatedRevolute1.cylinder.R.T[3,2] * actuatedRevolute1.cylinder.e_x[3];
//   actuatedRevolute1.cylinder.rxvisobj[3] = actuatedRevolute1.cylinder.R.T[1,3] * actuatedRevolute1.cylinder.e_x[1] + actuatedRevolute1.cylinder.R.T[2,3] * actuatedRevolute1.cylinder.e_x[2] + actuatedRevolute1.cylinder.R.T[3,3] * actuatedRevolute1.cylinder.e_x[3];
//   actuatedRevolute1.cylinder.ryvisobj[1] = actuatedRevolute1.cylinder.R.T[1,1] * actuatedRevolute1.cylinder.e_y[1] + actuatedRevolute1.cylinder.R.T[2,1] * actuatedRevolute1.cylinder.e_y[2] + actuatedRevolute1.cylinder.R.T[3,1] * actuatedRevolute1.cylinder.e_y[3];
//   actuatedRevolute1.cylinder.ryvisobj[2] = actuatedRevolute1.cylinder.R.T[1,2] * actuatedRevolute1.cylinder.e_y[1] + actuatedRevolute1.cylinder.R.T[2,2] * actuatedRevolute1.cylinder.e_y[2] + actuatedRevolute1.cylinder.R.T[3,2] * actuatedRevolute1.cylinder.e_y[3];
//   actuatedRevolute1.cylinder.ryvisobj[3] = actuatedRevolute1.cylinder.R.T[1,3] * actuatedRevolute1.cylinder.e_y[1] + actuatedRevolute1.cylinder.R.T[2,3] * actuatedRevolute1.cylinder.e_y[2] + actuatedRevolute1.cylinder.R.T[3,3] * actuatedRevolute1.cylinder.e_y[3];
//   actuatedRevolute1.cylinder.rvisobj = actuatedRevolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute1.cylinder.R.T[1,1],actuatedRevolute1.cylinder.R.T[1,2],actuatedRevolute1.cylinder.R.T[1,3]},{actuatedRevolute1.cylinder.R.T[2,1],actuatedRevolute1.cylinder.R.T[2,2],actuatedRevolute1.cylinder.R.T[2,3]},{actuatedRevolute1.cylinder.R.T[3,1],actuatedRevolute1.cylinder.R.T[3,2],actuatedRevolute1.cylinder.R.T[3,3]}},{actuatedRevolute1.cylinder.r_shape[1],actuatedRevolute1.cylinder.r_shape[2],actuatedRevolute1.cylinder.r_shape[3]});
//   actuatedRevolute1.cylinder.size[1] = actuatedRevolute1.cylinder.length;
//   actuatedRevolute1.cylinder.size[2] = actuatedRevolute1.cylinder.width;
//   actuatedRevolute1.cylinder.size[3] = actuatedRevolute1.cylinder.height;
//   actuatedRevolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute1.cylinder.color[1] / 255.0,actuatedRevolute1.cylinder.color[2] / 255.0,actuatedRevolute1.cylinder.color[3] / 255.0,actuatedRevolute1.cylinder.specularCoefficient);
//   actuatedRevolute1.cylinder.Extra = actuatedRevolute1.cylinder.extra;
//   actuatedRevolute1.phi = actuatedRevolute1.flange_a.phi;
//   actuatedRevolute1.w = der(actuatedRevolute1.phi);
//   actuatedRevolute1.z = der(actuatedRevolute1.w);
//   actuatedRevolute1.t = actuatedRevolute1.flange_a.tau;
//   actuatedRevolute1.frame_a.x = actuatedRevolute1.frame_b.x;
//   actuatedRevolute1.frame_a.y = actuatedRevolute1.frame_b.y;
//   actuatedRevolute1.frame_a.phi + actuatedRevolute1.phi = actuatedRevolute1.frame_b.phi;
//   actuatedRevolute1.frame_a.fx + actuatedRevolute1.frame_b.fx = 0.0;
//   actuatedRevolute1.frame_a.fy + actuatedRevolute1.frame_b.fy = 0.0;
//   actuatedRevolute1.frame_a.t + actuatedRevolute1.frame_b.t = 0.0;
//   actuatedRevolute1.frame_a.t = actuatedRevolute1.t;
//   torque.flange.tau = -torque.tau;
//   torque.phi_support = 0.0;
//   when sample(pulse.startTime,pulse.period) then
//   pulse.T0 = time;
//   end when;
//   pulse.y = pulse.offset + (if time < pulse.startTime or time >= pulse.T0 + pulse.T_width then 0.0 else pulse.amplitude);
//   (1.0 + differentialGear.idealPlanetary.ratio) * differentialGear.idealPlanetary.carrier.phi = differentialGear.idealPlanetary.sun.phi + differentialGear.idealPlanetary.ratio * differentialGear.idealPlanetary.ring.phi;
//   differentialGear.idealPlanetary.ring.tau = differentialGear.idealPlanetary.ratio * differentialGear.idealPlanetary.sun.tau;
//   differentialGear.idealPlanetary.carrier.tau = (-1.0 - differentialGear.idealPlanetary.ratio) * differentialGear.idealPlanetary.sun.tau;
//   leftTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(leftTrail.cylinder.shapeType);
//   leftTrail.cylinder.rxvisobj[1] = leftTrail.cylinder.R.T[1,1] * leftTrail.cylinder.e_x[1] + leftTrail.cylinder.R.T[2,1] * leftTrail.cylinder.e_x[2] + leftTrail.cylinder.R.T[3,1] * leftTrail.cylinder.e_x[3];
//   leftTrail.cylinder.rxvisobj[2] = leftTrail.cylinder.R.T[1,2] * leftTrail.cylinder.e_x[1] + leftTrail.cylinder.R.T[2,2] * leftTrail.cylinder.e_x[2] + leftTrail.cylinder.R.T[3,2] * leftTrail.cylinder.e_x[3];
//   leftTrail.cylinder.rxvisobj[3] = leftTrail.cylinder.R.T[1,3] * leftTrail.cylinder.e_x[1] + leftTrail.cylinder.R.T[2,3] * leftTrail.cylinder.e_x[2] + leftTrail.cylinder.R.T[3,3] * leftTrail.cylinder.e_x[3];
//   leftTrail.cylinder.ryvisobj[1] = leftTrail.cylinder.R.T[1,1] * leftTrail.cylinder.e_y[1] + leftTrail.cylinder.R.T[2,1] * leftTrail.cylinder.e_y[2] + leftTrail.cylinder.R.T[3,1] * leftTrail.cylinder.e_y[3];
//   leftTrail.cylinder.ryvisobj[2] = leftTrail.cylinder.R.T[1,2] * leftTrail.cylinder.e_y[1] + leftTrail.cylinder.R.T[2,2] * leftTrail.cylinder.e_y[2] + leftTrail.cylinder.R.T[3,2] * leftTrail.cylinder.e_y[3];
//   leftTrail.cylinder.ryvisobj[3] = leftTrail.cylinder.R.T[1,3] * leftTrail.cylinder.e_y[1] + leftTrail.cylinder.R.T[2,3] * leftTrail.cylinder.e_y[2] + leftTrail.cylinder.R.T[3,3] * leftTrail.cylinder.e_y[3];
//   leftTrail.cylinder.rvisobj = leftTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{leftTrail.cylinder.R.T[1,1],leftTrail.cylinder.R.T[1,2],leftTrail.cylinder.R.T[1,3]},{leftTrail.cylinder.R.T[2,1],leftTrail.cylinder.R.T[2,2],leftTrail.cylinder.R.T[2,3]},{leftTrail.cylinder.R.T[3,1],leftTrail.cylinder.R.T[3,2],leftTrail.cylinder.R.T[3,3]}},{leftTrail.cylinder.r_shape[1],leftTrail.cylinder.r_shape[2],leftTrail.cylinder.r_shape[3]});
//   leftTrail.cylinder.size[1] = leftTrail.cylinder.length;
//   leftTrail.cylinder.size[2] = leftTrail.cylinder.width;
//   leftTrail.cylinder.size[3] = leftTrail.cylinder.height;
//   leftTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(leftTrail.cylinder.color[1] / 255.0,leftTrail.cylinder.color[2] / 255.0,leftTrail.cylinder.color[3] / 255.0,leftTrail.cylinder.specularCoefficient);
//   leftTrail.cylinder.Extra = leftTrail.cylinder.extra;
//   leftTrail.R[1,1] = cos(leftTrail.frame_a.phi);
//   leftTrail.R[1,2] = sin(leftTrail.frame_a.phi);
//   leftTrail.R[2,1] = -sin(leftTrail.frame_a.phi);
//   leftTrail.R[2,2] = cos(leftTrail.frame_a.phi);
//   leftTrail.r0[1] = leftTrail.R[1,1] * leftTrail.r[1] + leftTrail.R[1,2] * leftTrail.r[2];
//   leftTrail.r0[2] = leftTrail.R[2,1] * leftTrail.r[1] + leftTrail.R[2,2] * leftTrail.r[2];
//   leftTrail.frame_a.x + leftTrail.r0[1] = leftTrail.frame_b.x;
//   leftTrail.frame_a.y + leftTrail.r0[2] = leftTrail.frame_b.y;
//   leftTrail.frame_a.phi = leftTrail.frame_b.phi;
//   leftTrail.frame_a.fx + leftTrail.frame_b.fx = 0.0;
//   leftTrail.frame_a.fy + leftTrail.frame_b.fy = 0.0;
//   leftTrail.frame_a.t + (leftTrail.frame_b.t + ((-leftTrail.r0[1]) * leftTrail.frame_b.fy + leftTrail.r0[2] * leftTrail.frame_b.fx)) = 0.0;
//   rightTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rightTrail.cylinder.shapeType);
//   rightTrail.cylinder.rxvisobj[1] = rightTrail.cylinder.R.T[1,1] * rightTrail.cylinder.e_x[1] + rightTrail.cylinder.R.T[2,1] * rightTrail.cylinder.e_x[2] + rightTrail.cylinder.R.T[3,1] * rightTrail.cylinder.e_x[3];
//   rightTrail.cylinder.rxvisobj[2] = rightTrail.cylinder.R.T[1,2] * rightTrail.cylinder.e_x[1] + rightTrail.cylinder.R.T[2,2] * rightTrail.cylinder.e_x[2] + rightTrail.cylinder.R.T[3,2] * rightTrail.cylinder.e_x[3];
//   rightTrail.cylinder.rxvisobj[3] = rightTrail.cylinder.R.T[1,3] * rightTrail.cylinder.e_x[1] + rightTrail.cylinder.R.T[2,3] * rightTrail.cylinder.e_x[2] + rightTrail.cylinder.R.T[3,3] * rightTrail.cylinder.e_x[3];
//   rightTrail.cylinder.ryvisobj[1] = rightTrail.cylinder.R.T[1,1] * rightTrail.cylinder.e_y[1] + rightTrail.cylinder.R.T[2,1] * rightTrail.cylinder.e_y[2] + rightTrail.cylinder.R.T[3,1] * rightTrail.cylinder.e_y[3];
//   rightTrail.cylinder.ryvisobj[2] = rightTrail.cylinder.R.T[1,2] * rightTrail.cylinder.e_y[1] + rightTrail.cylinder.R.T[2,2] * rightTrail.cylinder.e_y[2] + rightTrail.cylinder.R.T[3,2] * rightTrail.cylinder.e_y[3];
//   rightTrail.cylinder.ryvisobj[3] = rightTrail.cylinder.R.T[1,3] * rightTrail.cylinder.e_y[1] + rightTrail.cylinder.R.T[2,3] * rightTrail.cylinder.e_y[2] + rightTrail.cylinder.R.T[3,3] * rightTrail.cylinder.e_y[3];
//   rightTrail.cylinder.rvisobj = rightTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rightTrail.cylinder.R.T[1,1],rightTrail.cylinder.R.T[1,2],rightTrail.cylinder.R.T[1,3]},{rightTrail.cylinder.R.T[2,1],rightTrail.cylinder.R.T[2,2],rightTrail.cylinder.R.T[2,3]},{rightTrail.cylinder.R.T[3,1],rightTrail.cylinder.R.T[3,2],rightTrail.cylinder.R.T[3,3]}},{rightTrail.cylinder.r_shape[1],rightTrail.cylinder.r_shape[2],rightTrail.cylinder.r_shape[3]});
//   rightTrail.cylinder.size[1] = rightTrail.cylinder.length;
//   rightTrail.cylinder.size[2] = rightTrail.cylinder.width;
//   rightTrail.cylinder.size[3] = rightTrail.cylinder.height;
//   rightTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rightTrail.cylinder.color[1] / 255.0,rightTrail.cylinder.color[2] / 255.0,rightTrail.cylinder.color[3] / 255.0,rightTrail.cylinder.specularCoefficient);
//   rightTrail.cylinder.Extra = rightTrail.cylinder.extra;
//   rightTrail.R[1,1] = cos(rightTrail.frame_a.phi);
//   rightTrail.R[1,2] = sin(rightTrail.frame_a.phi);
//   rightTrail.R[2,1] = -sin(rightTrail.frame_a.phi);
//   rightTrail.R[2,2] = cos(rightTrail.frame_a.phi);
//   rightTrail.r0[1] = rightTrail.R[1,1] * rightTrail.r[1] + rightTrail.R[1,2] * rightTrail.r[2];
//   rightTrail.r0[2] = rightTrail.R[2,1] * rightTrail.r[1] + rightTrail.R[2,2] * rightTrail.r[2];
//   rightTrail.frame_a.x + rightTrail.r0[1] = rightTrail.frame_b.x;
//   rightTrail.frame_a.y + rightTrail.r0[2] = rightTrail.frame_b.y;
//   rightTrail.frame_a.phi = rightTrail.frame_b.phi;
//   rightTrail.frame_a.fx + rightTrail.frame_b.fx = 0.0;
//   rightTrail.frame_a.fy + rightTrail.frame_b.fy = 0.0;
//   rightTrail.frame_a.t + (rightTrail.frame_b.t + ((-rightTrail.r0[1]) * rightTrail.frame_b.fy + rightTrail.r0[2] * rightTrail.frame_b.fx)) = 0.0;
//   body.frame_a.t + WheelJoint1.frame_a.t + leftTrail.frame_b.t = 0.0;
//   body.frame_a.fy + WheelJoint1.frame_a.fy + leftTrail.frame_b.fy = 0.0;
//   body.frame_a.fx + WheelJoint1.frame_a.fx + leftTrail.frame_b.fx = 0.0;
//   WheelJoint1.flange_a.tau + inertia.flange_b.tau = 0.0;
//   fixedTranslation1.frame_a.t + body1.frame_a.t + fixedTranslation2.frame_b.t + fixedTranslation3.frame_b.t = 0.0;
//   fixedTranslation1.frame_a.fy + body1.frame_a.fy + fixedTranslation2.frame_b.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.fx + body1.frame_a.fx + fixedTranslation2.frame_b.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation1.frame_b.t + fixedTranslation4.frame_b.t + fixedTranslation5.frame_b.t = 0.0;
//   fixedTranslation1.frame_b.fy + fixedTranslation4.frame_b.fy + fixedTranslation5.frame_b.fy = 0.0;
//   fixedTranslation1.frame_b.fx + fixedTranslation4.frame_b.fx + fixedTranslation5.frame_b.fx = 0.0;
//   WheelJoint2.frame_a.t + fixedTranslation2.frame_a.t = 0.0;
//   WheelJoint2.frame_a.fy + fixedTranslation2.frame_a.fy = 0.0;
//   WheelJoint2.frame_a.fx + fixedTranslation2.frame_a.fx = 0.0;
//   WheelJoint2.flange_a.tau + inertia1.flange_b.tau + differentialGear.flange_left.tau = 0.0;
//   constantTorque1.flange.tau + differentialGear.flange_b.tau = 0.0;
//   inertia.flange_a.tau = 0.0;
//   inertia1.flange_a.tau = 0.0;
//   fixedTranslation3.frame_a.t + WheelJoint3.frame_a.t = 0.0;
//   fixedTranslation3.frame_a.fy + WheelJoint3.frame_a.fy = 0.0;
//   fixedTranslation3.frame_a.fx + WheelJoint3.frame_a.fx = 0.0;
//   WheelJoint3.flange_a.tau + inertia2.flange_b.tau + differentialGear.flange_right.tau = 0.0;
//   inertia2.flange_a.tau = 0.0;
//   fixedTranslation4.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   fixedTranslation4.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   fixedTranslation4.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   fixedTranslation5.frame_a.t + actuatedRevolute1.frame_b.t = 0.0;
//   fixedTranslation5.frame_a.fy + actuatedRevolute1.frame_b.fy = 0.0;
//   fixedTranslation5.frame_a.fx + actuatedRevolute1.frame_b.fx = 0.0;
//   WheelJoint4.frame_a.t + body2.frame_a.t + rightTrail.frame_b.t = 0.0;
//   WheelJoint4.frame_a.fy + body2.frame_a.fy + rightTrail.frame_b.fy = 0.0;
//   WheelJoint4.frame_a.fx + body2.frame_a.fx + rightTrail.frame_b.fx = 0.0;
//   WheelJoint4.flange_a.tau + inertia3.flange_b.tau = 0.0;
//   inertia3.flange_a.tau = 0.0;
//   actuatedRevolute.frame_a.t + leftTrail.frame_a.t = 0.0;
//   actuatedRevolute.frame_a.fy + leftTrail.frame_a.fy = 0.0;
//   actuatedRevolute.frame_a.fx + leftTrail.frame_a.fx = 0.0;
//   actuatedRevolute.flange_a.tau + actuatedRevolute1.flange_a.tau + torque.flange.tau = 0.0;
//   actuatedRevolute1.frame_a.t + rightTrail.frame_a.t = 0.0;
//   actuatedRevolute1.frame_a.fy + rightTrail.frame_a.fy = 0.0;
//   actuatedRevolute1.frame_a.fx + rightTrail.frame_a.fx = 0.0;
//   differentialGear.idealPlanetary.sun.tau + -differentialGear.flange_left.tau = 0.0;
//   differentialGear.idealPlanetary.carrier.tau + -differentialGear.flange_right.tau = 0.0;
//   differentialGear.idealPlanetary.ring.tau + -differentialGear.flange_b.tau = 0.0;
//   differentialGear.flange_b.phi = differentialGear.idealPlanetary.ring.phi;
//   differentialGear.flange_right.phi = differentialGear.idealPlanetary.carrier.phi;
//   differentialGear.flange_left.phi = differentialGear.idealPlanetary.sun.phi;
//   WheelJoint2.flange_a.phi = differentialGear.flange_left.phi;
//   WheelJoint2.flange_a.phi = inertia1.flange_b.phi;
//   WheelJoint1.flange_a.phi = inertia.flange_b.phi;
//   body1.frame_a.x = fixedTranslation1.frame_a.x;
//   body1.frame_a.x = fixedTranslation2.frame_b.x;
//   body1.frame_a.x = fixedTranslation3.frame_b.x;
//   body1.frame_a.y = fixedTranslation1.frame_a.y;
//   body1.frame_a.y = fixedTranslation2.frame_b.y;
//   body1.frame_a.y = fixedTranslation3.frame_b.y;
//   body1.frame_a.phi = fixedTranslation1.frame_a.phi;
//   body1.frame_a.phi = fixedTranslation2.frame_b.phi;
//   body1.frame_a.phi = fixedTranslation3.frame_b.phi;
//   WheelJoint2.frame_a.x = fixedTranslation2.frame_a.x;
//   WheelJoint2.frame_a.y = fixedTranslation2.frame_a.y;
//   WheelJoint2.frame_a.phi = fixedTranslation2.frame_a.phi;
//   WheelJoint3.frame_a.x = fixedTranslation3.frame_a.x;
//   WheelJoint3.frame_a.y = fixedTranslation3.frame_a.y;
//   WheelJoint3.frame_a.phi = fixedTranslation3.frame_a.phi;
//   WheelJoint3.flange_a.phi = differentialGear.flange_right.phi;
//   WheelJoint3.flange_a.phi = inertia2.flange_b.phi;
//   fixedTranslation1.frame_b.x = fixedTranslation4.frame_b.x;
//   fixedTranslation1.frame_b.x = fixedTranslation5.frame_b.x;
//   fixedTranslation1.frame_b.y = fixedTranslation4.frame_b.y;
//   fixedTranslation1.frame_b.y = fixedTranslation5.frame_b.y;
//   fixedTranslation1.frame_b.phi = fixedTranslation4.frame_b.phi;
//   fixedTranslation1.frame_b.phi = fixedTranslation5.frame_b.phi;
//   WheelJoint4.flange_a.phi = inertia3.flange_b.phi;
//   actuatedRevolute1.frame_b.x = fixedTranslation5.frame_a.x;
//   actuatedRevolute1.frame_b.y = fixedTranslation5.frame_a.y;
//   actuatedRevolute1.frame_b.phi = fixedTranslation5.frame_a.phi;
//   actuatedRevolute.frame_b.x = fixedTranslation4.frame_a.x;
//   actuatedRevolute.frame_b.y = fixedTranslation4.frame_a.y;
//   actuatedRevolute.frame_b.phi = fixedTranslation4.frame_a.phi;
//   actuatedRevolute.flange_a.phi = actuatedRevolute1.flange_a.phi;
//   actuatedRevolute.flange_a.phi = torque.flange.phi;
//   pulse.y = torque.tau;
//   constantTorque1.flange.phi = differentialGear.flange_b.phi;
//   WheelJoint1.frame_a.x = body.frame_a.x;
//   WheelJoint1.frame_a.x = leftTrail.frame_b.x;
//   WheelJoint1.frame_a.y = body.frame_a.y;
//   WheelJoint1.frame_a.y = leftTrail.frame_b.y;
//   WheelJoint1.frame_a.phi = body.frame_a.phi;
//   WheelJoint1.frame_a.phi = leftTrail.frame_b.phi;
//   actuatedRevolute.frame_a.x = leftTrail.frame_a.x;
//   actuatedRevolute.frame_a.y = leftTrail.frame_a.y;
//   actuatedRevolute.frame_a.phi = leftTrail.frame_a.phi;
//   WheelJoint4.frame_a.x = body2.frame_a.x;
//   WheelJoint4.frame_a.x = rightTrail.frame_b.x;
//   WheelJoint4.frame_a.y = body2.frame_a.y;
//   WheelJoint4.frame_a.y = rightTrail.frame_b.y;
//   WheelJoint4.frame_a.phi = body2.frame_a.phi;
//   WheelJoint4.frame_a.phi = rightTrail.frame_b.phi;
//   actuatedRevolute1.frame_a.x = rightTrail.frame_a.x;
//   actuatedRevolute1.frame_a.y = rightTrail.frame_a.y;
//   actuatedRevolute1.frame_a.phi = rightTrail.frame_a.phi;
// end PlanarMechanicsV4.Examples.SimpleCarWithDifferentialGear;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation \"Inline before index reduction\" \"Return absolute orientation object from another absolute and a relative orientation object\"
//   input Real[3, 3] T1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Real[3, 3] T_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3, 3] T2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   T2 := <matrix>[T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1],T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2],T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3];T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1],T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2],T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3];T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1],T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2],T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy \"Return orientation object from n_x and n_y vectors\"
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else if abs(e_x[1]) > 1e-06 then {0.0,1.0,0.0} else {1.0,0.0,0.0};
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   T := <matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.TwoTrackStaticLoad
//   Real world.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean world.enableAnimation = true \"= true, if animation of all components is enabled\";
//   parameter Boolean world.animateWorld = true \"= true, if world coordinate system shall be visualized\";
//   parameter Boolean world.animateGravity = true \"= true, if gravity field shall be visualized (acceleration vector or field center)\";
//   parameter String world.label1 = \"x\" \"Label of horizontal axis in icon\";
//   parameter String world.label2 = \"y\" \"Label of vertical axis in icon\";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity \"Type of gravity field\";
//   parameter Real world.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.81 \"Constant gravity acceleration\";
//   parameter Real world.n[1](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[2](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[3](unit = \"1\") = -1.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.mue(unit = \"m3/s2\", min = 0.0) = 398600000000000 \"Gravity field constant (default = field constant of earth)\";
//   parameter Boolean world.driveTrainMechanics3D = true \"= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account\";
//   parameter Boolean world.axisShowLabels = true \"= true, if labels shall be shown\";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of z-arrow\";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of z-arrow\";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of z-arrow\";
//   parameter Real world.gravityArrowTail[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   parameter Real world.gravitySphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 12742000.0 \"Diameter of sphere representing gravity center (default = mean diameter of earth)\";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   parameter Real world.nominalLength(quantity = \"Length\", unit = \"m\") = 1.0 \"\\\"Nominal\\\" length of multi-body system\";
//   parameter Real world.defaultWidthFraction = 20.0 \"Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)\";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 \"Default for arrow diameter of a coordinate system as a fraction of axis length\";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 \"Default reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real world.defaultN_to_m(unit = \"N/m\", min = 0.0) = 1000.0 \"Default scaling of force arrows (length = force/defaultN_to_m)\";
//   parameter Real world.defaultNm_to_m(unit = \"N.m/m\", min = 0.0) = 1000.0 \"Default scaling of torque arrows (length = torque/defaultNm_to_m)\";
//   protected parameter Integer world.ndim = if world.enableAnimation and world.animateWorld then 1 else 0;
//   protected parameter Integer world.ndim2 = if world.enableAnimation and world.animateWorld and world.axisShowLabels then 1 else 0;
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation and world.animateGravity and world.gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then 1 else 0;
//   parameter Real world.axisLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.nominalLength / 2.0 \"Length of world axes arrows\";
//   parameter Real world.defaultAxisLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 5.0 \"Default for length of a frame axis (but not world frame)\";
//   parameter Real world.defaultJointLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a joint\";
//   parameter Real world.defaultJointWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape representing a joint\";
//   parameter Real world.defaultForceLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a force (e.g. damper)\";
//   parameter Real world.defaultForceWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape represening a force (e.g. spring, bushing)\";
//   parameter Real world.defaultBodyDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 9.0 \"Default for diameter of sphere representing the center of mass of a body\";
//   parameter Real world.defaultArrowDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 40.0 \"Default for arrow diameter (e.g., of forces, torques, sensors)\";
//   parameter Real world.axisDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction \"Diameter of world axes arrows\";
//   parameter Real world.gravityArrowLength(quantity = \"Length\", unit = \"m\") = world.axisLength / 2.0 \"Length of gravity arrow\";
//   protected parameter Real world.labelStart(quantity = \"Length\", unit = \"m\") = 1.05 * world.axisLength;
//   protected parameter Real world.headLength(quantity = \"Length\", unit = \"m\") = min(world.axisLength,5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineWidth(quantity = \"Length\", unit = \"m\") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   parameter Real world.gravityArrowDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction \"Diameter of gravity arrow\";
//   protected parameter Real world.lineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.axisLength - world.headLength);
//   input Real world.x_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r_lines[1](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[1](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of cylinders\";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of cylinders\";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of cylinders\";
//   input Real world.x_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1,1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1,2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1,3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2,1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2,2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2,3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3,1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3,2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3,3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1,1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1,2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1,3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2,1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2,2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2,3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3,1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3,2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3,3];
//   protected Real world.x_label.r_abs[1](quantity = \"Length\", unit = \"m\") = ({world.x_label.r[1],world.x_label.r[2],world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]}))[1];
//   protected Real world.x_label.r_abs[2](quantity = \"Length\", unit = \"m\") = ({world.x_label.r[1],world.x_label.r[2],world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]}))[2];
//   protected Real world.x_label.r_abs[3](quantity = \"Length\", unit = \"m\") = ({world.x_label.r[1],world.x_label.r[2],world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]}))[3];
//   protected parameter Integer world.x_label.n = 2 \"Number of cylinders\";
//   parameter String world.x_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1],world.x_label.cylinders[1].lengthDirection[2],world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1],world.x_label.cylinders[2].lengthDirection[2],world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   input Real world.y_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[2](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[2](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[1](unit = \"1\") = -1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[2](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = 0.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.75 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] \"Color of cylinders\";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] \"Color of cylinders\";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] \"Color of cylinders\";
//   input Real world.y_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1,1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1,2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1,3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2,1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2,2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2,3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3,1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3,2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3,3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1,1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1,2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1,3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2,1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2,2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2,3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3,1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3,2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3,3];
//   protected Real world.y_label.r_abs[1](quantity = \"Length\", unit = \"m\") = ({world.y_label.r[1],world.y_label.r[2],world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]}))[1];
//   protected Real world.y_label.r_abs[2](quantity = \"Length\", unit = \"m\") = ({world.y_label.r[1],world.y_label.r[2],world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]}))[2];
//   protected Real world.y_label.r_abs[3](quantity = \"Length\", unit = \"m\") = ({world.y_label.r[1],world.y_label.r[2],world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]}))[3];
//   protected parameter Integer world.y_label.n = 2 \"Number of cylinders\";
//   parameter String world.y_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1],world.y_label.cylinders[1].lengthDirection[2],world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1],world.y_label.cylinders[2].lengthDirection[2],world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   input Real world.z_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[3](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[3](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] \"Color of cylinders\";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] \"Color of cylinders\";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] \"Color of cylinders\";
//   input Real world.z_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1,1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1,2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1,3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2,1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2,2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2,3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3,1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3,2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3,3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1,1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1,2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1,3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2,1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2,2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2,3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3,1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3,2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3,3];
//   protected Real world.z_label.r_abs[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r[1],world.z_label.r[2],world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]}))[1];
//   protected Real world.z_label.r_abs[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r[1],world.z_label.r[2],world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]}))[2];
//   protected Real world.z_label.r_abs[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r[1],world.z_label.r[2],world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]}))[3];
//   protected parameter Integer world.z_label.n = 3 \"Number of cylinders\";
//   parameter String world.z_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1],world.z_label.cylinders[1].lengthDirection[2],world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1],world.z_label.cylinders[2].lengthDirection[2],world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].r[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[3].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[3].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[3].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1],world.z_label.cylinders[3].lengthDirection[2],world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   protected parameter Real world.gravityHeadLength(quantity = \"Length\", unit = \"m\") = min(world.gravityArrowLength,4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.gravityArrowLength - world.gravityHeadLength);
//   parameter String world.x_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.x_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.x_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.x_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1],world.x_arrowLine.lengthDirection[2],world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = \"1\") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = \"1\") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = \"1\") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.x_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.x_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.x_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1],world.x_arrowHead.lengthDirection[2],world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = \"1\") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = \"1\") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = \"1\") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   parameter String world.y_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.y_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.y_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.y_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1],world.y_arrowLine.lengthDirection[2],world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = \"1\") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = \"1\") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = \"1\") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.y_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.y_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.y_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1],world.y_arrowHead.lengthDirection[2],world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = \"1\") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = \"1\") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = \"1\") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   parameter String world.z_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.z_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.z_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.z_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1],world.z_arrowLine.lengthDirection[2],world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = \"1\") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = \"1\") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = \"1\") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.z_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.z_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.z_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1],world.z_arrowHead.lengthDirection[2],world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = \"1\") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = \"1\") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = \"1\") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   parameter String world.gravityArrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.length(quantity = \"Length\", unit = \"m\") = world.gravityLineLength \"Length of visual object\";
//   input Real world.gravityArrowLine.width(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Width of visual object\";
//   input Real world.gravityArrowLine.height(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Height of visual object\";
//   input Real world.gravityArrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowLine.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowLine.lengthDirection[1],world.gravityArrowLine.lengthDirection[2],world.gravityArrowLine.lengthDirection[3]});
//   protected Real world.gravityArrowLine.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 1.0 else world.gravityArrowLine.lengthDirection[1] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[2] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[3] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.n_z_aux[1](unit = \"1\") = world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[3] - world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[2];
//   protected Real world.gravityArrowLine.n_z_aux[2](unit = \"1\") = world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[1] - world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[3];
//   protected Real world.gravityArrowLine.n_z_aux[3](unit = \"1\") = world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[2] - world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[1];
//   protected Real world.gravityArrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[1];
//   protected Real world.gravityArrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[2];
//   protected Real world.gravityArrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[3];
//   protected output Real world.gravityArrowLine.Form;
//   output Real world.gravityArrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.Material;
//   protected output Real world.gravityArrowLine.Extra;
//   parameter String world.gravityArrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = ({world.gravityArrowTail[1],world.gravityArrowTail[2],world.gravityArrowTail[3]} + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.gravityLineLength)[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = ({world.gravityArrowTail[1],world.gravityArrowTail[2],world.gravityArrowTail[3]} + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.gravityLineLength)[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = ({world.gravityArrowTail[1],world.gravityArrowTail[2],world.gravityArrowTail[3]} + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.gravityLineLength)[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.length(quantity = \"Length\", unit = \"m\") = world.gravityHeadLength \"Length of visual object\";
//   input Real world.gravityArrowHead.width(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Width of visual object\";
//   input Real world.gravityArrowHead.height(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Height of visual object\";
//   input Real world.gravityArrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowHead.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowHead.lengthDirection[1],world.gravityArrowHead.lengthDirection[2],world.gravityArrowHead.lengthDirection[3]});
//   protected Real world.gravityArrowHead.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 1.0 else world.gravityArrowHead.lengthDirection[1] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[2] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[3] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.n_z_aux[1](unit = \"1\") = world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[3] - world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[2];
//   protected Real world.gravityArrowHead.n_z_aux[2](unit = \"1\") = world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[1] - world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[3];
//   protected Real world.gravityArrowHead.n_z_aux[3](unit = \"1\") = world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[2] - world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[1];
//   protected Real world.gravityArrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[1];
//   protected Real world.gravityArrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[2];
//   protected Real world.gravityArrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[3];
//   protected output Real world.gravityArrowHead.Form;
//   output Real world.gravityArrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.Material;
//   protected output Real world.gravityArrowHead.Extra;
//   parameter Boolean torque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   input Real torque.tau \"Accelerating torque acting at flange (= -flange.tau)\";
//   output Real pulse.y \"Connector of Real output signal\";
//   parameter Real pulse.amplitude = 10.0 \"Amplitude of pulse\";
//   parameter Real pulse.width(min = 1e-60, max = 100.0) = 30.0 \"Width of pulse in % of period\";
//   parameter Real pulse.period(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = 2.0 \"Time for one period\";
//   parameter Real pulse.offset = 0.0 \"Offset of output signals\";
//   parameter Real pulse.startTime(quantity = \"Time\", unit = \"s\") = 3.0 \"Output = offset for time < startTime\";
//   protected Real pulse.T_width(quantity = \"Time\", unit = \"s\") = (pulse.period * pulse.width) / 100.0;
//   protected Real pulse.T0(quantity = \"Time\", unit = \"s\", start = pulse.startTime) \"Start time of current period\";
//   parameter Real rearAxis.axisLength(quantity = \"Length\", unit = \"m\") = 1.7 \"length of the axis (width of the car)\";
//   parameter Real rearAxis.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 2.0 \"Inertia of the wheel\";
//   parameter Real rearAxis.R(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   final parameter Real rearAxis.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel\";
//   final parameter Real rearAxis.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel\";
//   parameter Real rearAxis.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real rearAxis.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real rearAxis.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real rearAxis.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real rearAxis.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real rearAxis.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rearAxis.differentialGear.idealPlanetary.ratio(start = 2.0) = -2.0 \"number of ring_teeth/sun_teeth (e.g. ratio=100/50)\";
//   Real rearAxis.differentialGear.idealPlanetary.sun.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.idealPlanetary.sun.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.idealPlanetary.carrier.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.idealPlanetary.carrier.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.idealPlanetary.ring.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.idealPlanetary.ring.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.flange_left.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.flange_left.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.flange_right.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.flange_right.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rearAxis.fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real rearAxis.fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real rearAxis.fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean rearAxis.fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real rearAxis.fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.fixedTranslation2.r[1] ^ 2.0 + rearAxis.fixedTranslation2.r[2] ^ 2.0);
//   parameter String rearAxis.fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = rearAxis.fixedTranslation2.r0[1] / rearAxis.fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.fixedTranslation2.r0[2] / rearAxis.fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation2.l \"Length of visual object\";
//   input Real rearAxis.fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.fixedTranslation2.cylinder.lengthDirection[1],rearAxis.fixedTranslation2.cylinder.lengthDirection[2],rearAxis.fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real rearAxis.fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.fixedTranslation2.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.fixedTranslation2.cylinder.lengthDirection[1] / rearAxis.fixedTranslation2.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation2.cylinder.lengthDirection[2] / rearAxis.fixedTranslation2.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation2.cylinder.lengthDirection[3] / rearAxis.fixedTranslation2.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.fixedTranslation2.cylinder.e_x[2] * rearAxis.fixedTranslation2.cylinder.widthDirection[3] - rearAxis.fixedTranslation2.cylinder.e_x[3] * rearAxis.fixedTranslation2.cylinder.widthDirection[2];
//   protected Real rearAxis.fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.fixedTranslation2.cylinder.e_x[3] * rearAxis.fixedTranslation2.cylinder.widthDirection[1] - rearAxis.fixedTranslation2.cylinder.e_x[1] * rearAxis.fixedTranslation2.cylinder.widthDirection[3];
//   protected Real rearAxis.fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.fixedTranslation2.cylinder.e_x[1] * rearAxis.fixedTranslation2.cylinder.widthDirection[2] - rearAxis.fixedTranslation2.cylinder.e_x[2] * rearAxis.fixedTranslation2.cylinder.widthDirection[1];
//   protected Real rearAxis.fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation2.cylinder.widthDirection[1],rearAxis.fixedTranslation2.cylinder.widthDirection[2],rearAxis.fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real rearAxis.fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation2.cylinder.widthDirection[1],rearAxis.fixedTranslation2.cylinder.widthDirection[2],rearAxis.fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real rearAxis.fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation2.cylinder.widthDirection[1],rearAxis.fixedTranslation2.cylinder.widthDirection[2],rearAxis.fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.fixedTranslation2.cylinder.Form;
//   output Real rearAxis.fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.Material;
//   protected output Real rearAxis.fixedTranslation2.cylinder.Extra;
//   Real rearAxis.fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rearAxis.fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real rearAxis.fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real rearAxis.fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean rearAxis.fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real rearAxis.fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.fixedTranslation1.r[1] ^ 2.0 + rearAxis.fixedTranslation1.r[2] ^ 2.0);
//   parameter String rearAxis.fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = rearAxis.fixedTranslation1.r0[1] / rearAxis.fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.fixedTranslation1.r0[2] / rearAxis.fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation1.l \"Length of visual object\";
//   input Real rearAxis.fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.fixedTranslation1.cylinder.lengthDirection[1],rearAxis.fixedTranslation1.cylinder.lengthDirection[2],rearAxis.fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real rearAxis.fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.fixedTranslation1.cylinder.lengthDirection[1] / rearAxis.fixedTranslation1.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation1.cylinder.lengthDirection[2] / rearAxis.fixedTranslation1.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation1.cylinder.lengthDirection[3] / rearAxis.fixedTranslation1.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.fixedTranslation1.cylinder.e_x[2] * rearAxis.fixedTranslation1.cylinder.widthDirection[3] - rearAxis.fixedTranslation1.cylinder.e_x[3] * rearAxis.fixedTranslation1.cylinder.widthDirection[2];
//   protected Real rearAxis.fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.fixedTranslation1.cylinder.e_x[3] * rearAxis.fixedTranslation1.cylinder.widthDirection[1] - rearAxis.fixedTranslation1.cylinder.e_x[1] * rearAxis.fixedTranslation1.cylinder.widthDirection[3];
//   protected Real rearAxis.fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.fixedTranslation1.cylinder.e_x[1] * rearAxis.fixedTranslation1.cylinder.widthDirection[2] - rearAxis.fixedTranslation1.cylinder.e_x[2] * rearAxis.fixedTranslation1.cylinder.widthDirection[1];
//   protected Real rearAxis.fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation1.cylinder.widthDirection[1],rearAxis.fixedTranslation1.cylinder.widthDirection[2],rearAxis.fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real rearAxis.fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation1.cylinder.widthDirection[1],rearAxis.fixedTranslation1.cylinder.widthDirection[2],rearAxis.fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real rearAxis.fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation1.cylinder.widthDirection[1],rearAxis.fixedTranslation1.cylinder.widthDirection[2],rearAxis.fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.fixedTranslation1.cylinder.Form;
//   output Real rearAxis.fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.Material;
//   protected output Real rearAxis.fixedTranslation1.cylinder.Extra;
//   Real rearAxis.inertia1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.inertia1.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia1.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.inertia1.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = rearAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) rearAxis.inertia1.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real rearAxis.inertia1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real rearAxis.inertia1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real rearAxis.inertia1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real rearAxis.inertia2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.inertia2.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia2.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.inertia2.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = rearAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) rearAxis.inertia2.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real rearAxis.inertia2.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real rearAxis.inertia2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real rearAxis.inertia2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real rearAxis.WheelJointLeft.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.WheelJointLeft.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.WheelJointLeft.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.WheelJointLeft.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.WheelJointLeft.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.WheelJointLeft.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.WheelJointLeft.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.WheelJointLeft.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.WheelJointLeft.radius(quantity = \"Length\", unit = \"m\") = rearAxis.R \"radius of the wheel\";
//   parameter Real rearAxis.WheelJointLeft.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointLeft.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointLeft.N(quantity = \"Force\", unit = \"N\") = rearAxis.N \"normal force\";
//   parameter Real rearAxis.WheelJointLeft.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vAdhesion \"adhesion velocity\";
//   parameter Real rearAxis.WheelJointLeft.vSlide(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vSlide \"sliding velocity\";
//   parameter Real rearAxis.WheelJointLeft.mu_A = rearAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real rearAxis.WheelJointLeft.mu_S = rearAxis.mu_S \"friction coefficient at sliding\";
//   Real rearAxis.WheelJointLeft.e0[1] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointLeft.e0[2] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointLeft.R[1,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.R[1,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.R[2,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.R[2,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real rearAxis.WheelJointLeft.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointLeft.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointLeft.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real rearAxis.WheelJointLeft.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real rearAxis.WheelJointLeft.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real rearAxis.WheelJointLeft.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real rearAxis.WheelJointLeft.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real rearAxis.WheelJointLeft.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointLeft.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointLeft.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean rearAxis.WheelJointLeft.animate = true \"enable Animation\";
//   parameter Boolean rearAxis.WheelJointLeft.SimVis = false \"perform animation with SimVis\";
//   final parameter Real rearAxis.WheelJointLeft.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.WheelJointLeft.r[1] ^ 2.0 + rearAxis.WheelJointLeft.r[2] ^ 2.0);
//   final parameter Real rearAxis.WheelJointLeft.e[1] = rearAxis.WheelJointLeft.r[1] / rearAxis.WheelJointLeft.l \"normalized direction\";
//   final parameter Real rearAxis.WheelJointLeft.e[2] = rearAxis.WheelJointLeft.r[2] / rearAxis.WheelJointLeft.l \"normalized direction\";
//   parameter String rearAxis.WheelJointLeft.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * rearAxis.WheelJointLeft.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * rearAxis.WheelJointLeft.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.lengthDirection[1](unit = \"1\") = -rearAxis.WheelJointLeft.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.WheelJointLeft.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real rearAxis.WheelJointLeft.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Width of visual object\";
//   input Real rearAxis.WheelJointLeft.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Height of visual object\";
//   input Real rearAxis.WheelJointLeft.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointLeft.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointLeft.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointLeft.cylinder.lengthDirection[1],rearAxis.WheelJointLeft.cylinder.lengthDirection[2],rearAxis.WheelJointLeft.cylinder.lengthDirection[3]});
//   protected Real rearAxis.WheelJointLeft.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointLeft.cylinder.lengthDirection[1] / rearAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.cylinder.lengthDirection[2] / rearAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.cylinder.lengthDirection[3] / rearAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointLeft.cylinder.e_x[2] * rearAxis.WheelJointLeft.cylinder.widthDirection[3] - rearAxis.WheelJointLeft.cylinder.e_x[3] * rearAxis.WheelJointLeft.cylinder.widthDirection[2];
//   protected Real rearAxis.WheelJointLeft.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointLeft.cylinder.e_x[3] * rearAxis.WheelJointLeft.cylinder.widthDirection[1] - rearAxis.WheelJointLeft.cylinder.e_x[1] * rearAxis.WheelJointLeft.cylinder.widthDirection[3];
//   protected Real rearAxis.WheelJointLeft.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointLeft.cylinder.e_x[1] * rearAxis.WheelJointLeft.cylinder.widthDirection[2] - rearAxis.WheelJointLeft.cylinder.e_x[2] * rearAxis.WheelJointLeft.cylinder.widthDirection[1];
//   protected Real rearAxis.WheelJointLeft.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.cylinder.widthDirection[1],rearAxis.WheelJointLeft.cylinder.widthDirection[2],rearAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]})[1];
//   protected Real rearAxis.WheelJointLeft.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.cylinder.widthDirection[1],rearAxis.WheelJointLeft.cylinder.widthDirection[2],rearAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]})[2];
//   protected Real rearAxis.WheelJointLeft.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.cylinder.widthDirection[1],rearAxis.WheelJointLeft.cylinder.widthDirection[2],rearAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointLeft.cylinder.Form;
//   output Real rearAxis.WheelJointLeft.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.Material;
//   protected output Real rearAxis.WheelJointLeft.cylinder.Extra;
//   parameter String rearAxis.WheelJointLeft.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointLeft.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointLeft.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointLeft.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointLeft.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointLeft.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointLeft.rim1.lengthDirection[1],rearAxis.WheelJointLeft.rim1.lengthDirection[2],rearAxis.WheelJointLeft.rim1.lengthDirection[3]});
//   protected Real rearAxis.WheelJointLeft.rim1.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointLeft.rim1.lengthDirection[1] / rearAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim1.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim1.lengthDirection[2] / rearAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim1.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim1.lengthDirection[3] / rearAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim1.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointLeft.rim1.e_x[2] * rearAxis.WheelJointLeft.rim1.widthDirection[3] - rearAxis.WheelJointLeft.rim1.e_x[3] * rearAxis.WheelJointLeft.rim1.widthDirection[2];
//   protected Real rearAxis.WheelJointLeft.rim1.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointLeft.rim1.e_x[3] * rearAxis.WheelJointLeft.rim1.widthDirection[1] - rearAxis.WheelJointLeft.rim1.e_x[1] * rearAxis.WheelJointLeft.rim1.widthDirection[3];
//   protected Real rearAxis.WheelJointLeft.rim1.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointLeft.rim1.e_x[1] * rearAxis.WheelJointLeft.rim1.widthDirection[2] - rearAxis.WheelJointLeft.rim1.e_x[2] * rearAxis.WheelJointLeft.rim1.widthDirection[1];
//   protected Real rearAxis.WheelJointLeft.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim1.widthDirection[1],rearAxis.WheelJointLeft.rim1.widthDirection[2],rearAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]})[1];
//   protected Real rearAxis.WheelJointLeft.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim1.widthDirection[1],rearAxis.WheelJointLeft.rim1.widthDirection[2],rearAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]})[2];
//   protected Real rearAxis.WheelJointLeft.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim1.widthDirection[1],rearAxis.WheelJointLeft.rim1.widthDirection[2],rearAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointLeft.rim1.Form;
//   output Real rearAxis.WheelJointLeft.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointLeft.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim1.Material;
//   protected output Real rearAxis.WheelJointLeft.rim1.Extra;
//   parameter String rearAxis.WheelJointLeft.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointLeft.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointLeft.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointLeft.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointLeft.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointLeft.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointLeft.rim2.lengthDirection[1],rearAxis.WheelJointLeft.rim2.lengthDirection[2],rearAxis.WheelJointLeft.rim2.lengthDirection[3]});
//   protected Real rearAxis.WheelJointLeft.rim2.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointLeft.rim2.lengthDirection[1] / rearAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim2.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim2.lengthDirection[2] / rearAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim2.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim2.lengthDirection[3] / rearAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim2.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointLeft.rim2.e_x[2] * rearAxis.WheelJointLeft.rim2.widthDirection[3] - rearAxis.WheelJointLeft.rim2.e_x[3] * rearAxis.WheelJointLeft.rim2.widthDirection[2];
//   protected Real rearAxis.WheelJointLeft.rim2.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointLeft.rim2.e_x[3] * rearAxis.WheelJointLeft.rim2.widthDirection[1] - rearAxis.WheelJointLeft.rim2.e_x[1] * rearAxis.WheelJointLeft.rim2.widthDirection[3];
//   protected Real rearAxis.WheelJointLeft.rim2.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointLeft.rim2.e_x[1] * rearAxis.WheelJointLeft.rim2.widthDirection[2] - rearAxis.WheelJointLeft.rim2.e_x[2] * rearAxis.WheelJointLeft.rim2.widthDirection[1];
//   protected Real rearAxis.WheelJointLeft.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim2.widthDirection[1],rearAxis.WheelJointLeft.rim2.widthDirection[2],rearAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]})[1];
//   protected Real rearAxis.WheelJointLeft.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim2.widthDirection[1],rearAxis.WheelJointLeft.rim2.widthDirection[2],rearAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]})[2];
//   protected Real rearAxis.WheelJointLeft.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim2.widthDirection[1],rearAxis.WheelJointLeft.rim2.widthDirection[2],rearAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointLeft.rim2.Form;
//   output Real rearAxis.WheelJointLeft.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointLeft.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim2.Material;
//   protected output Real rearAxis.WheelJointLeft.rim2.Extra;
//   Real rearAxis.WheelJointRight.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.WheelJointRight.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.WheelJointRight.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.WheelJointRight.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.WheelJointRight.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.WheelJointRight.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.WheelJointRight.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.WheelJointRight.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.WheelJointRight.radius(quantity = \"Length\", unit = \"m\") = rearAxis.R \"radius of the wheel\";
//   parameter Real rearAxis.WheelJointRight.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointRight.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointRight.N(quantity = \"Force\", unit = \"N\") = rearAxis.N \"normal force\";
//   parameter Real rearAxis.WheelJointRight.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vAdhesion \"adhesion velocity\";
//   parameter Real rearAxis.WheelJointRight.vSlide(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vSlide \"sliding velocity\";
//   parameter Real rearAxis.WheelJointRight.mu_A = rearAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real rearAxis.WheelJointRight.mu_S = rearAxis.mu_S \"friction coefficient at sliding\";
//   Real rearAxis.WheelJointRight.e0[1] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointRight.e0[2] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointRight.R[1,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.R[1,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.R[2,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.R[2,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real rearAxis.WheelJointRight.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointRight.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointRight.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real rearAxis.WheelJointRight.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real rearAxis.WheelJointRight.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real rearAxis.WheelJointRight.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real rearAxis.WheelJointRight.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real rearAxis.WheelJointRight.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointRight.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointRight.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean rearAxis.WheelJointRight.animate = true \"enable Animation\";
//   parameter Boolean rearAxis.WheelJointRight.SimVis = false \"perform animation with SimVis\";
//   final parameter Real rearAxis.WheelJointRight.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.WheelJointRight.r[1] ^ 2.0 + rearAxis.WheelJointRight.r[2] ^ 2.0);
//   final parameter Real rearAxis.WheelJointRight.e[1] = rearAxis.WheelJointRight.r[1] / rearAxis.WheelJointRight.l \"normalized direction\";
//   final parameter Real rearAxis.WheelJointRight.e[2] = rearAxis.WheelJointRight.r[2] / rearAxis.WheelJointRight.l \"normalized direction\";
//   parameter String rearAxis.WheelJointRight.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * rearAxis.WheelJointRight.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * rearAxis.WheelJointRight.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.lengthDirection[1](unit = \"1\") = -rearAxis.WheelJointRight.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.WheelJointRight.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real rearAxis.WheelJointRight.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Width of visual object\";
//   input Real rearAxis.WheelJointRight.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Height of visual object\";
//   input Real rearAxis.WheelJointRight.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointRight.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointRight.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointRight.cylinder.lengthDirection[1],rearAxis.WheelJointRight.cylinder.lengthDirection[2],rearAxis.WheelJointRight.cylinder.lengthDirection[3]});
//   protected Real rearAxis.WheelJointRight.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointRight.cylinder.lengthDirection[1] / rearAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointRight.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.cylinder.lengthDirection[2] / rearAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointRight.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.cylinder.lengthDirection[3] / rearAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointRight.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointRight.cylinder.e_x[2] * rearAxis.WheelJointRight.cylinder.widthDirection[3] - rearAxis.WheelJointRight.cylinder.e_x[3] * rearAxis.WheelJointRight.cylinder.widthDirection[2];
//   protected Real rearAxis.WheelJointRight.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointRight.cylinder.e_x[3] * rearAxis.WheelJointRight.cylinder.widthDirection[1] - rearAxis.WheelJointRight.cylinder.e_x[1] * rearAxis.WheelJointRight.cylinder.widthDirection[3];
//   protected Real rearAxis.WheelJointRight.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointRight.cylinder.e_x[1] * rearAxis.WheelJointRight.cylinder.widthDirection[2] - rearAxis.WheelJointRight.cylinder.e_x[2] * rearAxis.WheelJointRight.cylinder.widthDirection[1];
//   protected Real rearAxis.WheelJointRight.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.cylinder.widthDirection[1],rearAxis.WheelJointRight.cylinder.widthDirection[2],rearAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]})[1];
//   protected Real rearAxis.WheelJointRight.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.cylinder.widthDirection[1],rearAxis.WheelJointRight.cylinder.widthDirection[2],rearAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]})[2];
//   protected Real rearAxis.WheelJointRight.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.cylinder.widthDirection[1],rearAxis.WheelJointRight.cylinder.widthDirection[2],rearAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointRight.cylinder.Form;
//   output Real rearAxis.WheelJointRight.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointRight.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.cylinder.Material;
//   protected output Real rearAxis.WheelJointRight.cylinder.Extra;
//   parameter String rearAxis.WheelJointRight.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim1.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim1.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointRight.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointRight.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointRight.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointRight.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointRight.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointRight.rim1.lengthDirection[1],rearAxis.WheelJointRight.rim1.lengthDirection[2],rearAxis.WheelJointRight.rim1.lengthDirection[3]});
//   protected Real rearAxis.WheelJointRight.rim1.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointRight.rim1.lengthDirection[1] / rearAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim1.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim1.lengthDirection[2] / rearAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim1.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim1.lengthDirection[3] / rearAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim1.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointRight.rim1.e_x[2] * rearAxis.WheelJointRight.rim1.widthDirection[3] - rearAxis.WheelJointRight.rim1.e_x[3] * rearAxis.WheelJointRight.rim1.widthDirection[2];
//   protected Real rearAxis.WheelJointRight.rim1.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointRight.rim1.e_x[3] * rearAxis.WheelJointRight.rim1.widthDirection[1] - rearAxis.WheelJointRight.rim1.e_x[1] * rearAxis.WheelJointRight.rim1.widthDirection[3];
//   protected Real rearAxis.WheelJointRight.rim1.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointRight.rim1.e_x[1] * rearAxis.WheelJointRight.rim1.widthDirection[2] - rearAxis.WheelJointRight.rim1.e_x[2] * rearAxis.WheelJointRight.rim1.widthDirection[1];
//   protected Real rearAxis.WheelJointRight.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim1.widthDirection[1],rearAxis.WheelJointRight.rim1.widthDirection[2],rearAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]})[1];
//   protected Real rearAxis.WheelJointRight.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim1.widthDirection[1],rearAxis.WheelJointRight.rim1.widthDirection[2],rearAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]})[2];
//   protected Real rearAxis.WheelJointRight.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim1.widthDirection[1],rearAxis.WheelJointRight.rim1.widthDirection[2],rearAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointRight.rim1.Form;
//   output Real rearAxis.WheelJointRight.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointRight.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim1.Material;
//   protected output Real rearAxis.WheelJointRight.rim1.Extra;
//   parameter String rearAxis.WheelJointRight.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim2.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim2.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointRight.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointRight.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointRight.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointRight.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointRight.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointRight.rim2.lengthDirection[1],rearAxis.WheelJointRight.rim2.lengthDirection[2],rearAxis.WheelJointRight.rim2.lengthDirection[3]});
//   protected Real rearAxis.WheelJointRight.rim2.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointRight.rim2.lengthDirection[1] / rearAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim2.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim2.lengthDirection[2] / rearAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim2.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim2.lengthDirection[3] / rearAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim2.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointRight.rim2.e_x[2] * rearAxis.WheelJointRight.rim2.widthDirection[3] - rearAxis.WheelJointRight.rim2.e_x[3] * rearAxis.WheelJointRight.rim2.widthDirection[2];
//   protected Real rearAxis.WheelJointRight.rim2.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointRight.rim2.e_x[3] * rearAxis.WheelJointRight.rim2.widthDirection[1] - rearAxis.WheelJointRight.rim2.e_x[1] * rearAxis.WheelJointRight.rim2.widthDirection[3];
//   protected Real rearAxis.WheelJointRight.rim2.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointRight.rim2.e_x[1] * rearAxis.WheelJointRight.rim2.widthDirection[2] - rearAxis.WheelJointRight.rim2.e_x[2] * rearAxis.WheelJointRight.rim2.widthDirection[1];
//   protected Real rearAxis.WheelJointRight.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim2.widthDirection[1],rearAxis.WheelJointRight.rim2.widthDirection[2],rearAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]})[1];
//   protected Real rearAxis.WheelJointRight.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim2.widthDirection[1],rearAxis.WheelJointRight.rim2.widthDirection[2],rearAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]})[2];
//   protected Real rearAxis.WheelJointRight.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim2.widthDirection[1],rearAxis.WheelJointRight.rim2.widthDirection[2],rearAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointRight.rim2.Form;
//   output Real rearAxis.WheelJointRight.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointRight.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim2.Material;
//   protected output Real rearAxis.WheelJointRight.rim2.Extra;
//   parameter Real frontAxis.axisLength(quantity = \"Length\", unit = \"m\") = 1.6 \"length of the axis (width of the car)\";
//   parameter Real frontAxis.trail(quantity = \"Length\", unit = \"m\") = 0.02;
//   parameter Real frontAxis.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 2.0 \"Inertia of the wheel\";
//   parameter Real frontAxis.I_susp(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 2.0 \"Rotational Inertia of the steering suspension\";
//   parameter Real frontAxis.R(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   final parameter Real frontAxis.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel\";
//   final parameter Real frontAxis.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel\";
//   parameter Real frontAxis.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real frontAxis.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real frontAxis.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real frontAxis.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real frontAxis.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real frontAxis.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftSteeringRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftSteeringRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftSteeringRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftSteeringRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean frontAxis.leftSteeringRevolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real frontAxis.leftSteeringRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real frontAxis.leftSteeringRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real frontAxis.leftSteeringRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real frontAxis.leftSteeringRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real frontAxis.leftSteeringRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real frontAxis.leftSteeringRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean frontAxis.leftSteeringRevolute.animate = true \"enable Animation\";
//   Real frontAxis.leftSteeringRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.leftSteeringRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String frontAxis.leftSteeringRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.leftSteeringRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.leftSteeringRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.leftSteeringRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.leftSteeringRevolute.cylinder.lengthDirection[1],frontAxis.leftSteeringRevolute.cylinder.lengthDirection[2],frontAxis.leftSteeringRevolute.cylinder.lengthDirection[3]});
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.leftSteeringRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.leftSteeringRevolute.cylinder.lengthDirection[1] / frontAxis.leftSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.leftSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftSteeringRevolute.cylinder.lengthDirection[2] / frontAxis.leftSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.leftSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftSteeringRevolute.cylinder.lengthDirection[3] / frontAxis.leftSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.leftSteeringRevolute.cylinder.e_x[2] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[3] - frontAxis.leftSteeringRevolute.cylinder.e_x[3] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[2];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.leftSteeringRevolute.cylinder.e_x[3] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[1] - frontAxis.leftSteeringRevolute.cylinder.e_x[1] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[3];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.leftSteeringRevolute.cylinder.e_x[1] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[2] - frontAxis.leftSteeringRevolute.cylinder.e_x[2] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[1];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftSteeringRevolute.cylinder.widthDirection[1],frontAxis.leftSteeringRevolute.cylinder.widthDirection[2],frontAxis.leftSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]})[1];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftSteeringRevolute.cylinder.widthDirection[1],frontAxis.leftSteeringRevolute.cylinder.widthDirection[2],frontAxis.leftSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]})[2];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftSteeringRevolute.cylinder.widthDirection[1],frontAxis.leftSteeringRevolute.cylinder.widthDirection[2],frontAxis.leftSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.Form;
//   output Real frontAxis.leftSteeringRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.Material;
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.Extra;
//   Real frontAxis.rightSteeringRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightSteeringRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightSteeringRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightSteeringRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.rightSteeringRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightSteeringRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightSteeringRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightSteeringRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean frontAxis.rightSteeringRevolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real frontAxis.rightSteeringRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real frontAxis.rightSteeringRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real frontAxis.rightSteeringRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real frontAxis.rightSteeringRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real frontAxis.rightSteeringRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real frontAxis.rightSteeringRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean frontAxis.rightSteeringRevolute.animate = true \"enable Animation\";
//   Real frontAxis.rightSteeringRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.rightSteeringRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String frontAxis.rightSteeringRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.rightSteeringRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.rightSteeringRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.rightSteeringRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.rightSteeringRevolute.cylinder.lengthDirection[1],frontAxis.rightSteeringRevolute.cylinder.lengthDirection[2],frontAxis.rightSteeringRevolute.cylinder.lengthDirection[3]});
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.rightSteeringRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.rightSteeringRevolute.cylinder.lengthDirection[1] / frontAxis.rightSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.rightSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightSteeringRevolute.cylinder.lengthDirection[2] / frontAxis.rightSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.rightSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightSteeringRevolute.cylinder.lengthDirection[3] / frontAxis.rightSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.rightSteeringRevolute.cylinder.e_x[2] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[3] - frontAxis.rightSteeringRevolute.cylinder.e_x[3] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[2];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.rightSteeringRevolute.cylinder.e_x[3] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[1] - frontAxis.rightSteeringRevolute.cylinder.e_x[1] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[3];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.rightSteeringRevolute.cylinder.e_x[1] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[2] - frontAxis.rightSteeringRevolute.cylinder.e_x[2] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[1];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightSteeringRevolute.cylinder.widthDirection[1],frontAxis.rightSteeringRevolute.cylinder.widthDirection[2],frontAxis.rightSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]})[1];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightSteeringRevolute.cylinder.widthDirection[1],frontAxis.rightSteeringRevolute.cylinder.widthDirection[2],frontAxis.rightSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]})[2];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightSteeringRevolute.cylinder.widthDirection[1],frontAxis.rightSteeringRevolute.cylinder.widthDirection[2],frontAxis.rightSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.Form;
//   output Real frontAxis.rightSteeringRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.Material;
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.Extra;
//   Real frontAxis.leftAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftAxis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftAxis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftAxis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftAxis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftAxis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftAxis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.leftAxis.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.leftAxis.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.leftAxis.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftAxis.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftAxis.R[1,1] \"Rotation matrix\";
//   Real frontAxis.leftAxis.R[1,2] \"Rotation matrix\";
//   Real frontAxis.leftAxis.R[2,1] \"Rotation matrix\";
//   Real frontAxis.leftAxis.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.leftAxis.animate = true \"enable Animation\";
//   final parameter Real frontAxis.leftAxis.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.leftAxis.r[1] ^ 2.0 + frontAxis.leftAxis.r[2] ^ 2.0);
//   parameter String frontAxis.leftAxis.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.leftAxis.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftAxis.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.leftAxis.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftAxis.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.leftAxis.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftAxis.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftAxis.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.leftAxis.r0[1] / frontAxis.leftAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.leftAxis.r0[2] / frontAxis.leftAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.leftAxis.l \"Length of visual object\";
//   input Real frontAxis.leftAxis.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.leftAxis.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.leftAxis.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.leftAxis.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftAxis.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftAxis.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftAxis.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.leftAxis.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.leftAxis.cylinder.lengthDirection[1],frontAxis.leftAxis.cylinder.lengthDirection[2],frontAxis.leftAxis.cylinder.lengthDirection[3]});
//   protected Real frontAxis.leftAxis.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.leftAxis.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.leftAxis.cylinder.lengthDirection[1] / frontAxis.leftAxis.cylinder.abs_n_x;
//   protected Real frontAxis.leftAxis.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.leftAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftAxis.cylinder.lengthDirection[2] / frontAxis.leftAxis.cylinder.abs_n_x;
//   protected Real frontAxis.leftAxis.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.leftAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftAxis.cylinder.lengthDirection[3] / frontAxis.leftAxis.cylinder.abs_n_x;
//   protected Real frontAxis.leftAxis.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.leftAxis.cylinder.e_x[2] * frontAxis.leftAxis.cylinder.widthDirection[3] - frontAxis.leftAxis.cylinder.e_x[3] * frontAxis.leftAxis.cylinder.widthDirection[2];
//   protected Real frontAxis.leftAxis.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.leftAxis.cylinder.e_x[3] * frontAxis.leftAxis.cylinder.widthDirection[1] - frontAxis.leftAxis.cylinder.e_x[1] * frontAxis.leftAxis.cylinder.widthDirection[3];
//   protected Real frontAxis.leftAxis.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.leftAxis.cylinder.e_x[1] * frontAxis.leftAxis.cylinder.widthDirection[2] - frontAxis.leftAxis.cylinder.e_x[2] * frontAxis.leftAxis.cylinder.widthDirection[1];
//   protected Real frontAxis.leftAxis.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]},if noEvent(frontAxis.leftAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftAxis.cylinder.widthDirection[1],frontAxis.leftAxis.cylinder.widthDirection[2],frontAxis.leftAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]})[1];
//   protected Real frontAxis.leftAxis.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]},if noEvent(frontAxis.leftAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftAxis.cylinder.widthDirection[1],frontAxis.leftAxis.cylinder.widthDirection[2],frontAxis.leftAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]})[2];
//   protected Real frontAxis.leftAxis.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]},if noEvent(frontAxis.leftAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftAxis.cylinder.widthDirection[1],frontAxis.leftAxis.cylinder.widthDirection[2],frontAxis.leftAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.leftAxis.cylinder.Form;
//   output Real frontAxis.leftAxis.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.leftAxis.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftAxis.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftAxis.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftAxis.cylinder.Material;
//   protected output Real frontAxis.leftAxis.cylinder.Extra;
//   Real frontAxis.rightAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.rightAxis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightAxis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightAxis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightAxis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightAxis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightAxis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.rightAxis.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.rightAxis.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.rightAxis.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rightAxis.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rightAxis.R[1,1] \"Rotation matrix\";
//   Real frontAxis.rightAxis.R[1,2] \"Rotation matrix\";
//   Real frontAxis.rightAxis.R[2,1] \"Rotation matrix\";
//   Real frontAxis.rightAxis.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.rightAxis.animate = true \"enable Animation\";
//   final parameter Real frontAxis.rightAxis.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.rightAxis.r[1] ^ 2.0 + frontAxis.rightAxis.r[2] ^ 2.0);
//   parameter String frontAxis.rightAxis.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.rightAxis.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightAxis.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.rightAxis.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightAxis.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.rightAxis.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightAxis.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightAxis.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.rightAxis.r0[1] / frontAxis.rightAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.rightAxis.r0[2] / frontAxis.rightAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.rightAxis.l \"Length of visual object\";
//   input Real frontAxis.rightAxis.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.rightAxis.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.rightAxis.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.rightAxis.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.rightAxis.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.rightAxis.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.rightAxis.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.rightAxis.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.rightAxis.cylinder.lengthDirection[1],frontAxis.rightAxis.cylinder.lengthDirection[2],frontAxis.rightAxis.cylinder.lengthDirection[3]});
//   protected Real frontAxis.rightAxis.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.rightAxis.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.rightAxis.cylinder.lengthDirection[1] / frontAxis.rightAxis.cylinder.abs_n_x;
//   protected Real frontAxis.rightAxis.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.rightAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightAxis.cylinder.lengthDirection[2] / frontAxis.rightAxis.cylinder.abs_n_x;
//   protected Real frontAxis.rightAxis.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.rightAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightAxis.cylinder.lengthDirection[3] / frontAxis.rightAxis.cylinder.abs_n_x;
//   protected Real frontAxis.rightAxis.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.rightAxis.cylinder.e_x[2] * frontAxis.rightAxis.cylinder.widthDirection[3] - frontAxis.rightAxis.cylinder.e_x[3] * frontAxis.rightAxis.cylinder.widthDirection[2];
//   protected Real frontAxis.rightAxis.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.rightAxis.cylinder.e_x[3] * frontAxis.rightAxis.cylinder.widthDirection[1] - frontAxis.rightAxis.cylinder.e_x[1] * frontAxis.rightAxis.cylinder.widthDirection[3];
//   protected Real frontAxis.rightAxis.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.rightAxis.cylinder.e_x[1] * frontAxis.rightAxis.cylinder.widthDirection[2] - frontAxis.rightAxis.cylinder.e_x[2] * frontAxis.rightAxis.cylinder.widthDirection[1];
//   protected Real frontAxis.rightAxis.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]},if noEvent(frontAxis.rightAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightAxis.cylinder.widthDirection[1],frontAxis.rightAxis.cylinder.widthDirection[2],frontAxis.rightAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]})[1];
//   protected Real frontAxis.rightAxis.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]},if noEvent(frontAxis.rightAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightAxis.cylinder.widthDirection[1],frontAxis.rightAxis.cylinder.widthDirection[2],frontAxis.rightAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]})[2];
//   protected Real frontAxis.rightAxis.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]},if noEvent(frontAxis.rightAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightAxis.cylinder.widthDirection[1],frontAxis.rightAxis.cylinder.widthDirection[2],frontAxis.rightAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.rightAxis.cylinder.Form;
//   output Real frontAxis.rightAxis.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.rightAxis.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightAxis.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightAxis.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightAxis.cylinder.Material;
//   protected output Real frontAxis.rightAxis.cylinder.Extra;
//   Real frontAxis.leftTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.leftTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.leftTrail.r[2](quantity = \"Length\", unit = \"m\") = -frontAxis.trail \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.leftTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftTrail.R[1,1] \"Rotation matrix\";
//   Real frontAxis.leftTrail.R[1,2] \"Rotation matrix\";
//   Real frontAxis.leftTrail.R[2,1] \"Rotation matrix\";
//   Real frontAxis.leftTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.leftTrail.animate = true \"enable Animation\";
//   final parameter Real frontAxis.leftTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.leftTrail.r[1] ^ 2.0 + frontAxis.leftTrail.r[2] ^ 2.0);
//   parameter String frontAxis.leftTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.leftTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.leftTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.leftTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.leftTrail.r0[1] / frontAxis.leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.leftTrail.r0[2] / frontAxis.leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.leftTrail.l \"Length of visual object\";
//   input Real frontAxis.leftTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.leftTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.leftTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.leftTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.leftTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.leftTrail.cylinder.lengthDirection[1],frontAxis.leftTrail.cylinder.lengthDirection[2],frontAxis.leftTrail.cylinder.lengthDirection[3]});
//   protected Real frontAxis.leftTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.leftTrail.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.leftTrail.cylinder.lengthDirection[1] / frontAxis.leftTrail.cylinder.abs_n_x;
//   protected Real frontAxis.leftTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.leftTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftTrail.cylinder.lengthDirection[2] / frontAxis.leftTrail.cylinder.abs_n_x;
//   protected Real frontAxis.leftTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.leftTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftTrail.cylinder.lengthDirection[3] / frontAxis.leftTrail.cylinder.abs_n_x;
//   protected Real frontAxis.leftTrail.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.leftTrail.cylinder.e_x[2] * frontAxis.leftTrail.cylinder.widthDirection[3] - frontAxis.leftTrail.cylinder.e_x[3] * frontAxis.leftTrail.cylinder.widthDirection[2];
//   protected Real frontAxis.leftTrail.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.leftTrail.cylinder.e_x[3] * frontAxis.leftTrail.cylinder.widthDirection[1] - frontAxis.leftTrail.cylinder.e_x[1] * frontAxis.leftTrail.cylinder.widthDirection[3];
//   protected Real frontAxis.leftTrail.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.leftTrail.cylinder.e_x[1] * frontAxis.leftTrail.cylinder.widthDirection[2] - frontAxis.leftTrail.cylinder.e_x[2] * frontAxis.leftTrail.cylinder.widthDirection[1];
//   protected Real frontAxis.leftTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]},if noEvent(frontAxis.leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftTrail.cylinder.widthDirection[1],frontAxis.leftTrail.cylinder.widthDirection[2],frontAxis.leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]})[1];
//   protected Real frontAxis.leftTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]},if noEvent(frontAxis.leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftTrail.cylinder.widthDirection[1],frontAxis.leftTrail.cylinder.widthDirection[2],frontAxis.leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]})[2];
//   protected Real frontAxis.leftTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]},if noEvent(frontAxis.leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftTrail.cylinder.widthDirection[1],frontAxis.leftTrail.cylinder.widthDirection[2],frontAxis.leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.leftTrail.cylinder.Form;
//   output Real frontAxis.leftTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.leftTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftTrail.cylinder.Material;
//   protected output Real frontAxis.leftTrail.cylinder.Extra;
//   Real frontAxis.rigthtTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rigthtTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rigthtTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rigthtTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rigthtTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rigthtTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.rigthtTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rigthtTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rigthtTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rigthtTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rigthtTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rigthtTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.rigthtTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.rigthtTrail.r[2](quantity = \"Length\", unit = \"m\") = -frontAxis.trail \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.rigthtTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rigthtTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rigthtTrail.R[1,1] \"Rotation matrix\";
//   Real frontAxis.rigthtTrail.R[1,2] \"Rotation matrix\";
//   Real frontAxis.rigthtTrail.R[2,1] \"Rotation matrix\";
//   Real frontAxis.rigthtTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.rigthtTrail.animate = true \"enable Animation\";
//   final parameter Real frontAxis.rigthtTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.rigthtTrail.r[1] ^ 2.0 + frontAxis.rigthtTrail.r[2] ^ 2.0);
//   parameter String frontAxis.rigthtTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.rigthtTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.rigthtTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.rigthtTrail.r0[1] / frontAxis.rigthtTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.rigthtTrail.r0[2] / frontAxis.rigthtTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.rigthtTrail.l \"Length of visual object\";
//   input Real frontAxis.rigthtTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.rigthtTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.rigthtTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.rigthtTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.rigthtTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.rigthtTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.rigthtTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.rigthtTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.rigthtTrail.cylinder.lengthDirection[1],frontAxis.rigthtTrail.cylinder.lengthDirection[2],frontAxis.rigthtTrail.cylinder.lengthDirection[3]});
//   protected Real frontAxis.rigthtTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.rigthtTrail.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.rigthtTrail.cylinder.lengthDirection[1] / frontAxis.rigthtTrail.cylinder.abs_n_x;
//   protected Real frontAxis.rigthtTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.rigthtTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rigthtTrail.cylinder.lengthDirection[2] / frontAxis.rigthtTrail.cylinder.abs_n_x;
//   protected Real frontAxis.rigthtTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.rigthtTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rigthtTrail.cylinder.lengthDirection[3] / frontAxis.rigthtTrail.cylinder.abs_n_x;
//   protected Real frontAxis.rigthtTrail.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.rigthtTrail.cylinder.e_x[2] * frontAxis.rigthtTrail.cylinder.widthDirection[3] - frontAxis.rigthtTrail.cylinder.e_x[3] * frontAxis.rigthtTrail.cylinder.widthDirection[2];
//   protected Real frontAxis.rigthtTrail.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.rigthtTrail.cylinder.e_x[3] * frontAxis.rigthtTrail.cylinder.widthDirection[1] - frontAxis.rigthtTrail.cylinder.e_x[1] * frontAxis.rigthtTrail.cylinder.widthDirection[3];
//   protected Real frontAxis.rigthtTrail.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.rigthtTrail.cylinder.e_x[1] * frontAxis.rigthtTrail.cylinder.widthDirection[2] - frontAxis.rigthtTrail.cylinder.e_x[2] * frontAxis.rigthtTrail.cylinder.widthDirection[1];
//   protected Real frontAxis.rigthtTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]},if noEvent(frontAxis.rigthtTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rigthtTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rigthtTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rigthtTrail.cylinder.widthDirection[1],frontAxis.rigthtTrail.cylinder.widthDirection[2],frontAxis.rigthtTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rigthtTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]})[1];
//   protected Real frontAxis.rigthtTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]},if noEvent(frontAxis.rigthtTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rigthtTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rigthtTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rigthtTrail.cylinder.widthDirection[1],frontAxis.rigthtTrail.cylinder.widthDirection[2],frontAxis.rigthtTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rigthtTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]})[2];
//   protected Real frontAxis.rigthtTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]},if noEvent(frontAxis.rigthtTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rigthtTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rigthtTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rigthtTrail.cylinder.widthDirection[1],frontAxis.rigthtTrail.cylinder.widthDirection[2],frontAxis.rigthtTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rigthtTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.rigthtTrail.cylinder.Form;
//   output Real frontAxis.rigthtTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.rigthtTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rigthtTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rigthtTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rigthtTrail.cylinder.Material;
//   protected output Real frontAxis.rigthtTrail.cylinder.Extra;
//   Real frontAxis.leftInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.leftInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.leftInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.leftInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.leftInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = frontAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) frontAxis.leftInertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real frontAxis.leftInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real frontAxis.leftInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real frontAxis.leftInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real frontAxis.rightInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.rightInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.rightInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.rightInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.rightInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = frontAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) frontAxis.rightInertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real frontAxis.rightInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real frontAxis.rightInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real frontAxis.rightInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real frontAxis.SteeringInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.SteeringInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.SteeringInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.SteeringInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.SteeringInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = frontAxis.I_susp \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) frontAxis.SteeringInertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real frontAxis.SteeringInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real frontAxis.SteeringInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real frontAxis.SteeringInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real frontAxis.WheelJointLeft.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.WheelJointLeft.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.WheelJointLeft.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.WheelJointLeft.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.WheelJointLeft.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.WheelJointLeft.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.WheelJointLeft.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.WheelJointLeft.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.WheelJointLeft.radius(quantity = \"Length\", unit = \"m\") = frontAxis.R \"radius of the wheel\";
//   parameter Real frontAxis.WheelJointLeft.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointLeft.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointLeft.N(quantity = \"Force\", unit = \"N\") = frontAxis.N \"normal force\";
//   parameter Real frontAxis.WheelJointLeft.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vAdhesion \"adhesion velocity\";
//   parameter Real frontAxis.WheelJointLeft.vSlide(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vSlide \"sliding velocity\";
//   parameter Real frontAxis.WheelJointLeft.mu_A = frontAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real frontAxis.WheelJointLeft.mu_S = frontAxis.mu_S \"friction coefficient at sliding\";
//   Real frontAxis.WheelJointLeft.e0[1] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointLeft.e0[2] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointLeft.R[1,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.R[1,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.R[2,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.R[2,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real frontAxis.WheelJointLeft.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointLeft.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointLeft.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real frontAxis.WheelJointLeft.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real frontAxis.WheelJointLeft.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real frontAxis.WheelJointLeft.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real frontAxis.WheelJointLeft.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real frontAxis.WheelJointLeft.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointLeft.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointLeft.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean frontAxis.WheelJointLeft.animate = true \"enable Animation\";
//   parameter Boolean frontAxis.WheelJointLeft.SimVis = false \"perform animation with SimVis\";
//   final parameter Real frontAxis.WheelJointLeft.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.WheelJointLeft.r[1] ^ 2.0 + frontAxis.WheelJointLeft.r[2] ^ 2.0);
//   final parameter Real frontAxis.WheelJointLeft.e[1] = frontAxis.WheelJointLeft.r[1] / frontAxis.WheelJointLeft.l \"normalized direction\";
//   final parameter Real frontAxis.WheelJointLeft.e[2] = frontAxis.WheelJointLeft.r[2] / frontAxis.WheelJointLeft.l \"normalized direction\";
//   parameter String frontAxis.WheelJointLeft.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * frontAxis.WheelJointLeft.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * frontAxis.WheelJointLeft.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.lengthDirection[1](unit = \"1\") = -frontAxis.WheelJointLeft.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.WheelJointLeft.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real frontAxis.WheelJointLeft.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Width of visual object\";
//   input Real frontAxis.WheelJointLeft.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Height of visual object\";
//   input Real frontAxis.WheelJointLeft.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointLeft.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointLeft.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointLeft.cylinder.lengthDirection[1],frontAxis.WheelJointLeft.cylinder.lengthDirection[2],frontAxis.WheelJointLeft.cylinder.lengthDirection[3]});
//   protected Real frontAxis.WheelJointLeft.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointLeft.cylinder.lengthDirection[1] / frontAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.cylinder.lengthDirection[2] / frontAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.cylinder.lengthDirection[3] / frontAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointLeft.cylinder.e_x[2] * frontAxis.WheelJointLeft.cylinder.widthDirection[3] - frontAxis.WheelJointLeft.cylinder.e_x[3] * frontAxis.WheelJointLeft.cylinder.widthDirection[2];
//   protected Real frontAxis.WheelJointLeft.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointLeft.cylinder.e_x[3] * frontAxis.WheelJointLeft.cylinder.widthDirection[1] - frontAxis.WheelJointLeft.cylinder.e_x[1] * frontAxis.WheelJointLeft.cylinder.widthDirection[3];
//   protected Real frontAxis.WheelJointLeft.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointLeft.cylinder.e_x[1] * frontAxis.WheelJointLeft.cylinder.widthDirection[2] - frontAxis.WheelJointLeft.cylinder.e_x[2] * frontAxis.WheelJointLeft.cylinder.widthDirection[1];
//   protected Real frontAxis.WheelJointLeft.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.cylinder.widthDirection[1],frontAxis.WheelJointLeft.cylinder.widthDirection[2],frontAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]})[1];
//   protected Real frontAxis.WheelJointLeft.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.cylinder.widthDirection[1],frontAxis.WheelJointLeft.cylinder.widthDirection[2],frontAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]})[2];
//   protected Real frontAxis.WheelJointLeft.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.cylinder.widthDirection[1],frontAxis.WheelJointLeft.cylinder.widthDirection[2],frontAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointLeft.cylinder.Form;
//   output Real frontAxis.WheelJointLeft.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.Material;
//   protected output Real frontAxis.WheelJointLeft.cylinder.Extra;
//   parameter String frontAxis.WheelJointLeft.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointLeft.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointLeft.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointLeft.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointLeft.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointLeft.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointLeft.rim1.lengthDirection[1],frontAxis.WheelJointLeft.rim1.lengthDirection[2],frontAxis.WheelJointLeft.rim1.lengthDirection[3]});
//   protected Real frontAxis.WheelJointLeft.rim1.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointLeft.rim1.lengthDirection[1] / frontAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim1.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim1.lengthDirection[2] / frontAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim1.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim1.lengthDirection[3] / frontAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim1.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointLeft.rim1.e_x[2] * frontAxis.WheelJointLeft.rim1.widthDirection[3] - frontAxis.WheelJointLeft.rim1.e_x[3] * frontAxis.WheelJointLeft.rim1.widthDirection[2];
//   protected Real frontAxis.WheelJointLeft.rim1.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointLeft.rim1.e_x[3] * frontAxis.WheelJointLeft.rim1.widthDirection[1] - frontAxis.WheelJointLeft.rim1.e_x[1] * frontAxis.WheelJointLeft.rim1.widthDirection[3];
//   protected Real frontAxis.WheelJointLeft.rim1.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointLeft.rim1.e_x[1] * frontAxis.WheelJointLeft.rim1.widthDirection[2] - frontAxis.WheelJointLeft.rim1.e_x[2] * frontAxis.WheelJointLeft.rim1.widthDirection[1];
//   protected Real frontAxis.WheelJointLeft.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim1.widthDirection[1],frontAxis.WheelJointLeft.rim1.widthDirection[2],frontAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]})[1];
//   protected Real frontAxis.WheelJointLeft.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim1.widthDirection[1],frontAxis.WheelJointLeft.rim1.widthDirection[2],frontAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]})[2];
//   protected Real frontAxis.WheelJointLeft.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim1.widthDirection[1],frontAxis.WheelJointLeft.rim1.widthDirection[2],frontAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointLeft.rim1.Form;
//   output Real frontAxis.WheelJointLeft.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointLeft.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim1.Material;
//   protected output Real frontAxis.WheelJointLeft.rim1.Extra;
//   parameter String frontAxis.WheelJointLeft.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointLeft.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointLeft.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointLeft.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointLeft.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointLeft.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointLeft.rim2.lengthDirection[1],frontAxis.WheelJointLeft.rim2.lengthDirection[2],frontAxis.WheelJointLeft.rim2.lengthDirection[3]});
//   protected Real frontAxis.WheelJointLeft.rim2.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointLeft.rim2.lengthDirection[1] / frontAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim2.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim2.lengthDirection[2] / frontAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim2.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim2.lengthDirection[3] / frontAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim2.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointLeft.rim2.e_x[2] * frontAxis.WheelJointLeft.rim2.widthDirection[3] - frontAxis.WheelJointLeft.rim2.e_x[3] * frontAxis.WheelJointLeft.rim2.widthDirection[2];
//   protected Real frontAxis.WheelJointLeft.rim2.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointLeft.rim2.e_x[3] * frontAxis.WheelJointLeft.rim2.widthDirection[1] - frontAxis.WheelJointLeft.rim2.e_x[1] * frontAxis.WheelJointLeft.rim2.widthDirection[3];
//   protected Real frontAxis.WheelJointLeft.rim2.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointLeft.rim2.e_x[1] * frontAxis.WheelJointLeft.rim2.widthDirection[2] - frontAxis.WheelJointLeft.rim2.e_x[2] * frontAxis.WheelJointLeft.rim2.widthDirection[1];
//   protected Real frontAxis.WheelJointLeft.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim2.widthDirection[1],frontAxis.WheelJointLeft.rim2.widthDirection[2],frontAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]})[1];
//   protected Real frontAxis.WheelJointLeft.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim2.widthDirection[1],frontAxis.WheelJointLeft.rim2.widthDirection[2],frontAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]})[2];
//   protected Real frontAxis.WheelJointLeft.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim2.widthDirection[1],frontAxis.WheelJointLeft.rim2.widthDirection[2],frontAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointLeft.rim2.Form;
//   output Real frontAxis.WheelJointLeft.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointLeft.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim2.Material;
//   protected output Real frontAxis.WheelJointLeft.rim2.Extra;
//   Real frontAxis.WheelJointRight.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.WheelJointRight.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.WheelJointRight.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.WheelJointRight.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.WheelJointRight.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.WheelJointRight.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.WheelJointRight.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.WheelJointRight.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.WheelJointRight.radius(quantity = \"Length\", unit = \"m\") = frontAxis.R \"radius of the wheel\";
//   parameter Real frontAxis.WheelJointRight.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointRight.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointRight.N(quantity = \"Force\", unit = \"N\") = frontAxis.N \"normal force\";
//   parameter Real frontAxis.WheelJointRight.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vAdhesion \"adhesion velocity\";
//   parameter Real frontAxis.WheelJointRight.vSlide(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vSlide \"sliding velocity\";
//   parameter Real frontAxis.WheelJointRight.mu_A = frontAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real frontAxis.WheelJointRight.mu_S = frontAxis.mu_S \"friction coefficient at sliding\";
//   Real frontAxis.WheelJointRight.e0[1] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointRight.e0[2] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointRight.R[1,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.R[1,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.R[2,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.R[2,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real frontAxis.WheelJointRight.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointRight.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointRight.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real frontAxis.WheelJointRight.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real frontAxis.WheelJointRight.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real frontAxis.WheelJointRight.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real frontAxis.WheelJointRight.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real frontAxis.WheelJointRight.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointRight.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointRight.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean frontAxis.WheelJointRight.animate = true \"enable Animation\";
//   parameter Boolean frontAxis.WheelJointRight.SimVis = false \"perform animation with SimVis\";
//   final parameter Real frontAxis.WheelJointRight.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.WheelJointRight.r[1] ^ 2.0 + frontAxis.WheelJointRight.r[2] ^ 2.0);
//   final parameter Real frontAxis.WheelJointRight.e[1] = frontAxis.WheelJointRight.r[1] / frontAxis.WheelJointRight.l \"normalized direction\";
//   final parameter Real frontAxis.WheelJointRight.e[2] = frontAxis.WheelJointRight.r[2] / frontAxis.WheelJointRight.l \"normalized direction\";
//   parameter String frontAxis.WheelJointRight.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * frontAxis.WheelJointRight.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * frontAxis.WheelJointRight.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.lengthDirection[1](unit = \"1\") = -frontAxis.WheelJointRight.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.WheelJointRight.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real frontAxis.WheelJointRight.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Width of visual object\";
//   input Real frontAxis.WheelJointRight.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Height of visual object\";
//   input Real frontAxis.WheelJointRight.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointRight.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointRight.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointRight.cylinder.lengthDirection[1],frontAxis.WheelJointRight.cylinder.lengthDirection[2],frontAxis.WheelJointRight.cylinder.lengthDirection[3]});
//   protected Real frontAxis.WheelJointRight.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointRight.cylinder.lengthDirection[1] / frontAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointRight.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.cylinder.lengthDirection[2] / frontAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointRight.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.cylinder.lengthDirection[3] / frontAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointRight.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointRight.cylinder.e_x[2] * frontAxis.WheelJointRight.cylinder.widthDirection[3] - frontAxis.WheelJointRight.cylinder.e_x[3] * frontAxis.WheelJointRight.cylinder.widthDirection[2];
//   protected Real frontAxis.WheelJointRight.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointRight.cylinder.e_x[3] * frontAxis.WheelJointRight.cylinder.widthDirection[1] - frontAxis.WheelJointRight.cylinder.e_x[1] * frontAxis.WheelJointRight.cylinder.widthDirection[3];
//   protected Real frontAxis.WheelJointRight.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointRight.cylinder.e_x[1] * frontAxis.WheelJointRight.cylinder.widthDirection[2] - frontAxis.WheelJointRight.cylinder.e_x[2] * frontAxis.WheelJointRight.cylinder.widthDirection[1];
//   protected Real frontAxis.WheelJointRight.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.cylinder.widthDirection[1],frontAxis.WheelJointRight.cylinder.widthDirection[2],frontAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]})[1];
//   protected Real frontAxis.WheelJointRight.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.cylinder.widthDirection[1],frontAxis.WheelJointRight.cylinder.widthDirection[2],frontAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]})[2];
//   protected Real frontAxis.WheelJointRight.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.cylinder.widthDirection[1],frontAxis.WheelJointRight.cylinder.widthDirection[2],frontAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointRight.cylinder.Form;
//   output Real frontAxis.WheelJointRight.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointRight.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.cylinder.Material;
//   protected output Real frontAxis.WheelJointRight.cylinder.Extra;
//   parameter String frontAxis.WheelJointRight.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim1.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim1.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointRight.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointRight.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointRight.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointRight.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointRight.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointRight.rim1.lengthDirection[1],frontAxis.WheelJointRight.rim1.lengthDirection[2],frontAxis.WheelJointRight.rim1.lengthDirection[3]});
//   protected Real frontAxis.WheelJointRight.rim1.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointRight.rim1.lengthDirection[1] / frontAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim1.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim1.lengthDirection[2] / frontAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim1.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim1.lengthDirection[3] / frontAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim1.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointRight.rim1.e_x[2] * frontAxis.WheelJointRight.rim1.widthDirection[3] - frontAxis.WheelJointRight.rim1.e_x[3] * frontAxis.WheelJointRight.rim1.widthDirection[2];
//   protected Real frontAxis.WheelJointRight.rim1.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointRight.rim1.e_x[3] * frontAxis.WheelJointRight.rim1.widthDirection[1] - frontAxis.WheelJointRight.rim1.e_x[1] * frontAxis.WheelJointRight.rim1.widthDirection[3];
//   protected Real frontAxis.WheelJointRight.rim1.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointRight.rim1.e_x[1] * frontAxis.WheelJointRight.rim1.widthDirection[2] - frontAxis.WheelJointRight.rim1.e_x[2] * frontAxis.WheelJointRight.rim1.widthDirection[1];
//   protected Real frontAxis.WheelJointRight.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim1.widthDirection[1],frontAxis.WheelJointRight.rim1.widthDirection[2],frontAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]})[1];
//   protected Real frontAxis.WheelJointRight.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim1.widthDirection[1],frontAxis.WheelJointRight.rim1.widthDirection[2],frontAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]})[2];
//   protected Real frontAxis.WheelJointRight.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim1.widthDirection[1],frontAxis.WheelJointRight.rim1.widthDirection[2],frontAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointRight.rim1.Form;
//   output Real frontAxis.WheelJointRight.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointRight.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim1.Material;
//   protected output Real frontAxis.WheelJointRight.rim1.Extra;
//   parameter String frontAxis.WheelJointRight.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim2.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim2.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointRight.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointRight.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointRight.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointRight.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointRight.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointRight.rim2.lengthDirection[1],frontAxis.WheelJointRight.rim2.lengthDirection[2],frontAxis.WheelJointRight.rim2.lengthDirection[3]});
//   protected Real frontAxis.WheelJointRight.rim2.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointRight.rim2.lengthDirection[1] / frontAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim2.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim2.lengthDirection[2] / frontAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim2.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim2.lengthDirection[3] / frontAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim2.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointRight.rim2.e_x[2] * frontAxis.WheelJointRight.rim2.widthDirection[3] - frontAxis.WheelJointRight.rim2.e_x[3] * frontAxis.WheelJointRight.rim2.widthDirection[2];
//   protected Real frontAxis.WheelJointRight.rim2.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointRight.rim2.e_x[3] * frontAxis.WheelJointRight.rim2.widthDirection[1] - frontAxis.WheelJointRight.rim2.e_x[1] * frontAxis.WheelJointRight.rim2.widthDirection[3];
//   protected Real frontAxis.WheelJointRight.rim2.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointRight.rim2.e_x[1] * frontAxis.WheelJointRight.rim2.widthDirection[2] - frontAxis.WheelJointRight.rim2.e_x[2] * frontAxis.WheelJointRight.rim2.widthDirection[1];
//   protected Real frontAxis.WheelJointRight.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim2.widthDirection[1],frontAxis.WheelJointRight.rim2.widthDirection[2],frontAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]})[1];
//   protected Real frontAxis.WheelJointRight.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim2.widthDirection[1],frontAxis.WheelJointRight.rim2.widthDirection[2],frontAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]})[2];
//   protected Real frontAxis.WheelJointRight.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim2.widthDirection[1],frontAxis.WheelJointRight.rim2.widthDirection[2],frontAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointRight.rim2.Form;
//   output Real frontAxis.WheelJointRight.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointRight.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim2.Material;
//   protected output Real frontAxis.WheelJointRight.rim2.Extra;
//   output Real ramp.y \"Connector of Real output signal\";
//   parameter Real ramp.height = 100.0 \"Height of ramps\";
//   parameter Real ramp.duration(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 2.0) = 2.0 \"Durations of ramp\";
//   parameter Real ramp.offset = 0.0 \"Offset of output signal\";
//   parameter Real ramp.startTime(quantity = \"Time\", unit = \"s\") = 0.2 \"Output = offset for time < startTime\";
//   parameter Boolean torque1.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torque1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torque1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torque1.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   input Real torque1.tau \"Accelerating torque acting at flange (= -flange.tau)\";
//   parameter Real simpleChassis.wheelBase(quantity = \"Length\", unit = \"m\") = 2.6 \"Wheel Base of the Vehicle\";
//   parameter Real simpleChassis.l(quantity = \"Length\", unit = \"m\") = 3.5 \"Length of the Vehicle\";
//   parameter Real simpleChassis.w(quantity = \"Length\", unit = \"m\") = 1.6 \"width of the Vehicle\";
//   parameter Real simpleChassis.h(quantity = \"Length\", unit = \"m\") = 0.5 \"height of the dynamic load\";
//   parameter Real simpleChassis.m_static(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1500.0 \"Base load of the vehicle\";
//   parameter Real simpleChassis.m_dynamic(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 500.0 \"Dynamic load of the vehicle\";
//   parameter Real simpleChassis.c_roll(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\") = 10000.0 \"Roll spring constant\";
//   parameter Real simpleChassis.d_roll(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\") = 1000.0 \"Roll damping constant\";
//   parameter Real simpleChassis.c_pitch(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\") = 15000.0 \"Pitch spring constant\";
//   parameter Real simpleChassis.d_pitch(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\") = 1500.0 \"Pitch damping constant\";
//   Real simpleChassis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis.fixedTranslationFront.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.fixedTranslationFront.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.fixedTranslationFront.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.fixedTranslationFront.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.fixedTranslationFront.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.fixedTranslationFront.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis.fixedTranslationFront.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.fixedTranslationFront.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.fixedTranslationFront.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.fixedTranslationFront.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.fixedTranslationFront.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.fixedTranslationFront.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real simpleChassis.fixedTranslationFront.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real simpleChassis.fixedTranslationFront.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis.wheelBase / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real simpleChassis.fixedTranslationFront.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis.fixedTranslationFront.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis.fixedTranslationFront.R[1,1] \"Rotation matrix\";
//   Real simpleChassis.fixedTranslationFront.R[1,2] \"Rotation matrix\";
//   Real simpleChassis.fixedTranslationFront.R[2,1] \"Rotation matrix\";
//   Real simpleChassis.fixedTranslationFront.R[2,2] \"Rotation matrix\";
//   parameter Boolean simpleChassis.fixedTranslationFront.animate = true \"enable Animation\";
//   final parameter Real simpleChassis.fixedTranslationFront.l(quantity = \"Length\", unit = \"m\") = sqrt(simpleChassis.fixedTranslationFront.r[1] ^ 2.0 + simpleChassis.fixedTranslationFront.r[2] ^ 2.0);
//   parameter String simpleChassis.fixedTranslationFront.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis.fixedTranslationFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis.fixedTranslationFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis.fixedTranslationFront.r0[1] / simpleChassis.fixedTranslationFront.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis.fixedTranslationFront.r0[2] / simpleChassis.fixedTranslationFront.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.length(quantity = \"Length\", unit = \"m\") = simpleChassis.fixedTranslationFront.l \"Length of visual object\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real simpleChassis.fixedTranslationFront.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis.fixedTranslationFront.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis.fixedTranslationFront.cylinder.lengthDirection[1],simpleChassis.fixedTranslationFront.cylinder.lengthDirection[2],simpleChassis.fixedTranslationFront.cylinder.lengthDirection[3]});
//   protected Real simpleChassis.fixedTranslationFront.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis.fixedTranslationFront.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis.fixedTranslationFront.cylinder.lengthDirection[1] / simpleChassis.fixedTranslationFront.cylinder.abs_n_x;
//   protected Real simpleChassis.fixedTranslationFront.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis.fixedTranslationFront.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis.fixedTranslationFront.cylinder.lengthDirection[2] / simpleChassis.fixedTranslationFront.cylinder.abs_n_x;
//   protected Real simpleChassis.fixedTranslationFront.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis.fixedTranslationFront.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis.fixedTranslationFront.cylinder.lengthDirection[3] / simpleChassis.fixedTranslationFront.cylinder.abs_n_x;
//   protected Real simpleChassis.fixedTranslationFront.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis.fixedTranslationFront.cylinder.e_x[2] * simpleChassis.fixedTranslationFront.cylinder.widthDirection[3] - simpleChassis.fixedTranslationFront.cylinder.e_x[3] * simpleChassis.fixedTranslationFront.cylinder.widthDirection[2];
//   protected Real simpleChassis.fixedTranslationFront.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis.fixedTranslationFront.cylinder.e_x[3] * simpleChassis.fixedTranslationFront.cylinder.widthDirection[1] - simpleChassis.fixedTranslationFront.cylinder.e_x[1] * simpleChassis.fixedTranslationFront.cylinder.widthDirection[3];
//   protected Real simpleChassis.fixedTranslationFront.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis.fixedTranslationFront.cylinder.e_x[1] * simpleChassis.fixedTranslationFront.cylinder.widthDirection[2] - simpleChassis.fixedTranslationFront.cylinder.e_x[2] * simpleChassis.fixedTranslationFront.cylinder.widthDirection[1];
//   protected Real simpleChassis.fixedTranslationFront.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.fixedTranslationFront.cylinder.e_x[1],simpleChassis.fixedTranslationFront.cylinder.e_x[2],simpleChassis.fixedTranslationFront.cylinder.e_x[3]},if noEvent(simpleChassis.fixedTranslationFront.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis.fixedTranslationFront.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis.fixedTranslationFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.fixedTranslationFront.cylinder.widthDirection[1],simpleChassis.fixedTranslationFront.cylinder.widthDirection[2],simpleChassis.fixedTranslationFront.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis.fixedTranslationFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.fixedTranslationFront.cylinder.e_x[1],simpleChassis.fixedTranslationFront.cylinder.e_x[2],simpleChassis.fixedTranslationFront.cylinder.e_x[3]})[1];
//   protected Real simpleChassis.fixedTranslationFront.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.fixedTranslationFront.cylinder.e_x[1],simpleChassis.fixedTranslationFront.cylinder.e_x[2],simpleChassis.fixedTranslationFront.cylinder.e_x[3]},if noEvent(simpleChassis.fixedTranslationFront.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis.fixedTranslationFront.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis.fixedTranslationFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.fixedTranslationFront.cylinder.widthDirection[1],simpleChassis.fixedTranslationFront.cylinder.widthDirection[2],simpleChassis.fixedTranslationFront.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis.fixedTranslationFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.fixedTranslationFront.cylinder.e_x[1],simpleChassis.fixedTranslationFront.cylinder.e_x[2],simpleChassis.fixedTranslationFront.cylinder.e_x[3]})[2];
//   protected Real simpleChassis.fixedTranslationFront.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.fixedTranslationFront.cylinder.e_x[1],simpleChassis.fixedTranslationFront.cylinder.e_x[2],simpleChassis.fixedTranslationFront.cylinder.e_x[3]},if noEvent(simpleChassis.fixedTranslationFront.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis.fixedTranslationFront.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis.fixedTranslationFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.fixedTranslationFront.cylinder.widthDirection[1],simpleChassis.fixedTranslationFront.cylinder.widthDirection[2],simpleChassis.fixedTranslationFront.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis.fixedTranslationFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.fixedTranslationFront.cylinder.e_x[1],simpleChassis.fixedTranslationFront.cylinder.e_x[2],simpleChassis.fixedTranslationFront.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis.fixedTranslationFront.cylinder.Form;
//   output Real simpleChassis.fixedTranslationFront.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationFront.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis.fixedTranslationFront.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.fixedTranslationFront.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.fixedTranslationFront.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.fixedTranslationFront.cylinder.Material;
//   protected output Real simpleChassis.fixedTranslationFront.cylinder.Extra;
//   Real simpleChassis.fixedTranslationRear.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.fixedTranslationRear.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.fixedTranslationRear.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.fixedTranslationRear.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.fixedTranslationRear.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.fixedTranslationRear.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis.fixedTranslationRear.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.fixedTranslationRear.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.fixedTranslationRear.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.fixedTranslationRear.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.fixedTranslationRear.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.fixedTranslationRear.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real simpleChassis.fixedTranslationRear.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real simpleChassis.fixedTranslationRear.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis.wheelBase / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real simpleChassis.fixedTranslationRear.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis.fixedTranslationRear.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis.fixedTranslationRear.R[1,1] \"Rotation matrix\";
//   Real simpleChassis.fixedTranslationRear.R[1,2] \"Rotation matrix\";
//   Real simpleChassis.fixedTranslationRear.R[2,1] \"Rotation matrix\";
//   Real simpleChassis.fixedTranslationRear.R[2,2] \"Rotation matrix\";
//   parameter Boolean simpleChassis.fixedTranslationRear.animate = true \"enable Animation\";
//   final parameter Real simpleChassis.fixedTranslationRear.l(quantity = \"Length\", unit = \"m\") = sqrt(simpleChassis.fixedTranslationRear.r[1] ^ 2.0 + simpleChassis.fixedTranslationRear.r[2] ^ 2.0);
//   parameter String simpleChassis.fixedTranslationRear.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis.fixedTranslationRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis.fixedTranslationRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis.fixedTranslationRear.r0[1] / simpleChassis.fixedTranslationRear.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis.fixedTranslationRear.r0[2] / simpleChassis.fixedTranslationRear.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.length(quantity = \"Length\", unit = \"m\") = simpleChassis.fixedTranslationRear.l \"Length of visual object\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real simpleChassis.fixedTranslationRear.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis.fixedTranslationRear.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis.fixedTranslationRear.cylinder.lengthDirection[1],simpleChassis.fixedTranslationRear.cylinder.lengthDirection[2],simpleChassis.fixedTranslationRear.cylinder.lengthDirection[3]});
//   protected Real simpleChassis.fixedTranslationRear.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis.fixedTranslationRear.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis.fixedTranslationRear.cylinder.lengthDirection[1] / simpleChassis.fixedTranslationRear.cylinder.abs_n_x;
//   protected Real simpleChassis.fixedTranslationRear.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis.fixedTranslationRear.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis.fixedTranslationRear.cylinder.lengthDirection[2] / simpleChassis.fixedTranslationRear.cylinder.abs_n_x;
//   protected Real simpleChassis.fixedTranslationRear.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis.fixedTranslationRear.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis.fixedTranslationRear.cylinder.lengthDirection[3] / simpleChassis.fixedTranslationRear.cylinder.abs_n_x;
//   protected Real simpleChassis.fixedTranslationRear.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis.fixedTranslationRear.cylinder.e_x[2] * simpleChassis.fixedTranslationRear.cylinder.widthDirection[3] - simpleChassis.fixedTranslationRear.cylinder.e_x[3] * simpleChassis.fixedTranslationRear.cylinder.widthDirection[2];
//   protected Real simpleChassis.fixedTranslationRear.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis.fixedTranslationRear.cylinder.e_x[3] * simpleChassis.fixedTranslationRear.cylinder.widthDirection[1] - simpleChassis.fixedTranslationRear.cylinder.e_x[1] * simpleChassis.fixedTranslationRear.cylinder.widthDirection[3];
//   protected Real simpleChassis.fixedTranslationRear.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis.fixedTranslationRear.cylinder.e_x[1] * simpleChassis.fixedTranslationRear.cylinder.widthDirection[2] - simpleChassis.fixedTranslationRear.cylinder.e_x[2] * simpleChassis.fixedTranslationRear.cylinder.widthDirection[1];
//   protected Real simpleChassis.fixedTranslationRear.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.fixedTranslationRear.cylinder.e_x[1],simpleChassis.fixedTranslationRear.cylinder.e_x[2],simpleChassis.fixedTranslationRear.cylinder.e_x[3]},if noEvent(simpleChassis.fixedTranslationRear.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis.fixedTranslationRear.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis.fixedTranslationRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.fixedTranslationRear.cylinder.widthDirection[1],simpleChassis.fixedTranslationRear.cylinder.widthDirection[2],simpleChassis.fixedTranslationRear.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis.fixedTranslationRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.fixedTranslationRear.cylinder.e_x[1],simpleChassis.fixedTranslationRear.cylinder.e_x[2],simpleChassis.fixedTranslationRear.cylinder.e_x[3]})[1];
//   protected Real simpleChassis.fixedTranslationRear.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.fixedTranslationRear.cylinder.e_x[1],simpleChassis.fixedTranslationRear.cylinder.e_x[2],simpleChassis.fixedTranslationRear.cylinder.e_x[3]},if noEvent(simpleChassis.fixedTranslationRear.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis.fixedTranslationRear.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis.fixedTranslationRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.fixedTranslationRear.cylinder.widthDirection[1],simpleChassis.fixedTranslationRear.cylinder.widthDirection[2],simpleChassis.fixedTranslationRear.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis.fixedTranslationRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.fixedTranslationRear.cylinder.e_x[1],simpleChassis.fixedTranslationRear.cylinder.e_x[2],simpleChassis.fixedTranslationRear.cylinder.e_x[3]})[2];
//   protected Real simpleChassis.fixedTranslationRear.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.fixedTranslationRear.cylinder.e_x[1],simpleChassis.fixedTranslationRear.cylinder.e_x[2],simpleChassis.fixedTranslationRear.cylinder.e_x[3]},if noEvent(simpleChassis.fixedTranslationRear.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis.fixedTranslationRear.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis.fixedTranslationRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.fixedTranslationRear.cylinder.widthDirection[1],simpleChassis.fixedTranslationRear.cylinder.widthDirection[2],simpleChassis.fixedTranslationRear.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis.fixedTranslationRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.fixedTranslationRear.cylinder.e_x[1],simpleChassis.fixedTranslationRear.cylinder.e_x[2],simpleChassis.fixedTranslationRear.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis.fixedTranslationRear.cylinder.Form;
//   output Real simpleChassis.fixedTranslationRear.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis.fixedTranslationRear.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis.fixedTranslationRear.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.fixedTranslationRear.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.fixedTranslationRear.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.fixedTranslationRear.cylinder.Material;
//   protected output Real simpleChassis.fixedTranslationRear.cylinder.Extra;
//   Real simpleChassis.baseLoad.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis.baseLoad.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis.baseLoad.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis.baseLoad.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis.baseLoad.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis.baseLoad.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real simpleChassis.baseLoad.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = simpleChassis.m_static \"mass of the body\";
//   parameter Real simpleChassis.baseLoad.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = (simpleChassis.m_static / 12.0 + simpleChassis.m_dynamic / 12.0) * (simpleChassis.w ^ 2.0 + simpleChassis.l ^ 2.0) \"Inertia of the Body\";
//   parameter Real simpleChassis.baseLoad.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real simpleChassis.baseLoad.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real simpleChassis.baseLoad.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real simpleChassis.baseLoad.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real simpleChassis.baseLoad.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real simpleChassis.baseLoad.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real simpleChassis.baseLoad.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real simpleChassis.baseLoad.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real simpleChassis.baseLoad.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real simpleChassis.baseLoad.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real simpleChassis.baseLoad.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real simpleChassis.baseLoad.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean simpleChassis.baseLoad.animate = true \"enable Animation\";
//   parameter String simpleChassis.baseLoad.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis.baseLoad.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.baseLoad.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis.baseLoad.sphere.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis.baseLoad.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.baseLoad.sphere.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis.baseLoad.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.baseLoad.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis.baseLoad.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis.baseLoad.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real simpleChassis.baseLoad.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real simpleChassis.baseLoad.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real simpleChassis.baseLoad.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis.baseLoad.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real simpleChassis.baseLoad.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real simpleChassis.baseLoad.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real simpleChassis.baseLoad.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis.baseLoad.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis.baseLoad.sphere.lengthDirection[1],simpleChassis.baseLoad.sphere.lengthDirection[2],simpleChassis.baseLoad.sphere.lengthDirection[3]});
//   protected Real simpleChassis.baseLoad.sphere.e_x[1](unit = \"1\") = if noEvent(simpleChassis.baseLoad.sphere.abs_n_x < 1e-10) then 1.0 else simpleChassis.baseLoad.sphere.lengthDirection[1] / simpleChassis.baseLoad.sphere.abs_n_x;
//   protected Real simpleChassis.baseLoad.sphere.e_x[2](unit = \"1\") = if noEvent(simpleChassis.baseLoad.sphere.abs_n_x < 1e-10) then 0.0 else simpleChassis.baseLoad.sphere.lengthDirection[2] / simpleChassis.baseLoad.sphere.abs_n_x;
//   protected Real simpleChassis.baseLoad.sphere.e_x[3](unit = \"1\") = if noEvent(simpleChassis.baseLoad.sphere.abs_n_x < 1e-10) then 0.0 else simpleChassis.baseLoad.sphere.lengthDirection[3] / simpleChassis.baseLoad.sphere.abs_n_x;
//   protected Real simpleChassis.baseLoad.sphere.n_z_aux[1](unit = \"1\") = simpleChassis.baseLoad.sphere.e_x[2] * simpleChassis.baseLoad.sphere.widthDirection[3] - simpleChassis.baseLoad.sphere.e_x[3] * simpleChassis.baseLoad.sphere.widthDirection[2];
//   protected Real simpleChassis.baseLoad.sphere.n_z_aux[2](unit = \"1\") = simpleChassis.baseLoad.sphere.e_x[3] * simpleChassis.baseLoad.sphere.widthDirection[1] - simpleChassis.baseLoad.sphere.e_x[1] * simpleChassis.baseLoad.sphere.widthDirection[3];
//   protected Real simpleChassis.baseLoad.sphere.n_z_aux[3](unit = \"1\") = simpleChassis.baseLoad.sphere.e_x[1] * simpleChassis.baseLoad.sphere.widthDirection[2] - simpleChassis.baseLoad.sphere.e_x[2] * simpleChassis.baseLoad.sphere.widthDirection[1];
//   protected Real simpleChassis.baseLoad.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.baseLoad.sphere.e_x[1],simpleChassis.baseLoad.sphere.e_x[2],simpleChassis.baseLoad.sphere.e_x[3]},if noEvent(simpleChassis.baseLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis.baseLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis.baseLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.baseLoad.sphere.widthDirection[1],simpleChassis.baseLoad.sphere.widthDirection[2],simpleChassis.baseLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis.baseLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.baseLoad.sphere.e_x[1],simpleChassis.baseLoad.sphere.e_x[2],simpleChassis.baseLoad.sphere.e_x[3]})[1];
//   protected Real simpleChassis.baseLoad.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.baseLoad.sphere.e_x[1],simpleChassis.baseLoad.sphere.e_x[2],simpleChassis.baseLoad.sphere.e_x[3]},if noEvent(simpleChassis.baseLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis.baseLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis.baseLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.baseLoad.sphere.widthDirection[1],simpleChassis.baseLoad.sphere.widthDirection[2],simpleChassis.baseLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis.baseLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.baseLoad.sphere.e_x[1],simpleChassis.baseLoad.sphere.e_x[2],simpleChassis.baseLoad.sphere.e_x[3]})[2];
//   protected Real simpleChassis.baseLoad.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis.baseLoad.sphere.e_x[1],simpleChassis.baseLoad.sphere.e_x[2],simpleChassis.baseLoad.sphere.e_x[3]},if noEvent(simpleChassis.baseLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis.baseLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis.baseLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis.baseLoad.sphere.widthDirection[1],simpleChassis.baseLoad.sphere.widthDirection[2],simpleChassis.baseLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis.baseLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis.baseLoad.sphere.e_x[1],simpleChassis.baseLoad.sphere.e_x[2],simpleChassis.baseLoad.sphere.e_x[3]})[3];
//   protected output Real simpleChassis.baseLoad.sphere.Form;
//   output Real simpleChassis.baseLoad.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis.baseLoad.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis.baseLoad.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.baseLoad.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.baseLoad.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis.baseLoad.sphere.Material;
//   protected output Real simpleChassis.baseLoad.sphere.Extra;
// equation
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1],world.x_label.cylinders[1].R.T[1,2],world.x_label.cylinders[1].R.T[1,3]},{world.x_label.cylinders[1].R.T[2,1],world.x_label.cylinders[1].R.T[2,2],world.x_label.cylinders[1].R.T[2,3]},{world.x_label.cylinders[1].R.T[3,1],world.x_label.cylinders[1].R.T[3,2],world.x_label.cylinders[1].R.T[3,3]}},{world.x_label.cylinders[1].r_shape[1],world.x_label.cylinders[1].r_shape[2],world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0,world.x_label.cylinders[1].color[2] / 255.0,world.x_label.cylinders[1].color[3] / 255.0,world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1],world.x_label.cylinders[2].R.T[1,2],world.x_label.cylinders[2].R.T[1,3]},{world.x_label.cylinders[2].R.T[2,1],world.x_label.cylinders[2].R.T[2,2],world.x_label.cylinders[2].R.T[2,3]},{world.x_label.cylinders[2].R.T[3,1],world.x_label.cylinders[2].R.T[3,2],world.x_label.cylinders[2].R.T[3,3]}},{world.x_label.cylinders[2].r_shape[1],world.x_label.cylinders[2].r_shape[2],world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0,world.x_label.cylinders[2].color[2] / 255.0,world.x_label.cylinders[2].color[3] / 255.0,world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1],world.y_label.cylinders[1].R.T[1,2],world.y_label.cylinders[1].R.T[1,3]},{world.y_label.cylinders[1].R.T[2,1],world.y_label.cylinders[1].R.T[2,2],world.y_label.cylinders[1].R.T[2,3]},{world.y_label.cylinders[1].R.T[3,1],world.y_label.cylinders[1].R.T[3,2],world.y_label.cylinders[1].R.T[3,3]}},{world.y_label.cylinders[1].r_shape[1],world.y_label.cylinders[1].r_shape[2],world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0,world.y_label.cylinders[1].color[2] / 255.0,world.y_label.cylinders[1].color[3] / 255.0,world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1],world.y_label.cylinders[2].R.T[1,2],world.y_label.cylinders[2].R.T[1,3]},{world.y_label.cylinders[2].R.T[2,1],world.y_label.cylinders[2].R.T[2,2],world.y_label.cylinders[2].R.T[2,3]},{world.y_label.cylinders[2].R.T[3,1],world.y_label.cylinders[2].R.T[3,2],world.y_label.cylinders[2].R.T[3,3]}},{world.y_label.cylinders[2].r_shape[1],world.y_label.cylinders[2].r_shape[2],world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0,world.y_label.cylinders[2].color[2] / 255.0,world.y_label.cylinders[2].color[3] / 255.0,world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1],world.z_label.cylinders[1].R.T[1,2],world.z_label.cylinders[1].R.T[1,3]},{world.z_label.cylinders[1].R.T[2,1],world.z_label.cylinders[1].R.T[2,2],world.z_label.cylinders[1].R.T[2,3]},{world.z_label.cylinders[1].R.T[3,1],world.z_label.cylinders[1].R.T[3,2],world.z_label.cylinders[1].R.T[3,3]}},{world.z_label.cylinders[1].r_shape[1],world.z_label.cylinders[1].r_shape[2],world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0,world.z_label.cylinders[1].color[2] / 255.0,world.z_label.cylinders[1].color[3] / 255.0,world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1],world.z_label.cylinders[2].R.T[1,2],world.z_label.cylinders[2].R.T[1,3]},{world.z_label.cylinders[2].R.T[2,1],world.z_label.cylinders[2].R.T[2,2],world.z_label.cylinders[2].R.T[2,3]},{world.z_label.cylinders[2].R.T[3,1],world.z_label.cylinders[2].R.T[3,2],world.z_label.cylinders[2].R.T[3,3]}},{world.z_label.cylinders[2].r_shape[1],world.z_label.cylinders[2].r_shape[2],world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0,world.z_label.cylinders[2].color[2] / 255.0,world.z_label.cylinders[2].color[3] / 255.0,world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1],world.z_label.cylinders[3].R.T[1,2],world.z_label.cylinders[3].R.T[1,3]},{world.z_label.cylinders[3].R.T[2,1],world.z_label.cylinders[3].R.T[2,2],world.z_label.cylinders[3].R.T[2,3]},{world.z_label.cylinders[3].R.T[3,1],world.z_label.cylinders[3].R.T[3,2],world.z_label.cylinders[3].R.T[3,3]}},{world.z_label.cylinders[3].r_shape[1],world.z_label.cylinders[3].r_shape[2],world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0,world.z_label.cylinders[3].color[2] / 255.0,world.z_label.cylinders[3].color[3] / 255.0,world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1],world.x_arrowLine.R.T[1,2],world.x_arrowLine.R.T[1,3]},{world.x_arrowLine.R.T[2,1],world.x_arrowLine.R.T[2,2],world.x_arrowLine.R.T[2,3]},{world.x_arrowLine.R.T[3,1],world.x_arrowLine.R.T[3,2],world.x_arrowLine.R.T[3,3]}},{world.x_arrowLine.r_shape[1],world.x_arrowLine.r_shape[2],world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0,world.x_arrowLine.color[2] / 255.0,world.x_arrowLine.color[3] / 255.0,world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1],world.x_arrowHead.R.T[1,2],world.x_arrowHead.R.T[1,3]},{world.x_arrowHead.R.T[2,1],world.x_arrowHead.R.T[2,2],world.x_arrowHead.R.T[2,3]},{world.x_arrowHead.R.T[3,1],world.x_arrowHead.R.T[3,2],world.x_arrowHead.R.T[3,3]}},{world.x_arrowHead.r_shape[1],world.x_arrowHead.r_shape[2],world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0,world.x_arrowHead.color[2] / 255.0,world.x_arrowHead.color[3] / 255.0,world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1],world.y_arrowLine.R.T[1,2],world.y_arrowLine.R.T[1,3]},{world.y_arrowLine.R.T[2,1],world.y_arrowLine.R.T[2,2],world.y_arrowLine.R.T[2,3]},{world.y_arrowLine.R.T[3,1],world.y_arrowLine.R.T[3,2],world.y_arrowLine.R.T[3,3]}},{world.y_arrowLine.r_shape[1],world.y_arrowLine.r_shape[2],world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0,world.y_arrowLine.color[2] / 255.0,world.y_arrowLine.color[3] / 255.0,world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1],world.y_arrowHead.R.T[1,2],world.y_arrowHead.R.T[1,3]},{world.y_arrowHead.R.T[2,1],world.y_arrowHead.R.T[2,2],world.y_arrowHead.R.T[2,3]},{world.y_arrowHead.R.T[3,1],world.y_arrowHead.R.T[3,2],world.y_arrowHead.R.T[3,3]}},{world.y_arrowHead.r_shape[1],world.y_arrowHead.r_shape[2],world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0,world.y_arrowHead.color[2] / 255.0,world.y_arrowHead.color[3] / 255.0,world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1],world.z_arrowLine.R.T[1,2],world.z_arrowLine.R.T[1,3]},{world.z_arrowLine.R.T[2,1],world.z_arrowLine.R.T[2,2],world.z_arrowLine.R.T[2,3]},{world.z_arrowLine.R.T[3,1],world.z_arrowLine.R.T[3,2],world.z_arrowLine.R.T[3,3]}},{world.z_arrowLine.r_shape[1],world.z_arrowLine.r_shape[2],world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0,world.z_arrowLine.color[2] / 255.0,world.z_arrowLine.color[3] / 255.0,world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1],world.z_arrowHead.R.T[1,2],world.z_arrowHead.R.T[1,3]},{world.z_arrowHead.R.T[2,1],world.z_arrowHead.R.T[2,2],world.z_arrowHead.R.T[2,3]},{world.z_arrowHead.R.T[3,1],world.z_arrowHead.R.T[3,2],world.z_arrowHead.R.T[3,3]}},{world.z_arrowHead.r_shape[1],world.z_arrowHead.r_shape[2],world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0,world.z_arrowHead.color[2] / 255.0,world.z_arrowHead.color[3] / 255.0,world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   world.gravityArrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowLine.shapeType);
//   world.gravityArrowLine.rxvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_x[1] + world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_x[3];
//   world.gravityArrowLine.rxvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_x[1] + world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_x[3];
//   world.gravityArrowLine.rxvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_x[1] + world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_x[3];
//   world.gravityArrowLine.ryvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_y[1] + world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_y[3];
//   world.gravityArrowLine.ryvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_y[1] + world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_y[3];
//   world.gravityArrowLine.ryvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_y[1] + world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_y[3];
//   world.gravityArrowLine.rvisobj = world.gravityArrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowLine.R.T[1,1],world.gravityArrowLine.R.T[1,2],world.gravityArrowLine.R.T[1,3]},{world.gravityArrowLine.R.T[2,1],world.gravityArrowLine.R.T[2,2],world.gravityArrowLine.R.T[2,3]},{world.gravityArrowLine.R.T[3,1],world.gravityArrowLine.R.T[3,2],world.gravityArrowLine.R.T[3,3]}},{world.gravityArrowLine.r_shape[1],world.gravityArrowLine.r_shape[2],world.gravityArrowLine.r_shape[3]});
//   world.gravityArrowLine.size[1] = world.gravityArrowLine.length;
//   world.gravityArrowLine.size[2] = world.gravityArrowLine.width;
//   world.gravityArrowLine.size[3] = world.gravityArrowLine.height;
//   world.gravityArrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowLine.color[1] / 255.0,world.gravityArrowLine.color[2] / 255.0,world.gravityArrowLine.color[3] / 255.0,world.gravityArrowLine.specularCoefficient);
//   world.gravityArrowLine.Extra = world.gravityArrowLine.extra;
//   world.gravityArrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowHead.shapeType);
//   world.gravityArrowHead.rxvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_x[1] + world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_x[3];
//   world.gravityArrowHead.rxvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_x[1] + world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_x[3];
//   world.gravityArrowHead.rxvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_x[1] + world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_x[3];
//   world.gravityArrowHead.ryvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_y[1] + world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_y[3];
//   world.gravityArrowHead.ryvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_y[1] + world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_y[3];
//   world.gravityArrowHead.ryvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_y[1] + world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_y[3];
//   world.gravityArrowHead.rvisobj = world.gravityArrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowHead.R.T[1,1],world.gravityArrowHead.R.T[1,2],world.gravityArrowHead.R.T[1,3]},{world.gravityArrowHead.R.T[2,1],world.gravityArrowHead.R.T[2,2],world.gravityArrowHead.R.T[2,3]},{world.gravityArrowHead.R.T[3,1],world.gravityArrowHead.R.T[3,2],world.gravityArrowHead.R.T[3,3]}},{world.gravityArrowHead.r_shape[1],world.gravityArrowHead.r_shape[2],world.gravityArrowHead.r_shape[3]});
//   world.gravityArrowHead.size[1] = world.gravityArrowHead.length;
//   world.gravityArrowHead.size[2] = world.gravityArrowHead.width;
//   world.gravityArrowHead.size[3] = world.gravityArrowHead.height;
//   world.gravityArrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowHead.color[1] / 255.0,world.gravityArrowHead.color[2] / 255.0,world.gravityArrowHead.color[3] / 255.0,world.gravityArrowHead.specularCoefficient);
//   world.gravityArrowHead.Extra = world.gravityArrowHead.extra;
//   assert(Modelica.Math.Vectors.length({world.n[1],world.n[2],world.n[3]}) > 1e-10,\"Parameter n of World object is wrong (lenght(n) > 0 required)\");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   torque.flange.tau = -torque.tau;
//   torque.phi_support = 0.0;
//   when sample(pulse.startTime,pulse.period) then
//   pulse.T0 = time;
//   end when;
//   pulse.y = pulse.offset + (if time < pulse.startTime or time >= pulse.T0 + pulse.T_width then 0.0 else pulse.amplitude);
//   (1.0 + rearAxis.differentialGear.idealPlanetary.ratio) * rearAxis.differentialGear.idealPlanetary.carrier.phi = rearAxis.differentialGear.idealPlanetary.sun.phi + rearAxis.differentialGear.idealPlanetary.ratio * rearAxis.differentialGear.idealPlanetary.ring.phi;
//   rearAxis.differentialGear.idealPlanetary.ring.tau = rearAxis.differentialGear.idealPlanetary.ratio * rearAxis.differentialGear.idealPlanetary.sun.tau;
//   rearAxis.differentialGear.idealPlanetary.carrier.tau = (-1.0 - rearAxis.differentialGear.idealPlanetary.ratio) * rearAxis.differentialGear.idealPlanetary.sun.tau;
//   rearAxis.fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.fixedTranslation2.cylinder.shapeType);
//   rearAxis.fixedTranslation2.cylinder.rxvisobj[1] = rearAxis.fixedTranslation2.cylinder.R.T[1,1] * rearAxis.fixedTranslation2.cylinder.e_x[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,1] * rearAxis.fixedTranslation2.cylinder.e_x[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,1] * rearAxis.fixedTranslation2.cylinder.e_x[3];
//   rearAxis.fixedTranslation2.cylinder.rxvisobj[2] = rearAxis.fixedTranslation2.cylinder.R.T[1,2] * rearAxis.fixedTranslation2.cylinder.e_x[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,2] * rearAxis.fixedTranslation2.cylinder.e_x[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,2] * rearAxis.fixedTranslation2.cylinder.e_x[3];
//   rearAxis.fixedTranslation2.cylinder.rxvisobj[3] = rearAxis.fixedTranslation2.cylinder.R.T[1,3] * rearAxis.fixedTranslation2.cylinder.e_x[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,3] * rearAxis.fixedTranslation2.cylinder.e_x[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,3] * rearAxis.fixedTranslation2.cylinder.e_x[3];
//   rearAxis.fixedTranslation2.cylinder.ryvisobj[1] = rearAxis.fixedTranslation2.cylinder.R.T[1,1] * rearAxis.fixedTranslation2.cylinder.e_y[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,1] * rearAxis.fixedTranslation2.cylinder.e_y[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,1] * rearAxis.fixedTranslation2.cylinder.e_y[3];
//   rearAxis.fixedTranslation2.cylinder.ryvisobj[2] = rearAxis.fixedTranslation2.cylinder.R.T[1,2] * rearAxis.fixedTranslation2.cylinder.e_y[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,2] * rearAxis.fixedTranslation2.cylinder.e_y[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,2] * rearAxis.fixedTranslation2.cylinder.e_y[3];
//   rearAxis.fixedTranslation2.cylinder.ryvisobj[3] = rearAxis.fixedTranslation2.cylinder.R.T[1,3] * rearAxis.fixedTranslation2.cylinder.e_y[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,3] * rearAxis.fixedTranslation2.cylinder.e_y[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,3] * rearAxis.fixedTranslation2.cylinder.e_y[3];
//   rearAxis.fixedTranslation2.cylinder.rvisobj = rearAxis.fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.fixedTranslation2.cylinder.R.T[1,1],rearAxis.fixedTranslation2.cylinder.R.T[1,2],rearAxis.fixedTranslation2.cylinder.R.T[1,3]},{rearAxis.fixedTranslation2.cylinder.R.T[2,1],rearAxis.fixedTranslation2.cylinder.R.T[2,2],rearAxis.fixedTranslation2.cylinder.R.T[2,3]},{rearAxis.fixedTranslation2.cylinder.R.T[3,1],rearAxis.fixedTranslation2.cylinder.R.T[3,2],rearAxis.fixedTranslation2.cylinder.R.T[3,3]}},{rearAxis.fixedTranslation2.cylinder.r_shape[1],rearAxis.fixedTranslation2.cylinder.r_shape[2],rearAxis.fixedTranslation2.cylinder.r_shape[3]});
//   rearAxis.fixedTranslation2.cylinder.size[1] = rearAxis.fixedTranslation2.cylinder.length;
//   rearAxis.fixedTranslation2.cylinder.size[2] = rearAxis.fixedTranslation2.cylinder.width;
//   rearAxis.fixedTranslation2.cylinder.size[3] = rearAxis.fixedTranslation2.cylinder.height;
//   rearAxis.fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.fixedTranslation2.cylinder.color[1] / 255.0,rearAxis.fixedTranslation2.cylinder.color[2] / 255.0,rearAxis.fixedTranslation2.cylinder.color[3] / 255.0,rearAxis.fixedTranslation2.cylinder.specularCoefficient);
//   rearAxis.fixedTranslation2.cylinder.Extra = rearAxis.fixedTranslation2.cylinder.extra;
//   rearAxis.fixedTranslation2.R[1,1] = cos(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.R[1,2] = sin(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.R[2,1] = -sin(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.R[2,2] = cos(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.r0[1] = rearAxis.fixedTranslation2.R[1,1] * rearAxis.fixedTranslation2.r[1] + rearAxis.fixedTranslation2.R[1,2] * rearAxis.fixedTranslation2.r[2];
//   rearAxis.fixedTranslation2.r0[2] = rearAxis.fixedTranslation2.R[2,1] * rearAxis.fixedTranslation2.r[1] + rearAxis.fixedTranslation2.R[2,2] * rearAxis.fixedTranslation2.r[2];
//   rearAxis.fixedTranslation2.frame_a.x + rearAxis.fixedTranslation2.r0[1] = rearAxis.fixedTranslation2.frame_b.x;
//   rearAxis.fixedTranslation2.frame_a.y + rearAxis.fixedTranslation2.r0[2] = rearAxis.fixedTranslation2.frame_b.y;
//   rearAxis.fixedTranslation2.frame_a.phi = rearAxis.fixedTranslation2.frame_b.phi;
//   rearAxis.fixedTranslation2.frame_a.fx + rearAxis.fixedTranslation2.frame_b.fx = 0.0;
//   rearAxis.fixedTranslation2.frame_a.fy + rearAxis.fixedTranslation2.frame_b.fy = 0.0;
//   rearAxis.fixedTranslation2.frame_a.t + (rearAxis.fixedTranslation2.frame_b.t + ((-rearAxis.fixedTranslation2.r0[1]) * rearAxis.fixedTranslation2.frame_b.fy + rearAxis.fixedTranslation2.r0[2] * rearAxis.fixedTranslation2.frame_b.fx)) = 0.0;
//   rearAxis.fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.fixedTranslation1.cylinder.shapeType);
//   rearAxis.fixedTranslation1.cylinder.rxvisobj[1] = rearAxis.fixedTranslation1.cylinder.R.T[1,1] * rearAxis.fixedTranslation1.cylinder.e_x[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,1] * rearAxis.fixedTranslation1.cylinder.e_x[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,1] * rearAxis.fixedTranslation1.cylinder.e_x[3];
//   rearAxis.fixedTranslation1.cylinder.rxvisobj[2] = rearAxis.fixedTranslation1.cylinder.R.T[1,2] * rearAxis.fixedTranslation1.cylinder.e_x[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,2] * rearAxis.fixedTranslation1.cylinder.e_x[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,2] * rearAxis.fixedTranslation1.cylinder.e_x[3];
//   rearAxis.fixedTranslation1.cylinder.rxvisobj[3] = rearAxis.fixedTranslation1.cylinder.R.T[1,3] * rearAxis.fixedTranslation1.cylinder.e_x[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,3] * rearAxis.fixedTranslation1.cylinder.e_x[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,3] * rearAxis.fixedTranslation1.cylinder.e_x[3];
//   rearAxis.fixedTranslation1.cylinder.ryvisobj[1] = rearAxis.fixedTranslation1.cylinder.R.T[1,1] * rearAxis.fixedTranslation1.cylinder.e_y[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,1] * rearAxis.fixedTranslation1.cylinder.e_y[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,1] * rearAxis.fixedTranslation1.cylinder.e_y[3];
//   rearAxis.fixedTranslation1.cylinder.ryvisobj[2] = rearAxis.fixedTranslation1.cylinder.R.T[1,2] * rearAxis.fixedTranslation1.cylinder.e_y[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,2] * rearAxis.fixedTranslation1.cylinder.e_y[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,2] * rearAxis.fixedTranslation1.cylinder.e_y[3];
//   rearAxis.fixedTranslation1.cylinder.ryvisobj[3] = rearAxis.fixedTranslation1.cylinder.R.T[1,3] * rearAxis.fixedTranslation1.cylinder.e_y[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,3] * rearAxis.fixedTranslation1.cylinder.e_y[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,3] * rearAxis.fixedTranslation1.cylinder.e_y[3];
//   rearAxis.fixedTranslation1.cylinder.rvisobj = rearAxis.fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.fixedTranslation1.cylinder.R.T[1,1],rearAxis.fixedTranslation1.cylinder.R.T[1,2],rearAxis.fixedTranslation1.cylinder.R.T[1,3]},{rearAxis.fixedTranslation1.cylinder.R.T[2,1],rearAxis.fixedTranslation1.cylinder.R.T[2,2],rearAxis.fixedTranslation1.cylinder.R.T[2,3]},{rearAxis.fixedTranslation1.cylinder.R.T[3,1],rearAxis.fixedTranslation1.cylinder.R.T[3,2],rearAxis.fixedTranslation1.cylinder.R.T[3,3]}},{rearAxis.fixedTranslation1.cylinder.r_shape[1],rearAxis.fixedTranslation1.cylinder.r_shape[2],rearAxis.fixedTranslation1.cylinder.r_shape[3]});
//   rearAxis.fixedTranslation1.cylinder.size[1] = rearAxis.fixedTranslation1.cylinder.length;
//   rearAxis.fixedTranslation1.cylinder.size[2] = rearAxis.fixedTranslation1.cylinder.width;
//   rearAxis.fixedTranslation1.cylinder.size[3] = rearAxis.fixedTranslation1.cylinder.height;
//   rearAxis.fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.fixedTranslation1.cylinder.color[1] / 255.0,rearAxis.fixedTranslation1.cylinder.color[2] / 255.0,rearAxis.fixedTranslation1.cylinder.color[3] / 255.0,rearAxis.fixedTranslation1.cylinder.specularCoefficient);
//   rearAxis.fixedTranslation1.cylinder.Extra = rearAxis.fixedTranslation1.cylinder.extra;
//   rearAxis.fixedTranslation1.R[1,1] = cos(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.R[1,2] = sin(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.R[2,1] = -sin(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.R[2,2] = cos(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.r0[1] = rearAxis.fixedTranslation1.R[1,1] * rearAxis.fixedTranslation1.r[1] + rearAxis.fixedTranslation1.R[1,2] * rearAxis.fixedTranslation1.r[2];
//   rearAxis.fixedTranslation1.r0[2] = rearAxis.fixedTranslation1.R[2,1] * rearAxis.fixedTranslation1.r[1] + rearAxis.fixedTranslation1.R[2,2] * rearAxis.fixedTranslation1.r[2];
//   rearAxis.fixedTranslation1.frame_a.x + rearAxis.fixedTranslation1.r0[1] = rearAxis.fixedTranslation1.frame_b.x;
//   rearAxis.fixedTranslation1.frame_a.y + rearAxis.fixedTranslation1.r0[2] = rearAxis.fixedTranslation1.frame_b.y;
//   rearAxis.fixedTranslation1.frame_a.phi = rearAxis.fixedTranslation1.frame_b.phi;
//   rearAxis.fixedTranslation1.frame_a.fx + rearAxis.fixedTranslation1.frame_b.fx = 0.0;
//   rearAxis.fixedTranslation1.frame_a.fy + rearAxis.fixedTranslation1.frame_b.fy = 0.0;
//   rearAxis.fixedTranslation1.frame_a.t + (rearAxis.fixedTranslation1.frame_b.t + ((-rearAxis.fixedTranslation1.r0[1]) * rearAxis.fixedTranslation1.frame_b.fy + rearAxis.fixedTranslation1.r0[2] * rearAxis.fixedTranslation1.frame_b.fx)) = 0.0;
//   rearAxis.inertia1.phi = rearAxis.inertia1.flange_a.phi;
//   rearAxis.inertia1.phi = rearAxis.inertia1.flange_b.phi;
//   rearAxis.inertia1.w = der(rearAxis.inertia1.phi);
//   rearAxis.inertia1.a = der(rearAxis.inertia1.w);
//   rearAxis.inertia1.J * rearAxis.inertia1.a = rearAxis.inertia1.flange_a.tau + rearAxis.inertia1.flange_b.tau;
//   rearAxis.inertia2.phi = rearAxis.inertia2.flange_a.phi;
//   rearAxis.inertia2.phi = rearAxis.inertia2.flange_b.phi;
//   rearAxis.inertia2.w = der(rearAxis.inertia2.phi);
//   rearAxis.inertia2.a = der(rearAxis.inertia2.w);
//   rearAxis.inertia2.J * rearAxis.inertia2.a = rearAxis.inertia2.flange_a.tau + rearAxis.inertia2.flange_b.tau;
//   rearAxis.WheelJointLeft.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointLeft.cylinder.shapeType);
//   rearAxis.WheelJointLeft.cylinder.rxvisobj[1] = rearAxis.WheelJointLeft.cylinder.R.T[1,1] * rearAxis.WheelJointLeft.cylinder.e_x[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,1] * rearAxis.WheelJointLeft.cylinder.e_x[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,1] * rearAxis.WheelJointLeft.cylinder.e_x[3];
//   rearAxis.WheelJointLeft.cylinder.rxvisobj[2] = rearAxis.WheelJointLeft.cylinder.R.T[1,2] * rearAxis.WheelJointLeft.cylinder.e_x[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,2] * rearAxis.WheelJointLeft.cylinder.e_x[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,2] * rearAxis.WheelJointLeft.cylinder.e_x[3];
//   rearAxis.WheelJointLeft.cylinder.rxvisobj[3] = rearAxis.WheelJointLeft.cylinder.R.T[1,3] * rearAxis.WheelJointLeft.cylinder.e_x[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,3] * rearAxis.WheelJointLeft.cylinder.e_x[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,3] * rearAxis.WheelJointLeft.cylinder.e_x[3];
//   rearAxis.WheelJointLeft.cylinder.ryvisobj[1] = rearAxis.WheelJointLeft.cylinder.R.T[1,1] * rearAxis.WheelJointLeft.cylinder.e_y[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,1] * rearAxis.WheelJointLeft.cylinder.e_y[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,1] * rearAxis.WheelJointLeft.cylinder.e_y[3];
//   rearAxis.WheelJointLeft.cylinder.ryvisobj[2] = rearAxis.WheelJointLeft.cylinder.R.T[1,2] * rearAxis.WheelJointLeft.cylinder.e_y[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,2] * rearAxis.WheelJointLeft.cylinder.e_y[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,2] * rearAxis.WheelJointLeft.cylinder.e_y[3];
//   rearAxis.WheelJointLeft.cylinder.ryvisobj[3] = rearAxis.WheelJointLeft.cylinder.R.T[1,3] * rearAxis.WheelJointLeft.cylinder.e_y[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,3] * rearAxis.WheelJointLeft.cylinder.e_y[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,3] * rearAxis.WheelJointLeft.cylinder.e_y[3];
//   rearAxis.WheelJointLeft.cylinder.rvisobj = rearAxis.WheelJointLeft.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointLeft.cylinder.R.T[1,1],rearAxis.WheelJointLeft.cylinder.R.T[1,2],rearAxis.WheelJointLeft.cylinder.R.T[1,3]},{rearAxis.WheelJointLeft.cylinder.R.T[2,1],rearAxis.WheelJointLeft.cylinder.R.T[2,2],rearAxis.WheelJointLeft.cylinder.R.T[2,3]},{rearAxis.WheelJointLeft.cylinder.R.T[3,1],rearAxis.WheelJointLeft.cylinder.R.T[3,2],rearAxis.WheelJointLeft.cylinder.R.T[3,3]}},{rearAxis.WheelJointLeft.cylinder.r_shape[1],rearAxis.WheelJointLeft.cylinder.r_shape[2],rearAxis.WheelJointLeft.cylinder.r_shape[3]});
//   rearAxis.WheelJointLeft.cylinder.size[1] = rearAxis.WheelJointLeft.cylinder.length;
//   rearAxis.WheelJointLeft.cylinder.size[2] = rearAxis.WheelJointLeft.cylinder.width;
//   rearAxis.WheelJointLeft.cylinder.size[3] = rearAxis.WheelJointLeft.cylinder.height;
//   rearAxis.WheelJointLeft.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointLeft.cylinder.color[1] / 255.0,rearAxis.WheelJointLeft.cylinder.color[2] / 255.0,rearAxis.WheelJointLeft.cylinder.color[3] / 255.0,rearAxis.WheelJointLeft.cylinder.specularCoefficient);
//   rearAxis.WheelJointLeft.cylinder.Extra = rearAxis.WheelJointLeft.cylinder.extra;
//   rearAxis.WheelJointLeft.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointLeft.e0[2],rearAxis.WheelJointLeft.e0[1],0.0},rearAxis.WheelJointLeft.flange_a.phi,0.0);
//   rearAxis.WheelJointLeft.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointLeft.rim1.shapeType);
//   rearAxis.WheelJointLeft.rim1.rxvisobj[1] = rearAxis.WheelJointLeft.rim1.R.T[1,1] * rearAxis.WheelJointLeft.rim1.e_x[1] + rearAxis.WheelJointLeft.rim1.R.T[2,1] * rearAxis.WheelJointLeft.rim1.e_x[2] + rearAxis.WheelJointLeft.rim1.R.T[3,1] * rearAxis.WheelJointLeft.rim1.e_x[3];
//   rearAxis.WheelJointLeft.rim1.rxvisobj[2] = rearAxis.WheelJointLeft.rim1.R.T[1,2] * rearAxis.WheelJointLeft.rim1.e_x[1] + rearAxis.WheelJointLeft.rim1.R.T[2,2] * rearAxis.WheelJointLeft.rim1.e_x[2] + rearAxis.WheelJointLeft.rim1.R.T[3,2] * rearAxis.WheelJointLeft.rim1.e_x[3];
//   rearAxis.WheelJointLeft.rim1.rxvisobj[3] = rearAxis.WheelJointLeft.rim1.R.T[1,3] * rearAxis.WheelJointLeft.rim1.e_x[1] + rearAxis.WheelJointLeft.rim1.R.T[2,3] * rearAxis.WheelJointLeft.rim1.e_x[2] + rearAxis.WheelJointLeft.rim1.R.T[3,3] * rearAxis.WheelJointLeft.rim1.e_x[3];
//   rearAxis.WheelJointLeft.rim1.ryvisobj[1] = rearAxis.WheelJointLeft.rim1.R.T[1,1] * rearAxis.WheelJointLeft.rim1.e_y[1] + rearAxis.WheelJointLeft.rim1.R.T[2,1] * rearAxis.WheelJointLeft.rim1.e_y[2] + rearAxis.WheelJointLeft.rim1.R.T[3,1] * rearAxis.WheelJointLeft.rim1.e_y[3];
//   rearAxis.WheelJointLeft.rim1.ryvisobj[2] = rearAxis.WheelJointLeft.rim1.R.T[1,2] * rearAxis.WheelJointLeft.rim1.e_y[1] + rearAxis.WheelJointLeft.rim1.R.T[2,2] * rearAxis.WheelJointLeft.rim1.e_y[2] + rearAxis.WheelJointLeft.rim1.R.T[3,2] * rearAxis.WheelJointLeft.rim1.e_y[3];
//   rearAxis.WheelJointLeft.rim1.ryvisobj[3] = rearAxis.WheelJointLeft.rim1.R.T[1,3] * rearAxis.WheelJointLeft.rim1.e_y[1] + rearAxis.WheelJointLeft.rim1.R.T[2,3] * rearAxis.WheelJointLeft.rim1.e_y[2] + rearAxis.WheelJointLeft.rim1.R.T[3,3] * rearAxis.WheelJointLeft.rim1.e_y[3];
//   rearAxis.WheelJointLeft.rim1.rvisobj = rearAxis.WheelJointLeft.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointLeft.rim1.R.T[1,1],rearAxis.WheelJointLeft.rim1.R.T[1,2],rearAxis.WheelJointLeft.rim1.R.T[1,3]},{rearAxis.WheelJointLeft.rim1.R.T[2,1],rearAxis.WheelJointLeft.rim1.R.T[2,2],rearAxis.WheelJointLeft.rim1.R.T[2,3]},{rearAxis.WheelJointLeft.rim1.R.T[3,1],rearAxis.WheelJointLeft.rim1.R.T[3,2],rearAxis.WheelJointLeft.rim1.R.T[3,3]}},{rearAxis.WheelJointLeft.rim1.r_shape[1],rearAxis.WheelJointLeft.rim1.r_shape[2],rearAxis.WheelJointLeft.rim1.r_shape[3]});
//   rearAxis.WheelJointLeft.rim1.size[1] = rearAxis.WheelJointLeft.rim1.length;
//   rearAxis.WheelJointLeft.rim1.size[2] = rearAxis.WheelJointLeft.rim1.width;
//   rearAxis.WheelJointLeft.rim1.size[3] = rearAxis.WheelJointLeft.rim1.height;
//   rearAxis.WheelJointLeft.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointLeft.rim1.color[1] / 255.0,rearAxis.WheelJointLeft.rim1.color[2] / 255.0,rearAxis.WheelJointLeft.rim1.color[3] / 255.0,rearAxis.WheelJointLeft.rim1.specularCoefficient);
//   rearAxis.WheelJointLeft.rim1.Extra = rearAxis.WheelJointLeft.rim1.extra;
//   rearAxis.WheelJointLeft.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointLeft.e0[2],rearAxis.WheelJointLeft.e0[1],0.0},1.5707963267949 + rearAxis.WheelJointLeft.flange_a.phi,0.0);
//   rearAxis.WheelJointLeft.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointLeft.rim2.shapeType);
//   rearAxis.WheelJointLeft.rim2.rxvisobj[1] = rearAxis.WheelJointLeft.rim2.R.T[1,1] * rearAxis.WheelJointLeft.rim2.e_x[1] + rearAxis.WheelJointLeft.rim2.R.T[2,1] * rearAxis.WheelJointLeft.rim2.e_x[2] + rearAxis.WheelJointLeft.rim2.R.T[3,1] * rearAxis.WheelJointLeft.rim2.e_x[3];
//   rearAxis.WheelJointLeft.rim2.rxvisobj[2] = rearAxis.WheelJointLeft.rim2.R.T[1,2] * rearAxis.WheelJointLeft.rim2.e_x[1] + rearAxis.WheelJointLeft.rim2.R.T[2,2] * rearAxis.WheelJointLeft.rim2.e_x[2] + rearAxis.WheelJointLeft.rim2.R.T[3,2] * rearAxis.WheelJointLeft.rim2.e_x[3];
//   rearAxis.WheelJointLeft.rim2.rxvisobj[3] = rearAxis.WheelJointLeft.rim2.R.T[1,3] * rearAxis.WheelJointLeft.rim2.e_x[1] + rearAxis.WheelJointLeft.rim2.R.T[2,3] * rearAxis.WheelJointLeft.rim2.e_x[2] + rearAxis.WheelJointLeft.rim2.R.T[3,3] * rearAxis.WheelJointLeft.rim2.e_x[3];
//   rearAxis.WheelJointLeft.rim2.ryvisobj[1] = rearAxis.WheelJointLeft.rim2.R.T[1,1] * rearAxis.WheelJointLeft.rim2.e_y[1] + rearAxis.WheelJointLeft.rim2.R.T[2,1] * rearAxis.WheelJointLeft.rim2.e_y[2] + rearAxis.WheelJointLeft.rim2.R.T[3,1] * rearAxis.WheelJointLeft.rim2.e_y[3];
//   rearAxis.WheelJointLeft.rim2.ryvisobj[2] = rearAxis.WheelJointLeft.rim2.R.T[1,2] * rearAxis.WheelJointLeft.rim2.e_y[1] + rearAxis.WheelJointLeft.rim2.R.T[2,2] * rearAxis.WheelJointLeft.rim2.e_y[2] + rearAxis.WheelJointLeft.rim2.R.T[3,2] * rearAxis.WheelJointLeft.rim2.e_y[3];
//   rearAxis.WheelJointLeft.rim2.ryvisobj[3] = rearAxis.WheelJointLeft.rim2.R.T[1,3] * rearAxis.WheelJointLeft.rim2.e_y[1] + rearAxis.WheelJointLeft.rim2.R.T[2,3] * rearAxis.WheelJointLeft.rim2.e_y[2] + rearAxis.WheelJointLeft.rim2.R.T[3,3] * rearAxis.WheelJointLeft.rim2.e_y[3];
//   rearAxis.WheelJointLeft.rim2.rvisobj = rearAxis.WheelJointLeft.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointLeft.rim2.R.T[1,1],rearAxis.WheelJointLeft.rim2.R.T[1,2],rearAxis.WheelJointLeft.rim2.R.T[1,3]},{rearAxis.WheelJointLeft.rim2.R.T[2,1],rearAxis.WheelJointLeft.rim2.R.T[2,2],rearAxis.WheelJointLeft.rim2.R.T[2,3]},{rearAxis.WheelJointLeft.rim2.R.T[3,1],rearAxis.WheelJointLeft.rim2.R.T[3,2],rearAxis.WheelJointLeft.rim2.R.T[3,3]}},{rearAxis.WheelJointLeft.rim2.r_shape[1],rearAxis.WheelJointLeft.rim2.r_shape[2],rearAxis.WheelJointLeft.rim2.r_shape[3]});
//   rearAxis.WheelJointLeft.rim2.size[1] = rearAxis.WheelJointLeft.rim2.length;
//   rearAxis.WheelJointLeft.rim2.size[2] = rearAxis.WheelJointLeft.rim2.width;
//   rearAxis.WheelJointLeft.rim2.size[3] = rearAxis.WheelJointLeft.rim2.height;
//   rearAxis.WheelJointLeft.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointLeft.rim2.color[1] / 255.0,rearAxis.WheelJointLeft.rim2.color[2] / 255.0,rearAxis.WheelJointLeft.rim2.color[3] / 255.0,rearAxis.WheelJointLeft.rim2.specularCoefficient);
//   rearAxis.WheelJointLeft.rim2.Extra = rearAxis.WheelJointLeft.rim2.extra;
//   rearAxis.WheelJointLeft.R[1,1] = cos(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.R[1,2] = sin(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.R[2,1] = -sin(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.R[2,2] = cos(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.e0[1] = rearAxis.WheelJointLeft.R[1,1] * rearAxis.WheelJointLeft.e[1] + rearAxis.WheelJointLeft.R[1,2] * rearAxis.WheelJointLeft.e[2];
//   rearAxis.WheelJointLeft.e0[2] = rearAxis.WheelJointLeft.R[2,1] * rearAxis.WheelJointLeft.e[1] + rearAxis.WheelJointLeft.R[2,2] * rearAxis.WheelJointLeft.e[2];
//   rearAxis.WheelJointLeft.v[1] = der(rearAxis.WheelJointLeft.frame_a.x);
//   rearAxis.WheelJointLeft.v[2] = der(rearAxis.WheelJointLeft.frame_a.y);
//   rearAxis.WheelJointLeft.w_roll = der(rearAxis.WheelJointLeft.flange_a.phi);
//   rearAxis.WheelJointLeft.v_long = rearAxis.WheelJointLeft.v[1] * rearAxis.WheelJointLeft.e0[1] + rearAxis.WheelJointLeft.v[2] * rearAxis.WheelJointLeft.e0[2];
//   rearAxis.WheelJointLeft.v_lat = (-rearAxis.WheelJointLeft.v[1]) * rearAxis.WheelJointLeft.e0[2] + rearAxis.WheelJointLeft.v[2] * rearAxis.WheelJointLeft.e0[1];
//   rearAxis.WheelJointLeft.v_slip_lat = rearAxis.WheelJointLeft.v_lat;
//   rearAxis.WheelJointLeft.v_slip_long = rearAxis.WheelJointLeft.v_long - rearAxis.WheelJointLeft.radius * rearAxis.WheelJointLeft.w_roll;
//   rearAxis.WheelJointLeft.v_slip = 0.0001 + sqrt(rearAxis.WheelJointLeft.v_slip_long ^ 2.0 + rearAxis.WheelJointLeft.v_slip_lat ^ 2.0);
//   (-rearAxis.WheelJointLeft.f_long) * rearAxis.WheelJointLeft.radius = rearAxis.WheelJointLeft.flange_a.tau;
//   rearAxis.WheelJointLeft.frame_a.t = 0.0;
//   rearAxis.WheelJointLeft.f = rearAxis.WheelJointLeft.N * PlanarMechanicsV4.Utilities.TripleS_Func(rearAxis.WheelJointLeft.vAdhesion,rearAxis.WheelJointLeft.vSlide,rearAxis.WheelJointLeft.mu_A,rearAxis.WheelJointLeft.mu_S,rearAxis.WheelJointLeft.v_slip);
//   rearAxis.WheelJointLeft.f_long = (rearAxis.WheelJointLeft.f * rearAxis.WheelJointLeft.v_slip_long) / rearAxis.WheelJointLeft.v_slip;
//   rearAxis.WheelJointLeft.f_lat = (rearAxis.WheelJointLeft.f * rearAxis.WheelJointLeft.v_slip_lat) / rearAxis.WheelJointLeft.v_slip;
//   rearAxis.WheelJointLeft.f_long = rearAxis.WheelJointLeft.frame_a.fx * rearAxis.WheelJointLeft.e0[1] + rearAxis.WheelJointLeft.frame_a.fy * rearAxis.WheelJointLeft.e0[2];
//   rearAxis.WheelJointLeft.f_lat = rearAxis.WheelJointLeft.frame_a.fy * rearAxis.WheelJointLeft.e0[1] + (-rearAxis.WheelJointLeft.frame_a.fx) * rearAxis.WheelJointLeft.e0[2];
//   rearAxis.WheelJointRight.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointRight.cylinder.shapeType);
//   rearAxis.WheelJointRight.cylinder.rxvisobj[1] = rearAxis.WheelJointRight.cylinder.R.T[1,1] * rearAxis.WheelJointRight.cylinder.e_x[1] + rearAxis.WheelJointRight.cylinder.R.T[2,1] * rearAxis.WheelJointRight.cylinder.e_x[2] + rearAxis.WheelJointRight.cylinder.R.T[3,1] * rearAxis.WheelJointRight.cylinder.e_x[3];
//   rearAxis.WheelJointRight.cylinder.rxvisobj[2] = rearAxis.WheelJointRight.cylinder.R.T[1,2] * rearAxis.WheelJointRight.cylinder.e_x[1] + rearAxis.WheelJointRight.cylinder.R.T[2,2] * rearAxis.WheelJointRight.cylinder.e_x[2] + rearAxis.WheelJointRight.cylinder.R.T[3,2] * rearAxis.WheelJointRight.cylinder.e_x[3];
//   rearAxis.WheelJointRight.cylinder.rxvisobj[3] = rearAxis.WheelJointRight.cylinder.R.T[1,3] * rearAxis.WheelJointRight.cylinder.e_x[1] + rearAxis.WheelJointRight.cylinder.R.T[2,3] * rearAxis.WheelJointRight.cylinder.e_x[2] + rearAxis.WheelJointRight.cylinder.R.T[3,3] * rearAxis.WheelJointRight.cylinder.e_x[3];
//   rearAxis.WheelJointRight.cylinder.ryvisobj[1] = rearAxis.WheelJointRight.cylinder.R.T[1,1] * rearAxis.WheelJointRight.cylinder.e_y[1] + rearAxis.WheelJointRight.cylinder.R.T[2,1] * rearAxis.WheelJointRight.cylinder.e_y[2] + rearAxis.WheelJointRight.cylinder.R.T[3,1] * rearAxis.WheelJointRight.cylinder.e_y[3];
//   rearAxis.WheelJointRight.cylinder.ryvisobj[2] = rearAxis.WheelJointRight.cylinder.R.T[1,2] * rearAxis.WheelJointRight.cylinder.e_y[1] + rearAxis.WheelJointRight.cylinder.R.T[2,2] * rearAxis.WheelJointRight.cylinder.e_y[2] + rearAxis.WheelJointRight.cylinder.R.T[3,2] * rearAxis.WheelJointRight.cylinder.e_y[3];
//   rearAxis.WheelJointRight.cylinder.ryvisobj[3] = rearAxis.WheelJointRight.cylinder.R.T[1,3] * rearAxis.WheelJointRight.cylinder.e_y[1] + rearAxis.WheelJointRight.cylinder.R.T[2,3] * rearAxis.WheelJointRight.cylinder.e_y[2] + rearAxis.WheelJointRight.cylinder.R.T[3,3] * rearAxis.WheelJointRight.cylinder.e_y[3];
//   rearAxis.WheelJointRight.cylinder.rvisobj = rearAxis.WheelJointRight.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointRight.cylinder.R.T[1,1],rearAxis.WheelJointRight.cylinder.R.T[1,2],rearAxis.WheelJointRight.cylinder.R.T[1,3]},{rearAxis.WheelJointRight.cylinder.R.T[2,1],rearAxis.WheelJointRight.cylinder.R.T[2,2],rearAxis.WheelJointRight.cylinder.R.T[2,3]},{rearAxis.WheelJointRight.cylinder.R.T[3,1],rearAxis.WheelJointRight.cylinder.R.T[3,2],rearAxis.WheelJointRight.cylinder.R.T[3,3]}},{rearAxis.WheelJointRight.cylinder.r_shape[1],rearAxis.WheelJointRight.cylinder.r_shape[2],rearAxis.WheelJointRight.cylinder.r_shape[3]});
//   rearAxis.WheelJointRight.cylinder.size[1] = rearAxis.WheelJointRight.cylinder.length;
//   rearAxis.WheelJointRight.cylinder.size[2] = rearAxis.WheelJointRight.cylinder.width;
//   rearAxis.WheelJointRight.cylinder.size[3] = rearAxis.WheelJointRight.cylinder.height;
//   rearAxis.WheelJointRight.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointRight.cylinder.color[1] / 255.0,rearAxis.WheelJointRight.cylinder.color[2] / 255.0,rearAxis.WheelJointRight.cylinder.color[3] / 255.0,rearAxis.WheelJointRight.cylinder.specularCoefficient);
//   rearAxis.WheelJointRight.cylinder.Extra = rearAxis.WheelJointRight.cylinder.extra;
//   rearAxis.WheelJointRight.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointRight.e0[2],rearAxis.WheelJointRight.e0[1],0.0},rearAxis.WheelJointRight.flange_a.phi,0.0);
//   rearAxis.WheelJointRight.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointRight.rim1.shapeType);
//   rearAxis.WheelJointRight.rim1.rxvisobj[1] = rearAxis.WheelJointRight.rim1.R.T[1,1] * rearAxis.WheelJointRight.rim1.e_x[1] + rearAxis.WheelJointRight.rim1.R.T[2,1] * rearAxis.WheelJointRight.rim1.e_x[2] + rearAxis.WheelJointRight.rim1.R.T[3,1] * rearAxis.WheelJointRight.rim1.e_x[3];
//   rearAxis.WheelJointRight.rim1.rxvisobj[2] = rearAxis.WheelJointRight.rim1.R.T[1,2] * rearAxis.WheelJointRight.rim1.e_x[1] + rearAxis.WheelJointRight.rim1.R.T[2,2] * rearAxis.WheelJointRight.rim1.e_x[2] + rearAxis.WheelJointRight.rim1.R.T[3,2] * rearAxis.WheelJointRight.rim1.e_x[3];
//   rearAxis.WheelJointRight.rim1.rxvisobj[3] = rearAxis.WheelJointRight.rim1.R.T[1,3] * rearAxis.WheelJointRight.rim1.e_x[1] + rearAxis.WheelJointRight.rim1.R.T[2,3] * rearAxis.WheelJointRight.rim1.e_x[2] + rearAxis.WheelJointRight.rim1.R.T[3,3] * rearAxis.WheelJointRight.rim1.e_x[3];
//   rearAxis.WheelJointRight.rim1.ryvisobj[1] = rearAxis.WheelJointRight.rim1.R.T[1,1] * rearAxis.WheelJointRight.rim1.e_y[1] + rearAxis.WheelJointRight.rim1.R.T[2,1] * rearAxis.WheelJointRight.rim1.e_y[2] + rearAxis.WheelJointRight.rim1.R.T[3,1] * rearAxis.WheelJointRight.rim1.e_y[3];
//   rearAxis.WheelJointRight.rim1.ryvisobj[2] = rearAxis.WheelJointRight.rim1.R.T[1,2] * rearAxis.WheelJointRight.rim1.e_y[1] + rearAxis.WheelJointRight.rim1.R.T[2,2] * rearAxis.WheelJointRight.rim1.e_y[2] + rearAxis.WheelJointRight.rim1.R.T[3,2] * rearAxis.WheelJointRight.rim1.e_y[3];
//   rearAxis.WheelJointRight.rim1.ryvisobj[3] = rearAxis.WheelJointRight.rim1.R.T[1,3] * rearAxis.WheelJointRight.rim1.e_y[1] + rearAxis.WheelJointRight.rim1.R.T[2,3] * rearAxis.WheelJointRight.rim1.e_y[2] + rearAxis.WheelJointRight.rim1.R.T[3,3] * rearAxis.WheelJointRight.rim1.e_y[3];
//   rearAxis.WheelJointRight.rim1.rvisobj = rearAxis.WheelJointRight.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointRight.rim1.R.T[1,1],rearAxis.WheelJointRight.rim1.R.T[1,2],rearAxis.WheelJointRight.rim1.R.T[1,3]},{rearAxis.WheelJointRight.rim1.R.T[2,1],rearAxis.WheelJointRight.rim1.R.T[2,2],rearAxis.WheelJointRight.rim1.R.T[2,3]},{rearAxis.WheelJointRight.rim1.R.T[3,1],rearAxis.WheelJointRight.rim1.R.T[3,2],rearAxis.WheelJointRight.rim1.R.T[3,3]}},{rearAxis.WheelJointRight.rim1.r_shape[1],rearAxis.WheelJointRight.rim1.r_shape[2],rearAxis.WheelJointRight.rim1.r_shape[3]});
//   rearAxis.WheelJointRight.rim1.size[1] = rearAxis.WheelJointRight.rim1.length;
//   rearAxis.WheelJointRight.rim1.size[2] = rearAxis.WheelJointRight.rim1.width;
//   rearAxis.WheelJointRight.rim1.size[3] = rearAxis.WheelJointRight.rim1.height;
//   rearAxis.WheelJointRight.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointRight.rim1.color[1] / 255.0,rearAxis.WheelJointRight.rim1.color[2] / 255.0,rearAxis.WheelJointRight.rim1.color[3] / 255.0,rearAxis.WheelJointRight.rim1.specularCoefficient);
//   rearAxis.WheelJointRight.rim1.Extra = rearAxis.WheelJointRight.rim1.extra;
//   rearAxis.WheelJointRight.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointRight.e0[2],rearAxis.WheelJointRight.e0[1],0.0},1.5707963267949 + rearAxis.WheelJointRight.flange_a.phi,0.0);
//   rearAxis.WheelJointRight.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointRight.rim2.shapeType);
//   rearAxis.WheelJointRight.rim2.rxvisobj[1] = rearAxis.WheelJointRight.rim2.R.T[1,1] * rearAxis.WheelJointRight.rim2.e_x[1] + rearAxis.WheelJointRight.rim2.R.T[2,1] * rearAxis.WheelJointRight.rim2.e_x[2] + rearAxis.WheelJointRight.rim2.R.T[3,1] * rearAxis.WheelJointRight.rim2.e_x[3];
//   rearAxis.WheelJointRight.rim2.rxvisobj[2] = rearAxis.WheelJointRight.rim2.R.T[1,2] * rearAxis.WheelJointRight.rim2.e_x[1] + rearAxis.WheelJointRight.rim2.R.T[2,2] * rearAxis.WheelJointRight.rim2.e_x[2] + rearAxis.WheelJointRight.rim2.R.T[3,2] * rearAxis.WheelJointRight.rim2.e_x[3];
//   rearAxis.WheelJointRight.rim2.rxvisobj[3] = rearAxis.WheelJointRight.rim2.R.T[1,3] * rearAxis.WheelJointRight.rim2.e_x[1] + rearAxis.WheelJointRight.rim2.R.T[2,3] * rearAxis.WheelJointRight.rim2.e_x[2] + rearAxis.WheelJointRight.rim2.R.T[3,3] * rearAxis.WheelJointRight.rim2.e_x[3];
//   rearAxis.WheelJointRight.rim2.ryvisobj[1] = rearAxis.WheelJointRight.rim2.R.T[1,1] * rearAxis.WheelJointRight.rim2.e_y[1] + rearAxis.WheelJointRight.rim2.R.T[2,1] * rearAxis.WheelJointRight.rim2.e_y[2] + rearAxis.WheelJointRight.rim2.R.T[3,1] * rearAxis.WheelJointRight.rim2.e_y[3];
//   rearAxis.WheelJointRight.rim2.ryvisobj[2] = rearAxis.WheelJointRight.rim2.R.T[1,2] * rearAxis.WheelJointRight.rim2.e_y[1] + rearAxis.WheelJointRight.rim2.R.T[2,2] * rearAxis.WheelJointRight.rim2.e_y[2] + rearAxis.WheelJointRight.rim2.R.T[3,2] * rearAxis.WheelJointRight.rim2.e_y[3];
//   rearAxis.WheelJointRight.rim2.ryvisobj[3] = rearAxis.WheelJointRight.rim2.R.T[1,3] * rearAxis.WheelJointRight.rim2.e_y[1] + rearAxis.WheelJointRight.rim2.R.T[2,3] * rearAxis.WheelJointRight.rim2.e_y[2] + rearAxis.WheelJointRight.rim2.R.T[3,3] * rearAxis.WheelJointRight.rim2.e_y[3];
//   rearAxis.WheelJointRight.rim2.rvisobj = rearAxis.WheelJointRight.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointRight.rim2.R.T[1,1],rearAxis.WheelJointRight.rim2.R.T[1,2],rearAxis.WheelJointRight.rim2.R.T[1,3]},{rearAxis.WheelJointRight.rim2.R.T[2,1],rearAxis.WheelJointRight.rim2.R.T[2,2],rearAxis.WheelJointRight.rim2.R.T[2,3]},{rearAxis.WheelJointRight.rim2.R.T[3,1],rearAxis.WheelJointRight.rim2.R.T[3,2],rearAxis.WheelJointRight.rim2.R.T[3,3]}},{rearAxis.WheelJointRight.rim2.r_shape[1],rearAxis.WheelJointRight.rim2.r_shape[2],rearAxis.WheelJointRight.rim2.r_shape[3]});
//   rearAxis.WheelJointRight.rim2.size[1] = rearAxis.WheelJointRight.rim2.length;
//   rearAxis.WheelJointRight.rim2.size[2] = rearAxis.WheelJointRight.rim2.width;
//   rearAxis.WheelJointRight.rim2.size[3] = rearAxis.WheelJointRight.rim2.height;
//   rearAxis.WheelJointRight.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointRight.rim2.color[1] / 255.0,rearAxis.WheelJointRight.rim2.color[2] / 255.0,rearAxis.WheelJointRight.rim2.color[3] / 255.0,rearAxis.WheelJointRight.rim2.specularCoefficient);
//   rearAxis.WheelJointRight.rim2.Extra = rearAxis.WheelJointRight.rim2.extra;
//   rearAxis.WheelJointRight.R[1,1] = cos(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.R[1,2] = sin(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.R[2,1] = -sin(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.R[2,2] = cos(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.e0[1] = rearAxis.WheelJointRight.R[1,1] * rearAxis.WheelJointRight.e[1] + rearAxis.WheelJointRight.R[1,2] * rearAxis.WheelJointRight.e[2];
//   rearAxis.WheelJointRight.e0[2] = rearAxis.WheelJointRight.R[2,1] * rearAxis.WheelJointRight.e[1] + rearAxis.WheelJointRight.R[2,2] * rearAxis.WheelJointRight.e[2];
//   rearAxis.WheelJointRight.v[1] = der(rearAxis.WheelJointRight.frame_a.x);
//   rearAxis.WheelJointRight.v[2] = der(rearAxis.WheelJointRight.frame_a.y);
//   rearAxis.WheelJointRight.w_roll = der(rearAxis.WheelJointRight.flange_a.phi);
//   rearAxis.WheelJointRight.v_long = rearAxis.WheelJointRight.v[1] * rearAxis.WheelJointRight.e0[1] + rearAxis.WheelJointRight.v[2] * rearAxis.WheelJointRight.e0[2];
//   rearAxis.WheelJointRight.v_lat = (-rearAxis.WheelJointRight.v[1]) * rearAxis.WheelJointRight.e0[2] + rearAxis.WheelJointRight.v[2] * rearAxis.WheelJointRight.e0[1];
//   rearAxis.WheelJointRight.v_slip_lat = rearAxis.WheelJointRight.v_lat;
//   rearAxis.WheelJointRight.v_slip_long = rearAxis.WheelJointRight.v_long - rearAxis.WheelJointRight.radius * rearAxis.WheelJointRight.w_roll;
//   rearAxis.WheelJointRight.v_slip = 0.0001 + sqrt(rearAxis.WheelJointRight.v_slip_long ^ 2.0 + rearAxis.WheelJointRight.v_slip_lat ^ 2.0);
//   (-rearAxis.WheelJointRight.f_long) * rearAxis.WheelJointRight.radius = rearAxis.WheelJointRight.flange_a.tau;
//   rearAxis.WheelJointRight.frame_a.t = 0.0;
//   rearAxis.WheelJointRight.f = rearAxis.WheelJointRight.N * PlanarMechanicsV4.Utilities.TripleS_Func(rearAxis.WheelJointRight.vAdhesion,rearAxis.WheelJointRight.vSlide,rearAxis.WheelJointRight.mu_A,rearAxis.WheelJointRight.mu_S,rearAxis.WheelJointRight.v_slip);
//   rearAxis.WheelJointRight.f_long = (rearAxis.WheelJointRight.f * rearAxis.WheelJointRight.v_slip_long) / rearAxis.WheelJointRight.v_slip;
//   rearAxis.WheelJointRight.f_lat = (rearAxis.WheelJointRight.f * rearAxis.WheelJointRight.v_slip_lat) / rearAxis.WheelJointRight.v_slip;
//   rearAxis.WheelJointRight.f_long = rearAxis.WheelJointRight.frame_a.fx * rearAxis.WheelJointRight.e0[1] + rearAxis.WheelJointRight.frame_a.fy * rearAxis.WheelJointRight.e0[2];
//   rearAxis.WheelJointRight.f_lat = rearAxis.WheelJointRight.frame_a.fy * rearAxis.WheelJointRight.e0[1] + (-rearAxis.WheelJointRight.frame_a.fx) * rearAxis.WheelJointRight.e0[2];
//   frontAxis.leftSteeringRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.leftSteeringRevolute.cylinder.shapeType);
//   frontAxis.leftSteeringRevolute.cylinder.rxvisobj[1] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,1] * frontAxis.leftSteeringRevolute.cylinder.e_x[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,1] * frontAxis.leftSteeringRevolute.cylinder.e_x[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,1] * frontAxis.leftSteeringRevolute.cylinder.e_x[3];
//   frontAxis.leftSteeringRevolute.cylinder.rxvisobj[2] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,2] * frontAxis.leftSteeringRevolute.cylinder.e_x[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,2] * frontAxis.leftSteeringRevolute.cylinder.e_x[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,2] * frontAxis.leftSteeringRevolute.cylinder.e_x[3];
//   frontAxis.leftSteeringRevolute.cylinder.rxvisobj[3] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,3] * frontAxis.leftSteeringRevolute.cylinder.e_x[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,3] * frontAxis.leftSteeringRevolute.cylinder.e_x[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,3] * frontAxis.leftSteeringRevolute.cylinder.e_x[3];
//   frontAxis.leftSteeringRevolute.cylinder.ryvisobj[1] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,1] * frontAxis.leftSteeringRevolute.cylinder.e_y[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,1] * frontAxis.leftSteeringRevolute.cylinder.e_y[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,1] * frontAxis.leftSteeringRevolute.cylinder.e_y[3];
//   frontAxis.leftSteeringRevolute.cylinder.ryvisobj[2] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,2] * frontAxis.leftSteeringRevolute.cylinder.e_y[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,2] * frontAxis.leftSteeringRevolute.cylinder.e_y[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,2] * frontAxis.leftSteeringRevolute.cylinder.e_y[3];
//   frontAxis.leftSteeringRevolute.cylinder.ryvisobj[3] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,3] * frontAxis.leftSteeringRevolute.cylinder.e_y[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,3] * frontAxis.leftSteeringRevolute.cylinder.e_y[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,3] * frontAxis.leftSteeringRevolute.cylinder.e_y[3];
//   frontAxis.leftSteeringRevolute.cylinder.rvisobj = frontAxis.leftSteeringRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.leftSteeringRevolute.cylinder.R.T[1,1],frontAxis.leftSteeringRevolute.cylinder.R.T[1,2],frontAxis.leftSteeringRevolute.cylinder.R.T[1,3]},{frontAxis.leftSteeringRevolute.cylinder.R.T[2,1],frontAxis.leftSteeringRevolute.cylinder.R.T[2,2],frontAxis.leftSteeringRevolute.cylinder.R.T[2,3]},{frontAxis.leftSteeringRevolute.cylinder.R.T[3,1],frontAxis.leftSteeringRevolute.cylinder.R.T[3,2],frontAxis.leftSteeringRevolute.cylinder.R.T[3,3]}},{frontAxis.leftSteeringRevolute.cylinder.r_shape[1],frontAxis.leftSteeringRevolute.cylinder.r_shape[2],frontAxis.leftSteeringRevolute.cylinder.r_shape[3]});
//   frontAxis.leftSteeringRevolute.cylinder.size[1] = frontAxis.leftSteeringRevolute.cylinder.length;
//   frontAxis.leftSteeringRevolute.cylinder.size[2] = frontAxis.leftSteeringRevolute.cylinder.width;
//   frontAxis.leftSteeringRevolute.cylinder.size[3] = frontAxis.leftSteeringRevolute.cylinder.height;
//   frontAxis.leftSteeringRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.leftSteeringRevolute.cylinder.color[1] / 255.0,frontAxis.leftSteeringRevolute.cylinder.color[2] / 255.0,frontAxis.leftSteeringRevolute.cylinder.color[3] / 255.0,frontAxis.leftSteeringRevolute.cylinder.specularCoefficient);
//   frontAxis.leftSteeringRevolute.cylinder.Extra = frontAxis.leftSteeringRevolute.cylinder.extra;
//   frontAxis.leftSteeringRevolute.phi = frontAxis.leftSteeringRevolute.flange_a.phi;
//   frontAxis.leftSteeringRevolute.w = der(frontAxis.leftSteeringRevolute.phi);
//   frontAxis.leftSteeringRevolute.z = der(frontAxis.leftSteeringRevolute.w);
//   frontAxis.leftSteeringRevolute.t = frontAxis.leftSteeringRevolute.flange_a.tau;
//   frontAxis.leftSteeringRevolute.frame_a.x = frontAxis.leftSteeringRevolute.frame_b.x;
//   frontAxis.leftSteeringRevolute.frame_a.y = frontAxis.leftSteeringRevolute.frame_b.y;
//   frontAxis.leftSteeringRevolute.frame_a.phi + frontAxis.leftSteeringRevolute.phi = frontAxis.leftSteeringRevolute.frame_b.phi;
//   frontAxis.leftSteeringRevolute.frame_a.fx + frontAxis.leftSteeringRevolute.frame_b.fx = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.fy + frontAxis.leftSteeringRevolute.frame_b.fy = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.t + frontAxis.leftSteeringRevolute.frame_b.t = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.t = frontAxis.leftSteeringRevolute.t;
//   frontAxis.rightSteeringRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.rightSteeringRevolute.cylinder.shapeType);
//   frontAxis.rightSteeringRevolute.cylinder.rxvisobj[1] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,1] * frontAxis.rightSteeringRevolute.cylinder.e_x[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,1] * frontAxis.rightSteeringRevolute.cylinder.e_x[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,1] * frontAxis.rightSteeringRevolute.cylinder.e_x[3];
//   frontAxis.rightSteeringRevolute.cylinder.rxvisobj[2] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,2] * frontAxis.rightSteeringRevolute.cylinder.e_x[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,2] * frontAxis.rightSteeringRevolute.cylinder.e_x[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,2] * frontAxis.rightSteeringRevolute.cylinder.e_x[3];
//   frontAxis.rightSteeringRevolute.cylinder.rxvisobj[3] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,3] * frontAxis.rightSteeringRevolute.cylinder.e_x[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,3] * frontAxis.rightSteeringRevolute.cylinder.e_x[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,3] * frontAxis.rightSteeringRevolute.cylinder.e_x[3];
//   frontAxis.rightSteeringRevolute.cylinder.ryvisobj[1] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,1] * frontAxis.rightSteeringRevolute.cylinder.e_y[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,1] * frontAxis.rightSteeringRevolute.cylinder.e_y[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,1] * frontAxis.rightSteeringRevolute.cylinder.e_y[3];
//   frontAxis.rightSteeringRevolute.cylinder.ryvisobj[2] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,2] * frontAxis.rightSteeringRevolute.cylinder.e_y[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,2] * frontAxis.rightSteeringRevolute.cylinder.e_y[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,2] * frontAxis.rightSteeringRevolute.cylinder.e_y[3];
//   frontAxis.rightSteeringRevolute.cylinder.ryvisobj[3] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,3] * frontAxis.rightSteeringRevolute.cylinder.e_y[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,3] * frontAxis.rightSteeringRevolute.cylinder.e_y[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,3] * frontAxis.rightSteeringRevolute.cylinder.e_y[3];
//   frontAxis.rightSteeringRevolute.cylinder.rvisobj = frontAxis.rightSteeringRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.rightSteeringRevolute.cylinder.R.T[1,1],frontAxis.rightSteeringRevolute.cylinder.R.T[1,2],frontAxis.rightSteeringRevolute.cylinder.R.T[1,3]},{frontAxis.rightSteeringRevolute.cylinder.R.T[2,1],frontAxis.rightSteeringRevolute.cylinder.R.T[2,2],frontAxis.rightSteeringRevolute.cylinder.R.T[2,3]},{frontAxis.rightSteeringRevolute.cylinder.R.T[3,1],frontAxis.rightSteeringRevolute.cylinder.R.T[3,2],frontAxis.rightSteeringRevolute.cylinder.R.T[3,3]}},{frontAxis.rightSteeringRevolute.cylinder.r_shape[1],frontAxis.rightSteeringRevolute.cylinder.r_shape[2],frontAxis.rightSteeringRevolute.cylinder.r_shape[3]});
//   frontAxis.rightSteeringRevolute.cylinder.size[1] = frontAxis.rightSteeringRevolute.cylinder.length;
//   frontAxis.rightSteeringRevolute.cylinder.size[2] = frontAxis.rightSteeringRevolute.cylinder.width;
//   frontAxis.rightSteeringRevolute.cylinder.size[3] = frontAxis.rightSteeringRevolute.cylinder.height;
//   frontAxis.rightSteeringRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.rightSteeringRevolute.cylinder.color[1] / 255.0,frontAxis.rightSteeringRevolute.cylinder.color[2] / 255.0,frontAxis.rightSteeringRevolute.cylinder.color[3] / 255.0,frontAxis.rightSteeringRevolute.cylinder.specularCoefficient);
//   frontAxis.rightSteeringRevolute.cylinder.Extra = frontAxis.rightSteeringRevolute.cylinder.extra;
//   frontAxis.rightSteeringRevolute.phi = frontAxis.rightSteeringRevolute.flange_a.phi;
//   frontAxis.rightSteeringRevolute.w = der(frontAxis.rightSteeringRevolute.phi);
//   frontAxis.rightSteeringRevolute.z = der(frontAxis.rightSteeringRevolute.w);
//   frontAxis.rightSteeringRevolute.t = frontAxis.rightSteeringRevolute.flange_a.tau;
//   frontAxis.rightSteeringRevolute.frame_a.x = frontAxis.rightSteeringRevolute.frame_b.x;
//   frontAxis.rightSteeringRevolute.frame_a.y = frontAxis.rightSteeringRevolute.frame_b.y;
//   frontAxis.rightSteeringRevolute.frame_a.phi + frontAxis.rightSteeringRevolute.phi = frontAxis.rightSteeringRevolute.frame_b.phi;
//   frontAxis.rightSteeringRevolute.frame_a.fx + frontAxis.rightSteeringRevolute.frame_b.fx = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.fy + frontAxis.rightSteeringRevolute.frame_b.fy = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.t + frontAxis.rightSteeringRevolute.frame_b.t = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.t = frontAxis.rightSteeringRevolute.t;
//   frontAxis.leftAxis.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.leftAxis.cylinder.shapeType);
//   frontAxis.leftAxis.cylinder.rxvisobj[1] = frontAxis.leftAxis.cylinder.R.T[1,1] * frontAxis.leftAxis.cylinder.e_x[1] + frontAxis.leftAxis.cylinder.R.T[2,1] * frontAxis.leftAxis.cylinder.e_x[2] + frontAxis.leftAxis.cylinder.R.T[3,1] * frontAxis.leftAxis.cylinder.e_x[3];
//   frontAxis.leftAxis.cylinder.rxvisobj[2] = frontAxis.leftAxis.cylinder.R.T[1,2] * frontAxis.leftAxis.cylinder.e_x[1] + frontAxis.leftAxis.cylinder.R.T[2,2] * frontAxis.leftAxis.cylinder.e_x[2] + frontAxis.leftAxis.cylinder.R.T[3,2] * frontAxis.leftAxis.cylinder.e_x[3];
//   frontAxis.leftAxis.cylinder.rxvisobj[3] = frontAxis.leftAxis.cylinder.R.T[1,3] * frontAxis.leftAxis.cylinder.e_x[1] + frontAxis.leftAxis.cylinder.R.T[2,3] * frontAxis.leftAxis.cylinder.e_x[2] + frontAxis.leftAxis.cylinder.R.T[3,3] * frontAxis.leftAxis.cylinder.e_x[3];
//   frontAxis.leftAxis.cylinder.ryvisobj[1] = frontAxis.leftAxis.cylinder.R.T[1,1] * frontAxis.leftAxis.cylinder.e_y[1] + frontAxis.leftAxis.cylinder.R.T[2,1] * frontAxis.leftAxis.cylinder.e_y[2] + frontAxis.leftAxis.cylinder.R.T[3,1] * frontAxis.leftAxis.cylinder.e_y[3];
//   frontAxis.leftAxis.cylinder.ryvisobj[2] = frontAxis.leftAxis.cylinder.R.T[1,2] * frontAxis.leftAxis.cylinder.e_y[1] + frontAxis.leftAxis.cylinder.R.T[2,2] * frontAxis.leftAxis.cylinder.e_y[2] + frontAxis.leftAxis.cylinder.R.T[3,2] * frontAxis.leftAxis.cylinder.e_y[3];
//   frontAxis.leftAxis.cylinder.ryvisobj[3] = frontAxis.leftAxis.cylinder.R.T[1,3] * frontAxis.leftAxis.cylinder.e_y[1] + frontAxis.leftAxis.cylinder.R.T[2,3] * frontAxis.leftAxis.cylinder.e_y[2] + frontAxis.leftAxis.cylinder.R.T[3,3] * frontAxis.leftAxis.cylinder.e_y[3];
//   frontAxis.leftAxis.cylinder.rvisobj = frontAxis.leftAxis.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.leftAxis.cylinder.R.T[1,1],frontAxis.leftAxis.cylinder.R.T[1,2],frontAxis.leftAxis.cylinder.R.T[1,3]},{frontAxis.leftAxis.cylinder.R.T[2,1],frontAxis.leftAxis.cylinder.R.T[2,2],frontAxis.leftAxis.cylinder.R.T[2,3]},{frontAxis.leftAxis.cylinder.R.T[3,1],frontAxis.leftAxis.cylinder.R.T[3,2],frontAxis.leftAxis.cylinder.R.T[3,3]}},{frontAxis.leftAxis.cylinder.r_shape[1],frontAxis.leftAxis.cylinder.r_shape[2],frontAxis.leftAxis.cylinder.r_shape[3]});
//   frontAxis.leftAxis.cylinder.size[1] = frontAxis.leftAxis.cylinder.length;
//   frontAxis.leftAxis.cylinder.size[2] = frontAxis.leftAxis.cylinder.width;
//   frontAxis.leftAxis.cylinder.size[3] = frontAxis.leftAxis.cylinder.height;
//   frontAxis.leftAxis.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.leftAxis.cylinder.color[1] / 255.0,frontAxis.leftAxis.cylinder.color[2] / 255.0,frontAxis.leftAxis.cylinder.color[3] / 255.0,frontAxis.leftAxis.cylinder.specularCoefficient);
//   frontAxis.leftAxis.cylinder.Extra = frontAxis.leftAxis.cylinder.extra;
//   frontAxis.leftAxis.R[1,1] = cos(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.R[1,2] = sin(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.R[2,1] = -sin(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.R[2,2] = cos(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.r0[1] = frontAxis.leftAxis.R[1,1] * frontAxis.leftAxis.r[1] + frontAxis.leftAxis.R[1,2] * frontAxis.leftAxis.r[2];
//   frontAxis.leftAxis.r0[2] = frontAxis.leftAxis.R[2,1] * frontAxis.leftAxis.r[1] + frontAxis.leftAxis.R[2,2] * frontAxis.leftAxis.r[2];
//   frontAxis.leftAxis.frame_a.x + frontAxis.leftAxis.r0[1] = frontAxis.leftAxis.frame_b.x;
//   frontAxis.leftAxis.frame_a.y + frontAxis.leftAxis.r0[2] = frontAxis.leftAxis.frame_b.y;
//   frontAxis.leftAxis.frame_a.phi = frontAxis.leftAxis.frame_b.phi;
//   frontAxis.leftAxis.frame_a.fx + frontAxis.leftAxis.frame_b.fx = 0.0;
//   frontAxis.leftAxis.frame_a.fy + frontAxis.leftAxis.frame_b.fy = 0.0;
//   frontAxis.leftAxis.frame_a.t + (frontAxis.leftAxis.frame_b.t + ((-frontAxis.leftAxis.r0[1]) * frontAxis.leftAxis.frame_b.fy + frontAxis.leftAxis.r0[2] * frontAxis.leftAxis.frame_b.fx)) = 0.0;
//   frontAxis.rightAxis.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.rightAxis.cylinder.shapeType);
//   frontAxis.rightAxis.cylinder.rxvisobj[1] = frontAxis.rightAxis.cylinder.R.T[1,1] * frontAxis.rightAxis.cylinder.e_x[1] + frontAxis.rightAxis.cylinder.R.T[2,1] * frontAxis.rightAxis.cylinder.e_x[2] + frontAxis.rightAxis.cylinder.R.T[3,1] * frontAxis.rightAxis.cylinder.e_x[3];
//   frontAxis.rightAxis.cylinder.rxvisobj[2] = frontAxis.rightAxis.cylinder.R.T[1,2] * frontAxis.rightAxis.cylinder.e_x[1] + frontAxis.rightAxis.cylinder.R.T[2,2] * frontAxis.rightAxis.cylinder.e_x[2] + frontAxis.rightAxis.cylinder.R.T[3,2] * frontAxis.rightAxis.cylinder.e_x[3];
//   frontAxis.rightAxis.cylinder.rxvisobj[3] = frontAxis.rightAxis.cylinder.R.T[1,3] * frontAxis.rightAxis.cylinder.e_x[1] + frontAxis.rightAxis.cylinder.R.T[2,3] * frontAxis.rightAxis.cylinder.e_x[2] + frontAxis.rightAxis.cylinder.R.T[3,3] * frontAxis.rightAxis.cylinder.e_x[3];
//   frontAxis.rightAxis.cylinder.ryvisobj[1] = frontAxis.rightAxis.cylinder.R.T[1,1] * frontAxis.rightAxis.cylinder.e_y[1] + frontAxis.rightAxis.cylinder.R.T[2,1] * frontAxis.rightAxis.cylinder.e_y[2] + frontAxis.rightAxis.cylinder.R.T[3,1] * frontAxis.rightAxis.cylinder.e_y[3];
//   frontAxis.rightAxis.cylinder.ryvisobj[2] = frontAxis.rightAxis.cylinder.R.T[1,2] * frontAxis.rightAxis.cylinder.e_y[1] + frontAxis.rightAxis.cylinder.R.T[2,2] * frontAxis.rightAxis.cylinder.e_y[2] + frontAxis.rightAxis.cylinder.R.T[3,2] * frontAxis.rightAxis.cylinder.e_y[3];
//   frontAxis.rightAxis.cylinder.ryvisobj[3] = frontAxis.rightAxis.cylinder.R.T[1,3] * frontAxis.rightAxis.cylinder.e_y[1] + frontAxis.rightAxis.cylinder.R.T[2,3] * frontAxis.rightAxis.cylinder.e_y[2] + frontAxis.rightAxis.cylinder.R.T[3,3] * frontAxis.rightAxis.cylinder.e_y[3];
//   frontAxis.rightAxis.cylinder.rvisobj = frontAxis.rightAxis.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.rightAxis.cylinder.R.T[1,1],frontAxis.rightAxis.cylinder.R.T[1,2],frontAxis.rightAxis.cylinder.R.T[1,3]},{frontAxis.rightAxis.cylinder.R.T[2,1],frontAxis.rightAxis.cylinder.R.T[2,2],frontAxis.rightAxis.cylinder.R.T[2,3]},{frontAxis.rightAxis.cylinder.R.T[3,1],frontAxis.rightAxis.cylinder.R.T[3,2],frontAxis.rightAxis.cylinder.R.T[3,3]}},{frontAxis.rightAxis.cylinder.r_shape[1],frontAxis.rightAxis.cylinder.r_shape[2],frontAxis.rightAxis.cylinder.r_shape[3]});
//   frontAxis.rightAxis.cylinder.size[1] = frontAxis.rightAxis.cylinder.length;
//   frontAxis.rightAxis.cylinder.size[2] = frontAxis.rightAxis.cylinder.width;
//   frontAxis.rightAxis.cylinder.size[3] = frontAxis.rightAxis.cylinder.height;
//   frontAxis.rightAxis.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.rightAxis.cylinder.color[1] / 255.0,frontAxis.rightAxis.cylinder.color[2] / 255.0,frontAxis.rightAxis.cylinder.color[3] / 255.0,frontAxis.rightAxis.cylinder.specularCoefficient);
//   frontAxis.rightAxis.cylinder.Extra = frontAxis.rightAxis.cylinder.extra;
//   frontAxis.rightAxis.R[1,1] = cos(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.R[1,2] = sin(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.R[2,1] = -sin(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.R[2,2] = cos(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.r0[1] = frontAxis.rightAxis.R[1,1] * frontAxis.rightAxis.r[1] + frontAxis.rightAxis.R[1,2] * frontAxis.rightAxis.r[2];
//   frontAxis.rightAxis.r0[2] = frontAxis.rightAxis.R[2,1] * frontAxis.rightAxis.r[1] + frontAxis.rightAxis.R[2,2] * frontAxis.rightAxis.r[2];
//   frontAxis.rightAxis.frame_a.x + frontAxis.rightAxis.r0[1] = frontAxis.rightAxis.frame_b.x;
//   frontAxis.rightAxis.frame_a.y + frontAxis.rightAxis.r0[2] = frontAxis.rightAxis.frame_b.y;
//   frontAxis.rightAxis.frame_a.phi = frontAxis.rightAxis.frame_b.phi;
//   frontAxis.rightAxis.frame_a.fx + frontAxis.rightAxis.frame_b.fx = 0.0;
//   frontAxis.rightAxis.frame_a.fy + frontAxis.rightAxis.frame_b.fy = 0.0;
//   frontAxis.rightAxis.frame_a.t + (frontAxis.rightAxis.frame_b.t + ((-frontAxis.rightAxis.r0[1]) * frontAxis.rightAxis.frame_b.fy + frontAxis.rightAxis.r0[2] * frontAxis.rightAxis.frame_b.fx)) = 0.0;
//   frontAxis.leftTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.leftTrail.cylinder.shapeType);
//   frontAxis.leftTrail.cylinder.rxvisobj[1] = frontAxis.leftTrail.cylinder.R.T[1,1] * frontAxis.leftTrail.cylinder.e_x[1] + frontAxis.leftTrail.cylinder.R.T[2,1] * frontAxis.leftTrail.cylinder.e_x[2] + frontAxis.leftTrail.cylinder.R.T[3,1] * frontAxis.leftTrail.cylinder.e_x[3];
//   frontAxis.leftTrail.cylinder.rxvisobj[2] = frontAxis.leftTrail.cylinder.R.T[1,2] * frontAxis.leftTrail.cylinder.e_x[1] + frontAxis.leftTrail.cylinder.R.T[2,2] * frontAxis.leftTrail.cylinder.e_x[2] + frontAxis.leftTrail.cylinder.R.T[3,2] * frontAxis.leftTrail.cylinder.e_x[3];
//   frontAxis.leftTrail.cylinder.rxvisobj[3] = frontAxis.leftTrail.cylinder.R.T[1,3] * frontAxis.leftTrail.cylinder.e_x[1] + frontAxis.leftTrail.cylinder.R.T[2,3] * frontAxis.leftTrail.cylinder.e_x[2] + frontAxis.leftTrail.cylinder.R.T[3,3] * frontAxis.leftTrail.cylinder.e_x[3];
//   frontAxis.leftTrail.cylinder.ryvisobj[1] = frontAxis.leftTrail.cylinder.R.T[1,1] * frontAxis.leftTrail.cylinder.e_y[1] + frontAxis.leftTrail.cylinder.R.T[2,1] * frontAxis.leftTrail.cylinder.e_y[2] + frontAxis.leftTrail.cylinder.R.T[3,1] * frontAxis.leftTrail.cylinder.e_y[3];
//   frontAxis.leftTrail.cylinder.ryvisobj[2] = frontAxis.leftTrail.cylinder.R.T[1,2] * frontAxis.leftTrail.cylinder.e_y[1] + frontAxis.leftTrail.cylinder.R.T[2,2] * frontAxis.leftTrail.cylinder.e_y[2] + frontAxis.leftTrail.cylinder.R.T[3,2] * frontAxis.leftTrail.cylinder.e_y[3];
//   frontAxis.leftTrail.cylinder.ryvisobj[3] = frontAxis.leftTrail.cylinder.R.T[1,3] * frontAxis.leftTrail.cylinder.e_y[1] + frontAxis.leftTrail.cylinder.R.T[2,3] * frontAxis.leftTrail.cylinder.e_y[2] + frontAxis.leftTrail.cylinder.R.T[3,3] * frontAxis.leftTrail.cylinder.e_y[3];
//   frontAxis.leftTrail.cylinder.rvisobj = frontAxis.leftTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.leftTrail.cylinder.R.T[1,1],frontAxis.leftTrail.cylinder.R.T[1,2],frontAxis.leftTrail.cylinder.R.T[1,3]},{frontAxis.leftTrail.cylinder.R.T[2,1],frontAxis.leftTrail.cylinder.R.T[2,2],frontAxis.leftTrail.cylinder.R.T[2,3]},{frontAxis.leftTrail.cylinder.R.T[3,1],frontAxis.leftTrail.cylinder.R.T[3,2],frontAxis.leftTrail.cylinder.R.T[3,3]}},{frontAxis.leftTrail.cylinder.r_shape[1],frontAxis.leftTrail.cylinder.r_shape[2],frontAxis.leftTrail.cylinder.r_shape[3]});
//   frontAxis.leftTrail.cylinder.size[1] = frontAxis.leftTrail.cylinder.length;
//   frontAxis.leftTrail.cylinder.size[2] = frontAxis.leftTrail.cylinder.width;
//   frontAxis.leftTrail.cylinder.size[3] = frontAxis.leftTrail.cylinder.height;
//   frontAxis.leftTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.leftTrail.cylinder.color[1] / 255.0,frontAxis.leftTrail.cylinder.color[2] / 255.0,frontAxis.leftTrail.cylinder.color[3] / 255.0,frontAxis.leftTrail.cylinder.specularCoefficient);
//   frontAxis.leftTrail.cylinder.Extra = frontAxis.leftTrail.cylinder.extra;
//   frontAxis.leftTrail.R[1,1] = cos(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.R[1,2] = sin(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.R[2,1] = -sin(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.R[2,2] = cos(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.r0[1] = frontAxis.leftTrail.R[1,1] * frontAxis.leftTrail.r[1] + frontAxis.leftTrail.R[1,2] * frontAxis.leftTrail.r[2];
//   frontAxis.leftTrail.r0[2] = frontAxis.leftTrail.R[2,1] * frontAxis.leftTrail.r[1] + frontAxis.leftTrail.R[2,2] * frontAxis.leftTrail.r[2];
//   frontAxis.leftTrail.frame_a.x + frontAxis.leftTrail.r0[1] = frontAxis.leftTrail.frame_b.x;
//   frontAxis.leftTrail.frame_a.y + frontAxis.leftTrail.r0[2] = frontAxis.leftTrail.frame_b.y;
//   frontAxis.leftTrail.frame_a.phi = frontAxis.leftTrail.frame_b.phi;
//   frontAxis.leftTrail.frame_a.fx + frontAxis.leftTrail.frame_b.fx = 0.0;
//   frontAxis.leftTrail.frame_a.fy + frontAxis.leftTrail.frame_b.fy = 0.0;
//   frontAxis.leftTrail.frame_a.t + (frontAxis.leftTrail.frame_b.t + ((-frontAxis.leftTrail.r0[1]) * frontAxis.leftTrail.frame_b.fy + frontAxis.leftTrail.r0[2] * frontAxis.leftTrail.frame_b.fx)) = 0.0;
//   frontAxis.rigthtTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.rigthtTrail.cylinder.shapeType);
//   frontAxis.rigthtTrail.cylinder.rxvisobj[1] = frontAxis.rigthtTrail.cylinder.R.T[1,1] * frontAxis.rigthtTrail.cylinder.e_x[1] + frontAxis.rigthtTrail.cylinder.R.T[2,1] * frontAxis.rigthtTrail.cylinder.e_x[2] + frontAxis.rigthtTrail.cylinder.R.T[3,1] * frontAxis.rigthtTrail.cylinder.e_x[3];
//   frontAxis.rigthtTrail.cylinder.rxvisobj[2] = frontAxis.rigthtTrail.cylinder.R.T[1,2] * frontAxis.rigthtTrail.cylinder.e_x[1] + frontAxis.rigthtTrail.cylinder.R.T[2,2] * frontAxis.rigthtTrail.cylinder.e_x[2] + frontAxis.rigthtTrail.cylinder.R.T[3,2] * frontAxis.rigthtTrail.cylinder.e_x[3];
//   frontAxis.rigthtTrail.cylinder.rxvisobj[3] = frontAxis.rigthtTrail.cylinder.R.T[1,3] * frontAxis.rigthtTrail.cylinder.e_x[1] + frontAxis.rigthtTrail.cylinder.R.T[2,3] * frontAxis.rigthtTrail.cylinder.e_x[2] + frontAxis.rigthtTrail.cylinder.R.T[3,3] * frontAxis.rigthtTrail.cylinder.e_x[3];
//   frontAxis.rigthtTrail.cylinder.ryvisobj[1] = frontAxis.rigthtTrail.cylinder.R.T[1,1] * frontAxis.rigthtTrail.cylinder.e_y[1] + frontAxis.rigthtTrail.cylinder.R.T[2,1] * frontAxis.rigthtTrail.cylinder.e_y[2] + frontAxis.rigthtTrail.cylinder.R.T[3,1] * frontAxis.rigthtTrail.cylinder.e_y[3];
//   frontAxis.rigthtTrail.cylinder.ryvisobj[2] = frontAxis.rigthtTrail.cylinder.R.T[1,2] * frontAxis.rigthtTrail.cylinder.e_y[1] + frontAxis.rigthtTrail.cylinder.R.T[2,2] * frontAxis.rigthtTrail.cylinder.e_y[2] + frontAxis.rigthtTrail.cylinder.R.T[3,2] * frontAxis.rigthtTrail.cylinder.e_y[3];
//   frontAxis.rigthtTrail.cylinder.ryvisobj[3] = frontAxis.rigthtTrail.cylinder.R.T[1,3] * frontAxis.rigthtTrail.cylinder.e_y[1] + frontAxis.rigthtTrail.cylinder.R.T[2,3] * frontAxis.rigthtTrail.cylinder.e_y[2] + frontAxis.rigthtTrail.cylinder.R.T[3,3] * frontAxis.rigthtTrail.cylinder.e_y[3];
//   frontAxis.rigthtTrail.cylinder.rvisobj = frontAxis.rigthtTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.rigthtTrail.cylinder.R.T[1,1],frontAxis.rigthtTrail.cylinder.R.T[1,2],frontAxis.rigthtTrail.cylinder.R.T[1,3]},{frontAxis.rigthtTrail.cylinder.R.T[2,1],frontAxis.rigthtTrail.cylinder.R.T[2,2],frontAxis.rigthtTrail.cylinder.R.T[2,3]},{frontAxis.rigthtTrail.cylinder.R.T[3,1],frontAxis.rigthtTrail.cylinder.R.T[3,2],frontAxis.rigthtTrail.cylinder.R.T[3,3]}},{frontAxis.rigthtTrail.cylinder.r_shape[1],frontAxis.rigthtTrail.cylinder.r_shape[2],frontAxis.rigthtTrail.cylinder.r_shape[3]});
//   frontAxis.rigthtTrail.cylinder.size[1] = frontAxis.rigthtTrail.cylinder.length;
//   frontAxis.rigthtTrail.cylinder.size[2] = frontAxis.rigthtTrail.cylinder.width;
//   frontAxis.rigthtTrail.cylinder.size[3] = frontAxis.rigthtTrail.cylinder.height;
//   frontAxis.rigthtTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.rigthtTrail.cylinder.color[1] / 255.0,frontAxis.rigthtTrail.cylinder.color[2] / 255.0,frontAxis.rigthtTrail.cylinder.color[3] / 255.0,frontAxis.rigthtTrail.cylinder.specularCoefficient);
//   frontAxis.rigthtTrail.cylinder.Extra = frontAxis.rigthtTrail.cylinder.extra;
//   frontAxis.rigthtTrail.R[1,1] = cos(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.R[1,2] = sin(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.R[2,1] = -sin(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.R[2,2] = cos(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.r0[1] = frontAxis.rigthtTrail.R[1,1] * frontAxis.rigthtTrail.r[1] + frontAxis.rigthtTrail.R[1,2] * frontAxis.rigthtTrail.r[2];
//   frontAxis.rigthtTrail.r0[2] = frontAxis.rigthtTrail.R[2,1] * frontAxis.rigthtTrail.r[1] + frontAxis.rigthtTrail.R[2,2] * frontAxis.rigthtTrail.r[2];
//   frontAxis.rigthtTrail.frame_a.x + frontAxis.rigthtTrail.r0[1] = frontAxis.rigthtTrail.frame_b.x;
//   frontAxis.rigthtTrail.frame_a.y + frontAxis.rigthtTrail.r0[2] = frontAxis.rigthtTrail.frame_b.y;
//   frontAxis.rigthtTrail.frame_a.phi = frontAxis.rigthtTrail.frame_b.phi;
//   frontAxis.rigthtTrail.frame_a.fx + frontAxis.rigthtTrail.frame_b.fx = 0.0;
//   frontAxis.rigthtTrail.frame_a.fy + frontAxis.rigthtTrail.frame_b.fy = 0.0;
//   frontAxis.rigthtTrail.frame_a.t + (frontAxis.rigthtTrail.frame_b.t + ((-frontAxis.rigthtTrail.r0[1]) * frontAxis.rigthtTrail.frame_b.fy + frontAxis.rigthtTrail.r0[2] * frontAxis.rigthtTrail.frame_b.fx)) = 0.0;
//   frontAxis.leftInertia.phi = frontAxis.leftInertia.flange_a.phi;
//   frontAxis.leftInertia.phi = frontAxis.leftInertia.flange_b.phi;
//   frontAxis.leftInertia.w = der(frontAxis.leftInertia.phi);
//   frontAxis.leftInertia.a = der(frontAxis.leftInertia.w);
//   frontAxis.leftInertia.J * frontAxis.leftInertia.a = frontAxis.leftInertia.flange_a.tau + frontAxis.leftInertia.flange_b.tau;
//   frontAxis.rightInertia.phi = frontAxis.rightInertia.flange_a.phi;
//   frontAxis.rightInertia.phi = frontAxis.rightInertia.flange_b.phi;
//   frontAxis.rightInertia.w = der(frontAxis.rightInertia.phi);
//   frontAxis.rightInertia.a = der(frontAxis.rightInertia.w);
//   frontAxis.rightInertia.J * frontAxis.rightInertia.a = frontAxis.rightInertia.flange_a.tau + frontAxis.rightInertia.flange_b.tau;
//   frontAxis.SteeringInertia.phi = frontAxis.SteeringInertia.flange_a.phi;
//   frontAxis.SteeringInertia.phi = frontAxis.SteeringInertia.flange_b.phi;
//   frontAxis.SteeringInertia.w = der(frontAxis.SteeringInertia.phi);
//   frontAxis.SteeringInertia.a = der(frontAxis.SteeringInertia.w);
//   frontAxis.SteeringInertia.J * frontAxis.SteeringInertia.a = frontAxis.SteeringInertia.flange_a.tau + frontAxis.SteeringInertia.flange_b.tau;
//   frontAxis.WheelJointLeft.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointLeft.cylinder.shapeType);
//   frontAxis.WheelJointLeft.cylinder.rxvisobj[1] = frontAxis.WheelJointLeft.cylinder.R.T[1,1] * frontAxis.WheelJointLeft.cylinder.e_x[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,1] * frontAxis.WheelJointLeft.cylinder.e_x[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,1] * frontAxis.WheelJointLeft.cylinder.e_x[3];
//   frontAxis.WheelJointLeft.cylinder.rxvisobj[2] = frontAxis.WheelJointLeft.cylinder.R.T[1,2] * frontAxis.WheelJointLeft.cylinder.e_x[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,2] * frontAxis.WheelJointLeft.cylinder.e_x[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,2] * frontAxis.WheelJointLeft.cylinder.e_x[3];
//   frontAxis.WheelJointLeft.cylinder.rxvisobj[3] = frontAxis.WheelJointLeft.cylinder.R.T[1,3] * frontAxis.WheelJointLeft.cylinder.e_x[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,3] * frontAxis.WheelJointLeft.cylinder.e_x[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,3] * frontAxis.WheelJointLeft.cylinder.e_x[3];
//   frontAxis.WheelJointLeft.cylinder.ryvisobj[1] = frontAxis.WheelJointLeft.cylinder.R.T[1,1] * frontAxis.WheelJointLeft.cylinder.e_y[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,1] * frontAxis.WheelJointLeft.cylinder.e_y[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,1] * frontAxis.WheelJointLeft.cylinder.e_y[3];
//   frontAxis.WheelJointLeft.cylinder.ryvisobj[2] = frontAxis.WheelJointLeft.cylinder.R.T[1,2] * frontAxis.WheelJointLeft.cylinder.e_y[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,2] * frontAxis.WheelJointLeft.cylinder.e_y[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,2] * frontAxis.WheelJointLeft.cylinder.e_y[3];
//   frontAxis.WheelJointLeft.cylinder.ryvisobj[3] = frontAxis.WheelJointLeft.cylinder.R.T[1,3] * frontAxis.WheelJointLeft.cylinder.e_y[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,3] * frontAxis.WheelJointLeft.cylinder.e_y[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,3] * frontAxis.WheelJointLeft.cylinder.e_y[3];
//   frontAxis.WheelJointLeft.cylinder.rvisobj = frontAxis.WheelJointLeft.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointLeft.cylinder.R.T[1,1],frontAxis.WheelJointLeft.cylinder.R.T[1,2],frontAxis.WheelJointLeft.cylinder.R.T[1,3]},{frontAxis.WheelJointLeft.cylinder.R.T[2,1],frontAxis.WheelJointLeft.cylinder.R.T[2,2],frontAxis.WheelJointLeft.cylinder.R.T[2,3]},{frontAxis.WheelJointLeft.cylinder.R.T[3,1],frontAxis.WheelJointLeft.cylinder.R.T[3,2],frontAxis.WheelJointLeft.cylinder.R.T[3,3]}},{frontAxis.WheelJointLeft.cylinder.r_shape[1],frontAxis.WheelJointLeft.cylinder.r_shape[2],frontAxis.WheelJointLeft.cylinder.r_shape[3]});
//   frontAxis.WheelJointLeft.cylinder.size[1] = frontAxis.WheelJointLeft.cylinder.length;
//   frontAxis.WheelJointLeft.cylinder.size[2] = frontAxis.WheelJointLeft.cylinder.width;
//   frontAxis.WheelJointLeft.cylinder.size[3] = frontAxis.WheelJointLeft.cylinder.height;
//   frontAxis.WheelJointLeft.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointLeft.cylinder.color[1] / 255.0,frontAxis.WheelJointLeft.cylinder.color[2] / 255.0,frontAxis.WheelJointLeft.cylinder.color[3] / 255.0,frontAxis.WheelJointLeft.cylinder.specularCoefficient);
//   frontAxis.WheelJointLeft.cylinder.Extra = frontAxis.WheelJointLeft.cylinder.extra;
//   frontAxis.WheelJointLeft.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointLeft.e0[2],frontAxis.WheelJointLeft.e0[1],0.0},frontAxis.WheelJointLeft.flange_a.phi,0.0);
//   frontAxis.WheelJointLeft.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointLeft.rim1.shapeType);
//   frontAxis.WheelJointLeft.rim1.rxvisobj[1] = frontAxis.WheelJointLeft.rim1.R.T[1,1] * frontAxis.WheelJointLeft.rim1.e_x[1] + frontAxis.WheelJointLeft.rim1.R.T[2,1] * frontAxis.WheelJointLeft.rim1.e_x[2] + frontAxis.WheelJointLeft.rim1.R.T[3,1] * frontAxis.WheelJointLeft.rim1.e_x[3];
//   frontAxis.WheelJointLeft.rim1.rxvisobj[2] = frontAxis.WheelJointLeft.rim1.R.T[1,2] * frontAxis.WheelJointLeft.rim1.e_x[1] + frontAxis.WheelJointLeft.rim1.R.T[2,2] * frontAxis.WheelJointLeft.rim1.e_x[2] + frontAxis.WheelJointLeft.rim1.R.T[3,2] * frontAxis.WheelJointLeft.rim1.e_x[3];
//   frontAxis.WheelJointLeft.rim1.rxvisobj[3] = frontAxis.WheelJointLeft.rim1.R.T[1,3] * frontAxis.WheelJointLeft.rim1.e_x[1] + frontAxis.WheelJointLeft.rim1.R.T[2,3] * frontAxis.WheelJointLeft.rim1.e_x[2] + frontAxis.WheelJointLeft.rim1.R.T[3,3] * frontAxis.WheelJointLeft.rim1.e_x[3];
//   frontAxis.WheelJointLeft.rim1.ryvisobj[1] = frontAxis.WheelJointLeft.rim1.R.T[1,1] * frontAxis.WheelJointLeft.rim1.e_y[1] + frontAxis.WheelJointLeft.rim1.R.T[2,1] * frontAxis.WheelJointLeft.rim1.e_y[2] + frontAxis.WheelJointLeft.rim1.R.T[3,1] * frontAxis.WheelJointLeft.rim1.e_y[3];
//   frontAxis.WheelJointLeft.rim1.ryvisobj[2] = frontAxis.WheelJointLeft.rim1.R.T[1,2] * frontAxis.WheelJointLeft.rim1.e_y[1] + frontAxis.WheelJointLeft.rim1.R.T[2,2] * frontAxis.WheelJointLeft.rim1.e_y[2] + frontAxis.WheelJointLeft.rim1.R.T[3,2] * frontAxis.WheelJointLeft.rim1.e_y[3];
//   frontAxis.WheelJointLeft.rim1.ryvisobj[3] = frontAxis.WheelJointLeft.rim1.R.T[1,3] * frontAxis.WheelJointLeft.rim1.e_y[1] + frontAxis.WheelJointLeft.rim1.R.T[2,3] * frontAxis.WheelJointLeft.rim1.e_y[2] + frontAxis.WheelJointLeft.rim1.R.T[3,3] * frontAxis.WheelJointLeft.rim1.e_y[3];
//   frontAxis.WheelJointLeft.rim1.rvisobj = frontAxis.WheelJointLeft.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointLeft.rim1.R.T[1,1],frontAxis.WheelJointLeft.rim1.R.T[1,2],frontAxis.WheelJointLeft.rim1.R.T[1,3]},{frontAxis.WheelJointLeft.rim1.R.T[2,1],frontAxis.WheelJointLeft.rim1.R.T[2,2],frontAxis.WheelJointLeft.rim1.R.T[2,3]},{frontAxis.WheelJointLeft.rim1.R.T[3,1],frontAxis.WheelJointLeft.rim1.R.T[3,2],frontAxis.WheelJointLeft.rim1.R.T[3,3]}},{frontAxis.WheelJointLeft.rim1.r_shape[1],frontAxis.WheelJointLeft.rim1.r_shape[2],frontAxis.WheelJointLeft.rim1.r_shape[3]});
//   frontAxis.WheelJointLeft.rim1.size[1] = frontAxis.WheelJointLeft.rim1.length;
//   frontAxis.WheelJointLeft.rim1.size[2] = frontAxis.WheelJointLeft.rim1.width;
//   frontAxis.WheelJointLeft.rim1.size[3] = frontAxis.WheelJointLeft.rim1.height;
//   frontAxis.WheelJointLeft.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointLeft.rim1.color[1] / 255.0,frontAxis.WheelJointLeft.rim1.color[2] / 255.0,frontAxis.WheelJointLeft.rim1.color[3] / 255.0,frontAxis.WheelJointLeft.rim1.specularCoefficient);
//   frontAxis.WheelJointLeft.rim1.Extra = frontAxis.WheelJointLeft.rim1.extra;
//   frontAxis.WheelJointLeft.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointLeft.e0[2],frontAxis.WheelJointLeft.e0[1],0.0},1.5707963267949 + frontAxis.WheelJointLeft.flange_a.phi,0.0);
//   frontAxis.WheelJointLeft.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointLeft.rim2.shapeType);
//   frontAxis.WheelJointLeft.rim2.rxvisobj[1] = frontAxis.WheelJointLeft.rim2.R.T[1,1] * frontAxis.WheelJointLeft.rim2.e_x[1] + frontAxis.WheelJointLeft.rim2.R.T[2,1] * frontAxis.WheelJointLeft.rim2.e_x[2] + frontAxis.WheelJointLeft.rim2.R.T[3,1] * frontAxis.WheelJointLeft.rim2.e_x[3];
//   frontAxis.WheelJointLeft.rim2.rxvisobj[2] = frontAxis.WheelJointLeft.rim2.R.T[1,2] * frontAxis.WheelJointLeft.rim2.e_x[1] + frontAxis.WheelJointLeft.rim2.R.T[2,2] * frontAxis.WheelJointLeft.rim2.e_x[2] + frontAxis.WheelJointLeft.rim2.R.T[3,2] * frontAxis.WheelJointLeft.rim2.e_x[3];
//   frontAxis.WheelJointLeft.rim2.rxvisobj[3] = frontAxis.WheelJointLeft.rim2.R.T[1,3] * frontAxis.WheelJointLeft.rim2.e_x[1] + frontAxis.WheelJointLeft.rim2.R.T[2,3] * frontAxis.WheelJointLeft.rim2.e_x[2] + frontAxis.WheelJointLeft.rim2.R.T[3,3] * frontAxis.WheelJointLeft.rim2.e_x[3];
//   frontAxis.WheelJointLeft.rim2.ryvisobj[1] = frontAxis.WheelJointLeft.rim2.R.T[1,1] * frontAxis.WheelJointLeft.rim2.e_y[1] + frontAxis.WheelJointLeft.rim2.R.T[2,1] * frontAxis.WheelJointLeft.rim2.e_y[2] + frontAxis.WheelJointLeft.rim2.R.T[3,1] * frontAxis.WheelJointLeft.rim2.e_y[3];
//   frontAxis.WheelJointLeft.rim2.ryvisobj[2] = frontAxis.WheelJointLeft.rim2.R.T[1,2] * frontAxis.WheelJointLeft.rim2.e_y[1] + frontAxis.WheelJointLeft.rim2.R.T[2,2] * frontAxis.WheelJointLeft.rim2.e_y[2] + frontAxis.WheelJointLeft.rim2.R.T[3,2] * frontAxis.WheelJointLeft.rim2.e_y[3];
//   frontAxis.WheelJointLeft.rim2.ryvisobj[3] = frontAxis.WheelJointLeft.rim2.R.T[1,3] * frontAxis.WheelJointLeft.rim2.e_y[1] + frontAxis.WheelJointLeft.rim2.R.T[2,3] * frontAxis.WheelJointLeft.rim2.e_y[2] + frontAxis.WheelJointLeft.rim2.R.T[3,3] * frontAxis.WheelJointLeft.rim2.e_y[3];
//   frontAxis.WheelJointLeft.rim2.rvisobj = frontAxis.WheelJointLeft.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointLeft.rim2.R.T[1,1],frontAxis.WheelJointLeft.rim2.R.T[1,2],frontAxis.WheelJointLeft.rim2.R.T[1,3]},{frontAxis.WheelJointLeft.rim2.R.T[2,1],frontAxis.WheelJointLeft.rim2.R.T[2,2],frontAxis.WheelJointLeft.rim2.R.T[2,3]},{frontAxis.WheelJointLeft.rim2.R.T[3,1],frontAxis.WheelJointLeft.rim2.R.T[3,2],frontAxis.WheelJointLeft.rim2.R.T[3,3]}},{frontAxis.WheelJointLeft.rim2.r_shape[1],frontAxis.WheelJointLeft.rim2.r_shape[2],frontAxis.WheelJointLeft.rim2.r_shape[3]});
//   frontAxis.WheelJointLeft.rim2.size[1] = frontAxis.WheelJointLeft.rim2.length;
//   frontAxis.WheelJointLeft.rim2.size[2] = frontAxis.WheelJointLeft.rim2.width;
//   frontAxis.WheelJointLeft.rim2.size[3] = frontAxis.WheelJointLeft.rim2.height;
//   frontAxis.WheelJointLeft.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointLeft.rim2.color[1] / 255.0,frontAxis.WheelJointLeft.rim2.color[2] / 255.0,frontAxis.WheelJointLeft.rim2.color[3] / 255.0,frontAxis.WheelJointLeft.rim2.specularCoefficient);
//   frontAxis.WheelJointLeft.rim2.Extra = frontAxis.WheelJointLeft.rim2.extra;
//   frontAxis.WheelJointLeft.R[1,1] = cos(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.R[1,2] = sin(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.R[2,1] = -sin(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.R[2,2] = cos(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.e0[1] = frontAxis.WheelJointLeft.R[1,1] * frontAxis.WheelJointLeft.e[1] + frontAxis.WheelJointLeft.R[1,2] * frontAxis.WheelJointLeft.e[2];
//   frontAxis.WheelJointLeft.e0[2] = frontAxis.WheelJointLeft.R[2,1] * frontAxis.WheelJointLeft.e[1] + frontAxis.WheelJointLeft.R[2,2] * frontAxis.WheelJointLeft.e[2];
//   frontAxis.WheelJointLeft.v[1] = der(frontAxis.WheelJointLeft.frame_a.x);
//   frontAxis.WheelJointLeft.v[2] = der(frontAxis.WheelJointLeft.frame_a.y);
//   frontAxis.WheelJointLeft.w_roll = der(frontAxis.WheelJointLeft.flange_a.phi);
//   frontAxis.WheelJointLeft.v_long = frontAxis.WheelJointLeft.v[1] * frontAxis.WheelJointLeft.e0[1] + frontAxis.WheelJointLeft.v[2] * frontAxis.WheelJointLeft.e0[2];
//   frontAxis.WheelJointLeft.v_lat = (-frontAxis.WheelJointLeft.v[1]) * frontAxis.WheelJointLeft.e0[2] + frontAxis.WheelJointLeft.v[2] * frontAxis.WheelJointLeft.e0[1];
//   frontAxis.WheelJointLeft.v_slip_lat = frontAxis.WheelJointLeft.v_lat;
//   frontAxis.WheelJointLeft.v_slip_long = frontAxis.WheelJointLeft.v_long - frontAxis.WheelJointLeft.radius * frontAxis.WheelJointLeft.w_roll;
//   frontAxis.WheelJointLeft.v_slip = 0.0001 + sqrt(frontAxis.WheelJointLeft.v_slip_long ^ 2.0 + frontAxis.WheelJointLeft.v_slip_lat ^ 2.0);
//   (-frontAxis.WheelJointLeft.f_long) * frontAxis.WheelJointLeft.radius = frontAxis.WheelJointLeft.flange_a.tau;
//   frontAxis.WheelJointLeft.frame_a.t = 0.0;
//   frontAxis.WheelJointLeft.f = frontAxis.WheelJointLeft.N * PlanarMechanicsV4.Utilities.TripleS_Func(frontAxis.WheelJointLeft.vAdhesion,frontAxis.WheelJointLeft.vSlide,frontAxis.WheelJointLeft.mu_A,frontAxis.WheelJointLeft.mu_S,frontAxis.WheelJointLeft.v_slip);
//   frontAxis.WheelJointLeft.f_long = (frontAxis.WheelJointLeft.f * frontAxis.WheelJointLeft.v_slip_long) / frontAxis.WheelJointLeft.v_slip;
//   frontAxis.WheelJointLeft.f_lat = (frontAxis.WheelJointLeft.f * frontAxis.WheelJointLeft.v_slip_lat) / frontAxis.WheelJointLeft.v_slip;
//   frontAxis.WheelJointLeft.f_long = frontAxis.WheelJointLeft.frame_a.fx * frontAxis.WheelJointLeft.e0[1] + frontAxis.WheelJointLeft.frame_a.fy * frontAxis.WheelJointLeft.e0[2];
//   frontAxis.WheelJointLeft.f_lat = frontAxis.WheelJointLeft.frame_a.fy * frontAxis.WheelJointLeft.e0[1] + (-frontAxis.WheelJointLeft.frame_a.fx) * frontAxis.WheelJointLeft.e0[2];
//   frontAxis.WheelJointRight.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointRight.cylinder.shapeType);
//   frontAxis.WheelJointRight.cylinder.rxvisobj[1] = frontAxis.WheelJointRight.cylinder.R.T[1,1] * frontAxis.WheelJointRight.cylinder.e_x[1] + frontAxis.WheelJointRight.cylinder.R.T[2,1] * frontAxis.WheelJointRight.cylinder.e_x[2] + frontAxis.WheelJointRight.cylinder.R.T[3,1] * frontAxis.WheelJointRight.cylinder.e_x[3];
//   frontAxis.WheelJointRight.cylinder.rxvisobj[2] = frontAxis.WheelJointRight.cylinder.R.T[1,2] * frontAxis.WheelJointRight.cylinder.e_x[1] + frontAxis.WheelJointRight.cylinder.R.T[2,2] * frontAxis.WheelJointRight.cylinder.e_x[2] + frontAxis.WheelJointRight.cylinder.R.T[3,2] * frontAxis.WheelJointRight.cylinder.e_x[3];
//   frontAxis.WheelJointRight.cylinder.rxvisobj[3] = frontAxis.WheelJointRight.cylinder.R.T[1,3] * frontAxis.WheelJointRight.cylinder.e_x[1] + frontAxis.WheelJointRight.cylinder.R.T[2,3] * frontAxis.WheelJointRight.cylinder.e_x[2] + frontAxis.WheelJointRight.cylinder.R.T[3,3] * frontAxis.WheelJointRight.cylinder.e_x[3];
//   frontAxis.WheelJointRight.cylinder.ryvisobj[1] = frontAxis.WheelJointRight.cylinder.R.T[1,1] * frontAxis.WheelJointRight.cylinder.e_y[1] + frontAxis.WheelJointRight.cylinder.R.T[2,1] * frontAxis.WheelJointRight.cylinder.e_y[2] + frontAxis.WheelJointRight.cylinder.R.T[3,1] * frontAxis.WheelJointRight.cylinder.e_y[3];
//   frontAxis.WheelJointRight.cylinder.ryvisobj[2] = frontAxis.WheelJointRight.cylinder.R.T[1,2] * frontAxis.WheelJointRight.cylinder.e_y[1] + frontAxis.WheelJointRight.cylinder.R.T[2,2] * frontAxis.WheelJointRight.cylinder.e_y[2] + frontAxis.WheelJointRight.cylinder.R.T[3,2] * frontAxis.WheelJointRight.cylinder.e_y[3];
//   frontAxis.WheelJointRight.cylinder.ryvisobj[3] = frontAxis.WheelJointRight.cylinder.R.T[1,3] * frontAxis.WheelJointRight.cylinder.e_y[1] + frontAxis.WheelJointRight.cylinder.R.T[2,3] * frontAxis.WheelJointRight.cylinder.e_y[2] + frontAxis.WheelJointRight.cylinder.R.T[3,3] * frontAxis.WheelJointRight.cylinder.e_y[3];
//   frontAxis.WheelJointRight.cylinder.rvisobj = frontAxis.WheelJointRight.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointRight.cylinder.R.T[1,1],frontAxis.WheelJointRight.cylinder.R.T[1,2],frontAxis.WheelJointRight.cylinder.R.T[1,3]},{frontAxis.WheelJointRight.cylinder.R.T[2,1],frontAxis.WheelJointRight.cylinder.R.T[2,2],frontAxis.WheelJointRight.cylinder.R.T[2,3]},{frontAxis.WheelJointRight.cylinder.R.T[3,1],frontAxis.WheelJointRight.cylinder.R.T[3,2],frontAxis.WheelJointRight.cylinder.R.T[3,3]}},{frontAxis.WheelJointRight.cylinder.r_shape[1],frontAxis.WheelJointRight.cylinder.r_shape[2],frontAxis.WheelJointRight.cylinder.r_shape[3]});
//   frontAxis.WheelJointRight.cylinder.size[1] = frontAxis.WheelJointRight.cylinder.length;
//   frontAxis.WheelJointRight.cylinder.size[2] = frontAxis.WheelJointRight.cylinder.width;
//   frontAxis.WheelJointRight.cylinder.size[3] = frontAxis.WheelJointRight.cylinder.height;
//   frontAxis.WheelJointRight.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointRight.cylinder.color[1] / 255.0,frontAxis.WheelJointRight.cylinder.color[2] / 255.0,frontAxis.WheelJointRight.cylinder.color[3] / 255.0,frontAxis.WheelJointRight.cylinder.specularCoefficient);
//   frontAxis.WheelJointRight.cylinder.Extra = frontAxis.WheelJointRight.cylinder.extra;
//   frontAxis.WheelJointRight.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointRight.e0[2],frontAxis.WheelJointRight.e0[1],0.0},frontAxis.WheelJointRight.flange_a.phi,0.0);
//   frontAxis.WheelJointRight.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointRight.rim1.shapeType);
//   frontAxis.WheelJointRight.rim1.rxvisobj[1] = frontAxis.WheelJointRight.rim1.R.T[1,1] * frontAxis.WheelJointRight.rim1.e_x[1] + frontAxis.WheelJointRight.rim1.R.T[2,1] * frontAxis.WheelJointRight.rim1.e_x[2] + frontAxis.WheelJointRight.rim1.R.T[3,1] * frontAxis.WheelJointRight.rim1.e_x[3];
//   frontAxis.WheelJointRight.rim1.rxvisobj[2] = frontAxis.WheelJointRight.rim1.R.T[1,2] * frontAxis.WheelJointRight.rim1.e_x[1] + frontAxis.WheelJointRight.rim1.R.T[2,2] * frontAxis.WheelJointRight.rim1.e_x[2] + frontAxis.WheelJointRight.rim1.R.T[3,2] * frontAxis.WheelJointRight.rim1.e_x[3];
//   frontAxis.WheelJointRight.rim1.rxvisobj[3] = frontAxis.WheelJointRight.rim1.R.T[1,3] * frontAxis.WheelJointRight.rim1.e_x[1] + frontAxis.WheelJointRight.rim1.R.T[2,3] * frontAxis.WheelJointRight.rim1.e_x[2] + frontAxis.WheelJointRight.rim1.R.T[3,3] * frontAxis.WheelJointRight.rim1.e_x[3];
//   frontAxis.WheelJointRight.rim1.ryvisobj[1] = frontAxis.WheelJointRight.rim1.R.T[1,1] * frontAxis.WheelJointRight.rim1.e_y[1] + frontAxis.WheelJointRight.rim1.R.T[2,1] * frontAxis.WheelJointRight.rim1.e_y[2] + frontAxis.WheelJointRight.rim1.R.T[3,1] * frontAxis.WheelJointRight.rim1.e_y[3];
//   frontAxis.WheelJointRight.rim1.ryvisobj[2] = frontAxis.WheelJointRight.rim1.R.T[1,2] * frontAxis.WheelJointRight.rim1.e_y[1] + frontAxis.WheelJointRight.rim1.R.T[2,2] * frontAxis.WheelJointRight.rim1.e_y[2] + frontAxis.WheelJointRight.rim1.R.T[3,2] * frontAxis.WheelJointRight.rim1.e_y[3];
//   frontAxis.WheelJointRight.rim1.ryvisobj[3] = frontAxis.WheelJointRight.rim1.R.T[1,3] * frontAxis.WheelJointRight.rim1.e_y[1] + frontAxis.WheelJointRight.rim1.R.T[2,3] * frontAxis.WheelJointRight.rim1.e_y[2] + frontAxis.WheelJointRight.rim1.R.T[3,3] * frontAxis.WheelJointRight.rim1.e_y[3];
//   frontAxis.WheelJointRight.rim1.rvisobj = frontAxis.WheelJointRight.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointRight.rim1.R.T[1,1],frontAxis.WheelJointRight.rim1.R.T[1,2],frontAxis.WheelJointRight.rim1.R.T[1,3]},{frontAxis.WheelJointRight.rim1.R.T[2,1],frontAxis.WheelJointRight.rim1.R.T[2,2],frontAxis.WheelJointRight.rim1.R.T[2,3]},{frontAxis.WheelJointRight.rim1.R.T[3,1],frontAxis.WheelJointRight.rim1.R.T[3,2],frontAxis.WheelJointRight.rim1.R.T[3,3]}},{frontAxis.WheelJointRight.rim1.r_shape[1],frontAxis.WheelJointRight.rim1.r_shape[2],frontAxis.WheelJointRight.rim1.r_shape[3]});
//   frontAxis.WheelJointRight.rim1.size[1] = frontAxis.WheelJointRight.rim1.length;
//   frontAxis.WheelJointRight.rim1.size[2] = frontAxis.WheelJointRight.rim1.width;
//   frontAxis.WheelJointRight.rim1.size[3] = frontAxis.WheelJointRight.rim1.height;
//   frontAxis.WheelJointRight.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointRight.rim1.color[1] / 255.0,frontAxis.WheelJointRight.rim1.color[2] / 255.0,frontAxis.WheelJointRight.rim1.color[3] / 255.0,frontAxis.WheelJointRight.rim1.specularCoefficient);
//   frontAxis.WheelJointRight.rim1.Extra = frontAxis.WheelJointRight.rim1.extra;
//   frontAxis.WheelJointRight.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointRight.e0[2],frontAxis.WheelJointRight.e0[1],0.0},1.5707963267949 + frontAxis.WheelJointRight.flange_a.phi,0.0);
//   frontAxis.WheelJointRight.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointRight.rim2.shapeType);
//   frontAxis.WheelJointRight.rim2.rxvisobj[1] = frontAxis.WheelJointRight.rim2.R.T[1,1] * frontAxis.WheelJointRight.rim2.e_x[1] + frontAxis.WheelJointRight.rim2.R.T[2,1] * frontAxis.WheelJointRight.rim2.e_x[2] + frontAxis.WheelJointRight.rim2.R.T[3,1] * frontAxis.WheelJointRight.rim2.e_x[3];
//   frontAxis.WheelJointRight.rim2.rxvisobj[2] = frontAxis.WheelJointRight.rim2.R.T[1,2] * frontAxis.WheelJointRight.rim2.e_x[1] + frontAxis.WheelJointRight.rim2.R.T[2,2] * frontAxis.WheelJointRight.rim2.e_x[2] + frontAxis.WheelJointRight.rim2.R.T[3,2] * frontAxis.WheelJointRight.rim2.e_x[3];
//   frontAxis.WheelJointRight.rim2.rxvisobj[3] = frontAxis.WheelJointRight.rim2.R.T[1,3] * frontAxis.WheelJointRight.rim2.e_x[1] + frontAxis.WheelJointRight.rim2.R.T[2,3] * frontAxis.WheelJointRight.rim2.e_x[2] + frontAxis.WheelJointRight.rim2.R.T[3,3] * frontAxis.WheelJointRight.rim2.e_x[3];
//   frontAxis.WheelJointRight.rim2.ryvisobj[1] = frontAxis.WheelJointRight.rim2.R.T[1,1] * frontAxis.WheelJointRight.rim2.e_y[1] + frontAxis.WheelJointRight.rim2.R.T[2,1] * frontAxis.WheelJointRight.rim2.e_y[2] + frontAxis.WheelJointRight.rim2.R.T[3,1] * frontAxis.WheelJointRight.rim2.e_y[3];
//   frontAxis.WheelJointRight.rim2.ryvisobj[2] = frontAxis.WheelJointRight.rim2.R.T[1,2] * frontAxis.WheelJointRight.rim2.e_y[1] + frontAxis.WheelJointRight.rim2.R.T[2,2] * frontAxis.WheelJointRight.rim2.e_y[2] + frontAxis.WheelJointRight.rim2.R.T[3,2] * frontAxis.WheelJointRight.rim2.e_y[3];
//   frontAxis.WheelJointRight.rim2.ryvisobj[3] = frontAxis.WheelJointRight.rim2.R.T[1,3] * frontAxis.WheelJointRight.rim2.e_y[1] + frontAxis.WheelJointRight.rim2.R.T[2,3] * frontAxis.WheelJointRight.rim2.e_y[2] + frontAxis.WheelJointRight.rim2.R.T[3,3] * frontAxis.WheelJointRight.rim2.e_y[3];
//   frontAxis.WheelJointRight.rim2.rvisobj = frontAxis.WheelJointRight.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointRight.rim2.R.T[1,1],frontAxis.WheelJointRight.rim2.R.T[1,2],frontAxis.WheelJointRight.rim2.R.T[1,3]},{frontAxis.WheelJointRight.rim2.R.T[2,1],frontAxis.WheelJointRight.rim2.R.T[2,2],frontAxis.WheelJointRight.rim2.R.T[2,3]},{frontAxis.WheelJointRight.rim2.R.T[3,1],frontAxis.WheelJointRight.rim2.R.T[3,2],frontAxis.WheelJointRight.rim2.R.T[3,3]}},{frontAxis.WheelJointRight.rim2.r_shape[1],frontAxis.WheelJointRight.rim2.r_shape[2],frontAxis.WheelJointRight.rim2.r_shape[3]});
//   frontAxis.WheelJointRight.rim2.size[1] = frontAxis.WheelJointRight.rim2.length;
//   frontAxis.WheelJointRight.rim2.size[2] = frontAxis.WheelJointRight.rim2.width;
//   frontAxis.WheelJointRight.rim2.size[3] = frontAxis.WheelJointRight.rim2.height;
//   frontAxis.WheelJointRight.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointRight.rim2.color[1] / 255.0,frontAxis.WheelJointRight.rim2.color[2] / 255.0,frontAxis.WheelJointRight.rim2.color[3] / 255.0,frontAxis.WheelJointRight.rim2.specularCoefficient);
//   frontAxis.WheelJointRight.rim2.Extra = frontAxis.WheelJointRight.rim2.extra;
//   frontAxis.WheelJointRight.R[1,1] = cos(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.R[1,2] = sin(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.R[2,1] = -sin(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.R[2,2] = cos(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.e0[1] = frontAxis.WheelJointRight.R[1,1] * frontAxis.WheelJointRight.e[1] + frontAxis.WheelJointRight.R[1,2] * frontAxis.WheelJointRight.e[2];
//   frontAxis.WheelJointRight.e0[2] = frontAxis.WheelJointRight.R[2,1] * frontAxis.WheelJointRight.e[1] + frontAxis.WheelJointRight.R[2,2] * frontAxis.WheelJointRight.e[2];
//   frontAxis.WheelJointRight.v[1] = der(frontAxis.WheelJointRight.frame_a.x);
//   frontAxis.WheelJointRight.v[2] = der(frontAxis.WheelJointRight.frame_a.y);
//   frontAxis.WheelJointRight.w_roll = der(frontAxis.WheelJointRight.flange_a.phi);
//   frontAxis.WheelJointRight.v_long = frontAxis.WheelJointRight.v[1] * frontAxis.WheelJointRight.e0[1] + frontAxis.WheelJointRight.v[2] * frontAxis.WheelJointRight.e0[2];
//   frontAxis.WheelJointRight.v_lat = (-frontAxis.WheelJointRight.v[1]) * frontAxis.WheelJointRight.e0[2] + frontAxis.WheelJointRight.v[2] * frontAxis.WheelJointRight.e0[1];
//   frontAxis.WheelJointRight.v_slip_lat = frontAxis.WheelJointRight.v_lat;
//   frontAxis.WheelJointRight.v_slip_long = frontAxis.WheelJointRight.v_long - frontAxis.WheelJointRight.radius * frontAxis.WheelJointRight.w_roll;
//   frontAxis.WheelJointRight.v_slip = 0.0001 + sqrt(frontAxis.WheelJointRight.v_slip_long ^ 2.0 + frontAxis.WheelJointRight.v_slip_lat ^ 2.0);
//   (-frontAxis.WheelJointRight.f_long) * frontAxis.WheelJointRight.radius = frontAxis.WheelJointRight.flange_a.tau;
//   frontAxis.WheelJointRight.frame_a.t = 0.0;
//   frontAxis.WheelJointRight.f = frontAxis.WheelJointRight.N * PlanarMechanicsV4.Utilities.TripleS_Func(frontAxis.WheelJointRight.vAdhesion,frontAxis.WheelJointRight.vSlide,frontAxis.WheelJointRight.mu_A,frontAxis.WheelJointRight.mu_S,frontAxis.WheelJointRight.v_slip);
//   frontAxis.WheelJointRight.f_long = (frontAxis.WheelJointRight.f * frontAxis.WheelJointRight.v_slip_long) / frontAxis.WheelJointRight.v_slip;
//   frontAxis.WheelJointRight.f_lat = (frontAxis.WheelJointRight.f * frontAxis.WheelJointRight.v_slip_lat) / frontAxis.WheelJointRight.v_slip;
//   frontAxis.WheelJointRight.f_long = frontAxis.WheelJointRight.frame_a.fx * frontAxis.WheelJointRight.e0[1] + frontAxis.WheelJointRight.frame_a.fy * frontAxis.WheelJointRight.e0[2];
//   frontAxis.WheelJointRight.f_lat = frontAxis.WheelJointRight.frame_a.fy * frontAxis.WheelJointRight.e0[1] + (-frontAxis.WheelJointRight.frame_a.fx) * frontAxis.WheelJointRight.e0[2];
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   torque1.flange.tau = -torque1.tau;
//   torque1.phi_support = 0.0;
//   simpleChassis.fixedTranslationFront.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis.fixedTranslationFront.cylinder.shapeType);
//   simpleChassis.fixedTranslationFront.cylinder.rxvisobj[1] = simpleChassis.fixedTranslationFront.cylinder.R.T[1,1] * simpleChassis.fixedTranslationFront.cylinder.e_x[1] + simpleChassis.fixedTranslationFront.cylinder.R.T[2,1] * simpleChassis.fixedTranslationFront.cylinder.e_x[2] + simpleChassis.fixedTranslationFront.cylinder.R.T[3,1] * simpleChassis.fixedTranslationFront.cylinder.e_x[3];
//   simpleChassis.fixedTranslationFront.cylinder.rxvisobj[2] = simpleChassis.fixedTranslationFront.cylinder.R.T[1,2] * simpleChassis.fixedTranslationFront.cylinder.e_x[1] + simpleChassis.fixedTranslationFront.cylinder.R.T[2,2] * simpleChassis.fixedTranslationFront.cylinder.e_x[2] + simpleChassis.fixedTranslationFront.cylinder.R.T[3,2] * simpleChassis.fixedTranslationFront.cylinder.e_x[3];
//   simpleChassis.fixedTranslationFront.cylinder.rxvisobj[3] = simpleChassis.fixedTranslationFront.cylinder.R.T[1,3] * simpleChassis.fixedTranslationFront.cylinder.e_x[1] + simpleChassis.fixedTranslationFront.cylinder.R.T[2,3] * simpleChassis.fixedTranslationFront.cylinder.e_x[2] + simpleChassis.fixedTranslationFront.cylinder.R.T[3,3] * simpleChassis.fixedTranslationFront.cylinder.e_x[3];
//   simpleChassis.fixedTranslationFront.cylinder.ryvisobj[1] = simpleChassis.fixedTranslationFront.cylinder.R.T[1,1] * simpleChassis.fixedTranslationFront.cylinder.e_y[1] + simpleChassis.fixedTranslationFront.cylinder.R.T[2,1] * simpleChassis.fixedTranslationFront.cylinder.e_y[2] + simpleChassis.fixedTranslationFront.cylinder.R.T[3,1] * simpleChassis.fixedTranslationFront.cylinder.e_y[3];
//   simpleChassis.fixedTranslationFront.cylinder.ryvisobj[2] = simpleChassis.fixedTranslationFront.cylinder.R.T[1,2] * simpleChassis.fixedTranslationFront.cylinder.e_y[1] + simpleChassis.fixedTranslationFront.cylinder.R.T[2,2] * simpleChassis.fixedTranslationFront.cylinder.e_y[2] + simpleChassis.fixedTranslationFront.cylinder.R.T[3,2] * simpleChassis.fixedTranslationFront.cylinder.e_y[3];
//   simpleChassis.fixedTranslationFront.cylinder.ryvisobj[3] = simpleChassis.fixedTranslationFront.cylinder.R.T[1,3] * simpleChassis.fixedTranslationFront.cylinder.e_y[1] + simpleChassis.fixedTranslationFront.cylinder.R.T[2,3] * simpleChassis.fixedTranslationFront.cylinder.e_y[2] + simpleChassis.fixedTranslationFront.cylinder.R.T[3,3] * simpleChassis.fixedTranslationFront.cylinder.e_y[3];
//   simpleChassis.fixedTranslationFront.cylinder.rvisobj = simpleChassis.fixedTranslationFront.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis.fixedTranslationFront.cylinder.R.T[1,1],simpleChassis.fixedTranslationFront.cylinder.R.T[1,2],simpleChassis.fixedTranslationFront.cylinder.R.T[1,3]},{simpleChassis.fixedTranslationFront.cylinder.R.T[2,1],simpleChassis.fixedTranslationFront.cylinder.R.T[2,2],simpleChassis.fixedTranslationFront.cylinder.R.T[2,3]},{simpleChassis.fixedTranslationFront.cylinder.R.T[3,1],simpleChassis.fixedTranslationFront.cylinder.R.T[3,2],simpleChassis.fixedTranslationFront.cylinder.R.T[3,3]}},{simpleChassis.fixedTranslationFront.cylinder.r_shape[1],simpleChassis.fixedTranslationFront.cylinder.r_shape[2],simpleChassis.fixedTranslationFront.cylinder.r_shape[3]});
//   simpleChassis.fixedTranslationFront.cylinder.size[1] = simpleChassis.fixedTranslationFront.cylinder.length;
//   simpleChassis.fixedTranslationFront.cylinder.size[2] = simpleChassis.fixedTranslationFront.cylinder.width;
//   simpleChassis.fixedTranslationFront.cylinder.size[3] = simpleChassis.fixedTranslationFront.cylinder.height;
//   simpleChassis.fixedTranslationFront.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis.fixedTranslationFront.cylinder.color[1] / 255.0,simpleChassis.fixedTranslationFront.cylinder.color[2] / 255.0,simpleChassis.fixedTranslationFront.cylinder.color[3] / 255.0,simpleChassis.fixedTranslationFront.cylinder.specularCoefficient);
//   simpleChassis.fixedTranslationFront.cylinder.Extra = simpleChassis.fixedTranslationFront.cylinder.extra;
//   simpleChassis.fixedTranslationFront.R[1,1] = cos(simpleChassis.fixedTranslationFront.frame_a.phi);
//   simpleChassis.fixedTranslationFront.R[1,2] = sin(simpleChassis.fixedTranslationFront.frame_a.phi);
//   simpleChassis.fixedTranslationFront.R[2,1] = -sin(simpleChassis.fixedTranslationFront.frame_a.phi);
//   simpleChassis.fixedTranslationFront.R[2,2] = cos(simpleChassis.fixedTranslationFront.frame_a.phi);
//   simpleChassis.fixedTranslationFront.r0[1] = simpleChassis.fixedTranslationFront.R[1,1] * simpleChassis.fixedTranslationFront.r[1] + simpleChassis.fixedTranslationFront.R[1,2] * simpleChassis.fixedTranslationFront.r[2];
//   simpleChassis.fixedTranslationFront.r0[2] = simpleChassis.fixedTranslationFront.R[2,1] * simpleChassis.fixedTranslationFront.r[1] + simpleChassis.fixedTranslationFront.R[2,2] * simpleChassis.fixedTranslationFront.r[2];
//   simpleChassis.fixedTranslationFront.frame_a.x + simpleChassis.fixedTranslationFront.r0[1] = simpleChassis.fixedTranslationFront.frame_b.x;
//   simpleChassis.fixedTranslationFront.frame_a.y + simpleChassis.fixedTranslationFront.r0[2] = simpleChassis.fixedTranslationFront.frame_b.y;
//   simpleChassis.fixedTranslationFront.frame_a.phi = simpleChassis.fixedTranslationFront.frame_b.phi;
//   simpleChassis.fixedTranslationFront.frame_a.fx + simpleChassis.fixedTranslationFront.frame_b.fx = 0.0;
//   simpleChassis.fixedTranslationFront.frame_a.fy + simpleChassis.fixedTranslationFront.frame_b.fy = 0.0;
//   simpleChassis.fixedTranslationFront.frame_a.t + (simpleChassis.fixedTranslationFront.frame_b.t + ((-simpleChassis.fixedTranslationFront.r0[1]) * simpleChassis.fixedTranslationFront.frame_b.fy + simpleChassis.fixedTranslationFront.r0[2] * simpleChassis.fixedTranslationFront.frame_b.fx)) = 0.0;
//   simpleChassis.fixedTranslationRear.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis.fixedTranslationRear.cylinder.shapeType);
//   simpleChassis.fixedTranslationRear.cylinder.rxvisobj[1] = simpleChassis.fixedTranslationRear.cylinder.R.T[1,1] * simpleChassis.fixedTranslationRear.cylinder.e_x[1] + simpleChassis.fixedTranslationRear.cylinder.R.T[2,1] * simpleChassis.fixedTranslationRear.cylinder.e_x[2] + simpleChassis.fixedTranslationRear.cylinder.R.T[3,1] * simpleChassis.fixedTranslationRear.cylinder.e_x[3];
//   simpleChassis.fixedTranslationRear.cylinder.rxvisobj[2] = simpleChassis.fixedTranslationRear.cylinder.R.T[1,2] * simpleChassis.fixedTranslationRear.cylinder.e_x[1] + simpleChassis.fixedTranslationRear.cylinder.R.T[2,2] * simpleChassis.fixedTranslationRear.cylinder.e_x[2] + simpleChassis.fixedTranslationRear.cylinder.R.T[3,2] * simpleChassis.fixedTranslationRear.cylinder.e_x[3];
//   simpleChassis.fixedTranslationRear.cylinder.rxvisobj[3] = simpleChassis.fixedTranslationRear.cylinder.R.T[1,3] * simpleChassis.fixedTranslationRear.cylinder.e_x[1] + simpleChassis.fixedTranslationRear.cylinder.R.T[2,3] * simpleChassis.fixedTranslationRear.cylinder.e_x[2] + simpleChassis.fixedTranslationRear.cylinder.R.T[3,3] * simpleChassis.fixedTranslationRear.cylinder.e_x[3];
//   simpleChassis.fixedTranslationRear.cylinder.ryvisobj[1] = simpleChassis.fixedTranslationRear.cylinder.R.T[1,1] * simpleChassis.fixedTranslationRear.cylinder.e_y[1] + simpleChassis.fixedTranslationRear.cylinder.R.T[2,1] * simpleChassis.fixedTranslationRear.cylinder.e_y[2] + simpleChassis.fixedTranslationRear.cylinder.R.T[3,1] * simpleChassis.fixedTranslationRear.cylinder.e_y[3];
//   simpleChassis.fixedTranslationRear.cylinder.ryvisobj[2] = simpleChassis.fixedTranslationRear.cylinder.R.T[1,2] * simpleChassis.fixedTranslationRear.cylinder.e_y[1] + simpleChassis.fixedTranslationRear.cylinder.R.T[2,2] * simpleChassis.fixedTranslationRear.cylinder.e_y[2] + simpleChassis.fixedTranslationRear.cylinder.R.T[3,2] * simpleChassis.fixedTranslationRear.cylinder.e_y[3];
//   simpleChassis.fixedTranslationRear.cylinder.ryvisobj[3] = simpleChassis.fixedTranslationRear.cylinder.R.T[1,3] * simpleChassis.fixedTranslationRear.cylinder.e_y[1] + simpleChassis.fixedTranslationRear.cylinder.R.T[2,3] * simpleChassis.fixedTranslationRear.cylinder.e_y[2] + simpleChassis.fixedTranslationRear.cylinder.R.T[3,3] * simpleChassis.fixedTranslationRear.cylinder.e_y[3];
//   simpleChassis.fixedTranslationRear.cylinder.rvisobj = simpleChassis.fixedTranslationRear.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis.fixedTranslationRear.cylinder.R.T[1,1],simpleChassis.fixedTranslationRear.cylinder.R.T[1,2],simpleChassis.fixedTranslationRear.cylinder.R.T[1,3]},{simpleChassis.fixedTranslationRear.cylinder.R.T[2,1],simpleChassis.fixedTranslationRear.cylinder.R.T[2,2],simpleChassis.fixedTranslationRear.cylinder.R.T[2,3]},{simpleChassis.fixedTranslationRear.cylinder.R.T[3,1],simpleChassis.fixedTranslationRear.cylinder.R.T[3,2],simpleChassis.fixedTranslationRear.cylinder.R.T[3,3]}},{simpleChassis.fixedTranslationRear.cylinder.r_shape[1],simpleChassis.fixedTranslationRear.cylinder.r_shape[2],simpleChassis.fixedTranslationRear.cylinder.r_shape[3]});
//   simpleChassis.fixedTranslationRear.cylinder.size[1] = simpleChassis.fixedTranslationRear.cylinder.length;
//   simpleChassis.fixedTranslationRear.cylinder.size[2] = simpleChassis.fixedTranslationRear.cylinder.width;
//   simpleChassis.fixedTranslationRear.cylinder.size[3] = simpleChassis.fixedTranslationRear.cylinder.height;
//   simpleChassis.fixedTranslationRear.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis.fixedTranslationRear.cylinder.color[1] / 255.0,simpleChassis.fixedTranslationRear.cylinder.color[2] / 255.0,simpleChassis.fixedTranslationRear.cylinder.color[3] / 255.0,simpleChassis.fixedTranslationRear.cylinder.specularCoefficient);
//   simpleChassis.fixedTranslationRear.cylinder.Extra = simpleChassis.fixedTranslationRear.cylinder.extra;
//   simpleChassis.fixedTranslationRear.R[1,1] = cos(simpleChassis.fixedTranslationRear.frame_a.phi);
//   simpleChassis.fixedTranslationRear.R[1,2] = sin(simpleChassis.fixedTranslationRear.frame_a.phi);
//   simpleChassis.fixedTranslationRear.R[2,1] = -sin(simpleChassis.fixedTranslationRear.frame_a.phi);
//   simpleChassis.fixedTranslationRear.R[2,2] = cos(simpleChassis.fixedTranslationRear.frame_a.phi);
//   simpleChassis.fixedTranslationRear.r0[1] = simpleChassis.fixedTranslationRear.R[1,1] * simpleChassis.fixedTranslationRear.r[1] + simpleChassis.fixedTranslationRear.R[1,2] * simpleChassis.fixedTranslationRear.r[2];
//   simpleChassis.fixedTranslationRear.r0[2] = simpleChassis.fixedTranslationRear.R[2,1] * simpleChassis.fixedTranslationRear.r[1] + simpleChassis.fixedTranslationRear.R[2,2] * simpleChassis.fixedTranslationRear.r[2];
//   simpleChassis.fixedTranslationRear.frame_a.x + simpleChassis.fixedTranslationRear.r0[1] = simpleChassis.fixedTranslationRear.frame_b.x;
//   simpleChassis.fixedTranslationRear.frame_a.y + simpleChassis.fixedTranslationRear.r0[2] = simpleChassis.fixedTranslationRear.frame_b.y;
//   simpleChassis.fixedTranslationRear.frame_a.phi = simpleChassis.fixedTranslationRear.frame_b.phi;
//   simpleChassis.fixedTranslationRear.frame_a.fx + simpleChassis.fixedTranslationRear.frame_b.fx = 0.0;
//   simpleChassis.fixedTranslationRear.frame_a.fy + simpleChassis.fixedTranslationRear.frame_b.fy = 0.0;
//   simpleChassis.fixedTranslationRear.frame_a.t + (simpleChassis.fixedTranslationRear.frame_b.t + ((-simpleChassis.fixedTranslationRear.r0[1]) * simpleChassis.fixedTranslationRear.frame_b.fy + simpleChassis.fixedTranslationRear.r0[2] * simpleChassis.fixedTranslationRear.frame_b.fx)) = 0.0;
//   simpleChassis.baseLoad.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis.baseLoad.sphere.shapeType);
//   simpleChassis.baseLoad.sphere.rxvisobj[1] = simpleChassis.baseLoad.sphere.R.T[1,1] * simpleChassis.baseLoad.sphere.e_x[1] + simpleChassis.baseLoad.sphere.R.T[2,1] * simpleChassis.baseLoad.sphere.e_x[2] + simpleChassis.baseLoad.sphere.R.T[3,1] * simpleChassis.baseLoad.sphere.e_x[3];
//   simpleChassis.baseLoad.sphere.rxvisobj[2] = simpleChassis.baseLoad.sphere.R.T[1,2] * simpleChassis.baseLoad.sphere.e_x[1] + simpleChassis.baseLoad.sphere.R.T[2,2] * simpleChassis.baseLoad.sphere.e_x[2] + simpleChassis.baseLoad.sphere.R.T[3,2] * simpleChassis.baseLoad.sphere.e_x[3];
//   simpleChassis.baseLoad.sphere.rxvisobj[3] = simpleChassis.baseLoad.sphere.R.T[1,3] * simpleChassis.baseLoad.sphere.e_x[1] + simpleChassis.baseLoad.sphere.R.T[2,3] * simpleChassis.baseLoad.sphere.e_x[2] + simpleChassis.baseLoad.sphere.R.T[3,3] * simpleChassis.baseLoad.sphere.e_x[3];
//   simpleChassis.baseLoad.sphere.ryvisobj[1] = simpleChassis.baseLoad.sphere.R.T[1,1] * simpleChassis.baseLoad.sphere.e_y[1] + simpleChassis.baseLoad.sphere.R.T[2,1] * simpleChassis.baseLoad.sphere.e_y[2] + simpleChassis.baseLoad.sphere.R.T[3,1] * simpleChassis.baseLoad.sphere.e_y[3];
//   simpleChassis.baseLoad.sphere.ryvisobj[2] = simpleChassis.baseLoad.sphere.R.T[1,2] * simpleChassis.baseLoad.sphere.e_y[1] + simpleChassis.baseLoad.sphere.R.T[2,2] * simpleChassis.baseLoad.sphere.e_y[2] + simpleChassis.baseLoad.sphere.R.T[3,2] * simpleChassis.baseLoad.sphere.e_y[3];
//   simpleChassis.baseLoad.sphere.ryvisobj[3] = simpleChassis.baseLoad.sphere.R.T[1,3] * simpleChassis.baseLoad.sphere.e_y[1] + simpleChassis.baseLoad.sphere.R.T[2,3] * simpleChassis.baseLoad.sphere.e_y[2] + simpleChassis.baseLoad.sphere.R.T[3,3] * simpleChassis.baseLoad.sphere.e_y[3];
//   simpleChassis.baseLoad.sphere.rvisobj = simpleChassis.baseLoad.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis.baseLoad.sphere.R.T[1,1],simpleChassis.baseLoad.sphere.R.T[1,2],simpleChassis.baseLoad.sphere.R.T[1,3]},{simpleChassis.baseLoad.sphere.R.T[2,1],simpleChassis.baseLoad.sphere.R.T[2,2],simpleChassis.baseLoad.sphere.R.T[2,3]},{simpleChassis.baseLoad.sphere.R.T[3,1],simpleChassis.baseLoad.sphere.R.T[3,2],simpleChassis.baseLoad.sphere.R.T[3,3]}},{simpleChassis.baseLoad.sphere.r_shape[1],simpleChassis.baseLoad.sphere.r_shape[2],simpleChassis.baseLoad.sphere.r_shape[3]});
//   simpleChassis.baseLoad.sphere.size[1] = simpleChassis.baseLoad.sphere.length;
//   simpleChassis.baseLoad.sphere.size[2] = simpleChassis.baseLoad.sphere.width;
//   simpleChassis.baseLoad.sphere.size[3] = simpleChassis.baseLoad.sphere.height;
//   simpleChassis.baseLoad.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis.baseLoad.sphere.color[1] / 255.0,simpleChassis.baseLoad.sphere.color[2] / 255.0,simpleChassis.baseLoad.sphere.color[3] / 255.0,simpleChassis.baseLoad.sphere.specularCoefficient);
//   simpleChassis.baseLoad.sphere.Extra = simpleChassis.baseLoad.sphere.extra;
//   simpleChassis.baseLoad.r[1] = simpleChassis.baseLoad.frame_a.x;
//   simpleChassis.baseLoad.r[2] = simpleChassis.baseLoad.frame_a.y;
//   simpleChassis.baseLoad.v[1] = der(simpleChassis.baseLoad.r[1]);
//   simpleChassis.baseLoad.v[2] = der(simpleChassis.baseLoad.r[2]);
//   simpleChassis.baseLoad.w = der(simpleChassis.baseLoad.frame_a.phi);
//   simpleChassis.baseLoad.a[1] = der(simpleChassis.baseLoad.v[1]);
//   simpleChassis.baseLoad.a[2] = der(simpleChassis.baseLoad.v[2]);
//   simpleChassis.baseLoad.z = der(simpleChassis.baseLoad.w);
//   simpleChassis.baseLoad.f[1] = simpleChassis.baseLoad.frame_a.fx;
//   simpleChassis.baseLoad.f[2] = simpleChassis.baseLoad.frame_a.fy;
//   simpleChassis.baseLoad.f[1] + simpleChassis.baseLoad.m * simpleChassis.baseLoad.g[1] = simpleChassis.baseLoad.m * simpleChassis.baseLoad.a[1];
//   simpleChassis.baseLoad.f[2] + simpleChassis.baseLoad.m * simpleChassis.baseLoad.g[2] = simpleChassis.baseLoad.m * simpleChassis.baseLoad.a[2];
//   simpleChassis.baseLoad.frame_a.t = simpleChassis.baseLoad.I * simpleChassis.baseLoad.z;
//   world.frame_b.t[1] = 0.0;
//   world.frame_b.t[2] = 0.0;
//   world.frame_b.t[3] = 0.0;
//   world.frame_b.f[1] = 0.0;
//   world.frame_b.f[2] = 0.0;
//   world.frame_b.f[3] = 0.0;
//   torque.flange.tau + rearAxis.flange_b.tau = 0.0;
//   rearAxis.frame_a.t + simpleChassis.frame_a.t = 0.0;
//   rearAxis.frame_a.fy + simpleChassis.frame_a.fy = 0.0;
//   rearAxis.frame_a.fx + simpleChassis.frame_a.fx = 0.0;
//   rearAxis.differentialGear.idealPlanetary.sun.tau + -rearAxis.differentialGear.flange_left.tau = 0.0;
//   rearAxis.differentialGear.idealPlanetary.carrier.tau + -rearAxis.differentialGear.flange_right.tau = 0.0;
//   rearAxis.differentialGear.idealPlanetary.ring.tau + -rearAxis.differentialGear.flange_b.tau = 0.0;
//   -rearAxis.flange_b.tau + rearAxis.differentialGear.flange_b.tau = 0.0;
//   rearAxis.differentialGear.flange_left.tau + rearAxis.inertia1.flange_b.tau + rearAxis.WheelJointLeft.flange_a.tau = 0.0;
//   rearAxis.differentialGear.flange_right.tau + rearAxis.inertia2.flange_b.tau + rearAxis.WheelJointRight.flange_a.tau = 0.0;
//   rearAxis.differentialGear.flange_b.phi = rearAxis.differentialGear.idealPlanetary.ring.phi;
//   rearAxis.differentialGear.flange_right.phi = rearAxis.differentialGear.idealPlanetary.carrier.phi;
//   rearAxis.differentialGear.flange_left.phi = rearAxis.differentialGear.idealPlanetary.sun.phi;
//   rearAxis.fixedTranslation2.frame_a.t + rearAxis.WheelJointLeft.frame_a.t = 0.0;
//   rearAxis.fixedTranslation2.frame_a.fy + rearAxis.WheelJointLeft.frame_a.fy = 0.0;
//   rearAxis.fixedTranslation2.frame_a.fx + rearAxis.WheelJointLeft.frame_a.fx = 0.0;
//   -rearAxis.frame_a.t + rearAxis.fixedTranslation2.frame_b.t + rearAxis.fixedTranslation1.frame_a.t = 0.0;
//   -rearAxis.frame_a.fy + rearAxis.fixedTranslation2.frame_b.fy + rearAxis.fixedTranslation1.frame_a.fy = 0.0;
//   -rearAxis.frame_a.fx + rearAxis.fixedTranslation2.frame_b.fx + rearAxis.fixedTranslation1.frame_a.fx = 0.0;
//   rearAxis.fixedTranslation1.frame_b.t + rearAxis.WheelJointRight.frame_a.t = 0.0;
//   rearAxis.fixedTranslation1.frame_b.fy + rearAxis.WheelJointRight.frame_a.fy = 0.0;
//   rearAxis.fixedTranslation1.frame_b.fx + rearAxis.WheelJointRight.frame_a.fx = 0.0;
//   rearAxis.inertia1.flange_a.tau = 0.0;
//   rearAxis.inertia2.flange_a.tau = 0.0;
//   rearAxis.WheelJointLeft.flange_a.phi = rearAxis.differentialGear.flange_left.phi;
//   rearAxis.WheelJointLeft.flange_a.phi = rearAxis.inertia1.flange_b.phi;
//   rearAxis.WheelJointLeft.frame_a.x = rearAxis.fixedTranslation2.frame_a.x;
//   rearAxis.WheelJointLeft.frame_a.y = rearAxis.fixedTranslation2.frame_a.y;
//   rearAxis.WheelJointLeft.frame_a.phi = rearAxis.fixedTranslation2.frame_a.phi;
//   rearAxis.WheelJointRight.flange_a.phi = rearAxis.differentialGear.flange_right.phi;
//   rearAxis.WheelJointRight.flange_a.phi = rearAxis.inertia2.flange_b.phi;
//   rearAxis.WheelJointRight.frame_a.x = rearAxis.fixedTranslation1.frame_b.x;
//   rearAxis.WheelJointRight.frame_a.y = rearAxis.fixedTranslation1.frame_b.y;
//   rearAxis.WheelJointRight.frame_a.phi = rearAxis.fixedTranslation1.frame_b.phi;
//   rearAxis.fixedTranslation1.frame_a.x = rearAxis.fixedTranslation2.frame_b.x;
//   rearAxis.fixedTranslation1.frame_a.x = rearAxis.frame_a.x;
//   rearAxis.fixedTranslation1.frame_a.y = rearAxis.fixedTranslation2.frame_b.y;
//   rearAxis.fixedTranslation1.frame_a.y = rearAxis.frame_a.y;
//   rearAxis.fixedTranslation1.frame_a.phi = rearAxis.fixedTranslation2.frame_b.phi;
//   rearAxis.fixedTranslation1.frame_a.phi = rearAxis.frame_a.phi;
//   rearAxis.differentialGear.flange_b.phi = rearAxis.flange_b.phi;
//   frontAxis.flange_b.tau + torque1.flange.tau = 0.0;
//   frontAxis.frame_a.t + simpleChassis.frame_b.t = 0.0;
//   frontAxis.frame_a.fy + simpleChassis.frame_b.fy = 0.0;
//   frontAxis.frame_a.fx + simpleChassis.frame_b.fx = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.t + frontAxis.leftTrail.frame_a.t = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.fy + frontAxis.leftTrail.frame_a.fy = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.fx + frontAxis.leftTrail.frame_a.fx = 0.0;
//   frontAxis.leftSteeringRevolute.frame_b.t + frontAxis.leftAxis.frame_a.t = 0.0;
//   frontAxis.leftSteeringRevolute.frame_b.fy + frontAxis.leftAxis.frame_a.fy = 0.0;
//   frontAxis.leftSteeringRevolute.frame_b.fx + frontAxis.leftAxis.frame_a.fx = 0.0;
//   frontAxis.leftSteeringRevolute.flange_a.tau + frontAxis.rightSteeringRevolute.flange_a.tau + frontAxis.SteeringInertia.flange_b.tau = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.t + frontAxis.rigthtTrail.frame_a.t = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.fy + frontAxis.rigthtTrail.frame_a.fy = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.fx + frontAxis.rigthtTrail.frame_a.fx = 0.0;
//   frontAxis.rightSteeringRevolute.frame_b.t + frontAxis.rightAxis.frame_b.t = 0.0;
//   frontAxis.rightSteeringRevolute.frame_b.fy + frontAxis.rightAxis.frame_b.fy = 0.0;
//   frontAxis.rightSteeringRevolute.frame_b.fx + frontAxis.rightAxis.frame_b.fx = 0.0;
//   -frontAxis.frame_a.t + frontAxis.leftAxis.frame_b.t + frontAxis.rightAxis.frame_a.t = 0.0;
//   -frontAxis.frame_a.fy + frontAxis.leftAxis.frame_b.fy + frontAxis.rightAxis.frame_a.fy = 0.0;
//   -frontAxis.frame_a.fx + frontAxis.leftAxis.frame_b.fx + frontAxis.rightAxis.frame_a.fx = 0.0;
//   frontAxis.leftTrail.frame_b.t + frontAxis.WheelJointLeft.frame_a.t = 0.0;
//   frontAxis.leftTrail.frame_b.fy + frontAxis.WheelJointLeft.frame_a.fy = 0.0;
//   frontAxis.leftTrail.frame_b.fx + frontAxis.WheelJointLeft.frame_a.fx = 0.0;
//   frontAxis.rigthtTrail.frame_b.t + frontAxis.WheelJointRight.frame_a.t = 0.0;
//   frontAxis.rigthtTrail.frame_b.fy + frontAxis.WheelJointRight.frame_a.fy = 0.0;
//   frontAxis.rigthtTrail.frame_b.fx + frontAxis.WheelJointRight.frame_a.fx = 0.0;
//   frontAxis.leftInertia.flange_a.tau = 0.0;
//   frontAxis.leftInertia.flange_b.tau + frontAxis.WheelJointLeft.flange_a.tau = 0.0;
//   frontAxis.rightInertia.flange_a.tau = 0.0;
//   frontAxis.rightInertia.flange_b.tau + frontAxis.WheelJointRight.flange_a.tau = 0.0;
//   -frontAxis.flange_b.tau + frontAxis.SteeringInertia.flange_a.tau = 0.0;
//   frontAxis.WheelJointLeft.flange_a.phi = frontAxis.leftInertia.flange_b.phi;
//   frontAxis.WheelJointRight.flange_a.phi = frontAxis.rightInertia.flange_b.phi;
//   frontAxis.frame_a.x = frontAxis.leftAxis.frame_b.x;
//   frontAxis.frame_a.x = frontAxis.rightAxis.frame_a.x;
//   frontAxis.frame_a.y = frontAxis.leftAxis.frame_b.y;
//   frontAxis.frame_a.y = frontAxis.rightAxis.frame_a.y;
//   frontAxis.frame_a.phi = frontAxis.leftAxis.frame_b.phi;
//   frontAxis.frame_a.phi = frontAxis.rightAxis.frame_a.phi;
//   frontAxis.SteeringInertia.flange_b.phi = frontAxis.leftSteeringRevolute.flange_a.phi;
//   frontAxis.SteeringInertia.flange_b.phi = frontAxis.rightSteeringRevolute.flange_a.phi;
//   frontAxis.leftAxis.frame_a.x = frontAxis.leftSteeringRevolute.frame_b.x;
//   frontAxis.leftAxis.frame_a.y = frontAxis.leftSteeringRevolute.frame_b.y;
//   frontAxis.leftAxis.frame_a.phi = frontAxis.leftSteeringRevolute.frame_b.phi;
//   frontAxis.rightAxis.frame_b.x = frontAxis.rightSteeringRevolute.frame_b.x;
//   frontAxis.rightAxis.frame_b.y = frontAxis.rightSteeringRevolute.frame_b.y;
//   frontAxis.rightAxis.frame_b.phi = frontAxis.rightSteeringRevolute.frame_b.phi;
//   frontAxis.SteeringInertia.flange_a.phi = frontAxis.flange_b.phi;
//   frontAxis.leftSteeringRevolute.frame_a.x = frontAxis.leftTrail.frame_a.x;
//   frontAxis.leftSteeringRevolute.frame_a.y = frontAxis.leftTrail.frame_a.y;
//   frontAxis.leftSteeringRevolute.frame_a.phi = frontAxis.leftTrail.frame_a.phi;
//   frontAxis.WheelJointLeft.frame_a.x = frontAxis.leftTrail.frame_b.x;
//   frontAxis.WheelJointLeft.frame_a.y = frontAxis.leftTrail.frame_b.y;
//   frontAxis.WheelJointLeft.frame_a.phi = frontAxis.leftTrail.frame_b.phi;
//   frontAxis.rightSteeringRevolute.frame_a.x = frontAxis.rigthtTrail.frame_a.x;
//   frontAxis.rightSteeringRevolute.frame_a.y = frontAxis.rigthtTrail.frame_a.y;
//   frontAxis.rightSteeringRevolute.frame_a.phi = frontAxis.rigthtTrail.frame_a.phi;
//   frontAxis.WheelJointRight.frame_a.x = frontAxis.rigthtTrail.frame_b.x;
//   frontAxis.WheelJointRight.frame_a.y = frontAxis.rigthtTrail.frame_b.y;
//   frontAxis.WheelJointRight.frame_a.phi = frontAxis.rigthtTrail.frame_b.phi;
//   simpleChassis.fixedTranslationFront.frame_a.t + simpleChassis.fixedTranslationRear.frame_b.t + simpleChassis.baseLoad.frame_a.t = 0.0;
//   simpleChassis.fixedTranslationFront.frame_a.fy + simpleChassis.fixedTranslationRear.frame_b.fy + simpleChassis.baseLoad.frame_a.fy = 0.0;
//   simpleChassis.fixedTranslationFront.frame_a.fx + simpleChassis.fixedTranslationRear.frame_b.fx + simpleChassis.baseLoad.frame_a.fx = 0.0;
//   -simpleChassis.frame_b.t + simpleChassis.fixedTranslationFront.frame_b.t = 0.0;
//   -simpleChassis.frame_b.fy + simpleChassis.fixedTranslationFront.frame_b.fy = 0.0;
//   -simpleChassis.frame_b.fx + simpleChassis.fixedTranslationFront.frame_b.fx = 0.0;
//   -simpleChassis.frame_a.t + simpleChassis.fixedTranslationRear.frame_a.t = 0.0;
//   -simpleChassis.frame_a.fy + simpleChassis.fixedTranslationRear.frame_a.fy = 0.0;
//   -simpleChassis.frame_a.fx + simpleChassis.fixedTranslationRear.frame_a.fx = 0.0;
//   simpleChassis.baseLoad.frame_a.x = simpleChassis.fixedTranslationFront.frame_a.x;
//   simpleChassis.baseLoad.frame_a.x = simpleChassis.fixedTranslationRear.frame_b.x;
//   simpleChassis.baseLoad.frame_a.y = simpleChassis.fixedTranslationFront.frame_a.y;
//   simpleChassis.baseLoad.frame_a.y = simpleChassis.fixedTranslationRear.frame_b.y;
//   simpleChassis.baseLoad.frame_a.phi = simpleChassis.fixedTranslationFront.frame_a.phi;
//   simpleChassis.baseLoad.frame_a.phi = simpleChassis.fixedTranslationRear.frame_b.phi;
//   simpleChassis.fixedTranslationFront.frame_b.x = simpleChassis.frame_b.x;
//   simpleChassis.fixedTranslationFront.frame_b.y = simpleChassis.frame_b.y;
//   simpleChassis.fixedTranslationFront.frame_b.phi = simpleChassis.frame_b.phi;
//   simpleChassis.fixedTranslationRear.frame_a.x = simpleChassis.frame_a.x;
//   simpleChassis.fixedTranslationRear.frame_a.y = simpleChassis.frame_a.y;
//   simpleChassis.fixedTranslationRear.frame_a.phi = simpleChassis.frame_a.phi;
//   ramp.y = torque.tau;
//   rearAxis.flange_b.phi = torque.flange.phi;
//   frontAxis.flange_b.phi = torque1.flange.phi;
//   pulse.y = torque1.tau;
//   frontAxis.frame_a.x = simpleChassis.frame_b.x;
//   frontAxis.frame_a.y = simpleChassis.frame_b.y;
//   frontAxis.frame_a.phi = simpleChassis.frame_b.phi;
//   rearAxis.frame_a.x = simpleChassis.frame_a.x;
//   rearAxis.frame_a.y = simpleChassis.frame_a.y;
//   rearAxis.frame_a.phi = simpleChassis.frame_a.phi;
// end PlanarMechanicsV4.Examples.TwoTrackStaticLoad;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = atan2(u1, u2);
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der \"Inline before index reduction\" \"Derivative of function Frames.resolve1(..)\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector resolved in frame 2\";
//   input Real[3] v2_der \"= der(v2)\";
//   output Real[3] v1_der \"Derivative of vector v resolved in frame 1\";
// algorithm
//   v1_der := Modelica.Mechanics.MultiBody.Frames.resolve1(R,{v2_der[1] + R.w[2] * v2[3] - R.w[3] * v2[2],v2_der[2] + R.w[3] * v2[1] - R.w[1] * v2[3],v2_der[3] + R.w[1] * v2[2] - R.w[2] * v2[1]});
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der \"Inline before index reduction\" \"Derivative of function Frames.resolve2(..)\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector resolved in frame 1\";
//   input Real[3] v1_der \"= der(v1)\";
//   output Real[3] v2_der \"Derivative of vector v resolved in frame 2\";
// algorithm
//   v2_der := Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1_der[1],v1_der[2],v1_der[3]}) - cross({R.w[1],R.w[2],R.w[3]},Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1[1],v1[2],v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint \"Inline before index reduction\" \"Return the constraint residues to express that two frames have the same orientation\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Real[3] residue \"The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)\";
// algorithm
//   residue := {atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3],R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]),atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3],R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]),atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3],R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2 \"Inline before index reduction\" \"Compute angular velocity resolved in frame 2 from quaternions orientation object and its derivative\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[4] der_Q(unit = \"1/s\") \"Derivative of Q\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {2.0 * (Q[4] * der_Q[1] + Q[3] * der_Q[2] + -Q[2] * der_Q[3] + -Q[1] * der_Q[4]),2.0 * (-Q[3] * der_Q[1] + Q[4] * der_Q[2] + Q[1] * der_Q[3] + -Q[2] * der_Q[4]),2.0 * (Q[2] * der_Q[1] + -Q[1] * der_Q[2] + Q[4] * der_Q[3] + -Q[3] * der_Q[4])};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T \"Return quaternions orientation object Q from transformation matrix T\"
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for Q (there are 2 solutions; the one close to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)\";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04;
// algorithm
//   c1 := 1.0 + T[1,1] + -T[2,2] - T[3,3];
//   c2 := 1.0 + T[2,2] + -T[1,1] - T[3,3];
//   c3 := 1.0 + T[3,3] + -T[1,1] - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04 or c4 > c1 and c4 > c2 and c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4,(T[1,2] - T[2,1]) / paux4,paux};
//   elseif c1 > c2 and c1 > c3 and c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux,(T[1,2] + T[2,1]) / paux4,(T[1,3] + T[3,1]) / paux4,(T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 and c2 > c3 and c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4,paux,(T[2,3] + T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4,(T[2,3] + T[3,2]) / paux4,paux,(T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1],Q[2],Q[3],Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation \"Inline before index reduction\" \"Return quaternions orientation object that does not rotate a frame\"
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := {0.0,0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint \"Inline before index reduction\" \"Return residues of orientation constraints (shall be zero)\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   output Real[1] residue \"Residue constraint (shall be zero)\";
// algorithm
//   residue := {Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0 + -1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation \"Inline before index reduction\" \"Return absolute orientation object from another absolute and a relative orientation object\"
//   input Real[3, 3] T1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Real[3, 3] T_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3, 3] T2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   T2 := <matrix>[T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1],T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2],T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3];T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1],T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2],T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3];T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1],T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2],T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation \"Inline before index reduction\" \"Return rotation object to rotate around one frame axis\"
//   input Integer axis(min = 1, max = 3) \"Rotate around 'axis' of frame 1\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := if axis == 1 then <matrix>[1.0,0.0,0.0;0.0,cos(angle),sin(angle);0.0,-sin(angle),cos(angle)] else if axis == 2 then <matrix>[cos(angle),0.0,-sin(angle);0.0,1.0,0.0;sin(angle),0.0,cos(angle)] else <matrix>[cos(angle),sin(angle),0.0;-sin(angle),cos(angle),0.0;0.0,0.0,1.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy \"Return orientation object from n_x and n_y vectors\"
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else if abs(e_x[1]) > 1e-06 then {0.0,1.0,0.0} else {1.0,0.0,0.0};
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   T := <matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := <matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2 \"Inline before index reduction\" \"Transform vector from frame 1 to frame 2\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3],T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3],T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation \"Inline before index reduction\" \"Return absolute orientation object from another absolute and a relative orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1],R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2],R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3];R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1],R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2],R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3];R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1],R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2],R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]],Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel,{R1.w[1],R1.w[2],R1.w[3]}) + {R_rel.w[1],R_rel.w[2],R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 \"Inline before index reduction\" \"Return angular velocity resolved in frame 2 from orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {R.w[1],R.w[2],R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations \"Inline before index reduction\" \"Return fixed rotation object to rotate in sequence around fixed angles along 3 axes\"
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence'\";
//   input Real[3] der_angles(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angles)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1],angles[1]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles \"Return the 3 angles to rotate in sequence around 3 axes to construct the given orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real guessAngle1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Select angles[1] such that |angles[1] - guessAngle1| is a minimum\";
//   output Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi\";
//   protected Real[3] e1_1(unit = \"1\") \"First rotation axis, resolved in frame 1\";
//   protected Real[3] e2_1a(unit = \"1\") \"Second rotation axis, resolved in frame 1a\";
//   protected Real[3] e3_1(unit = \"1\") \"Third rotation axis, resolved in frame 1\";
//   protected Real[3] e3_2(unit = \"1\") \"Third rotation axis, resolved in frame 2\";
//   protected Real A \"Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real B \"Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real angle_1a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 1 for angles[1]\";
//   protected Real angle_1b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 2 for angles[1]\";
//   protected Real[3, 3] T_1a \"Orientation object to rotate frame 1 into frame 1a\";
// algorithm
//   assert( sequence[1] <> sequence[2] and sequence[2] <> sequence[3], \"input argument 'sequence[1:3]' is not valid\");
//   e1_1 := if sequence[1] == 1 then {1.0,0.0,0.0} else if sequence[1] == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
//   e2_1a := if sequence[2] == 1 then {1.0,0.0,0.0} else if sequence[2] == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
//   e3_1 := {R.T[sequence[3],1],R.T[sequence[3],2],R.T[sequence[3],3]};
//   e3_2 := if sequence[3] == 1 then {1.0,0.0,0.0} else if sequence[3] == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 1e-12 and abs(B) <= 1e-12 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := atan2(A,-B);
//     angle_1b := atan2(-A,B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1],e1_1[2],e1_1[3]},angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e3_1[1],e3_1[2],e3_1[3]}),{e3_2[1],e3_2[2],e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1],e3_2[2],e3_2[3]},{e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e2_1a[1],e2_1a[2],e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis \"Inline before index reduction\" \"Return unit vector for x-, y-, or z-axis\"
//   input Integer axis(min = 1, max = 3) \"Axis vector to be returned\";
//   output Real[3] e(unit = \"1\") \"Unit axis vector\";
// algorithm
//   e := if axis == 1 then {1.0,0.0,0.0} else if axis == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q \"Inline before index reduction\" \"Return orientation object R from quaternion orientation object Q\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[2.0 * (Q[1] ^ 2.0 + Q[4] ^ 2.0) + -1.0,2.0 * (Q[1] * Q[2] + Q[3] * Q[4]),2.0 * (Q[1] * Q[3] - Q[2] * Q[4]);2.0 * (Q[2] * Q[1] - Q[3] * Q[4]),2.0 * (Q[2] ^ 2.0 + Q[4] ^ 2.0) + -1.0,2.0 * (Q[2] * Q[3] + Q[1] * Q[4]);2.0 * (Q[3] * Q[1] + Q[2] * Q[4]),2.0 * (Q[3] * Q[2] - Q[1] * Q[4]),2.0 * (Q[3] ^ 2.0 + Q[4] ^ 2.0) + -1.0],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle \"Inline before index reduction\" \"Return angle of a planar rotation, given the rotation axis and the representations of a vector in frame 1 and frame 2\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)\";
//   input Real[3] v1 \"A vector v resolved in frame 1 (shall not be parallel to e)\";
//   input Real[3] v2 \"Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)\";
//   output Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi\";
// algorithm
//   angle := atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3],v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3] - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1 \"Inline after index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3],R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3],R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2 \"Inline after index reduction\" \"Transform vector from frame 1 to frame 2\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3],R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3],R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q \"Inline before index reduction\" \"Return quaternion orientation object Q from orientation object R\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],{Q_guess[1],Q_guess[2],Q_guess[3],Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration \"Gravity field acceleration depending on field type and position\"
//   input Real[3] r(quantity = \"Length\", unit = \"m\") \"Position vector from world frame to actual point, resolved in world frame\";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType \"Type of gravity field\";
//   input Real[3] g(quantity = \"Acceleration\", unit = \"m/s2\") \"Constant gravity acceleration, resolved in world frame, if gravityType=1\";
//   input Real mue(unit = \"m3/s2\") \"Field constant of point gravity field, if gravityType=2\";
//   output Real[3] gravity(quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration at point r, resolved in world frame\";
// algorithm
//   gravity := if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity then -{(r[1] * mue) / (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0 * Modelica.Math.Vectors.length({r[1],r[2],r[3]})),(r[2] * mue) / (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0 * Modelica.Math.Vectors.length({r[1],r[2],r[3]})),(r[3] * mue) / (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0 * Modelica.Math.Vectors.length({r[1],r[2],r[3]}))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsV4.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsV4.Utilities.S_Func;
// 
// function PlanarMechanicsV4.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsV4.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsV4.Utilities.TripleS_Func;
// 
// class PlanarMechanicsV4.Examples.TwoTrackStaticLoad3D
//   Real world.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean world.enableAnimation = true \"= true, if animation of all components is enabled\";
//   parameter Boolean world.animateWorld = true \"= true, if world coordinate system shall be visualized\";
//   parameter Boolean world.animateGravity = true \"= true, if gravity field shall be visualized (acceleration vector or field center)\";
//   parameter String world.label1 = \"x\" \"Label of horizontal axis in icon\";
//   parameter String world.label2 = \"y\" \"Label of vertical axis in icon\";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity \"Type of gravity field\";
//   parameter Real world.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.81 \"Constant gravity acceleration\";
//   parameter Real world.n[1](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[2](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[3](unit = \"1\") = -1.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.mue(unit = \"m3/s2\", min = 0.0) = 398600000000000 \"Gravity field constant (default = field constant of earth)\";
//   parameter Boolean world.driveTrainMechanics3D = true \"= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account\";
//   parameter Boolean world.axisShowLabels = true \"= true, if labels shall be shown\";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of z-arrow\";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of z-arrow\";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of z-arrow\";
//   parameter Real world.gravityArrowTail[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   parameter Real world.gravitySphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 12742000.0 \"Diameter of sphere representing gravity center (default = mean diameter of earth)\";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   parameter Real world.nominalLength(quantity = \"Length\", unit = \"m\") = 1.0 \"\\\"Nominal\\\" length of multi-body system\";
//   parameter Real world.defaultWidthFraction = 20.0 \"Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)\";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 \"Default for arrow diameter of a coordinate system as a fraction of axis length\";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 \"Default reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real world.defaultN_to_m(unit = \"N/m\", min = 0.0) = 1000.0 \"Default scaling of force arrows (length = force/defaultN_to_m)\";
//   parameter Real world.defaultNm_to_m(unit = \"N.m/m\", min = 0.0) = 1000.0 \"Default scaling of torque arrows (length = torque/defaultNm_to_m)\";
//   protected parameter Integer world.ndim = if world.enableAnimation and world.animateWorld then 1 else 0;
//   protected parameter Integer world.ndim2 = if world.enableAnimation and world.animateWorld and world.axisShowLabels then 1 else 0;
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation and world.animateGravity and world.gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then 1 else 0;
//   parameter Real world.axisLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.nominalLength / 2.0 \"Length of world axes arrows\";
//   parameter Real world.defaultAxisLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 5.0 \"Default for length of a frame axis (but not world frame)\";
//   parameter Real world.defaultJointLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a joint\";
//   parameter Real world.defaultJointWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape representing a joint\";
//   parameter Real world.defaultForceLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a force (e.g. damper)\";
//   parameter Real world.defaultForceWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape represening a force (e.g. spring, bushing)\";
//   parameter Real world.defaultBodyDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 9.0 \"Default for diameter of sphere representing the center of mass of a body\";
//   parameter Real world.defaultArrowDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 40.0 \"Default for arrow diameter (e.g., of forces, torques, sensors)\";
//   parameter Real world.axisDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction \"Diameter of world axes arrows\";
//   parameter Real world.gravityArrowLength(quantity = \"Length\", unit = \"m\") = world.axisLength / 2.0 \"Length of gravity arrow\";
//   protected parameter Real world.labelStart(quantity = \"Length\", unit = \"m\") = 1.05 * world.axisLength;
//   protected parameter Real world.headLength(quantity = \"Length\", unit = \"m\") = min(world.axisLength,5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineWidth(quantity = \"Length\", unit = \"m\") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   parameter Real world.gravityArrowDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction \"Diameter of gravity arrow\";
//   protected parameter Real world.lineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.axisLength - world.headLength);
//   input Real world.x_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r_lines[1](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[1](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of cylinders\";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of cylinders\";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of cylinders\";
//   input Real world.x_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1,1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1,2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1,3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2,1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2,2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2,3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3,1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3,2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3,3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1,1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1,2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1,3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2,1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2,2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2,3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3,1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3,2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3,3];
//   protected Real world.x_label.r_abs[1](quantity = \"Length\", unit = \"m\") = ({world.x_label.r[1],world.x_label.r[2],world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]}))[1];
//   protected Real world.x_label.r_abs[2](quantity = \"Length\", unit = \"m\") = ({world.x_label.r[1],world.x_label.r[2],world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]}))[2];
//   protected Real world.x_label.r_abs[3](quantity = \"Length\", unit = \"m\") = ({world.x_label.r[1],world.x_label.r[2],world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]}))[3];
//   protected parameter Integer world.x_label.n = 2 \"Number of cylinders\";
//   parameter String world.x_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1],world.x_label.cylinders[1].lengthDirection[2],world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = ({world.x_label.r_abs[1],world.x_label.r_abs[2],world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1],world.x_label.cylinders[2].lengthDirection[2],world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   input Real world.y_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[2](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[2](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[1](unit = \"1\") = -1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[2](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = 0.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.75 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] \"Color of cylinders\";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] \"Color of cylinders\";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] \"Color of cylinders\";
//   input Real world.y_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1,1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1,2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1,3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2,1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2,2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2,3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3,1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3,2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3,3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1,1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1,2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1,3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2,1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2,2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2,3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3,1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3,2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3,3];
//   protected Real world.y_label.r_abs[1](quantity = \"Length\", unit = \"m\") = ({world.y_label.r[1],world.y_label.r[2],world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]}))[1];
//   protected Real world.y_label.r_abs[2](quantity = \"Length\", unit = \"m\") = ({world.y_label.r[1],world.y_label.r[2],world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]}))[2];
//   protected Real world.y_label.r_abs[3](quantity = \"Length\", unit = \"m\") = ({world.y_label.r[1],world.y_label.r[2],world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]}))[3];
//   protected parameter Integer world.y_label.n = 2 \"Number of cylinders\";
//   parameter String world.y_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1],world.y_label.cylinders[1].lengthDirection[2],world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = ({world.y_label.r_abs[1],world.y_label.r_abs[2],world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1],world.y_label.cylinders[2].lengthDirection[2],world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   input Real world.z_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[3](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[3](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] \"Color of cylinders\";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] \"Color of cylinders\";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] \"Color of cylinders\";
//   input Real world.z_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1,1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1,2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1,3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2,1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2,2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2,3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3,1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3,2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3,3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1,1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1,2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1,3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2,1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2,2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2,3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3,1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3,2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3,3];
//   protected Real world.z_label.r_abs[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r[1],world.z_label.r[2],world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]}))[1];
//   protected Real world.z_label.r_abs[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r[1],world.z_label.r[2],world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]}))[2];
//   protected Real world.z_label.r_abs[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r[1],world.z_label.r[2],world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]}))[3];
//   protected parameter Integer world.z_label.n = 3 \"Number of cylinders\";
//   parameter String world.z_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1],world.z_label.cylinders[1].lengthDirection[2],world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1],world.z_label.cylinders[2].lengthDirection[2],world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].r[1](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0}))[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[2](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0}))[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[3](quantity = \"Length\", unit = \"m\") = ({world.z_label.r_abs[1],world.z_label.r_abs[2],world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0}))[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[3].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[3].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[3].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1],world.z_label.cylinders[3].lengthDirection[2],world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   protected parameter Real world.gravityHeadLength(quantity = \"Length\", unit = \"m\") = min(world.gravityArrowLength,4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.gravityArrowLength - world.gravityHeadLength);
//   parameter String world.x_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.x_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.x_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.x_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1],world.x_arrowLine.lengthDirection[2],world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = \"1\") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = \"1\") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = \"1\") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.x_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.x_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.x_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1],world.x_arrowHead.lengthDirection[2],world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = \"1\") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = \"1\") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = \"1\") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   parameter String world.y_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.y_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.y_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.y_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1],world.y_arrowLine.lengthDirection[2],world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = \"1\") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = \"1\") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = \"1\") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.y_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.y_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.y_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1],world.y_arrowHead.lengthDirection[2],world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = \"1\") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = \"1\") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = \"1\") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   parameter String world.z_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.z_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.z_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.z_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1],world.z_arrowLine.lengthDirection[2],world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = \"1\") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = \"1\") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = \"1\") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.z_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.z_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.z_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1],world.z_arrowHead.lengthDirection[2],world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = \"1\") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = \"1\") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = \"1\") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   parameter String world.gravityArrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.length(quantity = \"Length\", unit = \"m\") = world.gravityLineLength \"Length of visual object\";
//   input Real world.gravityArrowLine.width(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Width of visual object\";
//   input Real world.gravityArrowLine.height(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Height of visual object\";
//   input Real world.gravityArrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowLine.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowLine.lengthDirection[1],world.gravityArrowLine.lengthDirection[2],world.gravityArrowLine.lengthDirection[3]});
//   protected Real world.gravityArrowLine.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 1.0 else world.gravityArrowLine.lengthDirection[1] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[2] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[3] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.n_z_aux[1](unit = \"1\") = world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[3] - world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[2];
//   protected Real world.gravityArrowLine.n_z_aux[2](unit = \"1\") = world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[1] - world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[3];
//   protected Real world.gravityArrowLine.n_z_aux[3](unit = \"1\") = world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[2] - world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[1];
//   protected Real world.gravityArrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[1];
//   protected Real world.gravityArrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[2];
//   protected Real world.gravityArrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[3];
//   protected output Real world.gravityArrowLine.Form;
//   output Real world.gravityArrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.Material;
//   protected output Real world.gravityArrowLine.Extra;
//   parameter String world.gravityArrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = ({world.gravityArrowTail[1],world.gravityArrowTail[2],world.gravityArrowTail[3]} + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.gravityLineLength)[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = ({world.gravityArrowTail[1],world.gravityArrowTail[2],world.gravityArrowTail[3]} + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.gravityLineLength)[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = ({world.gravityArrowTail[1],world.gravityArrowTail[2],world.gravityArrowTail[3]} + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.gravityLineLength)[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.length(quantity = \"Length\", unit = \"m\") = world.gravityHeadLength \"Length of visual object\";
//   input Real world.gravityArrowHead.width(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Width of visual object\";
//   input Real world.gravityArrowHead.height(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Height of visual object\";
//   input Real world.gravityArrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowHead.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowHead.lengthDirection[1],world.gravityArrowHead.lengthDirection[2],world.gravityArrowHead.lengthDirection[3]});
//   protected Real world.gravityArrowHead.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 1.0 else world.gravityArrowHead.lengthDirection[1] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[2] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[3] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.n_z_aux[1](unit = \"1\") = world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[3] - world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[2];
//   protected Real world.gravityArrowHead.n_z_aux[2](unit = \"1\") = world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[1] - world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[3];
//   protected Real world.gravityArrowHead.n_z_aux[3](unit = \"1\") = world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[2] - world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[1];
//   protected Real world.gravityArrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[1];
//   protected Real world.gravityArrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[2];
//   protected Real world.gravityArrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[3];
//   protected output Real world.gravityArrowHead.Form;
//   output Real world.gravityArrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.Material;
//   protected output Real world.gravityArrowHead.Extra;
//   parameter Boolean torque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   input Real torque.tau \"Accelerating torque acting at flange (= -flange.tau)\";
//   output Real pulse.y \"Connector of Real output signal\";
//   parameter Real pulse.amplitude = 10.0 \"Amplitude of pulse\";
//   parameter Real pulse.width(min = 1e-60, max = 100.0) = 30.0 \"Width of pulse in % of period\";
//   parameter Real pulse.period(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = 2.0 \"Time for one period\";
//   parameter Real pulse.offset = 0.0 \"Offset of output signals\";
//   parameter Real pulse.startTime(quantity = \"Time\", unit = \"s\") = 3.0 \"Output = offset for time < startTime\";
//   protected Real pulse.T_width(quantity = \"Time\", unit = \"s\") = (pulse.period * pulse.width) / 100.0;
//   protected Real pulse.T0(quantity = \"Time\", unit = \"s\", start = pulse.startTime) \"Start time of current period\";
//   parameter Real rearAxis.axisLength(quantity = \"Length\", unit = \"m\") = 1.7 \"length of the axis (width of the car)\";
//   parameter Real rearAxis.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 2.0 \"Inertia of the wheel\";
//   parameter Real rearAxis.R(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   final parameter Real rearAxis.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel\";
//   final parameter Real rearAxis.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel\";
//   parameter Real rearAxis.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real rearAxis.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real rearAxis.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real rearAxis.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real rearAxis.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real rearAxis.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rearAxis.differentialGear.idealPlanetary.ratio(start = 2.0) = -2.0 \"number of ring_teeth/sun_teeth (e.g. ratio=100/50)\";
//   Real rearAxis.differentialGear.idealPlanetary.sun.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.idealPlanetary.sun.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.idealPlanetary.carrier.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.idealPlanetary.carrier.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.idealPlanetary.ring.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.idealPlanetary.ring.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.flange_left.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.flange_left.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.differentialGear.flange_right.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.differentialGear.flange_right.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rearAxis.fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real rearAxis.fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real rearAxis.fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean rearAxis.fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real rearAxis.fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.fixedTranslation2.r[1] ^ 2.0 + rearAxis.fixedTranslation2.r[2] ^ 2.0);
//   parameter String rearAxis.fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = rearAxis.fixedTranslation2.r0[1] / rearAxis.fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.fixedTranslation2.r0[2] / rearAxis.fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation2.l \"Length of visual object\";
//   input Real rearAxis.fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.fixedTranslation2.cylinder.lengthDirection[1],rearAxis.fixedTranslation2.cylinder.lengthDirection[2],rearAxis.fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real rearAxis.fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.fixedTranslation2.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.fixedTranslation2.cylinder.lengthDirection[1] / rearAxis.fixedTranslation2.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation2.cylinder.lengthDirection[2] / rearAxis.fixedTranslation2.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.fixedTranslation2.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation2.cylinder.lengthDirection[3] / rearAxis.fixedTranslation2.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.fixedTranslation2.cylinder.e_x[2] * rearAxis.fixedTranslation2.cylinder.widthDirection[3] - rearAxis.fixedTranslation2.cylinder.e_x[3] * rearAxis.fixedTranslation2.cylinder.widthDirection[2];
//   protected Real rearAxis.fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.fixedTranslation2.cylinder.e_x[3] * rearAxis.fixedTranslation2.cylinder.widthDirection[1] - rearAxis.fixedTranslation2.cylinder.e_x[1] * rearAxis.fixedTranslation2.cylinder.widthDirection[3];
//   protected Real rearAxis.fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.fixedTranslation2.cylinder.e_x[1] * rearAxis.fixedTranslation2.cylinder.widthDirection[2] - rearAxis.fixedTranslation2.cylinder.e_x[2] * rearAxis.fixedTranslation2.cylinder.widthDirection[1];
//   protected Real rearAxis.fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation2.cylinder.widthDirection[1],rearAxis.fixedTranslation2.cylinder.widthDirection[2],rearAxis.fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real rearAxis.fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation2.cylinder.widthDirection[1],rearAxis.fixedTranslation2.cylinder.widthDirection[2],rearAxis.fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real rearAxis.fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation2.cylinder.widthDirection[1],rearAxis.fixedTranslation2.cylinder.widthDirection[2],rearAxis.fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation2.cylinder.e_x[1],rearAxis.fixedTranslation2.cylinder.e_x[2],rearAxis.fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.fixedTranslation2.cylinder.Form;
//   output Real rearAxis.fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation2.cylinder.Material;
//   protected output Real rearAxis.fixedTranslation2.cylinder.Extra;
//   Real rearAxis.fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rearAxis.fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real rearAxis.fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real rearAxis.fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rearAxis.fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real rearAxis.fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean rearAxis.fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real rearAxis.fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.fixedTranslation1.r[1] ^ 2.0 + rearAxis.fixedTranslation1.r[2] ^ 2.0);
//   parameter String rearAxis.fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = rearAxis.fixedTranslation1.r0[1] / rearAxis.fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.fixedTranslation1.r0[2] / rearAxis.fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = rearAxis.fixedTranslation1.l \"Length of visual object\";
//   input Real rearAxis.fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real rearAxis.fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.fixedTranslation1.cylinder.lengthDirection[1],rearAxis.fixedTranslation1.cylinder.lengthDirection[2],rearAxis.fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real rearAxis.fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.fixedTranslation1.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.fixedTranslation1.cylinder.lengthDirection[1] / rearAxis.fixedTranslation1.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation1.cylinder.lengthDirection[2] / rearAxis.fixedTranslation1.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.fixedTranslation1.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.fixedTranslation1.cylinder.lengthDirection[3] / rearAxis.fixedTranslation1.cylinder.abs_n_x;
//   protected Real rearAxis.fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.fixedTranslation1.cylinder.e_x[2] * rearAxis.fixedTranslation1.cylinder.widthDirection[3] - rearAxis.fixedTranslation1.cylinder.e_x[3] * rearAxis.fixedTranslation1.cylinder.widthDirection[2];
//   protected Real rearAxis.fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.fixedTranslation1.cylinder.e_x[3] * rearAxis.fixedTranslation1.cylinder.widthDirection[1] - rearAxis.fixedTranslation1.cylinder.e_x[1] * rearAxis.fixedTranslation1.cylinder.widthDirection[3];
//   protected Real rearAxis.fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.fixedTranslation1.cylinder.e_x[1] * rearAxis.fixedTranslation1.cylinder.widthDirection[2] - rearAxis.fixedTranslation1.cylinder.e_x[2] * rearAxis.fixedTranslation1.cylinder.widthDirection[1];
//   protected Real rearAxis.fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation1.cylinder.widthDirection[1],rearAxis.fixedTranslation1.cylinder.widthDirection[2],rearAxis.fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real rearAxis.fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation1.cylinder.widthDirection[1],rearAxis.fixedTranslation1.cylinder.widthDirection[2],rearAxis.fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real rearAxis.fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]},if noEvent(rearAxis.fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.fixedTranslation1.cylinder.widthDirection[1],rearAxis.fixedTranslation1.cylinder.widthDirection[2],rearAxis.fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.fixedTranslation1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.fixedTranslation1.cylinder.e_x[1],rearAxis.fixedTranslation1.cylinder.e_x[2],rearAxis.fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.fixedTranslation1.cylinder.Form;
//   output Real rearAxis.fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.fixedTranslation1.cylinder.Material;
//   protected output Real rearAxis.fixedTranslation1.cylinder.Extra;
//   Real rearAxis.inertia1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.inertia1.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia1.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.inertia1.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = rearAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) rearAxis.inertia1.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real rearAxis.inertia1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real rearAxis.inertia1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real rearAxis.inertia1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real rearAxis.inertia2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rearAxis.inertia2.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.inertia2.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.inertia2.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = rearAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) rearAxis.inertia2.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real rearAxis.inertia2.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real rearAxis.inertia2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real rearAxis.inertia2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real rearAxis.WheelJointLeft.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.WheelJointLeft.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.WheelJointLeft.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.WheelJointLeft.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.WheelJointLeft.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.WheelJointLeft.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.WheelJointLeft.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.WheelJointLeft.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.WheelJointLeft.radius(quantity = \"Length\", unit = \"m\") = rearAxis.R \"radius of the wheel\";
//   parameter Real rearAxis.WheelJointLeft.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointLeft.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointLeft.N(quantity = \"Force\", unit = \"N\") = rearAxis.N \"normal force\";
//   parameter Real rearAxis.WheelJointLeft.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vAdhesion \"adhesion velocity\";
//   parameter Real rearAxis.WheelJointLeft.vSlide(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vSlide \"sliding velocity\";
//   parameter Real rearAxis.WheelJointLeft.mu_A = rearAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real rearAxis.WheelJointLeft.mu_S = rearAxis.mu_S \"friction coefficient at sliding\";
//   Real rearAxis.WheelJointLeft.e0[1] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointLeft.e0[2] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointLeft.R[1,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.R[1,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.R[2,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.R[2,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointLeft.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real rearAxis.WheelJointLeft.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointLeft.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointLeft.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real rearAxis.WheelJointLeft.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real rearAxis.WheelJointLeft.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real rearAxis.WheelJointLeft.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real rearAxis.WheelJointLeft.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real rearAxis.WheelJointLeft.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointLeft.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointLeft.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean rearAxis.WheelJointLeft.animate = true \"enable Animation\";
//   parameter Boolean rearAxis.WheelJointLeft.SimVis = false \"perform animation with SimVis\";
//   final parameter Real rearAxis.WheelJointLeft.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.WheelJointLeft.r[1] ^ 2.0 + rearAxis.WheelJointLeft.r[2] ^ 2.0);
//   final parameter Real rearAxis.WheelJointLeft.e[1] = rearAxis.WheelJointLeft.r[1] / rearAxis.WheelJointLeft.l \"normalized direction\";
//   final parameter Real rearAxis.WheelJointLeft.e[2] = rearAxis.WheelJointLeft.r[2] / rearAxis.WheelJointLeft.l \"normalized direction\";
//   parameter String rearAxis.WheelJointLeft.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * rearAxis.WheelJointLeft.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * rearAxis.WheelJointLeft.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.lengthDirection[1](unit = \"1\") = -rearAxis.WheelJointLeft.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.WheelJointLeft.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real rearAxis.WheelJointLeft.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Width of visual object\";
//   input Real rearAxis.WheelJointLeft.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Height of visual object\";
//   input Real rearAxis.WheelJointLeft.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointLeft.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointLeft.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointLeft.cylinder.lengthDirection[1],rearAxis.WheelJointLeft.cylinder.lengthDirection[2],rearAxis.WheelJointLeft.cylinder.lengthDirection[3]});
//   protected Real rearAxis.WheelJointLeft.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointLeft.cylinder.lengthDirection[1] / rearAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.cylinder.lengthDirection[2] / rearAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.cylinder.lengthDirection[3] / rearAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointLeft.cylinder.e_x[2] * rearAxis.WheelJointLeft.cylinder.widthDirection[3] - rearAxis.WheelJointLeft.cylinder.e_x[3] * rearAxis.WheelJointLeft.cylinder.widthDirection[2];
//   protected Real rearAxis.WheelJointLeft.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointLeft.cylinder.e_x[3] * rearAxis.WheelJointLeft.cylinder.widthDirection[1] - rearAxis.WheelJointLeft.cylinder.e_x[1] * rearAxis.WheelJointLeft.cylinder.widthDirection[3];
//   protected Real rearAxis.WheelJointLeft.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointLeft.cylinder.e_x[1] * rearAxis.WheelJointLeft.cylinder.widthDirection[2] - rearAxis.WheelJointLeft.cylinder.e_x[2] * rearAxis.WheelJointLeft.cylinder.widthDirection[1];
//   protected Real rearAxis.WheelJointLeft.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.cylinder.widthDirection[1],rearAxis.WheelJointLeft.cylinder.widthDirection[2],rearAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]})[1];
//   protected Real rearAxis.WheelJointLeft.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.cylinder.widthDirection[1],rearAxis.WheelJointLeft.cylinder.widthDirection[2],rearAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]})[2];
//   protected Real rearAxis.WheelJointLeft.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.cylinder.widthDirection[1],rearAxis.WheelJointLeft.cylinder.widthDirection[2],rearAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.cylinder.e_x[1],rearAxis.WheelJointLeft.cylinder.e_x[2],rearAxis.WheelJointLeft.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointLeft.cylinder.Form;
//   output Real rearAxis.WheelJointLeft.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.cylinder.Material;
//   protected output Real rearAxis.WheelJointLeft.cylinder.Extra;
//   parameter String rearAxis.WheelJointLeft.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointLeft.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointLeft.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointLeft.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointLeft.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointLeft.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointLeft.rim1.lengthDirection[1],rearAxis.WheelJointLeft.rim1.lengthDirection[2],rearAxis.WheelJointLeft.rim1.lengthDirection[3]});
//   protected Real rearAxis.WheelJointLeft.rim1.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointLeft.rim1.lengthDirection[1] / rearAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim1.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim1.lengthDirection[2] / rearAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim1.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim1.lengthDirection[3] / rearAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim1.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointLeft.rim1.e_x[2] * rearAxis.WheelJointLeft.rim1.widthDirection[3] - rearAxis.WheelJointLeft.rim1.e_x[3] * rearAxis.WheelJointLeft.rim1.widthDirection[2];
//   protected Real rearAxis.WheelJointLeft.rim1.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointLeft.rim1.e_x[3] * rearAxis.WheelJointLeft.rim1.widthDirection[1] - rearAxis.WheelJointLeft.rim1.e_x[1] * rearAxis.WheelJointLeft.rim1.widthDirection[3];
//   protected Real rearAxis.WheelJointLeft.rim1.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointLeft.rim1.e_x[1] * rearAxis.WheelJointLeft.rim1.widthDirection[2] - rearAxis.WheelJointLeft.rim1.e_x[2] * rearAxis.WheelJointLeft.rim1.widthDirection[1];
//   protected Real rearAxis.WheelJointLeft.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim1.widthDirection[1],rearAxis.WheelJointLeft.rim1.widthDirection[2],rearAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]})[1];
//   protected Real rearAxis.WheelJointLeft.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim1.widthDirection[1],rearAxis.WheelJointLeft.rim1.widthDirection[2],rearAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]})[2];
//   protected Real rearAxis.WheelJointLeft.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim1.widthDirection[1],rearAxis.WheelJointLeft.rim1.widthDirection[2],rearAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim1.e_x[1],rearAxis.WheelJointLeft.rim1.e_x[2],rearAxis.WheelJointLeft.rim1.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointLeft.rim1.Form;
//   output Real rearAxis.WheelJointLeft.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointLeft.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim1.Material;
//   protected output Real rearAxis.WheelJointLeft.rim1.Extra;
//   parameter String rearAxis.WheelJointLeft.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointLeft.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointLeft.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointLeft.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointLeft.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointLeft.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointLeft.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointLeft.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointLeft.rim2.lengthDirection[1],rearAxis.WheelJointLeft.rim2.lengthDirection[2],rearAxis.WheelJointLeft.rim2.lengthDirection[3]});
//   protected Real rearAxis.WheelJointLeft.rim2.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointLeft.rim2.lengthDirection[1] / rearAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim2.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim2.lengthDirection[2] / rearAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim2.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointLeft.rim2.lengthDirection[3] / rearAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointLeft.rim2.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointLeft.rim2.e_x[2] * rearAxis.WheelJointLeft.rim2.widthDirection[3] - rearAxis.WheelJointLeft.rim2.e_x[3] * rearAxis.WheelJointLeft.rim2.widthDirection[2];
//   protected Real rearAxis.WheelJointLeft.rim2.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointLeft.rim2.e_x[3] * rearAxis.WheelJointLeft.rim2.widthDirection[1] - rearAxis.WheelJointLeft.rim2.e_x[1] * rearAxis.WheelJointLeft.rim2.widthDirection[3];
//   protected Real rearAxis.WheelJointLeft.rim2.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointLeft.rim2.e_x[1] * rearAxis.WheelJointLeft.rim2.widthDirection[2] - rearAxis.WheelJointLeft.rim2.e_x[2] * rearAxis.WheelJointLeft.rim2.widthDirection[1];
//   protected Real rearAxis.WheelJointLeft.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim2.widthDirection[1],rearAxis.WheelJointLeft.rim2.widthDirection[2],rearAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]})[1];
//   protected Real rearAxis.WheelJointLeft.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim2.widthDirection[1],rearAxis.WheelJointLeft.rim2.widthDirection[2],rearAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]})[2];
//   protected Real rearAxis.WheelJointLeft.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(rearAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointLeft.rim2.widthDirection[1],rearAxis.WheelJointLeft.rim2.widthDirection[2],rearAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointLeft.rim2.e_x[1],rearAxis.WheelJointLeft.rim2.e_x[2],rearAxis.WheelJointLeft.rim2.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointLeft.rim2.Form;
//   output Real rearAxis.WheelJointLeft.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointLeft.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointLeft.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointLeft.rim2.Material;
//   protected output Real rearAxis.WheelJointLeft.rim2.Extra;
//   Real rearAxis.WheelJointRight.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rearAxis.WheelJointRight.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rearAxis.WheelJointRight.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rearAxis.WheelJointRight.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rearAxis.WheelJointRight.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rearAxis.WheelJointRight.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rearAxis.WheelJointRight.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rearAxis.WheelJointRight.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real rearAxis.WheelJointRight.radius(quantity = \"Length\", unit = \"m\") = rearAxis.R \"radius of the wheel\";
//   parameter Real rearAxis.WheelJointRight.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointRight.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real rearAxis.WheelJointRight.N(quantity = \"Force\", unit = \"N\") = rearAxis.N \"normal force\";
//   parameter Real rearAxis.WheelJointRight.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vAdhesion \"adhesion velocity\";
//   parameter Real rearAxis.WheelJointRight.vSlide(quantity = \"Velocity\", unit = \"m/s\") = rearAxis.vSlide \"sliding velocity\";
//   parameter Real rearAxis.WheelJointRight.mu_A = rearAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real rearAxis.WheelJointRight.mu_S = rearAxis.mu_S \"friction coefficient at sliding\";
//   Real rearAxis.WheelJointRight.e0[1] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointRight.e0[2] \"normalized direction w.r.t inertial system\";
//   Real rearAxis.WheelJointRight.R[1,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.R[1,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.R[2,1] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.R[2,2] \"Rotation Matrix\";
//   Real rearAxis.WheelJointRight.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real rearAxis.WheelJointRight.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointRight.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real rearAxis.WheelJointRight.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real rearAxis.WheelJointRight.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real rearAxis.WheelJointRight.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real rearAxis.WheelJointRight.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real rearAxis.WheelJointRight.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real rearAxis.WheelJointRight.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointRight.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real rearAxis.WheelJointRight.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean rearAxis.WheelJointRight.animate = true \"enable Animation\";
//   parameter Boolean rearAxis.WheelJointRight.SimVis = false \"perform animation with SimVis\";
//   final parameter Real rearAxis.WheelJointRight.l(quantity = \"Length\", unit = \"m\") = sqrt(rearAxis.WheelJointRight.r[1] ^ 2.0 + rearAxis.WheelJointRight.r[2] ^ 2.0);
//   final parameter Real rearAxis.WheelJointRight.e[1] = rearAxis.WheelJointRight.r[1] / rearAxis.WheelJointRight.l \"normalized direction\";
//   final parameter Real rearAxis.WheelJointRight.e[2] = rearAxis.WheelJointRight.r[2] / rearAxis.WheelJointRight.l \"normalized direction\";
//   parameter String rearAxis.WheelJointRight.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * rearAxis.WheelJointRight.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * rearAxis.WheelJointRight.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.lengthDirection[1](unit = \"1\") = -rearAxis.WheelJointRight.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.lengthDirection[2](unit = \"1\") = rearAxis.WheelJointRight.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real rearAxis.WheelJointRight.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Width of visual object\";
//   input Real rearAxis.WheelJointRight.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Height of visual object\";
//   input Real rearAxis.WheelJointRight.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointRight.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointRight.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointRight.cylinder.lengthDirection[1],rearAxis.WheelJointRight.cylinder.lengthDirection[2],rearAxis.WheelJointRight.cylinder.lengthDirection[3]});
//   protected Real rearAxis.WheelJointRight.cylinder.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointRight.cylinder.lengthDirection[1] / rearAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointRight.cylinder.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.cylinder.lengthDirection[2] / rearAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointRight.cylinder.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.cylinder.lengthDirection[3] / rearAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real rearAxis.WheelJointRight.cylinder.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointRight.cylinder.e_x[2] * rearAxis.WheelJointRight.cylinder.widthDirection[3] - rearAxis.WheelJointRight.cylinder.e_x[3] * rearAxis.WheelJointRight.cylinder.widthDirection[2];
//   protected Real rearAxis.WheelJointRight.cylinder.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointRight.cylinder.e_x[3] * rearAxis.WheelJointRight.cylinder.widthDirection[1] - rearAxis.WheelJointRight.cylinder.e_x[1] * rearAxis.WheelJointRight.cylinder.widthDirection[3];
//   protected Real rearAxis.WheelJointRight.cylinder.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointRight.cylinder.e_x[1] * rearAxis.WheelJointRight.cylinder.widthDirection[2] - rearAxis.WheelJointRight.cylinder.e_x[2] * rearAxis.WheelJointRight.cylinder.widthDirection[1];
//   protected Real rearAxis.WheelJointRight.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.cylinder.widthDirection[1],rearAxis.WheelJointRight.cylinder.widthDirection[2],rearAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]})[1];
//   protected Real rearAxis.WheelJointRight.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.cylinder.widthDirection[1],rearAxis.WheelJointRight.cylinder.widthDirection[2],rearAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]})[2];
//   protected Real rearAxis.WheelJointRight.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(rearAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.cylinder.widthDirection[1],rearAxis.WheelJointRight.cylinder.widthDirection[2],rearAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.cylinder.e_x[1],rearAxis.WheelJointRight.cylinder.e_x[2],rearAxis.WheelJointRight.cylinder.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointRight.cylinder.Form;
//   output Real rearAxis.WheelJointRight.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointRight.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.cylinder.Material;
//   protected output Real rearAxis.WheelJointRight.cylinder.Extra;
//   parameter String rearAxis.WheelJointRight.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim1.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim1.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointRight.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointRight.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointRight.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointRight.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointRight.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointRight.rim1.lengthDirection[1],rearAxis.WheelJointRight.rim1.lengthDirection[2],rearAxis.WheelJointRight.rim1.lengthDirection[3]});
//   protected Real rearAxis.WheelJointRight.rim1.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointRight.rim1.lengthDirection[1] / rearAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim1.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim1.lengthDirection[2] / rearAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim1.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim1.lengthDirection[3] / rearAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim1.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointRight.rim1.e_x[2] * rearAxis.WheelJointRight.rim1.widthDirection[3] - rearAxis.WheelJointRight.rim1.e_x[3] * rearAxis.WheelJointRight.rim1.widthDirection[2];
//   protected Real rearAxis.WheelJointRight.rim1.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointRight.rim1.e_x[3] * rearAxis.WheelJointRight.rim1.widthDirection[1] - rearAxis.WheelJointRight.rim1.e_x[1] * rearAxis.WheelJointRight.rim1.widthDirection[3];
//   protected Real rearAxis.WheelJointRight.rim1.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointRight.rim1.e_x[1] * rearAxis.WheelJointRight.rim1.widthDirection[2] - rearAxis.WheelJointRight.rim1.e_x[2] * rearAxis.WheelJointRight.rim1.widthDirection[1];
//   protected Real rearAxis.WheelJointRight.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim1.widthDirection[1],rearAxis.WheelJointRight.rim1.widthDirection[2],rearAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]})[1];
//   protected Real rearAxis.WheelJointRight.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim1.widthDirection[1],rearAxis.WheelJointRight.rim1.widthDirection[2],rearAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]})[2];
//   protected Real rearAxis.WheelJointRight.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim1.widthDirection[1],rearAxis.WheelJointRight.rim1.widthDirection[2],rearAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim1.e_x[1],rearAxis.WheelJointRight.rim1.e_x[2],rearAxis.WheelJointRight.rim1.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointRight.rim1.Form;
//   output Real rearAxis.WheelJointRight.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointRight.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim1.Material;
//   protected output Real rearAxis.WheelJointRight.rim1.Extra;
//   parameter String rearAxis.WheelJointRight.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rearAxis.WheelJointRight.rim2.r[1](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim2.r[2](quantity = \"Length\", unit = \"m\") = rearAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rearAxis.WheelJointRight.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -rearAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rearAxis.WheelJointRight.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * rearAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real rearAxis.WheelJointRight.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rearAxis.WheelJointRight.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rearAxis.WheelJointRight.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rearAxis.WheelJointRight.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real rearAxis.WheelJointRight.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rearAxis.WheelJointRight.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rearAxis.WheelJointRight.rim2.lengthDirection[1],rearAxis.WheelJointRight.rim2.lengthDirection[2],rearAxis.WheelJointRight.rim2.lengthDirection[3]});
//   protected Real rearAxis.WheelJointRight.rim2.e_x[1](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 1.0 else rearAxis.WheelJointRight.rim2.lengthDirection[1] / rearAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim2.e_x[2](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim2.lengthDirection[2] / rearAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim2.e_x[3](unit = \"1\") = if noEvent(rearAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else rearAxis.WheelJointRight.rim2.lengthDirection[3] / rearAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real rearAxis.WheelJointRight.rim2.n_z_aux[1](unit = \"1\") = rearAxis.WheelJointRight.rim2.e_x[2] * rearAxis.WheelJointRight.rim2.widthDirection[3] - rearAxis.WheelJointRight.rim2.e_x[3] * rearAxis.WheelJointRight.rim2.widthDirection[2];
//   protected Real rearAxis.WheelJointRight.rim2.n_z_aux[2](unit = \"1\") = rearAxis.WheelJointRight.rim2.e_x[3] * rearAxis.WheelJointRight.rim2.widthDirection[1] - rearAxis.WheelJointRight.rim2.e_x[1] * rearAxis.WheelJointRight.rim2.widthDirection[3];
//   protected Real rearAxis.WheelJointRight.rim2.n_z_aux[3](unit = \"1\") = rearAxis.WheelJointRight.rim2.e_x[1] * rearAxis.WheelJointRight.rim2.widthDirection[2] - rearAxis.WheelJointRight.rim2.e_x[2] * rearAxis.WheelJointRight.rim2.widthDirection[1];
//   protected Real rearAxis.WheelJointRight.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim2.widthDirection[1],rearAxis.WheelJointRight.rim2.widthDirection[2],rearAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]})[1];
//   protected Real rearAxis.WheelJointRight.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim2.widthDirection[1],rearAxis.WheelJointRight.rim2.widthDirection[2],rearAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]})[2];
//   protected Real rearAxis.WheelJointRight.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]},if noEvent(rearAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (rearAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + rearAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {rearAxis.WheelJointRight.rim2.widthDirection[1],rearAxis.WheelJointRight.rim2.widthDirection[2],rearAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(rearAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rearAxis.WheelJointRight.rim2.e_x[1],rearAxis.WheelJointRight.rim2.e_x[2],rearAxis.WheelJointRight.rim2.e_x[3]})[3];
//   protected output Real rearAxis.WheelJointRight.rim2.Form;
//   output Real rearAxis.WheelJointRight.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rearAxis.WheelJointRight.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rearAxis.WheelJointRight.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rearAxis.WheelJointRight.rim2.Material;
//   protected output Real rearAxis.WheelJointRight.rim2.Extra;
//   parameter Real frontAxis.axisLength(quantity = \"Length\", unit = \"m\") = 1.6 \"length of the axis (width of the car)\";
//   parameter Real frontAxis.trail(quantity = \"Length\", unit = \"m\") = 0.02;
//   parameter Real frontAxis.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 2.0 \"Inertia of the wheel\";
//   parameter Real frontAxis.I_susp(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 2.0 \"Rotational Inertia of the steering suspension\";
//   parameter Real frontAxis.R(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   final parameter Real frontAxis.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel\";
//   final parameter Real frontAxis.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel\";
//   parameter Real frontAxis.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real frontAxis.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real frontAxis.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real frontAxis.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real frontAxis.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real frontAxis.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftSteeringRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftSteeringRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftSteeringRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftSteeringRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftSteeringRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftSteeringRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean frontAxis.leftSteeringRevolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real frontAxis.leftSteeringRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real frontAxis.leftSteeringRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real frontAxis.leftSteeringRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real frontAxis.leftSteeringRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real frontAxis.leftSteeringRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real frontAxis.leftSteeringRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean frontAxis.leftSteeringRevolute.animate = true \"enable Animation\";
//   Real frontAxis.leftSteeringRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.leftSteeringRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String frontAxis.leftSteeringRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.leftSteeringRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.leftSteeringRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real frontAxis.leftSteeringRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.leftSteeringRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.leftSteeringRevolute.cylinder.lengthDirection[1],frontAxis.leftSteeringRevolute.cylinder.lengthDirection[2],frontAxis.leftSteeringRevolute.cylinder.lengthDirection[3]});
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.leftSteeringRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.leftSteeringRevolute.cylinder.lengthDirection[1] / frontAxis.leftSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.leftSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftSteeringRevolute.cylinder.lengthDirection[2] / frontAxis.leftSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.leftSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftSteeringRevolute.cylinder.lengthDirection[3] / frontAxis.leftSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.leftSteeringRevolute.cylinder.e_x[2] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[3] - frontAxis.leftSteeringRevolute.cylinder.e_x[3] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[2];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.leftSteeringRevolute.cylinder.e_x[3] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[1] - frontAxis.leftSteeringRevolute.cylinder.e_x[1] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[3];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.leftSteeringRevolute.cylinder.e_x[1] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[2] - frontAxis.leftSteeringRevolute.cylinder.e_x[2] * frontAxis.leftSteeringRevolute.cylinder.widthDirection[1];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftSteeringRevolute.cylinder.widthDirection[1],frontAxis.leftSteeringRevolute.cylinder.widthDirection[2],frontAxis.leftSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]})[1];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftSteeringRevolute.cylinder.widthDirection[1],frontAxis.leftSteeringRevolute.cylinder.widthDirection[2],frontAxis.leftSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]})[2];
//   protected Real frontAxis.leftSteeringRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.leftSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftSteeringRevolute.cylinder.widthDirection[1],frontAxis.leftSteeringRevolute.cylinder.widthDirection[2],frontAxis.leftSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftSteeringRevolute.cylinder.e_x[1],frontAxis.leftSteeringRevolute.cylinder.e_x[2],frontAxis.leftSteeringRevolute.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.Form;
//   output Real frontAxis.leftSteeringRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftSteeringRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.Material;
//   protected output Real frontAxis.leftSteeringRevolute.cylinder.Extra;
//   Real frontAxis.rightSteeringRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightSteeringRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightSteeringRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightSteeringRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.rightSteeringRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightSteeringRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightSteeringRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightSteeringRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightSteeringRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean frontAxis.rightSteeringRevolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real frontAxis.rightSteeringRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real frontAxis.rightSteeringRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real frontAxis.rightSteeringRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real frontAxis.rightSteeringRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real frontAxis.rightSteeringRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real frontAxis.rightSteeringRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean frontAxis.rightSteeringRevolute.animate = true \"enable Animation\";
//   Real frontAxis.rightSteeringRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.rightSteeringRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String frontAxis.rightSteeringRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.rightSteeringRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.rightSteeringRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real frontAxis.rightSteeringRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.rightSteeringRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.rightSteeringRevolute.cylinder.lengthDirection[1],frontAxis.rightSteeringRevolute.cylinder.lengthDirection[2],frontAxis.rightSteeringRevolute.cylinder.lengthDirection[3]});
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.rightSteeringRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.rightSteeringRevolute.cylinder.lengthDirection[1] / frontAxis.rightSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.rightSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightSteeringRevolute.cylinder.lengthDirection[2] / frontAxis.rightSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.rightSteeringRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightSteeringRevolute.cylinder.lengthDirection[3] / frontAxis.rightSteeringRevolute.cylinder.abs_n_x;
//   protected Real frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.rightSteeringRevolute.cylinder.e_x[2] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[3] - frontAxis.rightSteeringRevolute.cylinder.e_x[3] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[2];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.rightSteeringRevolute.cylinder.e_x[3] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[1] - frontAxis.rightSteeringRevolute.cylinder.e_x[1] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[3];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.rightSteeringRevolute.cylinder.e_x[1] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[2] - frontAxis.rightSteeringRevolute.cylinder.e_x[2] * frontAxis.rightSteeringRevolute.cylinder.widthDirection[1];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightSteeringRevolute.cylinder.widthDirection[1],frontAxis.rightSteeringRevolute.cylinder.widthDirection[2],frontAxis.rightSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]})[1];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightSteeringRevolute.cylinder.widthDirection[1],frontAxis.rightSteeringRevolute.cylinder.widthDirection[2],frontAxis.rightSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]})[2];
//   protected Real frontAxis.rightSteeringRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]},if noEvent(frontAxis.rightSteeringRevolute.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightSteeringRevolute.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightSteeringRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightSteeringRevolute.cylinder.widthDirection[1],frontAxis.rightSteeringRevolute.cylinder.widthDirection[2],frontAxis.rightSteeringRevolute.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightSteeringRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightSteeringRevolute.cylinder.e_x[1],frontAxis.rightSteeringRevolute.cylinder.e_x[2],frontAxis.rightSteeringRevolute.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.Form;
//   output Real frontAxis.rightSteeringRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightSteeringRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.Material;
//   protected output Real frontAxis.rightSteeringRevolute.cylinder.Extra;
//   Real frontAxis.leftAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftAxis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftAxis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftAxis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftAxis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftAxis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftAxis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.leftAxis.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.leftAxis.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.leftAxis.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftAxis.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftAxis.R[1,1] \"Rotation matrix\";
//   Real frontAxis.leftAxis.R[1,2] \"Rotation matrix\";
//   Real frontAxis.leftAxis.R[2,1] \"Rotation matrix\";
//   Real frontAxis.leftAxis.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.leftAxis.animate = true \"enable Animation\";
//   final parameter Real frontAxis.leftAxis.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.leftAxis.r[1] ^ 2.0 + frontAxis.leftAxis.r[2] ^ 2.0);
//   parameter String frontAxis.leftAxis.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.leftAxis.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftAxis.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftAxis.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.leftAxis.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftAxis.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.leftAxis.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftAxis.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftAxis.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.leftAxis.r0[1] / frontAxis.leftAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.leftAxis.r0[2] / frontAxis.leftAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftAxis.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.leftAxis.l \"Length of visual object\";
//   input Real frontAxis.leftAxis.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.leftAxis.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.leftAxis.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.leftAxis.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftAxis.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftAxis.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftAxis.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.leftAxis.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.leftAxis.cylinder.lengthDirection[1],frontAxis.leftAxis.cylinder.lengthDirection[2],frontAxis.leftAxis.cylinder.lengthDirection[3]});
//   protected Real frontAxis.leftAxis.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.leftAxis.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.leftAxis.cylinder.lengthDirection[1] / frontAxis.leftAxis.cylinder.abs_n_x;
//   protected Real frontAxis.leftAxis.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.leftAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftAxis.cylinder.lengthDirection[2] / frontAxis.leftAxis.cylinder.abs_n_x;
//   protected Real frontAxis.leftAxis.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.leftAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftAxis.cylinder.lengthDirection[3] / frontAxis.leftAxis.cylinder.abs_n_x;
//   protected Real frontAxis.leftAxis.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.leftAxis.cylinder.e_x[2] * frontAxis.leftAxis.cylinder.widthDirection[3] - frontAxis.leftAxis.cylinder.e_x[3] * frontAxis.leftAxis.cylinder.widthDirection[2];
//   protected Real frontAxis.leftAxis.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.leftAxis.cylinder.e_x[3] * frontAxis.leftAxis.cylinder.widthDirection[1] - frontAxis.leftAxis.cylinder.e_x[1] * frontAxis.leftAxis.cylinder.widthDirection[3];
//   protected Real frontAxis.leftAxis.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.leftAxis.cylinder.e_x[1] * frontAxis.leftAxis.cylinder.widthDirection[2] - frontAxis.leftAxis.cylinder.e_x[2] * frontAxis.leftAxis.cylinder.widthDirection[1];
//   protected Real frontAxis.leftAxis.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]},if noEvent(frontAxis.leftAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftAxis.cylinder.widthDirection[1],frontAxis.leftAxis.cylinder.widthDirection[2],frontAxis.leftAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]})[1];
//   protected Real frontAxis.leftAxis.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]},if noEvent(frontAxis.leftAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftAxis.cylinder.widthDirection[1],frontAxis.leftAxis.cylinder.widthDirection[2],frontAxis.leftAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]})[2];
//   protected Real frontAxis.leftAxis.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]},if noEvent(frontAxis.leftAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftAxis.cylinder.widthDirection[1],frontAxis.leftAxis.cylinder.widthDirection[2],frontAxis.leftAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftAxis.cylinder.e_x[1],frontAxis.leftAxis.cylinder.e_x[2],frontAxis.leftAxis.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.leftAxis.cylinder.Form;
//   output Real frontAxis.leftAxis.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftAxis.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.leftAxis.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftAxis.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftAxis.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftAxis.cylinder.Material;
//   protected output Real frontAxis.leftAxis.cylinder.Extra;
//   Real frontAxis.rightAxis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightAxis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightAxis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightAxis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightAxis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightAxis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.rightAxis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rightAxis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rightAxis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rightAxis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rightAxis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rightAxis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.rightAxis.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.axisLength / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.rightAxis.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.rightAxis.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rightAxis.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rightAxis.R[1,1] \"Rotation matrix\";
//   Real frontAxis.rightAxis.R[1,2] \"Rotation matrix\";
//   Real frontAxis.rightAxis.R[2,1] \"Rotation matrix\";
//   Real frontAxis.rightAxis.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.rightAxis.animate = true \"enable Animation\";
//   final parameter Real frontAxis.rightAxis.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.rightAxis.r[1] ^ 2.0 + frontAxis.rightAxis.r[2] ^ 2.0);
//   parameter String frontAxis.rightAxis.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.rightAxis.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightAxis.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rightAxis.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.rightAxis.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightAxis.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.rightAxis.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightAxis.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rightAxis.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.rightAxis.r0[1] / frontAxis.rightAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.rightAxis.r0[2] / frontAxis.rightAxis.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rightAxis.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.rightAxis.l \"Length of visual object\";
//   input Real frontAxis.rightAxis.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.rightAxis.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.rightAxis.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.rightAxis.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.rightAxis.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.rightAxis.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.rightAxis.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.rightAxis.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.rightAxis.cylinder.lengthDirection[1],frontAxis.rightAxis.cylinder.lengthDirection[2],frontAxis.rightAxis.cylinder.lengthDirection[3]});
//   protected Real frontAxis.rightAxis.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.rightAxis.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.rightAxis.cylinder.lengthDirection[1] / frontAxis.rightAxis.cylinder.abs_n_x;
//   protected Real frontAxis.rightAxis.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.rightAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightAxis.cylinder.lengthDirection[2] / frontAxis.rightAxis.cylinder.abs_n_x;
//   protected Real frontAxis.rightAxis.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.rightAxis.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rightAxis.cylinder.lengthDirection[3] / frontAxis.rightAxis.cylinder.abs_n_x;
//   protected Real frontAxis.rightAxis.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.rightAxis.cylinder.e_x[2] * frontAxis.rightAxis.cylinder.widthDirection[3] - frontAxis.rightAxis.cylinder.e_x[3] * frontAxis.rightAxis.cylinder.widthDirection[2];
//   protected Real frontAxis.rightAxis.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.rightAxis.cylinder.e_x[3] * frontAxis.rightAxis.cylinder.widthDirection[1] - frontAxis.rightAxis.cylinder.e_x[1] * frontAxis.rightAxis.cylinder.widthDirection[3];
//   protected Real frontAxis.rightAxis.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.rightAxis.cylinder.e_x[1] * frontAxis.rightAxis.cylinder.widthDirection[2] - frontAxis.rightAxis.cylinder.e_x[2] * frontAxis.rightAxis.cylinder.widthDirection[1];
//   protected Real frontAxis.rightAxis.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]},if noEvent(frontAxis.rightAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightAxis.cylinder.widthDirection[1],frontAxis.rightAxis.cylinder.widthDirection[2],frontAxis.rightAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]})[1];
//   protected Real frontAxis.rightAxis.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]},if noEvent(frontAxis.rightAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightAxis.cylinder.widthDirection[1],frontAxis.rightAxis.cylinder.widthDirection[2],frontAxis.rightAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]})[2];
//   protected Real frontAxis.rightAxis.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]},if noEvent(frontAxis.rightAxis.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rightAxis.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rightAxis.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rightAxis.cylinder.widthDirection[1],frontAxis.rightAxis.cylinder.widthDirection[2],frontAxis.rightAxis.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rightAxis.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rightAxis.cylinder.e_x[1],frontAxis.rightAxis.cylinder.e_x[2],frontAxis.rightAxis.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.rightAxis.cylinder.Form;
//   output Real frontAxis.rightAxis.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rightAxis.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.rightAxis.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightAxis.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightAxis.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rightAxis.cylinder.Material;
//   protected output Real frontAxis.rightAxis.cylinder.Extra;
//   Real frontAxis.leftTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.leftTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.leftTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.leftTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.leftTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.leftTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.leftTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.leftTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.leftTrail.r[2](quantity = \"Length\", unit = \"m\") = -frontAxis.trail \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.leftTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.leftTrail.R[1,1] \"Rotation matrix\";
//   Real frontAxis.leftTrail.R[1,2] \"Rotation matrix\";
//   Real frontAxis.leftTrail.R[2,1] \"Rotation matrix\";
//   Real frontAxis.leftTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.leftTrail.animate = true \"enable Animation\";
//   final parameter Real frontAxis.leftTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.leftTrail.r[1] ^ 2.0 + frontAxis.leftTrail.r[2] ^ 2.0);
//   parameter String frontAxis.leftTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.leftTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.leftTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.leftTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.leftTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.leftTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.leftTrail.r0[1] / frontAxis.leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.leftTrail.r0[2] / frontAxis.leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.leftTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.leftTrail.l \"Length of visual object\";
//   input Real frontAxis.leftTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.leftTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.leftTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.leftTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.leftTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.leftTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.leftTrail.cylinder.lengthDirection[1],frontAxis.leftTrail.cylinder.lengthDirection[2],frontAxis.leftTrail.cylinder.lengthDirection[3]});
//   protected Real frontAxis.leftTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.leftTrail.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.leftTrail.cylinder.lengthDirection[1] / frontAxis.leftTrail.cylinder.abs_n_x;
//   protected Real frontAxis.leftTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.leftTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftTrail.cylinder.lengthDirection[2] / frontAxis.leftTrail.cylinder.abs_n_x;
//   protected Real frontAxis.leftTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.leftTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.leftTrail.cylinder.lengthDirection[3] / frontAxis.leftTrail.cylinder.abs_n_x;
//   protected Real frontAxis.leftTrail.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.leftTrail.cylinder.e_x[2] * frontAxis.leftTrail.cylinder.widthDirection[3] - frontAxis.leftTrail.cylinder.e_x[3] * frontAxis.leftTrail.cylinder.widthDirection[2];
//   protected Real frontAxis.leftTrail.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.leftTrail.cylinder.e_x[3] * frontAxis.leftTrail.cylinder.widthDirection[1] - frontAxis.leftTrail.cylinder.e_x[1] * frontAxis.leftTrail.cylinder.widthDirection[3];
//   protected Real frontAxis.leftTrail.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.leftTrail.cylinder.e_x[1] * frontAxis.leftTrail.cylinder.widthDirection[2] - frontAxis.leftTrail.cylinder.e_x[2] * frontAxis.leftTrail.cylinder.widthDirection[1];
//   protected Real frontAxis.leftTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]},if noEvent(frontAxis.leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftTrail.cylinder.widthDirection[1],frontAxis.leftTrail.cylinder.widthDirection[2],frontAxis.leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]})[1];
//   protected Real frontAxis.leftTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]},if noEvent(frontAxis.leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftTrail.cylinder.widthDirection[1],frontAxis.leftTrail.cylinder.widthDirection[2],frontAxis.leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]})[2];
//   protected Real frontAxis.leftTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]},if noEvent(frontAxis.leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.leftTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.leftTrail.cylinder.widthDirection[1],frontAxis.leftTrail.cylinder.widthDirection[2],frontAxis.leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.leftTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.leftTrail.cylinder.e_x[1],frontAxis.leftTrail.cylinder.e_x[2],frontAxis.leftTrail.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.leftTrail.cylinder.Form;
//   output Real frontAxis.leftTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.leftTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.leftTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.leftTrail.cylinder.Material;
//   protected output Real frontAxis.leftTrail.cylinder.Extra;
//   Real frontAxis.rigthtTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rigthtTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rigthtTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rigthtTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rigthtTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rigthtTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.rigthtTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.rigthtTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.rigthtTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.rigthtTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.rigthtTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.rigthtTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real frontAxis.rigthtTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real frontAxis.rigthtTrail.r[2](quantity = \"Length\", unit = \"m\") = -frontAxis.trail \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real frontAxis.rigthtTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rigthtTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real frontAxis.rigthtTrail.R[1,1] \"Rotation matrix\";
//   Real frontAxis.rigthtTrail.R[1,2] \"Rotation matrix\";
//   Real frontAxis.rigthtTrail.R[2,1] \"Rotation matrix\";
//   Real frontAxis.rigthtTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean frontAxis.rigthtTrail.animate = true \"enable Animation\";
//   final parameter Real frontAxis.rigthtTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.rigthtTrail.r[1] ^ 2.0 + frontAxis.rigthtTrail.r[2] ^ 2.0);
//   parameter String frontAxis.rigthtTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.rigthtTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.rigthtTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.lengthDirection[1](unit = \"1\") = frontAxis.rigthtTrail.r0[1] / frontAxis.rigthtTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.rigthtTrail.r0[2] / frontAxis.rigthtTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.rigthtTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = frontAxis.rigthtTrail.l \"Length of visual object\";
//   input Real frontAxis.rigthtTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.rigthtTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.rigthtTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.rigthtTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real frontAxis.rigthtTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real frontAxis.rigthtTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real frontAxis.rigthtTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.rigthtTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.rigthtTrail.cylinder.lengthDirection[1],frontAxis.rigthtTrail.cylinder.lengthDirection[2],frontAxis.rigthtTrail.cylinder.lengthDirection[3]});
//   protected Real frontAxis.rigthtTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.rigthtTrail.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.rigthtTrail.cylinder.lengthDirection[1] / frontAxis.rigthtTrail.cylinder.abs_n_x;
//   protected Real frontAxis.rigthtTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.rigthtTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rigthtTrail.cylinder.lengthDirection[2] / frontAxis.rigthtTrail.cylinder.abs_n_x;
//   protected Real frontAxis.rigthtTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.rigthtTrail.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.rigthtTrail.cylinder.lengthDirection[3] / frontAxis.rigthtTrail.cylinder.abs_n_x;
//   protected Real frontAxis.rigthtTrail.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.rigthtTrail.cylinder.e_x[2] * frontAxis.rigthtTrail.cylinder.widthDirection[3] - frontAxis.rigthtTrail.cylinder.e_x[3] * frontAxis.rigthtTrail.cylinder.widthDirection[2];
//   protected Real frontAxis.rigthtTrail.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.rigthtTrail.cylinder.e_x[3] * frontAxis.rigthtTrail.cylinder.widthDirection[1] - frontAxis.rigthtTrail.cylinder.e_x[1] * frontAxis.rigthtTrail.cylinder.widthDirection[3];
//   protected Real frontAxis.rigthtTrail.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.rigthtTrail.cylinder.e_x[1] * frontAxis.rigthtTrail.cylinder.widthDirection[2] - frontAxis.rigthtTrail.cylinder.e_x[2] * frontAxis.rigthtTrail.cylinder.widthDirection[1];
//   protected Real frontAxis.rigthtTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]},if noEvent(frontAxis.rigthtTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rigthtTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rigthtTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rigthtTrail.cylinder.widthDirection[1],frontAxis.rigthtTrail.cylinder.widthDirection[2],frontAxis.rigthtTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rigthtTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]})[1];
//   protected Real frontAxis.rigthtTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]},if noEvent(frontAxis.rigthtTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rigthtTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rigthtTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rigthtTrail.cylinder.widthDirection[1],frontAxis.rigthtTrail.cylinder.widthDirection[2],frontAxis.rigthtTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rigthtTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]})[2];
//   protected Real frontAxis.rigthtTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]},if noEvent(frontAxis.rigthtTrail.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.rigthtTrail.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.rigthtTrail.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.rigthtTrail.cylinder.widthDirection[1],frontAxis.rigthtTrail.cylinder.widthDirection[2],frontAxis.rigthtTrail.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.rigthtTrail.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.rigthtTrail.cylinder.e_x[1],frontAxis.rigthtTrail.cylinder.e_x[2],frontAxis.rigthtTrail.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.rigthtTrail.cylinder.Form;
//   output Real frontAxis.rigthtTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.rigthtTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.rigthtTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rigthtTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rigthtTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.rigthtTrail.cylinder.Material;
//   protected output Real frontAxis.rigthtTrail.cylinder.Extra;
//   Real frontAxis.leftInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.leftInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.leftInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.leftInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.leftInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = frontAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) frontAxis.leftInertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real frontAxis.leftInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real frontAxis.leftInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real frontAxis.leftInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real frontAxis.rightInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.rightInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.rightInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.rightInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.rightInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = frontAxis.I \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) frontAxis.rightInertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real frontAxis.rightInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real frontAxis.rightInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real frontAxis.rightInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real frontAxis.SteeringInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.SteeringInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real frontAxis.SteeringInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.SteeringInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.SteeringInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = frontAxis.I_susp \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) frontAxis.SteeringInertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real frontAxis.SteeringInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real frontAxis.SteeringInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real frontAxis.SteeringInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real frontAxis.WheelJointLeft.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.WheelJointLeft.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.WheelJointLeft.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.WheelJointLeft.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.WheelJointLeft.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.WheelJointLeft.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.WheelJointLeft.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.WheelJointLeft.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.WheelJointLeft.radius(quantity = \"Length\", unit = \"m\") = frontAxis.R \"radius of the wheel\";
//   parameter Real frontAxis.WheelJointLeft.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointLeft.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointLeft.N(quantity = \"Force\", unit = \"N\") = frontAxis.N \"normal force\";
//   parameter Real frontAxis.WheelJointLeft.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vAdhesion \"adhesion velocity\";
//   parameter Real frontAxis.WheelJointLeft.vSlide(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vSlide \"sliding velocity\";
//   parameter Real frontAxis.WheelJointLeft.mu_A = frontAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real frontAxis.WheelJointLeft.mu_S = frontAxis.mu_S \"friction coefficient at sliding\";
//   Real frontAxis.WheelJointLeft.e0[1] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointLeft.e0[2] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointLeft.R[1,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.R[1,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.R[2,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.R[2,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointLeft.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real frontAxis.WheelJointLeft.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointLeft.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointLeft.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real frontAxis.WheelJointLeft.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real frontAxis.WheelJointLeft.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real frontAxis.WheelJointLeft.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real frontAxis.WheelJointLeft.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real frontAxis.WheelJointLeft.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointLeft.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointLeft.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean frontAxis.WheelJointLeft.animate = true \"enable Animation\";
//   parameter Boolean frontAxis.WheelJointLeft.SimVis = false \"perform animation with SimVis\";
//   final parameter Real frontAxis.WheelJointLeft.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.WheelJointLeft.r[1] ^ 2.0 + frontAxis.WheelJointLeft.r[2] ^ 2.0);
//   final parameter Real frontAxis.WheelJointLeft.e[1] = frontAxis.WheelJointLeft.r[1] / frontAxis.WheelJointLeft.l \"normalized direction\";
//   final parameter Real frontAxis.WheelJointLeft.e[2] = frontAxis.WheelJointLeft.r[2] / frontAxis.WheelJointLeft.l \"normalized direction\";
//   parameter String frontAxis.WheelJointLeft.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * frontAxis.WheelJointLeft.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * frontAxis.WheelJointLeft.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.lengthDirection[1](unit = \"1\") = -frontAxis.WheelJointLeft.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.WheelJointLeft.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real frontAxis.WheelJointLeft.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Width of visual object\";
//   input Real frontAxis.WheelJointLeft.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Height of visual object\";
//   input Real frontAxis.WheelJointLeft.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointLeft.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointLeft.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointLeft.cylinder.lengthDirection[1],frontAxis.WheelJointLeft.cylinder.lengthDirection[2],frontAxis.WheelJointLeft.cylinder.lengthDirection[3]});
//   protected Real frontAxis.WheelJointLeft.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointLeft.cylinder.lengthDirection[1] / frontAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.cylinder.lengthDirection[2] / frontAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.cylinder.lengthDirection[3] / frontAxis.WheelJointLeft.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointLeft.cylinder.e_x[2] * frontAxis.WheelJointLeft.cylinder.widthDirection[3] - frontAxis.WheelJointLeft.cylinder.e_x[3] * frontAxis.WheelJointLeft.cylinder.widthDirection[2];
//   protected Real frontAxis.WheelJointLeft.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointLeft.cylinder.e_x[3] * frontAxis.WheelJointLeft.cylinder.widthDirection[1] - frontAxis.WheelJointLeft.cylinder.e_x[1] * frontAxis.WheelJointLeft.cylinder.widthDirection[3];
//   protected Real frontAxis.WheelJointLeft.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointLeft.cylinder.e_x[1] * frontAxis.WheelJointLeft.cylinder.widthDirection[2] - frontAxis.WheelJointLeft.cylinder.e_x[2] * frontAxis.WheelJointLeft.cylinder.widthDirection[1];
//   protected Real frontAxis.WheelJointLeft.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.cylinder.widthDirection[1],frontAxis.WheelJointLeft.cylinder.widthDirection[2],frontAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]})[1];
//   protected Real frontAxis.WheelJointLeft.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.cylinder.widthDirection[1],frontAxis.WheelJointLeft.cylinder.widthDirection[2],frontAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]})[2];
//   protected Real frontAxis.WheelJointLeft.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointLeft.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.cylinder.widthDirection[1],frontAxis.WheelJointLeft.cylinder.widthDirection[2],frontAxis.WheelJointLeft.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.cylinder.e_x[1],frontAxis.WheelJointLeft.cylinder.e_x[2],frontAxis.WheelJointLeft.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointLeft.cylinder.Form;
//   output Real frontAxis.WheelJointLeft.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.cylinder.Material;
//   protected output Real frontAxis.WheelJointLeft.cylinder.Extra;
//   parameter String frontAxis.WheelJointLeft.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointLeft.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointLeft.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointLeft.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointLeft.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointLeft.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointLeft.rim1.lengthDirection[1],frontAxis.WheelJointLeft.rim1.lengthDirection[2],frontAxis.WheelJointLeft.rim1.lengthDirection[3]});
//   protected Real frontAxis.WheelJointLeft.rim1.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointLeft.rim1.lengthDirection[1] / frontAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim1.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim1.lengthDirection[2] / frontAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim1.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim1.lengthDirection[3] / frontAxis.WheelJointLeft.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim1.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointLeft.rim1.e_x[2] * frontAxis.WheelJointLeft.rim1.widthDirection[3] - frontAxis.WheelJointLeft.rim1.e_x[3] * frontAxis.WheelJointLeft.rim1.widthDirection[2];
//   protected Real frontAxis.WheelJointLeft.rim1.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointLeft.rim1.e_x[3] * frontAxis.WheelJointLeft.rim1.widthDirection[1] - frontAxis.WheelJointLeft.rim1.e_x[1] * frontAxis.WheelJointLeft.rim1.widthDirection[3];
//   protected Real frontAxis.WheelJointLeft.rim1.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointLeft.rim1.e_x[1] * frontAxis.WheelJointLeft.rim1.widthDirection[2] - frontAxis.WheelJointLeft.rim1.e_x[2] * frontAxis.WheelJointLeft.rim1.widthDirection[1];
//   protected Real frontAxis.WheelJointLeft.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim1.widthDirection[1],frontAxis.WheelJointLeft.rim1.widthDirection[2],frontAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]})[1];
//   protected Real frontAxis.WheelJointLeft.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim1.widthDirection[1],frontAxis.WheelJointLeft.rim1.widthDirection[2],frontAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]})[2];
//   protected Real frontAxis.WheelJointLeft.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim1.widthDirection[1],frontAxis.WheelJointLeft.rim1.widthDirection[2],frontAxis.WheelJointLeft.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim1.e_x[1],frontAxis.WheelJointLeft.rim1.e_x[2],frontAxis.WheelJointLeft.rim1.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointLeft.rim1.Form;
//   output Real frontAxis.WheelJointLeft.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointLeft.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim1.Material;
//   protected output Real frontAxis.WheelJointLeft.rim1.Extra;
//   parameter String frontAxis.WheelJointLeft.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointLeft.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointLeft.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointLeft.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointLeft.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointLeft.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointLeft.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointLeft.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointLeft.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointLeft.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointLeft.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointLeft.rim2.lengthDirection[1],frontAxis.WheelJointLeft.rim2.lengthDirection[2],frontAxis.WheelJointLeft.rim2.lengthDirection[3]});
//   protected Real frontAxis.WheelJointLeft.rim2.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointLeft.rim2.lengthDirection[1] / frontAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim2.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim2.lengthDirection[2] / frontAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim2.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointLeft.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointLeft.rim2.lengthDirection[3] / frontAxis.WheelJointLeft.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointLeft.rim2.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointLeft.rim2.e_x[2] * frontAxis.WheelJointLeft.rim2.widthDirection[3] - frontAxis.WheelJointLeft.rim2.e_x[3] * frontAxis.WheelJointLeft.rim2.widthDirection[2];
//   protected Real frontAxis.WheelJointLeft.rim2.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointLeft.rim2.e_x[3] * frontAxis.WheelJointLeft.rim2.widthDirection[1] - frontAxis.WheelJointLeft.rim2.e_x[1] * frontAxis.WheelJointLeft.rim2.widthDirection[3];
//   protected Real frontAxis.WheelJointLeft.rim2.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointLeft.rim2.e_x[1] * frontAxis.WheelJointLeft.rim2.widthDirection[2] - frontAxis.WheelJointLeft.rim2.e_x[2] * frontAxis.WheelJointLeft.rim2.widthDirection[1];
//   protected Real frontAxis.WheelJointLeft.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim2.widthDirection[1],frontAxis.WheelJointLeft.rim2.widthDirection[2],frontAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]})[1];
//   protected Real frontAxis.WheelJointLeft.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim2.widthDirection[1],frontAxis.WheelJointLeft.rim2.widthDirection[2],frontAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]})[2];
//   protected Real frontAxis.WheelJointLeft.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]},if noEvent(frontAxis.WheelJointLeft.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointLeft.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointLeft.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointLeft.rim2.widthDirection[1],frontAxis.WheelJointLeft.rim2.widthDirection[2],frontAxis.WheelJointLeft.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointLeft.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointLeft.rim2.e_x[1],frontAxis.WheelJointLeft.rim2.e_x[2],frontAxis.WheelJointLeft.rim2.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointLeft.rim2.Form;
//   output Real frontAxis.WheelJointLeft.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointLeft.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointLeft.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointLeft.rim2.Material;
//   protected output Real frontAxis.WheelJointLeft.rim2.Extra;
//   Real frontAxis.WheelJointRight.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real frontAxis.WheelJointRight.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real frontAxis.WheelJointRight.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real frontAxis.WheelJointRight.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real frontAxis.WheelJointRight.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real frontAxis.WheelJointRight.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real frontAxis.WheelJointRight.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frontAxis.WheelJointRight.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frontAxis.WheelJointRight.radius(quantity = \"Length\", unit = \"m\") = frontAxis.R \"radius of the wheel\";
//   parameter Real frontAxis.WheelJointRight.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.r[1] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointRight.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.r[2] \"driving direction of the wheel at angle phi = 0\";
//   parameter Real frontAxis.WheelJointRight.N(quantity = \"Force\", unit = \"N\") = frontAxis.N \"normal force\";
//   parameter Real frontAxis.WheelJointRight.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vAdhesion \"adhesion velocity\";
//   parameter Real frontAxis.WheelJointRight.vSlide(quantity = \"Velocity\", unit = \"m/s\") = frontAxis.vSlide \"sliding velocity\";
//   parameter Real frontAxis.WheelJointRight.mu_A = frontAxis.mu_A \"friction coefficient at adhesion\";
//   parameter Real frontAxis.WheelJointRight.mu_S = frontAxis.mu_S \"friction coefficient at sliding\";
//   Real frontAxis.WheelJointRight.e0[1] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointRight.e0[2] \"normalized direction w.r.t inertial system\";
//   Real frontAxis.WheelJointRight.R[1,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.R[1,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.R[2,1] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.R[2,2] \"Rotation Matrix\";
//   Real frontAxis.WheelJointRight.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real frontAxis.WheelJointRight.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointRight.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real frontAxis.WheelJointRight.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real frontAxis.WheelJointRight.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real frontAxis.WheelJointRight.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real frontAxis.WheelJointRight.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real frontAxis.WheelJointRight.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real frontAxis.WheelJointRight.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointRight.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real frontAxis.WheelJointRight.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean frontAxis.WheelJointRight.animate = true \"enable Animation\";
//   parameter Boolean frontAxis.WheelJointRight.SimVis = false \"perform animation with SimVis\";
//   final parameter Real frontAxis.WheelJointRight.l(quantity = \"Length\", unit = \"m\") = sqrt(frontAxis.WheelJointRight.r[1] ^ 2.0 + frontAxis.WheelJointRight.r[2] ^ 2.0);
//   final parameter Real frontAxis.WheelJointRight.e[1] = frontAxis.WheelJointRight.r[1] / frontAxis.WheelJointRight.l \"normalized direction\";
//   final parameter Real frontAxis.WheelJointRight.e[2] = frontAxis.WheelJointRight.r[2] / frontAxis.WheelJointRight.l \"normalized direction\";
//   parameter String frontAxis.WheelJointRight.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.03 * frontAxis.WheelJointRight.e0[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = -0.03 * frontAxis.WheelJointRight.e0[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.lengthDirection[1](unit = \"1\") = -frontAxis.WheelJointRight.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.lengthDirection[2](unit = \"1\") = frontAxis.WheelJointRight.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real frontAxis.WheelJointRight.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Width of visual object\";
//   input Real frontAxis.WheelJointRight.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Height of visual object\";
//   input Real frontAxis.WheelJointRight.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointRight.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointRight.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointRight.cylinder.lengthDirection[1],frontAxis.WheelJointRight.cylinder.lengthDirection[2],frontAxis.WheelJointRight.cylinder.lengthDirection[3]});
//   protected Real frontAxis.WheelJointRight.cylinder.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointRight.cylinder.lengthDirection[1] / frontAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointRight.cylinder.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.cylinder.lengthDirection[2] / frontAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointRight.cylinder.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.cylinder.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.cylinder.lengthDirection[3] / frontAxis.WheelJointRight.cylinder.abs_n_x;
//   protected Real frontAxis.WheelJointRight.cylinder.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointRight.cylinder.e_x[2] * frontAxis.WheelJointRight.cylinder.widthDirection[3] - frontAxis.WheelJointRight.cylinder.e_x[3] * frontAxis.WheelJointRight.cylinder.widthDirection[2];
//   protected Real frontAxis.WheelJointRight.cylinder.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointRight.cylinder.e_x[3] * frontAxis.WheelJointRight.cylinder.widthDirection[1] - frontAxis.WheelJointRight.cylinder.e_x[1] * frontAxis.WheelJointRight.cylinder.widthDirection[3];
//   protected Real frontAxis.WheelJointRight.cylinder.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointRight.cylinder.e_x[1] * frontAxis.WheelJointRight.cylinder.widthDirection[2] - frontAxis.WheelJointRight.cylinder.e_x[2] * frontAxis.WheelJointRight.cylinder.widthDirection[1];
//   protected Real frontAxis.WheelJointRight.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.cylinder.widthDirection[1],frontAxis.WheelJointRight.cylinder.widthDirection[2],frontAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]})[1];
//   protected Real frontAxis.WheelJointRight.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.cylinder.widthDirection[1],frontAxis.WheelJointRight.cylinder.widthDirection[2],frontAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]})[2];
//   protected Real frontAxis.WheelJointRight.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]},if noEvent(frontAxis.WheelJointRight.cylinder.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.cylinder.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.cylinder.widthDirection[1],frontAxis.WheelJointRight.cylinder.widthDirection[2],frontAxis.WheelJointRight.cylinder.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.cylinder.e_x[1],frontAxis.WheelJointRight.cylinder.e_x[2],frontAxis.WheelJointRight.cylinder.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointRight.cylinder.Form;
//   output Real frontAxis.WheelJointRight.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointRight.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.cylinder.Material;
//   protected output Real frontAxis.WheelJointRight.cylinder.Extra;
//   parameter String frontAxis.WheelJointRight.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim1.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim1.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointRight.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointRight.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointRight.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointRight.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointRight.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointRight.rim1.lengthDirection[1],frontAxis.WheelJointRight.rim1.lengthDirection[2],frontAxis.WheelJointRight.rim1.lengthDirection[3]});
//   protected Real frontAxis.WheelJointRight.rim1.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointRight.rim1.lengthDirection[1] / frontAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim1.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim1.lengthDirection[2] / frontAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim1.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim1.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim1.lengthDirection[3] / frontAxis.WheelJointRight.rim1.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim1.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointRight.rim1.e_x[2] * frontAxis.WheelJointRight.rim1.widthDirection[3] - frontAxis.WheelJointRight.rim1.e_x[3] * frontAxis.WheelJointRight.rim1.widthDirection[2];
//   protected Real frontAxis.WheelJointRight.rim1.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointRight.rim1.e_x[3] * frontAxis.WheelJointRight.rim1.widthDirection[1] - frontAxis.WheelJointRight.rim1.e_x[1] * frontAxis.WheelJointRight.rim1.widthDirection[3];
//   protected Real frontAxis.WheelJointRight.rim1.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointRight.rim1.e_x[1] * frontAxis.WheelJointRight.rim1.widthDirection[2] - frontAxis.WheelJointRight.rim1.e_x[2] * frontAxis.WheelJointRight.rim1.widthDirection[1];
//   protected Real frontAxis.WheelJointRight.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim1.widthDirection[1],frontAxis.WheelJointRight.rim1.widthDirection[2],frontAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]})[1];
//   protected Real frontAxis.WheelJointRight.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim1.widthDirection[1],frontAxis.WheelJointRight.rim1.widthDirection[2],frontAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]})[2];
//   protected Real frontAxis.WheelJointRight.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim1.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim1.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim1.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim1.widthDirection[1],frontAxis.WheelJointRight.rim1.widthDirection[2],frontAxis.WheelJointRight.rim1.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim1.e_x[1],frontAxis.WheelJointRight.rim1.e_x[2],frontAxis.WheelJointRight.rim1.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointRight.rim1.Form;
//   output Real frontAxis.WheelJointRight.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointRight.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim1.Material;
//   protected output Real frontAxis.WheelJointRight.rim1.Extra;
//   parameter String frontAxis.WheelJointRight.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real frontAxis.WheelJointRight.rim2.r[1](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim2.r[2](quantity = \"Length\", unit = \"m\") = frontAxis.WheelJointRight.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real frontAxis.WheelJointRight.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -frontAxis.WheelJointRight.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real frontAxis.WheelJointRight.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * frontAxis.WheelJointRight.radius \"Length of visual object\";
//   input Real frontAxis.WheelJointRight.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real frontAxis.WheelJointRight.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real frontAxis.WheelJointRight.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real frontAxis.WheelJointRight.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real frontAxis.WheelJointRight.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real frontAxis.WheelJointRight.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({frontAxis.WheelJointRight.rim2.lengthDirection[1],frontAxis.WheelJointRight.rim2.lengthDirection[2],frontAxis.WheelJointRight.rim2.lengthDirection[3]});
//   protected Real frontAxis.WheelJointRight.rim2.e_x[1](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 1.0 else frontAxis.WheelJointRight.rim2.lengthDirection[1] / frontAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim2.e_x[2](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim2.lengthDirection[2] / frontAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim2.e_x[3](unit = \"1\") = if noEvent(frontAxis.WheelJointRight.rim2.abs_n_x < 1e-10) then 0.0 else frontAxis.WheelJointRight.rim2.lengthDirection[3] / frontAxis.WheelJointRight.rim2.abs_n_x;
//   protected Real frontAxis.WheelJointRight.rim2.n_z_aux[1](unit = \"1\") = frontAxis.WheelJointRight.rim2.e_x[2] * frontAxis.WheelJointRight.rim2.widthDirection[3] - frontAxis.WheelJointRight.rim2.e_x[3] * frontAxis.WheelJointRight.rim2.widthDirection[2];
//   protected Real frontAxis.WheelJointRight.rim2.n_z_aux[2](unit = \"1\") = frontAxis.WheelJointRight.rim2.e_x[3] * frontAxis.WheelJointRight.rim2.widthDirection[1] - frontAxis.WheelJointRight.rim2.e_x[1] * frontAxis.WheelJointRight.rim2.widthDirection[3];
//   protected Real frontAxis.WheelJointRight.rim2.n_z_aux[3](unit = \"1\") = frontAxis.WheelJointRight.rim2.e_x[1] * frontAxis.WheelJointRight.rim2.widthDirection[2] - frontAxis.WheelJointRight.rim2.e_x[2] * frontAxis.WheelJointRight.rim2.widthDirection[1];
//   protected Real frontAxis.WheelJointRight.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim2.widthDirection[1],frontAxis.WheelJointRight.rim2.widthDirection[2],frontAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]})[1];
//   protected Real frontAxis.WheelJointRight.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim2.widthDirection[1],frontAxis.WheelJointRight.rim2.widthDirection[2],frontAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]})[2];
//   protected Real frontAxis.WheelJointRight.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]},if noEvent(frontAxis.WheelJointRight.rim2.n_z_aux[1] ^ 2.0 + (frontAxis.WheelJointRight.rim2.n_z_aux[2] ^ 2.0 + frontAxis.WheelJointRight.rim2.n_z_aux[3] ^ 2.0) > 1e-06) then {frontAxis.WheelJointRight.rim2.widthDirection[1],frontAxis.WheelJointRight.rim2.widthDirection[2],frontAxis.WheelJointRight.rim2.widthDirection[3]} else if noEvent(abs(frontAxis.WheelJointRight.rim2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{frontAxis.WheelJointRight.rim2.e_x[1],frontAxis.WheelJointRight.rim2.e_x[2],frontAxis.WheelJointRight.rim2.e_x[3]})[3];
//   protected output Real frontAxis.WheelJointRight.rim2.Form;
//   output Real frontAxis.WheelJointRight.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real frontAxis.WheelJointRight.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real frontAxis.WheelJointRight.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real frontAxis.WheelJointRight.rim2.Material;
//   protected output Real frontAxis.WheelJointRight.rim2.Extra;
//   output Real ramp.y \"Connector of Real output signal\";
//   parameter Real ramp.height = 100.0 \"Height of ramps\";
//   parameter Real ramp.duration(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 2.0) = 2.0 \"Durations of ramp\";
//   parameter Real ramp.offset = 0.0 \"Offset of output signal\";
//   parameter Real ramp.startTime(quantity = \"Time\", unit = \"s\") = 0.2 \"Output = offset for time < startTime\";
//   parameter Boolean torque1.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torque1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torque1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torque1.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   input Real torque1.tau \"Accelerating torque acting at flange (= -flange.tau)\";
//   parameter Real simpleChassis3D.wheelBase(quantity = \"Length\", unit = \"m\") = 2.6 \"Wheel Base of the Vehicle\";
//   parameter Real simpleChassis3D.l(quantity = \"Length\", unit = \"m\") = 3.5 \"Length of the Vehicle\";
//   parameter Real simpleChassis3D.w(quantity = \"Length\", unit = \"m\") = 1.6 \"width of the Vehicle\";
//   parameter Real simpleChassis3D.h(quantity = \"Length\", unit = \"m\") = 0.5 \"height of the dynamic load\";
//   parameter Real simpleChassis3D.m_static(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1500.0 \"Base load of the vehicle\";
//   parameter Real simpleChassis3D.m_dynamic(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 500.0 \"Dynamic load of the vehicle\";
//   parameter Real simpleChassis3D.c_roll(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\") = 2000.0 \"Roll spring constant\";
//   parameter Real simpleChassis3D.d_roll(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\") = 200.0 \"Roll damping constant\";
//   parameter Real simpleChassis3D.c_pitch(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\") = 3000.0 \"Pitch spring constant\";
//   parameter Real simpleChassis3D.d_pitch(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\") = 300.0 \"Pitch damping constant\";
//   Real simpleChassis3D.planarToMultiBody.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.planarToMultiBody.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.planarToMultiBody.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.planarToMultiBody.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.planarToMultiBody.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.planarToMultiBody.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.planarToMultiBody.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   protected Real simpleChassis3D.planarToMultiBody.fz(quantity = \"Force\", unit = \"N\") \"Normal Force\";
//   protected Real simpleChassis3D.planarToMultiBody.f0[1](quantity = \"Force\", unit = \"N\") \"Force vector\";
//   protected Real simpleChassis3D.planarToMultiBody.f0[2](quantity = \"Force\", unit = \"N\") \"Force vector\";
//   protected Real simpleChassis3D.planarToMultiBody.f0[3](quantity = \"Force\", unit = \"N\") \"Force vector\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.toCenterOfGravity.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean simpleChassis3D.toCenterOfGravity.animation = true \"= true, if animation shall be enabled\";
//   parameter Real simpleChassis3D.toCenterOfGravity.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.5 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String simpleChassis3D.toCenterOfGravity.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real simpleChassis3D.toCenterOfGravity.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer simpleChassis3D.toCenterOfGravity.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer simpleChassis3D.toCenterOfGravity.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer simpleChassis3D.toCenterOfGravity.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real simpleChassis3D.toCenterOfGravity.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real simpleChassis3D.toCenterOfGravity.lengthDirection[1](unit = \"1\") = simpleChassis3D.toCenterOfGravity.r[1] - simpleChassis3D.toCenterOfGravity.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.lengthDirection[2](unit = \"1\") = simpleChassis3D.toCenterOfGravity.r[2] - simpleChassis3D.toCenterOfGravity.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.lengthDirection[3](unit = \"1\") = simpleChassis3D.toCenterOfGravity.r[3] - simpleChassis3D.toCenterOfGravity.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real simpleChassis3D.toCenterOfGravity.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({simpleChassis3D.toCenterOfGravity.r[1] - simpleChassis3D.toCenterOfGravity.r_shape[1],simpleChassis3D.toCenterOfGravity.r[2] - simpleChassis3D.toCenterOfGravity.r_shape[2],simpleChassis3D.toCenterOfGravity.r[3] - simpleChassis3D.toCenterOfGravity.r_shape[3]}) \" Length of shape\";
//   parameter Real simpleChassis3D.toCenterOfGravity.width(quantity = \"Length\", unit = \"m\", min = 0.0) = simpleChassis3D.toCenterOfGravity.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real simpleChassis3D.toCenterOfGravity.height(quantity = \"Length\", unit = \"m\", min = 0.0) = simpleChassis3D.toCenterOfGravity.width \" Height of shape.\";
//   parameter String simpleChassis3D.toCenterOfGravity.shape.shapeType = simpleChassis3D.toCenterOfGravity.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[1,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[1,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[1,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[2,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[2,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[2,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[3,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[3,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.T[3,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.toCenterOfGravity.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.toCenterOfGravity.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.toCenterOfGravity.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.r[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.lengthDirection[1](unit = \"1\") = simpleChassis3D.toCenterOfGravity.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.lengthDirection[2](unit = \"1\") = simpleChassis3D.toCenterOfGravity.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.lengthDirection[3](unit = \"1\") = simpleChassis3D.toCenterOfGravity.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.widthDirection[1](unit = \"1\") = simpleChassis3D.toCenterOfGravity.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.widthDirection[2](unit = \"1\") = simpleChassis3D.toCenterOfGravity.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.widthDirection[3](unit = \"1\") = simpleChassis3D.toCenterOfGravity.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.length(quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.length \"Length of visual object\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.width(quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.width \"Width of visual object\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.height(quantity = \"Length\", unit = \"m\") = simpleChassis3D.toCenterOfGravity.height \"Height of visual object\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.extra = simpleChassis3D.toCenterOfGravity.extra \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.color[1] = Real(simpleChassis3D.toCenterOfGravity.color[1]) \"Color of shape\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.color[2] = Real(simpleChassis3D.toCenterOfGravity.color[2]) \"Color of shape\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.color[3] = Real(simpleChassis3D.toCenterOfGravity.color[3]) \"Color of shape\";
//   input Real simpleChassis3D.toCenterOfGravity.shape.specularCoefficient = simpleChassis3D.toCenterOfGravity.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.toCenterOfGravity.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.toCenterOfGravity.shape.lengthDirection[1],simpleChassis3D.toCenterOfGravity.shape.lengthDirection[2],simpleChassis3D.toCenterOfGravity.shape.lengthDirection[3]});
//   protected Real simpleChassis3D.toCenterOfGravity.shape.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.toCenterOfGravity.shape.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.toCenterOfGravity.shape.lengthDirection[1] / simpleChassis3D.toCenterOfGravity.shape.abs_n_x;
//   protected Real simpleChassis3D.toCenterOfGravity.shape.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.toCenterOfGravity.shape.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.toCenterOfGravity.shape.lengthDirection[2] / simpleChassis3D.toCenterOfGravity.shape.abs_n_x;
//   protected Real simpleChassis3D.toCenterOfGravity.shape.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.toCenterOfGravity.shape.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.toCenterOfGravity.shape.lengthDirection[3] / simpleChassis3D.toCenterOfGravity.shape.abs_n_x;
//   protected Real simpleChassis3D.toCenterOfGravity.shape.n_z_aux[1](unit = \"1\") = simpleChassis3D.toCenterOfGravity.shape.e_x[2] * simpleChassis3D.toCenterOfGravity.shape.widthDirection[3] - simpleChassis3D.toCenterOfGravity.shape.e_x[3] * simpleChassis3D.toCenterOfGravity.shape.widthDirection[2];
//   protected Real simpleChassis3D.toCenterOfGravity.shape.n_z_aux[2](unit = \"1\") = simpleChassis3D.toCenterOfGravity.shape.e_x[3] * simpleChassis3D.toCenterOfGravity.shape.widthDirection[1] - simpleChassis3D.toCenterOfGravity.shape.e_x[1] * simpleChassis3D.toCenterOfGravity.shape.widthDirection[3];
//   protected Real simpleChassis3D.toCenterOfGravity.shape.n_z_aux[3](unit = \"1\") = simpleChassis3D.toCenterOfGravity.shape.e_x[1] * simpleChassis3D.toCenterOfGravity.shape.widthDirection[2] - simpleChassis3D.toCenterOfGravity.shape.e_x[2] * simpleChassis3D.toCenterOfGravity.shape.widthDirection[1];
//   protected Real simpleChassis3D.toCenterOfGravity.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.toCenterOfGravity.shape.e_x[1],simpleChassis3D.toCenterOfGravity.shape.e_x[2],simpleChassis3D.toCenterOfGravity.shape.e_x[3]},if noEvent(simpleChassis3D.toCenterOfGravity.shape.n_z_aux[1] ^ 2.0 + (simpleChassis3D.toCenterOfGravity.shape.n_z_aux[2] ^ 2.0 + simpleChassis3D.toCenterOfGravity.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.toCenterOfGravity.shape.widthDirection[1],simpleChassis3D.toCenterOfGravity.shape.widthDirection[2],simpleChassis3D.toCenterOfGravity.shape.widthDirection[3]} else if noEvent(abs(simpleChassis3D.toCenterOfGravity.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.toCenterOfGravity.shape.e_x[1],simpleChassis3D.toCenterOfGravity.shape.e_x[2],simpleChassis3D.toCenterOfGravity.shape.e_x[3]})[1];
//   protected Real simpleChassis3D.toCenterOfGravity.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.toCenterOfGravity.shape.e_x[1],simpleChassis3D.toCenterOfGravity.shape.e_x[2],simpleChassis3D.toCenterOfGravity.shape.e_x[3]},if noEvent(simpleChassis3D.toCenterOfGravity.shape.n_z_aux[1] ^ 2.0 + (simpleChassis3D.toCenterOfGravity.shape.n_z_aux[2] ^ 2.0 + simpleChassis3D.toCenterOfGravity.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.toCenterOfGravity.shape.widthDirection[1],simpleChassis3D.toCenterOfGravity.shape.widthDirection[2],simpleChassis3D.toCenterOfGravity.shape.widthDirection[3]} else if noEvent(abs(simpleChassis3D.toCenterOfGravity.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.toCenterOfGravity.shape.e_x[1],simpleChassis3D.toCenterOfGravity.shape.e_x[2],simpleChassis3D.toCenterOfGravity.shape.e_x[3]})[2];
//   protected Real simpleChassis3D.toCenterOfGravity.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.toCenterOfGravity.shape.e_x[1],simpleChassis3D.toCenterOfGravity.shape.e_x[2],simpleChassis3D.toCenterOfGravity.shape.e_x[3]},if noEvent(simpleChassis3D.toCenterOfGravity.shape.n_z_aux[1] ^ 2.0 + (simpleChassis3D.toCenterOfGravity.shape.n_z_aux[2] ^ 2.0 + simpleChassis3D.toCenterOfGravity.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.toCenterOfGravity.shape.widthDirection[1],simpleChassis3D.toCenterOfGravity.shape.widthDirection[2],simpleChassis3D.toCenterOfGravity.shape.widthDirection[3]} else if noEvent(abs(simpleChassis3D.toCenterOfGravity.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.toCenterOfGravity.shape.e_x[1],simpleChassis3D.toCenterOfGravity.shape.e_x[2],simpleChassis3D.toCenterOfGravity.shape.e_x[3]})[3];
//   protected output Real simpleChassis3D.toCenterOfGravity.shape.Form;
//   output Real simpleChassis3D.toCenterOfGravity.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.toCenterOfGravity.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.toCenterOfGravity.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.toCenterOfGravity.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.toCenterOfGravity.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.toCenterOfGravity.shape.Material;
//   protected output Real simpleChassis3D.toCenterOfGravity.shape.Extra;
//   Real simpleChassis3D.roll.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.roll.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.roll.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.roll.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.roll.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.roll.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean simpleChassis3D.roll.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean simpleChassis3D.roll.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real simpleChassis3D.roll.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real simpleChassis3D.roll.n[2](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real simpleChassis3D.roll.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real simpleChassis3D.roll.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real simpleChassis3D.roll.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real simpleChassis3D.roll.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer simpleChassis3D.roll.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer simpleChassis3D.roll.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer simpleChassis3D.roll.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real simpleChassis3D.roll.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) simpleChassis3D.roll.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real simpleChassis3D.roll.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real simpleChassis3D.roll.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real simpleChassis3D.roll.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real simpleChassis3D.roll.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.roll.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.roll.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real simpleChassis3D.roll.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real simpleChassis3D.roll.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.roll.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real simpleChassis3D.roll.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.roll.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real simpleChassis3D.roll.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.roll.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected parameter Real simpleChassis3D.roll.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({simpleChassis3D.roll.n[1],simpleChassis3D.roll.n[2],simpleChassis3D.roll.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real simpleChassis3D.roll.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({simpleChassis3D.roll.n[1],simpleChassis3D.roll.n[2],simpleChassis3D.roll.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real simpleChassis3D.roll.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({simpleChassis3D.roll.n[1],simpleChassis3D.roll.n[2],simpleChassis3D.roll.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real simpleChassis3D.roll.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real simpleChassis3D.roll.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   input Real simpleChassis3D.roll.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = simpleChassis3D.roll.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real simpleChassis3D.roll.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real simpleChassis3D.roll.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.roll.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String simpleChassis3D.roll.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.roll.cylinder.R.T[1,1] = simpleChassis3D.roll.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[1,2] = simpleChassis3D.roll.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[1,3] = simpleChassis3D.roll.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[2,1] = simpleChassis3D.roll.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[2,2] = simpleChassis3D.roll.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[2,3] = simpleChassis3D.roll.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[3,1] = simpleChassis3D.roll.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[3,2] = simpleChassis3D.roll.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.T[3,3] = simpleChassis3D.roll.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.roll.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.roll.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.roll.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.roll.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.roll.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.roll.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.roll.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.roll.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.roll.cylinder.r[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.roll.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.roll.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-simpleChassis3D.roll.e[1]) * simpleChassis3D.roll.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-simpleChassis3D.roll.e[2]) * simpleChassis3D.roll.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-simpleChassis3D.roll.e[3]) * simpleChassis3D.roll.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis3D.roll.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis3D.roll.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.lengthDirection[3](unit = \"1\") = simpleChassis3D.roll.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.roll.cylinder.length(quantity = \"Length\", unit = \"m\") = simpleChassis3D.roll.cylinderLength \"Length of visual object\";
//   input Real simpleChassis3D.roll.cylinder.width(quantity = \"Length\", unit = \"m\") = simpleChassis3D.roll.cylinderDiameter \"Width of visual object\";
//   input Real simpleChassis3D.roll.cylinder.height(quantity = \"Length\", unit = \"m\") = simpleChassis3D.roll.cylinderDiameter \"Height of visual object\";
//   input Real simpleChassis3D.roll.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.roll.cylinder.color[1] = Real(simpleChassis3D.roll.cylinderColor[1]) \"Color of shape\";
//   input Real simpleChassis3D.roll.cylinder.color[2] = Real(simpleChassis3D.roll.cylinderColor[2]) \"Color of shape\";
//   input Real simpleChassis3D.roll.cylinder.color[3] = Real(simpleChassis3D.roll.cylinderColor[3]) \"Color of shape\";
//   input Real simpleChassis3D.roll.cylinder.specularCoefficient = simpleChassis3D.roll.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.roll.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.roll.cylinder.lengthDirection[1],simpleChassis3D.roll.cylinder.lengthDirection[2],simpleChassis3D.roll.cylinder.lengthDirection[3]});
//   protected Real simpleChassis3D.roll.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.roll.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.roll.cylinder.lengthDirection[1] / simpleChassis3D.roll.cylinder.abs_n_x;
//   protected Real simpleChassis3D.roll.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.roll.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.roll.cylinder.lengthDirection[2] / simpleChassis3D.roll.cylinder.abs_n_x;
//   protected Real simpleChassis3D.roll.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.roll.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.roll.cylinder.lengthDirection[3] / simpleChassis3D.roll.cylinder.abs_n_x;
//   protected Real simpleChassis3D.roll.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis3D.roll.cylinder.e_x[2] * simpleChassis3D.roll.cylinder.widthDirection[3] - simpleChassis3D.roll.cylinder.e_x[3] * simpleChassis3D.roll.cylinder.widthDirection[2];
//   protected Real simpleChassis3D.roll.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis3D.roll.cylinder.e_x[3] * simpleChassis3D.roll.cylinder.widthDirection[1] - simpleChassis3D.roll.cylinder.e_x[1] * simpleChassis3D.roll.cylinder.widthDirection[3];
//   protected Real simpleChassis3D.roll.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis3D.roll.cylinder.e_x[1] * simpleChassis3D.roll.cylinder.widthDirection[2] - simpleChassis3D.roll.cylinder.e_x[2] * simpleChassis3D.roll.cylinder.widthDirection[1];
//   protected Real simpleChassis3D.roll.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.roll.cylinder.e_x[1],simpleChassis3D.roll.cylinder.e_x[2],simpleChassis3D.roll.cylinder.e_x[3]},if noEvent(simpleChassis3D.roll.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.roll.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.roll.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.roll.cylinder.widthDirection[1],simpleChassis3D.roll.cylinder.widthDirection[2],simpleChassis3D.roll.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.roll.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.roll.cylinder.e_x[1],simpleChassis3D.roll.cylinder.e_x[2],simpleChassis3D.roll.cylinder.e_x[3]})[1];
//   protected Real simpleChassis3D.roll.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.roll.cylinder.e_x[1],simpleChassis3D.roll.cylinder.e_x[2],simpleChassis3D.roll.cylinder.e_x[3]},if noEvent(simpleChassis3D.roll.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.roll.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.roll.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.roll.cylinder.widthDirection[1],simpleChassis3D.roll.cylinder.widthDirection[2],simpleChassis3D.roll.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.roll.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.roll.cylinder.e_x[1],simpleChassis3D.roll.cylinder.e_x[2],simpleChassis3D.roll.cylinder.e_x[3]})[2];
//   protected Real simpleChassis3D.roll.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.roll.cylinder.e_x[1],simpleChassis3D.roll.cylinder.e_x[2],simpleChassis3D.roll.cylinder.e_x[3]},if noEvent(simpleChassis3D.roll.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.roll.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.roll.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.roll.cylinder.widthDirection[1],simpleChassis3D.roll.cylinder.widthDirection[2],simpleChassis3D.roll.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.roll.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.roll.cylinder.e_x[1],simpleChassis3D.roll.cylinder.e_x[2],simpleChassis3D.roll.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis3D.roll.cylinder.Form;
//   output Real simpleChassis3D.roll.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.roll.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.roll.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.roll.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.roll.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.roll.cylinder.Material;
//   protected output Real simpleChassis3D.roll.cylinder.Extra;
//   Real simpleChassis3D.pitch.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.pitch.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.pitch.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.pitch.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.pitch.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.pitch.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean simpleChassis3D.pitch.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean simpleChassis3D.pitch.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real simpleChassis3D.pitch.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real simpleChassis3D.pitch.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real simpleChassis3D.pitch.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real simpleChassis3D.pitch.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real simpleChassis3D.pitch.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real simpleChassis3D.pitch.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer simpleChassis3D.pitch.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer simpleChassis3D.pitch.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer simpleChassis3D.pitch.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real simpleChassis3D.pitch.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) simpleChassis3D.pitch.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real simpleChassis3D.pitch.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real simpleChassis3D.pitch.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real simpleChassis3D.pitch.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real simpleChassis3D.pitch.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.pitch.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.pitch.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real simpleChassis3D.pitch.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real simpleChassis3D.pitch.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.pitch.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real simpleChassis3D.pitch.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.pitch.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real simpleChassis3D.pitch.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.pitch.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected parameter Real simpleChassis3D.pitch.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({simpleChassis3D.pitch.n[1],simpleChassis3D.pitch.n[2],simpleChassis3D.pitch.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real simpleChassis3D.pitch.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({simpleChassis3D.pitch.n[1],simpleChassis3D.pitch.n[2],simpleChassis3D.pitch.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real simpleChassis3D.pitch.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({simpleChassis3D.pitch.n[1],simpleChassis3D.pitch.n[2],simpleChassis3D.pitch.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real simpleChassis3D.pitch.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real simpleChassis3D.pitch.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   input Real simpleChassis3D.pitch.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = simpleChassis3D.pitch.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real simpleChassis3D.pitch.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real simpleChassis3D.pitch.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.pitch.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String simpleChassis3D.pitch.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[1,1] = simpleChassis3D.pitch.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[1,2] = simpleChassis3D.pitch.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[1,3] = simpleChassis3D.pitch.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[2,1] = simpleChassis3D.pitch.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[2,2] = simpleChassis3D.pitch.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[2,3] = simpleChassis3D.pitch.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[3,1] = simpleChassis3D.pitch.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[3,2] = simpleChassis3D.pitch.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.T[3,3] = simpleChassis3D.pitch.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.pitch.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.pitch.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.pitch.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.pitch.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.pitch.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.pitch.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.pitch.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.pitch.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.pitch.cylinder.r[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.pitch.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.pitch.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-simpleChassis3D.pitch.e[1]) * simpleChassis3D.pitch.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-simpleChassis3D.pitch.e[2]) * simpleChassis3D.pitch.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-simpleChassis3D.pitch.e[3]) * simpleChassis3D.pitch.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis3D.pitch.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis3D.pitch.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.lengthDirection[3](unit = \"1\") = simpleChassis3D.pitch.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.pitch.cylinder.length(quantity = \"Length\", unit = \"m\") = simpleChassis3D.pitch.cylinderLength \"Length of visual object\";
//   input Real simpleChassis3D.pitch.cylinder.width(quantity = \"Length\", unit = \"m\") = simpleChassis3D.pitch.cylinderDiameter \"Width of visual object\";
//   input Real simpleChassis3D.pitch.cylinder.height(quantity = \"Length\", unit = \"m\") = simpleChassis3D.pitch.cylinderDiameter \"Height of visual object\";
//   input Real simpleChassis3D.pitch.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.pitch.cylinder.color[1] = Real(simpleChassis3D.pitch.cylinderColor[1]) \"Color of shape\";
//   input Real simpleChassis3D.pitch.cylinder.color[2] = Real(simpleChassis3D.pitch.cylinderColor[2]) \"Color of shape\";
//   input Real simpleChassis3D.pitch.cylinder.color[3] = Real(simpleChassis3D.pitch.cylinderColor[3]) \"Color of shape\";
//   input Real simpleChassis3D.pitch.cylinder.specularCoefficient = simpleChassis3D.pitch.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.pitch.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.pitch.cylinder.lengthDirection[1],simpleChassis3D.pitch.cylinder.lengthDirection[2],simpleChassis3D.pitch.cylinder.lengthDirection[3]});
//   protected Real simpleChassis3D.pitch.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.pitch.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.pitch.cylinder.lengthDirection[1] / simpleChassis3D.pitch.cylinder.abs_n_x;
//   protected Real simpleChassis3D.pitch.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.pitch.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.pitch.cylinder.lengthDirection[2] / simpleChassis3D.pitch.cylinder.abs_n_x;
//   protected Real simpleChassis3D.pitch.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.pitch.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.pitch.cylinder.lengthDirection[3] / simpleChassis3D.pitch.cylinder.abs_n_x;
//   protected Real simpleChassis3D.pitch.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis3D.pitch.cylinder.e_x[2] * simpleChassis3D.pitch.cylinder.widthDirection[3] - simpleChassis3D.pitch.cylinder.e_x[3] * simpleChassis3D.pitch.cylinder.widthDirection[2];
//   protected Real simpleChassis3D.pitch.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis3D.pitch.cylinder.e_x[3] * simpleChassis3D.pitch.cylinder.widthDirection[1] - simpleChassis3D.pitch.cylinder.e_x[1] * simpleChassis3D.pitch.cylinder.widthDirection[3];
//   protected Real simpleChassis3D.pitch.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis3D.pitch.cylinder.e_x[1] * simpleChassis3D.pitch.cylinder.widthDirection[2] - simpleChassis3D.pitch.cylinder.e_x[2] * simpleChassis3D.pitch.cylinder.widthDirection[1];
//   protected Real simpleChassis3D.pitch.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.pitch.cylinder.e_x[1],simpleChassis3D.pitch.cylinder.e_x[2],simpleChassis3D.pitch.cylinder.e_x[3]},if noEvent(simpleChassis3D.pitch.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.pitch.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.pitch.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.pitch.cylinder.widthDirection[1],simpleChassis3D.pitch.cylinder.widthDirection[2],simpleChassis3D.pitch.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.pitch.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.pitch.cylinder.e_x[1],simpleChassis3D.pitch.cylinder.e_x[2],simpleChassis3D.pitch.cylinder.e_x[3]})[1];
//   protected Real simpleChassis3D.pitch.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.pitch.cylinder.e_x[1],simpleChassis3D.pitch.cylinder.e_x[2],simpleChassis3D.pitch.cylinder.e_x[3]},if noEvent(simpleChassis3D.pitch.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.pitch.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.pitch.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.pitch.cylinder.widthDirection[1],simpleChassis3D.pitch.cylinder.widthDirection[2],simpleChassis3D.pitch.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.pitch.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.pitch.cylinder.e_x[1],simpleChassis3D.pitch.cylinder.e_x[2],simpleChassis3D.pitch.cylinder.e_x[3]})[2];
//   protected Real simpleChassis3D.pitch.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.pitch.cylinder.e_x[1],simpleChassis3D.pitch.cylinder.e_x[2],simpleChassis3D.pitch.cylinder.e_x[3]},if noEvent(simpleChassis3D.pitch.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.pitch.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.pitch.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.pitch.cylinder.widthDirection[1],simpleChassis3D.pitch.cylinder.widthDirection[2],simpleChassis3D.pitch.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.pitch.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.pitch.cylinder.e_x[1],simpleChassis3D.pitch.cylinder.e_x[2],simpleChassis3D.pitch.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis3D.pitch.cylinder.Form;
//   output Real simpleChassis3D.pitch.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.pitch.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.pitch.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.pitch.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.pitch.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.pitch.cylinder.Material;
//   protected output Real simpleChassis3D.pitch.cylinder.Extra;
//   Real simpleChassis3D.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis3D.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis3D.fixedTranslationFront.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.fixedTranslationFront.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.fixedTranslationFront.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.fixedTranslationFront.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.fixedTranslationFront.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.fixedTranslationFront.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis3D.fixedTranslationFront.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.fixedTranslationFront.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.fixedTranslationFront.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.fixedTranslationFront.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.fixedTranslationFront.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.fixedTranslationFront.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real simpleChassis3D.fixedTranslationFront.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real simpleChassis3D.fixedTranslationFront.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.wheelBase / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real simpleChassis3D.fixedTranslationFront.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis3D.fixedTranslationFront.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis3D.fixedTranslationFront.R[1,1] \"Rotation matrix\";
//   Real simpleChassis3D.fixedTranslationFront.R[1,2] \"Rotation matrix\";
//   Real simpleChassis3D.fixedTranslationFront.R[2,1] \"Rotation matrix\";
//   Real simpleChassis3D.fixedTranslationFront.R[2,2] \"Rotation matrix\";
//   parameter Boolean simpleChassis3D.fixedTranslationFront.animate = true \"enable Animation\";
//   final parameter Real simpleChassis3D.fixedTranslationFront.l(quantity = \"Length\", unit = \"m\") = sqrt(simpleChassis3D.fixedTranslationFront.r[1] ^ 2.0 + simpleChassis3D.fixedTranslationFront.r[2] ^ 2.0);
//   parameter String simpleChassis3D.fixedTranslationFront.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.fixedTranslationFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.fixedTranslationFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis3D.fixedTranslationFront.r0[1] / simpleChassis3D.fixedTranslationFront.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis3D.fixedTranslationFront.r0[2] / simpleChassis3D.fixedTranslationFront.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.length(quantity = \"Length\", unit = \"m\") = simpleChassis3D.fixedTranslationFront.l \"Length of visual object\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real simpleChassis3D.fixedTranslationFront.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[1],simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[2],simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[3]});
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[1] / simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x;
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[2] / simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x;
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.fixedTranslationFront.cylinder.lengthDirection[3] / simpleChassis3D.fixedTranslationFront.cylinder.abs_n_x;
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis3D.fixedTranslationFront.cylinder.e_x[2] * simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[3] - simpleChassis3D.fixedTranslationFront.cylinder.e_x[3] * simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[2];
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis3D.fixedTranslationFront.cylinder.e_x[3] * simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[1] - simpleChassis3D.fixedTranslationFront.cylinder.e_x[1] * simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[3];
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis3D.fixedTranslationFront.cylinder.e_x[1] * simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[2] - simpleChassis3D.fixedTranslationFront.cylinder.e_x[2] * simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[1];
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.fixedTranslationFront.cylinder.e_x[1],simpleChassis3D.fixedTranslationFront.cylinder.e_x[2],simpleChassis3D.fixedTranslationFront.cylinder.e_x[3]},if noEvent(simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[1],simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[2],simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.fixedTranslationFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.fixedTranslationFront.cylinder.e_x[1],simpleChassis3D.fixedTranslationFront.cylinder.e_x[2],simpleChassis3D.fixedTranslationFront.cylinder.e_x[3]})[1];
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.fixedTranslationFront.cylinder.e_x[1],simpleChassis3D.fixedTranslationFront.cylinder.e_x[2],simpleChassis3D.fixedTranslationFront.cylinder.e_x[3]},if noEvent(simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[1],simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[2],simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.fixedTranslationFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.fixedTranslationFront.cylinder.e_x[1],simpleChassis3D.fixedTranslationFront.cylinder.e_x[2],simpleChassis3D.fixedTranslationFront.cylinder.e_x[3]})[2];
//   protected Real simpleChassis3D.fixedTranslationFront.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.fixedTranslationFront.cylinder.e_x[1],simpleChassis3D.fixedTranslationFront.cylinder.e_x[2],simpleChassis3D.fixedTranslationFront.cylinder.e_x[3]},if noEvent(simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.fixedTranslationFront.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[1],simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[2],simpleChassis3D.fixedTranslationFront.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.fixedTranslationFront.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.fixedTranslationFront.cylinder.e_x[1],simpleChassis3D.fixedTranslationFront.cylinder.e_x[2],simpleChassis3D.fixedTranslationFront.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis3D.fixedTranslationFront.cylinder.Form;
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationFront.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.fixedTranslationFront.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.fixedTranslationFront.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.fixedTranslationFront.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.fixedTranslationFront.cylinder.Material;
//   protected output Real simpleChassis3D.fixedTranslationFront.cylinder.Extra;
//   Real simpleChassis3D.fixedTranslationRear.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.fixedTranslationRear.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.fixedTranslationRear.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.fixedTranslationRear.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.fixedTranslationRear.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.fixedTranslationRear.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real simpleChassis3D.fixedTranslationRear.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.fixedTranslationRear.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.fixedTranslationRear.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.fixedTranslationRear.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.fixedTranslationRear.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.fixedTranslationRear.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real simpleChassis3D.fixedTranslationRear.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real simpleChassis3D.fixedTranslationRear.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.wheelBase / 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real simpleChassis3D.fixedTranslationRear.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis3D.fixedTranslationRear.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real simpleChassis3D.fixedTranslationRear.R[1,1] \"Rotation matrix\";
//   Real simpleChassis3D.fixedTranslationRear.R[1,2] \"Rotation matrix\";
//   Real simpleChassis3D.fixedTranslationRear.R[2,1] \"Rotation matrix\";
//   Real simpleChassis3D.fixedTranslationRear.R[2,2] \"Rotation matrix\";
//   parameter Boolean simpleChassis3D.fixedTranslationRear.animate = true \"enable Animation\";
//   final parameter Real simpleChassis3D.fixedTranslationRear.l(quantity = \"Length\", unit = \"m\") = sqrt(simpleChassis3D.fixedTranslationRear.r[1] ^ 2.0 + simpleChassis3D.fixedTranslationRear.r[2] ^ 2.0);
//   parameter String simpleChassis3D.fixedTranslationRear.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.fixedTranslationRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.fixedTranslationRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis3D.fixedTranslationRear.r0[1] / simpleChassis3D.fixedTranslationRear.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis3D.fixedTranslationRear.r0[2] / simpleChassis3D.fixedTranslationRear.l \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.length(quantity = \"Length\", unit = \"m\") = simpleChassis3D.fixedTranslationRear.l \"Length of visual object\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real simpleChassis3D.fixedTranslationRear.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[1],simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[2],simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[3]});
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[1] / simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x;
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[2] / simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x;
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.fixedTranslationRear.cylinder.lengthDirection[3] / simpleChassis3D.fixedTranslationRear.cylinder.abs_n_x;
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis3D.fixedTranslationRear.cylinder.e_x[2] * simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[3] - simpleChassis3D.fixedTranslationRear.cylinder.e_x[3] * simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[2];
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis3D.fixedTranslationRear.cylinder.e_x[3] * simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[1] - simpleChassis3D.fixedTranslationRear.cylinder.e_x[1] * simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[3];
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis3D.fixedTranslationRear.cylinder.e_x[1] * simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[2] - simpleChassis3D.fixedTranslationRear.cylinder.e_x[2] * simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[1];
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.fixedTranslationRear.cylinder.e_x[1],simpleChassis3D.fixedTranslationRear.cylinder.e_x[2],simpleChassis3D.fixedTranslationRear.cylinder.e_x[3]},if noEvent(simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[1],simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[2],simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.fixedTranslationRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.fixedTranslationRear.cylinder.e_x[1],simpleChassis3D.fixedTranslationRear.cylinder.e_x[2],simpleChassis3D.fixedTranslationRear.cylinder.e_x[3]})[1];
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.fixedTranslationRear.cylinder.e_x[1],simpleChassis3D.fixedTranslationRear.cylinder.e_x[2],simpleChassis3D.fixedTranslationRear.cylinder.e_x[3]},if noEvent(simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[1],simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[2],simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.fixedTranslationRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.fixedTranslationRear.cylinder.e_x[1],simpleChassis3D.fixedTranslationRear.cylinder.e_x[2],simpleChassis3D.fixedTranslationRear.cylinder.e_x[3]})[2];
//   protected Real simpleChassis3D.fixedTranslationRear.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.fixedTranslationRear.cylinder.e_x[1],simpleChassis3D.fixedTranslationRear.cylinder.e_x[2],simpleChassis3D.fixedTranslationRear.cylinder.e_x[3]},if noEvent(simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.fixedTranslationRear.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[1],simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[2],simpleChassis3D.fixedTranslationRear.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.fixedTranslationRear.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.fixedTranslationRear.cylinder.e_x[1],simpleChassis3D.fixedTranslationRear.cylinder.e_x[2],simpleChassis3D.fixedTranslationRear.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis3D.fixedTranslationRear.cylinder.Form;
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.fixedTranslationRear.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.fixedTranslationRear.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.fixedTranslationRear.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.fixedTranslationRear.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.fixedTranslationRear.cylinder.Material;
//   protected output Real simpleChassis3D.fixedTranslationRear.cylinder.Extra;
//   Real simpleChassis3D.dynamicLoad.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real simpleChassis3D.dynamicLoad.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean simpleChassis3D.dynamicLoad.animation = true \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real simpleChassis3D.dynamicLoad.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real simpleChassis3D.dynamicLoad.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real simpleChassis3D.dynamicLoad.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real simpleChassis3D.dynamicLoad.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = simpleChassis3D.m_dynamic \"Mass of rigid body\";
//   parameter Real simpleChassis3D.dynamicLoad.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0 \" (1,1) element of inertia tensor\";
//   parameter Real simpleChassis3D.dynamicLoad.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0 \" (2,2) element of inertia tensor\";
//   parameter Real simpleChassis3D.dynamicLoad.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0 \" (3,3) element of inertia tensor\";
//   parameter Real simpleChassis3D.dynamicLoad.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real simpleChassis3D.dynamicLoad.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real simpleChassis3D.dynamicLoad.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real simpleChassis3D.dynamicLoad.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real simpleChassis3D.dynamicLoad.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real simpleChassis3D.dynamicLoad.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real simpleChassis3D.dynamicLoad.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real simpleChassis3D.dynamicLoad.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real simpleChassis3D.dynamicLoad.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real simpleChassis3D.dynamicLoad.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real simpleChassis3D.dynamicLoad.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real simpleChassis3D.dynamicLoad.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean simpleChassis3D.dynamicLoad.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real simpleChassis3D.dynamicLoad.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real simpleChassis3D.dynamicLoad.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real simpleChassis3D.dynamicLoad.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer simpleChassis3D.dynamicLoad.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer simpleChassis3D.dynamicLoad.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer simpleChassis3D.dynamicLoad.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean simpleChassis3D.dynamicLoad.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real simpleChassis3D.dynamicLoad.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real simpleChassis3D.dynamicLoad.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real simpleChassis3D.dynamicLoad.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean simpleChassis3D.dynamicLoad.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real simpleChassis3D.dynamicLoad.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real simpleChassis3D.dynamicLoad.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real simpleChassis3D.dynamicLoad.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real simpleChassis3D.dynamicLoad.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer simpleChassis3D.dynamicLoad.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer simpleChassis3D.dynamicLoad.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer simpleChassis3D.dynamicLoad.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer simpleChassis3D.dynamicLoad.cylinderColor[1](min = 0, max = 255) = simpleChassis3D.dynamicLoad.sphereColor[1] \"Color of cylinder\";
//   input Integer simpleChassis3D.dynamicLoad.cylinderColor[2](min = 0, max = 255) = simpleChassis3D.dynamicLoad.sphereColor[2] \"Color of cylinder\";
//   input Integer simpleChassis3D.dynamicLoad.cylinderColor[3](min = 0, max = 255) = simpleChassis3D.dynamicLoad.sphereColor[3] \"Color of cylinder\";
//   input Real simpleChassis3D.dynamicLoad.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean simpleChassis3D.dynamicLoad.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean simpleChassis3D.dynamicLoad.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer simpleChassis3D.dynamicLoad.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer simpleChassis3D.dynamicLoad.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer simpleChassis3D.dynamicLoad.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real simpleChassis3D.dynamicLoad.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.w_0_start[1],simpleChassis3D.dynamicLoad.w_0_start[2],simpleChassis3D.dynamicLoad.w_0_start[3]})[1], fixed = simpleChassis3D.dynamicLoad.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real simpleChassis3D.dynamicLoad.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.w_0_start[1],simpleChassis3D.dynamicLoad.w_0_start[2],simpleChassis3D.dynamicLoad.w_0_start[3]})[2], fixed = simpleChassis3D.dynamicLoad.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real simpleChassis3D.dynamicLoad.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.w_0_start[1],simpleChassis3D.dynamicLoad.w_0_start[2],simpleChassis3D.dynamicLoad.w_0_start[3]})[3], fixed = simpleChassis3D.dynamicLoad.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real simpleChassis3D.dynamicLoad.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real simpleChassis3D.dynamicLoad.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real simpleChassis3D.dynamicLoad.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real simpleChassis3D.dynamicLoad.Q[1](start = simpleChassis3D.dynamicLoad.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real simpleChassis3D.dynamicLoad.Q[2](start = simpleChassis3D.dynamicLoad.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real simpleChassis3D.dynamicLoad.Q[3](start = simpleChassis3D.dynamicLoad.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real simpleChassis3D.dynamicLoad.Q[4](start = simpleChassis3D.dynamicLoad.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real simpleChassis3D.dynamicLoad.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if simpleChassis3D.dynamicLoad.sequence_start[1] == simpleChassis3D.dynamicLoad.sequence_angleStates[1] and simpleChassis3D.dynamicLoad.sequence_start[2] == simpleChassis3D.dynamicLoad.sequence_angleStates[2] and simpleChassis3D.dynamicLoad.sequence_start[3] == simpleChassis3D.dynamicLoad.sequence_angleStates[3] then simpleChassis3D.dynamicLoad.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.sequence_angleStates[1],simpleChassis3D.dynamicLoad.sequence_angleStates[2],simpleChassis3D.dynamicLoad.sequence_angleStates[3]},0)[1] \"Potential angle states at initial time\";
//   protected parameter Real simpleChassis3D.dynamicLoad.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if simpleChassis3D.dynamicLoad.sequence_start[1] == simpleChassis3D.dynamicLoad.sequence_angleStates[1] and simpleChassis3D.dynamicLoad.sequence_start[2] == simpleChassis3D.dynamicLoad.sequence_angleStates[2] and simpleChassis3D.dynamicLoad.sequence_start[3] == simpleChassis3D.dynamicLoad.sequence_angleStates[3] then simpleChassis3D.dynamicLoad.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.sequence_angleStates[1],simpleChassis3D.dynamicLoad.sequence_angleStates[2],simpleChassis3D.dynamicLoad.sequence_angleStates[3]},0)[2] \"Potential angle states at initial time\";
//   protected parameter Real simpleChassis3D.dynamicLoad.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if simpleChassis3D.dynamicLoad.sequence_start[1] == simpleChassis3D.dynamicLoad.sequence_angleStates[1] and simpleChassis3D.dynamicLoad.sequence_start[2] == simpleChassis3D.dynamicLoad.sequence_angleStates[2] and simpleChassis3D.dynamicLoad.sequence_start[3] == simpleChassis3D.dynamicLoad.sequence_angleStates[3] then simpleChassis3D.dynamicLoad.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.sequence_angleStates[1],simpleChassis3D.dynamicLoad.sequence_angleStates[2],simpleChassis3D.dynamicLoad.sequence_angleStates[3]},0)[3] \"Potential angle states at initial time\";
//   protected Real simpleChassis3D.dynamicLoad.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = simpleChassis3D.dynamicLoad.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real simpleChassis3D.dynamicLoad.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = simpleChassis3D.dynamicLoad.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real simpleChassis3D.dynamicLoad.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = simpleChassis3D.dynamicLoad.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real simpleChassis3D.dynamicLoad.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real simpleChassis3D.dynamicLoad.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real simpleChassis3D.dynamicLoad.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real simpleChassis3D.dynamicLoad.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real simpleChassis3D.dynamicLoad.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real simpleChassis3D.dynamicLoad.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_11 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_21 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_31 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_21 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_22 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_32 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_31 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_32 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = simpleChassis3D.dynamicLoad.I_33 \"inertia tensor\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real simpleChassis3D.dynamicLoad.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real simpleChassis3D.dynamicLoad.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = simpleChassis3D.dynamicLoad.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real simpleChassis3D.dynamicLoad.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.z_0_start[1],simpleChassis3D.dynamicLoad.z_0_start[2],simpleChassis3D.dynamicLoad.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real simpleChassis3D.dynamicLoad.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.z_0_start[1],simpleChassis3D.dynamicLoad.z_0_start[2],simpleChassis3D.dynamicLoad.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real simpleChassis3D.dynamicLoad.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.z_0_start[1],simpleChassis3D.dynamicLoad.z_0_start[2],simpleChassis3D.dynamicLoad.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real simpleChassis3D.dynamicLoad.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.z_0_start[1],simpleChassis3D.dynamicLoad.z_0_start[2],simpleChassis3D.dynamicLoad.z_0_start[3]})[1], fixed = simpleChassis3D.dynamicLoad.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real simpleChassis3D.dynamicLoad.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.z_0_start[1],simpleChassis3D.dynamicLoad.z_0_start[2],simpleChassis3D.dynamicLoad.z_0_start[3]})[2], fixed = simpleChassis3D.dynamicLoad.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real simpleChassis3D.dynamicLoad.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.R_start,{simpleChassis3D.dynamicLoad.z_0_start[1],simpleChassis3D.dynamicLoad.z_0_start[2],simpleChassis3D.dynamicLoad.z_0_start[3]})[3], fixed = simpleChassis3D.dynamicLoad.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   protected parameter Real simpleChassis3D.dynamicLoad.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(simpleChassis3D.dynamicLoad.R_start,{0.0,0.0,0.0,1.0})[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real simpleChassis3D.dynamicLoad.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(simpleChassis3D.dynamicLoad.R_start,{0.0,0.0,0.0,1.0})[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real simpleChassis3D.dynamicLoad.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(simpleChassis3D.dynamicLoad.R_start,{0.0,0.0,0.0,1.0})[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real simpleChassis3D.dynamicLoad.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(simpleChassis3D.dynamicLoad.R_start,{0.0,0.0,0.0,1.0})[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   parameter String simpleChassis3D.dynamicLoad.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[1,1] = simpleChassis3D.dynamicLoad.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[1,2] = simpleChassis3D.dynamicLoad.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[1,3] = simpleChassis3D.dynamicLoad.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[2,1] = simpleChassis3D.dynamicLoad.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[2,2] = simpleChassis3D.dynamicLoad.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[2,3] = simpleChassis3D.dynamicLoad.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[3,1] = simpleChassis3D.dynamicLoad.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[3,2] = simpleChassis3D.dynamicLoad.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.T[3,3] = simpleChassis3D.dynamicLoad.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.dynamicLoad.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.dynamicLoad.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.dynamicLoad.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.r[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.lengthDirection[1](unit = \"1\") = simpleChassis3D.dynamicLoad.r_CM[1] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.lengthDirection[2](unit = \"1\") = simpleChassis3D.dynamicLoad.r_CM[2] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.lengthDirection[3](unit = \"1\") = simpleChassis3D.dynamicLoad.r_CM[3] \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.length(quantity = \"Length\", unit = \"m\") = if Modelica.Math.Vectors.length({simpleChassis3D.dynamicLoad.r_CM[1],simpleChassis3D.dynamicLoad.r_CM[2],simpleChassis3D.dynamicLoad.r_CM[3]}) > simpleChassis3D.dynamicLoad.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({simpleChassis3D.dynamicLoad.r_CM[1],simpleChassis3D.dynamicLoad.r_CM[2],simpleChassis3D.dynamicLoad.r_CM[3]}) - (if simpleChassis3D.dynamicLoad.cylinderDiameter > 1.1 * simpleChassis3D.dynamicLoad.sphereDiameter then simpleChassis3D.dynamicLoad.sphereDiameter / 2.0 else 0.0) else 0.0 \"Length of visual object\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.width(quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.cylinderDiameter \"Width of visual object\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.height(quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.cylinderDiameter \"Height of visual object\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.color[1] = Real(simpleChassis3D.dynamicLoad.cylinderColor[1]) \"Color of shape\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.color[2] = Real(simpleChassis3D.dynamicLoad.cylinderColor[2]) \"Color of shape\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.color[3] = Real(simpleChassis3D.dynamicLoad.cylinderColor[3]) \"Color of shape\";
//   input Real simpleChassis3D.dynamicLoad.cylinder.specularCoefficient = simpleChassis3D.dynamicLoad.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.dynamicLoad.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.dynamicLoad.cylinder.lengthDirection[1],simpleChassis3D.dynamicLoad.cylinder.lengthDirection[2],simpleChassis3D.dynamicLoad.cylinder.lengthDirection[3]});
//   protected Real simpleChassis3D.dynamicLoad.cylinder.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.dynamicLoad.cylinder.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.dynamicLoad.cylinder.lengthDirection[1] / simpleChassis3D.dynamicLoad.cylinder.abs_n_x;
//   protected Real simpleChassis3D.dynamicLoad.cylinder.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.dynamicLoad.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.dynamicLoad.cylinder.lengthDirection[2] / simpleChassis3D.dynamicLoad.cylinder.abs_n_x;
//   protected Real simpleChassis3D.dynamicLoad.cylinder.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.dynamicLoad.cylinder.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.dynamicLoad.cylinder.lengthDirection[3] / simpleChassis3D.dynamicLoad.cylinder.abs_n_x;
//   protected Real simpleChassis3D.dynamicLoad.cylinder.n_z_aux[1](unit = \"1\") = simpleChassis3D.dynamicLoad.cylinder.e_x[2] * simpleChassis3D.dynamicLoad.cylinder.widthDirection[3] - simpleChassis3D.dynamicLoad.cylinder.e_x[3] * simpleChassis3D.dynamicLoad.cylinder.widthDirection[2];
//   protected Real simpleChassis3D.dynamicLoad.cylinder.n_z_aux[2](unit = \"1\") = simpleChassis3D.dynamicLoad.cylinder.e_x[3] * simpleChassis3D.dynamicLoad.cylinder.widthDirection[1] - simpleChassis3D.dynamicLoad.cylinder.e_x[1] * simpleChassis3D.dynamicLoad.cylinder.widthDirection[3];
//   protected Real simpleChassis3D.dynamicLoad.cylinder.n_z_aux[3](unit = \"1\") = simpleChassis3D.dynamicLoad.cylinder.e_x[1] * simpleChassis3D.dynamicLoad.cylinder.widthDirection[2] - simpleChassis3D.dynamicLoad.cylinder.e_x[2] * simpleChassis3D.dynamicLoad.cylinder.widthDirection[1];
//   protected Real simpleChassis3D.dynamicLoad.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.dynamicLoad.cylinder.e_x[1],simpleChassis3D.dynamicLoad.cylinder.e_x[2],simpleChassis3D.dynamicLoad.cylinder.e_x[3]},if noEvent(simpleChassis3D.dynamicLoad.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.dynamicLoad.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.dynamicLoad.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.dynamicLoad.cylinder.widthDirection[1],simpleChassis3D.dynamicLoad.cylinder.widthDirection[2],simpleChassis3D.dynamicLoad.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.dynamicLoad.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.dynamicLoad.cylinder.e_x[1],simpleChassis3D.dynamicLoad.cylinder.e_x[2],simpleChassis3D.dynamicLoad.cylinder.e_x[3]})[1];
//   protected Real simpleChassis3D.dynamicLoad.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.dynamicLoad.cylinder.e_x[1],simpleChassis3D.dynamicLoad.cylinder.e_x[2],simpleChassis3D.dynamicLoad.cylinder.e_x[3]},if noEvent(simpleChassis3D.dynamicLoad.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.dynamicLoad.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.dynamicLoad.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.dynamicLoad.cylinder.widthDirection[1],simpleChassis3D.dynamicLoad.cylinder.widthDirection[2],simpleChassis3D.dynamicLoad.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.dynamicLoad.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.dynamicLoad.cylinder.e_x[1],simpleChassis3D.dynamicLoad.cylinder.e_x[2],simpleChassis3D.dynamicLoad.cylinder.e_x[3]})[2];
//   protected Real simpleChassis3D.dynamicLoad.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.dynamicLoad.cylinder.e_x[1],simpleChassis3D.dynamicLoad.cylinder.e_x[2],simpleChassis3D.dynamicLoad.cylinder.e_x[3]},if noEvent(simpleChassis3D.dynamicLoad.cylinder.n_z_aux[1] ^ 2.0 + (simpleChassis3D.dynamicLoad.cylinder.n_z_aux[2] ^ 2.0 + simpleChassis3D.dynamicLoad.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.dynamicLoad.cylinder.widthDirection[1],simpleChassis3D.dynamicLoad.cylinder.widthDirection[2],simpleChassis3D.dynamicLoad.cylinder.widthDirection[3]} else if noEvent(abs(simpleChassis3D.dynamicLoad.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.dynamicLoad.cylinder.e_x[1],simpleChassis3D.dynamicLoad.cylinder.e_x[2],simpleChassis3D.dynamicLoad.cylinder.e_x[3]})[3];
//   protected output Real simpleChassis3D.dynamicLoad.cylinder.Form;
//   output Real simpleChassis3D.dynamicLoad.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.dynamicLoad.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.dynamicLoad.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.dynamicLoad.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.dynamicLoad.cylinder.Material;
//   protected output Real simpleChassis3D.dynamicLoad.cylinder.Extra;
//   parameter String simpleChassis3D.dynamicLoad.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[1,1] = simpleChassis3D.dynamicLoad.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[1,2] = simpleChassis3D.dynamicLoad.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[1,3] = simpleChassis3D.dynamicLoad.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[2,1] = simpleChassis3D.dynamicLoad.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[2,2] = simpleChassis3D.dynamicLoad.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[2,3] = simpleChassis3D.dynamicLoad.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[3,1] = simpleChassis3D.dynamicLoad.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[3,2] = simpleChassis3D.dynamicLoad.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.T[3,3] = simpleChassis3D.dynamicLoad.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.dynamicLoad.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.dynamicLoad.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = simpleChassis3D.dynamicLoad.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.r[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.r_CM[1] - simpleChassis3D.dynamicLoad.sphereDiameter / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.r_CM[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.r_CM[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.dynamicLoad.sphere.length(quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.sphereDiameter \"Length of visual object\";
//   input Real simpleChassis3D.dynamicLoad.sphere.width(quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.sphereDiameter \"Width of visual object\";
//   input Real simpleChassis3D.dynamicLoad.sphere.height(quantity = \"Length\", unit = \"m\") = simpleChassis3D.dynamicLoad.sphereDiameter \"Height of visual object\";
//   input Real simpleChassis3D.dynamicLoad.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.dynamicLoad.sphere.color[1] = Real(simpleChassis3D.dynamicLoad.sphereColor[1]) \"Color of shape\";
//   input Real simpleChassis3D.dynamicLoad.sphere.color[2] = Real(simpleChassis3D.dynamicLoad.sphereColor[2]) \"Color of shape\";
//   input Real simpleChassis3D.dynamicLoad.sphere.color[3] = Real(simpleChassis3D.dynamicLoad.sphereColor[3]) \"Color of shape\";
//   input Real simpleChassis3D.dynamicLoad.sphere.specularCoefficient = simpleChassis3D.dynamicLoad.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.dynamicLoad.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.dynamicLoad.sphere.lengthDirection[1],simpleChassis3D.dynamicLoad.sphere.lengthDirection[2],simpleChassis3D.dynamicLoad.sphere.lengthDirection[3]});
//   protected Real simpleChassis3D.dynamicLoad.sphere.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.dynamicLoad.sphere.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.dynamicLoad.sphere.lengthDirection[1] / simpleChassis3D.dynamicLoad.sphere.abs_n_x;
//   protected Real simpleChassis3D.dynamicLoad.sphere.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.dynamicLoad.sphere.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.dynamicLoad.sphere.lengthDirection[2] / simpleChassis3D.dynamicLoad.sphere.abs_n_x;
//   protected Real simpleChassis3D.dynamicLoad.sphere.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.dynamicLoad.sphere.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.dynamicLoad.sphere.lengthDirection[3] / simpleChassis3D.dynamicLoad.sphere.abs_n_x;
//   protected Real simpleChassis3D.dynamicLoad.sphere.n_z_aux[1](unit = \"1\") = simpleChassis3D.dynamicLoad.sphere.e_x[2] * simpleChassis3D.dynamicLoad.sphere.widthDirection[3] - simpleChassis3D.dynamicLoad.sphere.e_x[3] * simpleChassis3D.dynamicLoad.sphere.widthDirection[2];
//   protected Real simpleChassis3D.dynamicLoad.sphere.n_z_aux[2](unit = \"1\") = simpleChassis3D.dynamicLoad.sphere.e_x[3] * simpleChassis3D.dynamicLoad.sphere.widthDirection[1] - simpleChassis3D.dynamicLoad.sphere.e_x[1] * simpleChassis3D.dynamicLoad.sphere.widthDirection[3];
//   protected Real simpleChassis3D.dynamicLoad.sphere.n_z_aux[3](unit = \"1\") = simpleChassis3D.dynamicLoad.sphere.e_x[1] * simpleChassis3D.dynamicLoad.sphere.widthDirection[2] - simpleChassis3D.dynamicLoad.sphere.e_x[2] * simpleChassis3D.dynamicLoad.sphere.widthDirection[1];
//   protected Real simpleChassis3D.dynamicLoad.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.dynamicLoad.sphere.e_x[1],simpleChassis3D.dynamicLoad.sphere.e_x[2],simpleChassis3D.dynamicLoad.sphere.e_x[3]},if noEvent(simpleChassis3D.dynamicLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis3D.dynamicLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis3D.dynamicLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.dynamicLoad.sphere.widthDirection[1],simpleChassis3D.dynamicLoad.sphere.widthDirection[2],simpleChassis3D.dynamicLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis3D.dynamicLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.dynamicLoad.sphere.e_x[1],simpleChassis3D.dynamicLoad.sphere.e_x[2],simpleChassis3D.dynamicLoad.sphere.e_x[3]})[1];
//   protected Real simpleChassis3D.dynamicLoad.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.dynamicLoad.sphere.e_x[1],simpleChassis3D.dynamicLoad.sphere.e_x[2],simpleChassis3D.dynamicLoad.sphere.e_x[3]},if noEvent(simpleChassis3D.dynamicLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis3D.dynamicLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis3D.dynamicLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.dynamicLoad.sphere.widthDirection[1],simpleChassis3D.dynamicLoad.sphere.widthDirection[2],simpleChassis3D.dynamicLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis3D.dynamicLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.dynamicLoad.sphere.e_x[1],simpleChassis3D.dynamicLoad.sphere.e_x[2],simpleChassis3D.dynamicLoad.sphere.e_x[3]})[2];
//   protected Real simpleChassis3D.dynamicLoad.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.dynamicLoad.sphere.e_x[1],simpleChassis3D.dynamicLoad.sphere.e_x[2],simpleChassis3D.dynamicLoad.sphere.e_x[3]},if noEvent(simpleChassis3D.dynamicLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis3D.dynamicLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis3D.dynamicLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.dynamicLoad.sphere.widthDirection[1],simpleChassis3D.dynamicLoad.sphere.widthDirection[2],simpleChassis3D.dynamicLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis3D.dynamicLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.dynamicLoad.sphere.e_x[1],simpleChassis3D.dynamicLoad.sphere.e_x[2],simpleChassis3D.dynamicLoad.sphere.e_x[3]})[3];
//   protected output Real simpleChassis3D.dynamicLoad.sphere.Form;
//   output Real simpleChassis3D.dynamicLoad.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.dynamicLoad.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.dynamicLoad.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.dynamicLoad.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.dynamicLoad.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.dynamicLoad.sphere.Material;
//   protected output Real simpleChassis3D.dynamicLoad.sphere.Extra;
//   Real simpleChassis3D.rollSpringDamper.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Relative angular acceleration (= der(w_rel))\";
//   Real simpleChassis3D.rollSpringDamper.tau(quantity = \"Torque\", unit = \"N.m\") \"Torque between flanges (= flange_b.tau)\";
//   Real simpleChassis3D.rollSpringDamper.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.rollSpringDamper.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real simpleChassis3D.rollSpringDamper.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.rollSpringDamper.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real simpleChassis3D.rollSpringDamper.phi_nominal(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\") = 0.0001 \"Nominal value of phi_rel (used for scaling)\";
//   parameter enumeration(never, avoid, default, prefer, always) simpleChassis3D.rollSpringDamper.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real simpleChassis3D.rollSpringDamper.c(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\", min = 0.0, start = 100000.0) = simpleChassis3D.c_pitch \"Spring constant\";
//   parameter Real simpleChassis3D.rollSpringDamper.d(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\", min = 0.0, start = 0.0) = simpleChassis3D.d_pitch \"Damping constant\";
//   parameter Real simpleChassis3D.rollSpringDamper.phi_rel0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Unstretched spring angle\";
//   Real simpleChassis3D.rollSpringDamper.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, nominal = simpleChassis3D.rollSpringDamper.phi_nominal, StateSelect = StateSelect.prefer) \"Relative rotation angle (= flange_b.phi - flange_a.phi)\";
//   Real simpleChassis3D.rollSpringDamper.w_rel(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative angular velocity (= der(phi_rel))\";
//   Real simpleChassis3D.pitchSpringDamper.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Relative angular acceleration (= der(w_rel))\";
//   Real simpleChassis3D.pitchSpringDamper.tau(quantity = \"Torque\", unit = \"N.m\") \"Torque between flanges (= flange_b.tau)\";
//   Real simpleChassis3D.pitchSpringDamper.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.pitchSpringDamper.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real simpleChassis3D.pitchSpringDamper.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real simpleChassis3D.pitchSpringDamper.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real simpleChassis3D.pitchSpringDamper.phi_nominal(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\") = 0.0001 \"Nominal value of phi_rel (used for scaling)\";
//   parameter enumeration(never, avoid, default, prefer, always) simpleChassis3D.pitchSpringDamper.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real simpleChassis3D.pitchSpringDamper.c(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\", min = 0.0, start = 100000.0) = simpleChassis3D.c_pitch \"Spring constant\";
//   parameter Real simpleChassis3D.pitchSpringDamper.d(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\", min = 0.0, start = 0.0) = simpleChassis3D.d_pitch \"Damping constant\";
//   parameter Real simpleChassis3D.pitchSpringDamper.phi_rel0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Unstretched spring angle\";
//   Real simpleChassis3D.pitchSpringDamper.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, nominal = simpleChassis3D.pitchSpringDamper.phi_nominal, StateSelect = StateSelect.prefer) \"Relative rotation angle (= flange_b.phi - flange_a.phi)\";
//   Real simpleChassis3D.pitchSpringDamper.w_rel(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative angular velocity (= der(phi_rel))\";
//   Real simpleChassis3D.baseLoad.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real simpleChassis3D.baseLoad.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real simpleChassis3D.baseLoad.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real simpleChassis3D.baseLoad.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real simpleChassis3D.baseLoad.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real simpleChassis3D.baseLoad.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real simpleChassis3D.baseLoad.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = simpleChassis3D.m_static \"mass of the body\";
//   parameter Real simpleChassis3D.baseLoad.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = (simpleChassis3D.m_static / 12.0 + simpleChassis3D.m_dynamic / 12.0) * (simpleChassis3D.w ^ 2.0 + simpleChassis3D.l ^ 2.0) \"Inertia of the Body\";
//   parameter Real simpleChassis3D.baseLoad.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real simpleChassis3D.baseLoad.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real simpleChassis3D.baseLoad.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real simpleChassis3D.baseLoad.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real simpleChassis3D.baseLoad.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real simpleChassis3D.baseLoad.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real simpleChassis3D.baseLoad.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real simpleChassis3D.baseLoad.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real simpleChassis3D.baseLoad.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real simpleChassis3D.baseLoad.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real simpleChassis3D.baseLoad.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real simpleChassis3D.baseLoad.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean simpleChassis3D.baseLoad.animate = true \"enable Animation\";
//   parameter String simpleChassis3D.baseLoad.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real simpleChassis3D.baseLoad.sphere.r[1](quantity = \"Length\", unit = \"m\") = simpleChassis3D.baseLoad.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.baseLoad.sphere.r[2](quantity = \"Length\", unit = \"m\") = simpleChassis3D.baseLoad.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.baseLoad.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real simpleChassis3D.baseLoad.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real simpleChassis3D.baseLoad.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real simpleChassis3D.baseLoad.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real simpleChassis3D.baseLoad.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real simpleChassis3D.baseLoad.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real simpleChassis3D.baseLoad.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real simpleChassis3D.baseLoad.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real simpleChassis3D.baseLoad.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real simpleChassis3D.baseLoad.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real simpleChassis3D.baseLoad.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({simpleChassis3D.baseLoad.sphere.lengthDirection[1],simpleChassis3D.baseLoad.sphere.lengthDirection[2],simpleChassis3D.baseLoad.sphere.lengthDirection[3]});
//   protected Real simpleChassis3D.baseLoad.sphere.e_x[1](unit = \"1\") = if noEvent(simpleChassis3D.baseLoad.sphere.abs_n_x < 1e-10) then 1.0 else simpleChassis3D.baseLoad.sphere.lengthDirection[1] / simpleChassis3D.baseLoad.sphere.abs_n_x;
//   protected Real simpleChassis3D.baseLoad.sphere.e_x[2](unit = \"1\") = if noEvent(simpleChassis3D.baseLoad.sphere.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.baseLoad.sphere.lengthDirection[2] / simpleChassis3D.baseLoad.sphere.abs_n_x;
//   protected Real simpleChassis3D.baseLoad.sphere.e_x[3](unit = \"1\") = if noEvent(simpleChassis3D.baseLoad.sphere.abs_n_x < 1e-10) then 0.0 else simpleChassis3D.baseLoad.sphere.lengthDirection[3] / simpleChassis3D.baseLoad.sphere.abs_n_x;
//   protected Real simpleChassis3D.baseLoad.sphere.n_z_aux[1](unit = \"1\") = simpleChassis3D.baseLoad.sphere.e_x[2] * simpleChassis3D.baseLoad.sphere.widthDirection[3] - simpleChassis3D.baseLoad.sphere.e_x[3] * simpleChassis3D.baseLoad.sphere.widthDirection[2];
//   protected Real simpleChassis3D.baseLoad.sphere.n_z_aux[2](unit = \"1\") = simpleChassis3D.baseLoad.sphere.e_x[3] * simpleChassis3D.baseLoad.sphere.widthDirection[1] - simpleChassis3D.baseLoad.sphere.e_x[1] * simpleChassis3D.baseLoad.sphere.widthDirection[3];
//   protected Real simpleChassis3D.baseLoad.sphere.n_z_aux[3](unit = \"1\") = simpleChassis3D.baseLoad.sphere.e_x[1] * simpleChassis3D.baseLoad.sphere.widthDirection[2] - simpleChassis3D.baseLoad.sphere.e_x[2] * simpleChassis3D.baseLoad.sphere.widthDirection[1];
//   protected Real simpleChassis3D.baseLoad.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.baseLoad.sphere.e_x[1],simpleChassis3D.baseLoad.sphere.e_x[2],simpleChassis3D.baseLoad.sphere.e_x[3]},if noEvent(simpleChassis3D.baseLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis3D.baseLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis3D.baseLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.baseLoad.sphere.widthDirection[1],simpleChassis3D.baseLoad.sphere.widthDirection[2],simpleChassis3D.baseLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis3D.baseLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.baseLoad.sphere.e_x[1],simpleChassis3D.baseLoad.sphere.e_x[2],simpleChassis3D.baseLoad.sphere.e_x[3]})[1];
//   protected Real simpleChassis3D.baseLoad.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.baseLoad.sphere.e_x[1],simpleChassis3D.baseLoad.sphere.e_x[2],simpleChassis3D.baseLoad.sphere.e_x[3]},if noEvent(simpleChassis3D.baseLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis3D.baseLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis3D.baseLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.baseLoad.sphere.widthDirection[1],simpleChassis3D.baseLoad.sphere.widthDirection[2],simpleChassis3D.baseLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis3D.baseLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.baseLoad.sphere.e_x[1],simpleChassis3D.baseLoad.sphere.e_x[2],simpleChassis3D.baseLoad.sphere.e_x[3]})[2];
//   protected Real simpleChassis3D.baseLoad.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({simpleChassis3D.baseLoad.sphere.e_x[1],simpleChassis3D.baseLoad.sphere.e_x[2],simpleChassis3D.baseLoad.sphere.e_x[3]},if noEvent(simpleChassis3D.baseLoad.sphere.n_z_aux[1] ^ 2.0 + (simpleChassis3D.baseLoad.sphere.n_z_aux[2] ^ 2.0 + simpleChassis3D.baseLoad.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {simpleChassis3D.baseLoad.sphere.widthDirection[1],simpleChassis3D.baseLoad.sphere.widthDirection[2],simpleChassis3D.baseLoad.sphere.widthDirection[3]} else if noEvent(abs(simpleChassis3D.baseLoad.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{simpleChassis3D.baseLoad.sphere.e_x[1],simpleChassis3D.baseLoad.sphere.e_x[2],simpleChassis3D.baseLoad.sphere.e_x[3]})[3];
//   protected output Real simpleChassis3D.baseLoad.sphere.Form;
//   output Real simpleChassis3D.baseLoad.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real simpleChassis3D.baseLoad.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real simpleChassis3D.baseLoad.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.baseLoad.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.baseLoad.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real simpleChassis3D.baseLoad.sphere.Material;
//   protected output Real simpleChassis3D.baseLoad.sphere.Extra;
// equation
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1],world.x_label.cylinders[1].R.T[1,2],world.x_label.cylinders[1].R.T[1,3]},{world.x_label.cylinders[1].R.T[2,1],world.x_label.cylinders[1].R.T[2,2],world.x_label.cylinders[1].R.T[2,3]},{world.x_label.cylinders[1].R.T[3,1],world.x_label.cylinders[1].R.T[3,2],world.x_label.cylinders[1].R.T[3,3]}},{world.x_label.cylinders[1].r_shape[1],world.x_label.cylinders[1].r_shape[2],world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0,world.x_label.cylinders[1].color[2] / 255.0,world.x_label.cylinders[1].color[3] / 255.0,world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1],world.x_label.cylinders[2].R.T[1,2],world.x_label.cylinders[2].R.T[1,3]},{world.x_label.cylinders[2].R.T[2,1],world.x_label.cylinders[2].R.T[2,2],world.x_label.cylinders[2].R.T[2,3]},{world.x_label.cylinders[2].R.T[3,1],world.x_label.cylinders[2].R.T[3,2],world.x_label.cylinders[2].R.T[3,3]}},{world.x_label.cylinders[2].r_shape[1],world.x_label.cylinders[2].r_shape[2],world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0,world.x_label.cylinders[2].color[2] / 255.0,world.x_label.cylinders[2].color[3] / 255.0,world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1],world.y_label.cylinders[1].R.T[1,2],world.y_label.cylinders[1].R.T[1,3]},{world.y_label.cylinders[1].R.T[2,1],world.y_label.cylinders[1].R.T[2,2],world.y_label.cylinders[1].R.T[2,3]},{world.y_label.cylinders[1].R.T[3,1],world.y_label.cylinders[1].R.T[3,2],world.y_label.cylinders[1].R.T[3,3]}},{world.y_label.cylinders[1].r_shape[1],world.y_label.cylinders[1].r_shape[2],world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0,world.y_label.cylinders[1].color[2] / 255.0,world.y_label.cylinders[1].color[3] / 255.0,world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1],world.y_label.cylinders[2].R.T[1,2],world.y_label.cylinders[2].R.T[1,3]},{world.y_label.cylinders[2].R.T[2,1],world.y_label.cylinders[2].R.T[2,2],world.y_label.cylinders[2].R.T[2,3]},{world.y_label.cylinders[2].R.T[3,1],world.y_label.cylinders[2].R.T[3,2],world.y_label.cylinders[2].R.T[3,3]}},{world.y_label.cylinders[2].r_shape[1],world.y_label.cylinders[2].r_shape[2],world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0,world.y_label.cylinders[2].color[2] / 255.0,world.y_label.cylinders[2].color[3] / 255.0,world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1],world.z_label.cylinders[1].R.T[1,2],world.z_label.cylinders[1].R.T[1,3]},{world.z_label.cylinders[1].R.T[2,1],world.z_label.cylinders[1].R.T[2,2],world.z_label.cylinders[1].R.T[2,3]},{world.z_label.cylinders[1].R.T[3,1],world.z_label.cylinders[1].R.T[3,2],world.z_label.cylinders[1].R.T[3,3]}},{world.z_label.cylinders[1].r_shape[1],world.z_label.cylinders[1].r_shape[2],world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0,world.z_label.cylinders[1].color[2] / 255.0,world.z_label.cylinders[1].color[3] / 255.0,world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1],world.z_label.cylinders[2].R.T[1,2],world.z_label.cylinders[2].R.T[1,3]},{world.z_label.cylinders[2].R.T[2,1],world.z_label.cylinders[2].R.T[2,2],world.z_label.cylinders[2].R.T[2,3]},{world.z_label.cylinders[2].R.T[3,1],world.z_label.cylinders[2].R.T[3,2],world.z_label.cylinders[2].R.T[3,3]}},{world.z_label.cylinders[2].r_shape[1],world.z_label.cylinders[2].r_shape[2],world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0,world.z_label.cylinders[2].color[2] / 255.0,world.z_label.cylinders[2].color[3] / 255.0,world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1],world.z_label.cylinders[3].R.T[1,2],world.z_label.cylinders[3].R.T[1,3]},{world.z_label.cylinders[3].R.T[2,1],world.z_label.cylinders[3].R.T[2,2],world.z_label.cylinders[3].R.T[2,3]},{world.z_label.cylinders[3].R.T[3,1],world.z_label.cylinders[3].R.T[3,2],world.z_label.cylinders[3].R.T[3,3]}},{world.z_label.cylinders[3].r_shape[1],world.z_label.cylinders[3].r_shape[2],world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0,world.z_label.cylinders[3].color[2] / 255.0,world.z_label.cylinders[3].color[3] / 255.0,world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1],world.x_arrowLine.R.T[1,2],world.x_arrowLine.R.T[1,3]},{world.x_arrowLine.R.T[2,1],world.x_arrowLine.R.T[2,2],world.x_arrowLine.R.T[2,3]},{world.x_arrowLine.R.T[3,1],world.x_arrowLine.R.T[3,2],world.x_arrowLine.R.T[3,3]}},{world.x_arrowLine.r_shape[1],world.x_arrowLine.r_shape[2],world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0,world.x_arrowLine.color[2] / 255.0,world.x_arrowLine.color[3] / 255.0,world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1],world.x_arrowHead.R.T[1,2],world.x_arrowHead.R.T[1,3]},{world.x_arrowHead.R.T[2,1],world.x_arrowHead.R.T[2,2],world.x_arrowHead.R.T[2,3]},{world.x_arrowHead.R.T[3,1],world.x_arrowHead.R.T[3,2],world.x_arrowHead.R.T[3,3]}},{world.x_arrowHead.r_shape[1],world.x_arrowHead.r_shape[2],world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0,world.x_arrowHead.color[2] / 255.0,world.x_arrowHead.color[3] / 255.0,world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1],world.y_arrowLine.R.T[1,2],world.y_arrowLine.R.T[1,3]},{world.y_arrowLine.R.T[2,1],world.y_arrowLine.R.T[2,2],world.y_arrowLine.R.T[2,3]},{world.y_arrowLine.R.T[3,1],world.y_arrowLine.R.T[3,2],world.y_arrowLine.R.T[3,3]}},{world.y_arrowLine.r_shape[1],world.y_arrowLine.r_shape[2],world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0,world.y_arrowLine.color[2] / 255.0,world.y_arrowLine.color[3] / 255.0,world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1],world.y_arrowHead.R.T[1,2],world.y_arrowHead.R.T[1,3]},{world.y_arrowHead.R.T[2,1],world.y_arrowHead.R.T[2,2],world.y_arrowHead.R.T[2,3]},{world.y_arrowHead.R.T[3,1],world.y_arrowHead.R.T[3,2],world.y_arrowHead.R.T[3,3]}},{world.y_arrowHead.r_shape[1],world.y_arrowHead.r_shape[2],world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0,world.y_arrowHead.color[2] / 255.0,world.y_arrowHead.color[3] / 255.0,world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1],world.z_arrowLine.R.T[1,2],world.z_arrowLine.R.T[1,3]},{world.z_arrowLine.R.T[2,1],world.z_arrowLine.R.T[2,2],world.z_arrowLine.R.T[2,3]},{world.z_arrowLine.R.T[3,1],world.z_arrowLine.R.T[3,2],world.z_arrowLine.R.T[3,3]}},{world.z_arrowLine.r_shape[1],world.z_arrowLine.r_shape[2],world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0,world.z_arrowLine.color[2] / 255.0,world.z_arrowLine.color[3] / 255.0,world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1],world.z_arrowHead.R.T[1,2],world.z_arrowHead.R.T[1,3]},{world.z_arrowHead.R.T[2,1],world.z_arrowHead.R.T[2,2],world.z_arrowHead.R.T[2,3]},{world.z_arrowHead.R.T[3,1],world.z_arrowHead.R.T[3,2],world.z_arrowHead.R.T[3,3]}},{world.z_arrowHead.r_shape[1],world.z_arrowHead.r_shape[2],world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0,world.z_arrowHead.color[2] / 255.0,world.z_arrowHead.color[3] / 255.0,world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   world.gravityArrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowLine.shapeType);
//   world.gravityArrowLine.rxvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_x[1] + world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_x[3];
//   world.gravityArrowLine.rxvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_x[1] + world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_x[3];
//   world.gravityArrowLine.rxvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_x[1] + world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_x[3];
//   world.gravityArrowLine.ryvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_y[1] + world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_y[3];
//   world.gravityArrowLine.ryvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_y[1] + world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_y[3];
//   world.gravityArrowLine.ryvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_y[1] + world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_y[3];
//   world.gravityArrowLine.rvisobj = world.gravityArrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowLine.R.T[1,1],world.gravityArrowLine.R.T[1,2],world.gravityArrowLine.R.T[1,3]},{world.gravityArrowLine.R.T[2,1],world.gravityArrowLine.R.T[2,2],world.gravityArrowLine.R.T[2,3]},{world.gravityArrowLine.R.T[3,1],world.gravityArrowLine.R.T[3,2],world.gravityArrowLine.R.T[3,3]}},{world.gravityArrowLine.r_shape[1],world.gravityArrowLine.r_shape[2],world.gravityArrowLine.r_shape[3]});
//   world.gravityArrowLine.size[1] = world.gravityArrowLine.length;
//   world.gravityArrowLine.size[2] = world.gravityArrowLine.width;
//   world.gravityArrowLine.size[3] = world.gravityArrowLine.height;
//   world.gravityArrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowLine.color[1] / 255.0,world.gravityArrowLine.color[2] / 255.0,world.gravityArrowLine.color[3] / 255.0,world.gravityArrowLine.specularCoefficient);
//   world.gravityArrowLine.Extra = world.gravityArrowLine.extra;
//   world.gravityArrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowHead.shapeType);
//   world.gravityArrowHead.rxvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_x[1] + world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_x[3];
//   world.gravityArrowHead.rxvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_x[1] + world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_x[3];
//   world.gravityArrowHead.rxvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_x[1] + world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_x[3];
//   world.gravityArrowHead.ryvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_y[1] + world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_y[3];
//   world.gravityArrowHead.ryvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_y[1] + world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_y[3];
//   world.gravityArrowHead.ryvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_y[1] + world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_y[3];
//   world.gravityArrowHead.rvisobj = world.gravityArrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowHead.R.T[1,1],world.gravityArrowHead.R.T[1,2],world.gravityArrowHead.R.T[1,3]},{world.gravityArrowHead.R.T[2,1],world.gravityArrowHead.R.T[2,2],world.gravityArrowHead.R.T[2,3]},{world.gravityArrowHead.R.T[3,1],world.gravityArrowHead.R.T[3,2],world.gravityArrowHead.R.T[3,3]}},{world.gravityArrowHead.r_shape[1],world.gravityArrowHead.r_shape[2],world.gravityArrowHead.r_shape[3]});
//   world.gravityArrowHead.size[1] = world.gravityArrowHead.length;
//   world.gravityArrowHead.size[2] = world.gravityArrowHead.width;
//   world.gravityArrowHead.size[3] = world.gravityArrowHead.height;
//   world.gravityArrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowHead.color[1] / 255.0,world.gravityArrowHead.color[2] / 255.0,world.gravityArrowHead.color[3] / 255.0,world.gravityArrowHead.specularCoefficient);
//   world.gravityArrowHead.Extra = world.gravityArrowHead.extra;
//   assert(Modelica.Math.Vectors.length({world.n[1],world.n[2],world.n[3]}) > 1e-10,\"Parameter n of World object is wrong (lenght(n) > 0 required)\");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   torque.flange.tau = -torque.tau;
//   torque.phi_support = 0.0;
//   when sample(pulse.startTime,pulse.period) then
//   pulse.T0 = time;
//   end when;
//   pulse.y = pulse.offset + (if time < pulse.startTime or time >= pulse.T0 + pulse.T_width then 0.0 else pulse.amplitude);
//   (1.0 + rearAxis.differentialGear.idealPlanetary.ratio) * rearAxis.differentialGear.idealPlanetary.carrier.phi = rearAxis.differentialGear.idealPlanetary.sun.phi + rearAxis.differentialGear.idealPlanetary.ratio * rearAxis.differentialGear.idealPlanetary.ring.phi;
//   rearAxis.differentialGear.idealPlanetary.ring.tau = rearAxis.differentialGear.idealPlanetary.ratio * rearAxis.differentialGear.idealPlanetary.sun.tau;
//   rearAxis.differentialGear.idealPlanetary.carrier.tau = (-1.0 - rearAxis.differentialGear.idealPlanetary.ratio) * rearAxis.differentialGear.idealPlanetary.sun.tau;
//   rearAxis.fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.fixedTranslation2.cylinder.shapeType);
//   rearAxis.fixedTranslation2.cylinder.rxvisobj[1] = rearAxis.fixedTranslation2.cylinder.R.T[1,1] * rearAxis.fixedTranslation2.cylinder.e_x[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,1] * rearAxis.fixedTranslation2.cylinder.e_x[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,1] * rearAxis.fixedTranslation2.cylinder.e_x[3];
//   rearAxis.fixedTranslation2.cylinder.rxvisobj[2] = rearAxis.fixedTranslation2.cylinder.R.T[1,2] * rearAxis.fixedTranslation2.cylinder.e_x[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,2] * rearAxis.fixedTranslation2.cylinder.e_x[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,2] * rearAxis.fixedTranslation2.cylinder.e_x[3];
//   rearAxis.fixedTranslation2.cylinder.rxvisobj[3] = rearAxis.fixedTranslation2.cylinder.R.T[1,3] * rearAxis.fixedTranslation2.cylinder.e_x[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,3] * rearAxis.fixedTranslation2.cylinder.e_x[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,3] * rearAxis.fixedTranslation2.cylinder.e_x[3];
//   rearAxis.fixedTranslation2.cylinder.ryvisobj[1] = rearAxis.fixedTranslation2.cylinder.R.T[1,1] * rearAxis.fixedTranslation2.cylinder.e_y[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,1] * rearAxis.fixedTranslation2.cylinder.e_y[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,1] * rearAxis.fixedTranslation2.cylinder.e_y[3];
//   rearAxis.fixedTranslation2.cylinder.ryvisobj[2] = rearAxis.fixedTranslation2.cylinder.R.T[1,2] * rearAxis.fixedTranslation2.cylinder.e_y[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,2] * rearAxis.fixedTranslation2.cylinder.e_y[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,2] * rearAxis.fixedTranslation2.cylinder.e_y[3];
//   rearAxis.fixedTranslation2.cylinder.ryvisobj[3] = rearAxis.fixedTranslation2.cylinder.R.T[1,3] * rearAxis.fixedTranslation2.cylinder.e_y[1] + rearAxis.fixedTranslation2.cylinder.R.T[2,3] * rearAxis.fixedTranslation2.cylinder.e_y[2] + rearAxis.fixedTranslation2.cylinder.R.T[3,3] * rearAxis.fixedTranslation2.cylinder.e_y[3];
//   rearAxis.fixedTranslation2.cylinder.rvisobj = rearAxis.fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.fixedTranslation2.cylinder.R.T[1,1],rearAxis.fixedTranslation2.cylinder.R.T[1,2],rearAxis.fixedTranslation2.cylinder.R.T[1,3]},{rearAxis.fixedTranslation2.cylinder.R.T[2,1],rearAxis.fixedTranslation2.cylinder.R.T[2,2],rearAxis.fixedTranslation2.cylinder.R.T[2,3]},{rearAxis.fixedTranslation2.cylinder.R.T[3,1],rearAxis.fixedTranslation2.cylinder.R.T[3,2],rearAxis.fixedTranslation2.cylinder.R.T[3,3]}},{rearAxis.fixedTranslation2.cylinder.r_shape[1],rearAxis.fixedTranslation2.cylinder.r_shape[2],rearAxis.fixedTranslation2.cylinder.r_shape[3]});
//   rearAxis.fixedTranslation2.cylinder.size[1] = rearAxis.fixedTranslation2.cylinder.length;
//   rearAxis.fixedTranslation2.cylinder.size[2] = rearAxis.fixedTranslation2.cylinder.width;
//   rearAxis.fixedTranslation2.cylinder.size[3] = rearAxis.fixedTranslation2.cylinder.height;
//   rearAxis.fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.fixedTranslation2.cylinder.color[1] / 255.0,rearAxis.fixedTranslation2.cylinder.color[2] / 255.0,rearAxis.fixedTranslation2.cylinder.color[3] / 255.0,rearAxis.fixedTranslation2.cylinder.specularCoefficient);
//   rearAxis.fixedTranslation2.cylinder.Extra = rearAxis.fixedTranslation2.cylinder.extra;
//   rearAxis.fixedTranslation2.R[1,1] = cos(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.R[1,2] = sin(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.R[2,1] = -sin(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.R[2,2] = cos(rearAxis.fixedTranslation2.frame_a.phi);
//   rearAxis.fixedTranslation2.r0[1] = rearAxis.fixedTranslation2.R[1,1] * rearAxis.fixedTranslation2.r[1] + rearAxis.fixedTranslation2.R[1,2] * rearAxis.fixedTranslation2.r[2];
//   rearAxis.fixedTranslation2.r0[2] = rearAxis.fixedTranslation2.R[2,1] * rearAxis.fixedTranslation2.r[1] + rearAxis.fixedTranslation2.R[2,2] * rearAxis.fixedTranslation2.r[2];
//   rearAxis.fixedTranslation2.frame_a.x + rearAxis.fixedTranslation2.r0[1] = rearAxis.fixedTranslation2.frame_b.x;
//   rearAxis.fixedTranslation2.frame_a.y + rearAxis.fixedTranslation2.r0[2] = rearAxis.fixedTranslation2.frame_b.y;
//   rearAxis.fixedTranslation2.frame_a.phi = rearAxis.fixedTranslation2.frame_b.phi;
//   rearAxis.fixedTranslation2.frame_a.fx + rearAxis.fixedTranslation2.frame_b.fx = 0.0;
//   rearAxis.fixedTranslation2.frame_a.fy + rearAxis.fixedTranslation2.frame_b.fy = 0.0;
//   rearAxis.fixedTranslation2.frame_a.t + (rearAxis.fixedTranslation2.frame_b.t + ((-rearAxis.fixedTranslation2.r0[1]) * rearAxis.fixedTranslation2.frame_b.fy + rearAxis.fixedTranslation2.r0[2] * rearAxis.fixedTranslation2.frame_b.fx)) = 0.0;
//   rearAxis.fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.fixedTranslation1.cylinder.shapeType);
//   rearAxis.fixedTranslation1.cylinder.rxvisobj[1] = rearAxis.fixedTranslation1.cylinder.R.T[1,1] * rearAxis.fixedTranslation1.cylinder.e_x[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,1] * rearAxis.fixedTranslation1.cylinder.e_x[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,1] * rearAxis.fixedTranslation1.cylinder.e_x[3];
//   rearAxis.fixedTranslation1.cylinder.rxvisobj[2] = rearAxis.fixedTranslation1.cylinder.R.T[1,2] * rearAxis.fixedTranslation1.cylinder.e_x[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,2] * rearAxis.fixedTranslation1.cylinder.e_x[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,2] * rearAxis.fixedTranslation1.cylinder.e_x[3];
//   rearAxis.fixedTranslation1.cylinder.rxvisobj[3] = rearAxis.fixedTranslation1.cylinder.R.T[1,3] * rearAxis.fixedTranslation1.cylinder.e_x[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,3] * rearAxis.fixedTranslation1.cylinder.e_x[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,3] * rearAxis.fixedTranslation1.cylinder.e_x[3];
//   rearAxis.fixedTranslation1.cylinder.ryvisobj[1] = rearAxis.fixedTranslation1.cylinder.R.T[1,1] * rearAxis.fixedTranslation1.cylinder.e_y[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,1] * rearAxis.fixedTranslation1.cylinder.e_y[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,1] * rearAxis.fixedTranslation1.cylinder.e_y[3];
//   rearAxis.fixedTranslation1.cylinder.ryvisobj[2] = rearAxis.fixedTranslation1.cylinder.R.T[1,2] * rearAxis.fixedTranslation1.cylinder.e_y[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,2] * rearAxis.fixedTranslation1.cylinder.e_y[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,2] * rearAxis.fixedTranslation1.cylinder.e_y[3];
//   rearAxis.fixedTranslation1.cylinder.ryvisobj[3] = rearAxis.fixedTranslation1.cylinder.R.T[1,3] * rearAxis.fixedTranslation1.cylinder.e_y[1] + rearAxis.fixedTranslation1.cylinder.R.T[2,3] * rearAxis.fixedTranslation1.cylinder.e_y[2] + rearAxis.fixedTranslation1.cylinder.R.T[3,3] * rearAxis.fixedTranslation1.cylinder.e_y[3];
//   rearAxis.fixedTranslation1.cylinder.rvisobj = rearAxis.fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.fixedTranslation1.cylinder.R.T[1,1],rearAxis.fixedTranslation1.cylinder.R.T[1,2],rearAxis.fixedTranslation1.cylinder.R.T[1,3]},{rearAxis.fixedTranslation1.cylinder.R.T[2,1],rearAxis.fixedTranslation1.cylinder.R.T[2,2],rearAxis.fixedTranslation1.cylinder.R.T[2,3]},{rearAxis.fixedTranslation1.cylinder.R.T[3,1],rearAxis.fixedTranslation1.cylinder.R.T[3,2],rearAxis.fixedTranslation1.cylinder.R.T[3,3]}},{rearAxis.fixedTranslation1.cylinder.r_shape[1],rearAxis.fixedTranslation1.cylinder.r_shape[2],rearAxis.fixedTranslation1.cylinder.r_shape[3]});
//   rearAxis.fixedTranslation1.cylinder.size[1] = rearAxis.fixedTranslation1.cylinder.length;
//   rearAxis.fixedTranslation1.cylinder.size[2] = rearAxis.fixedTranslation1.cylinder.width;
//   rearAxis.fixedTranslation1.cylinder.size[3] = rearAxis.fixedTranslation1.cylinder.height;
//   rearAxis.fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.fixedTranslation1.cylinder.color[1] / 255.0,rearAxis.fixedTranslation1.cylinder.color[2] / 255.0,rearAxis.fixedTranslation1.cylinder.color[3] / 255.0,rearAxis.fixedTranslation1.cylinder.specularCoefficient);
//   rearAxis.fixedTranslation1.cylinder.Extra = rearAxis.fixedTranslation1.cylinder.extra;
//   rearAxis.fixedTranslation1.R[1,1] = cos(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.R[1,2] = sin(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.R[2,1] = -sin(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.R[2,2] = cos(rearAxis.fixedTranslation1.frame_a.phi);
//   rearAxis.fixedTranslation1.r0[1] = rearAxis.fixedTranslation1.R[1,1] * rearAxis.fixedTranslation1.r[1] + rearAxis.fixedTranslation1.R[1,2] * rearAxis.fixedTranslation1.r[2];
//   rearAxis.fixedTranslation1.r0[2] = rearAxis.fixedTranslation1.R[2,1] * rearAxis.fixedTranslation1.r[1] + rearAxis.fixedTranslation1.R[2,2] * rearAxis.fixedTranslation1.r[2];
//   rearAxis.fixedTranslation1.frame_a.x + rearAxis.fixedTranslation1.r0[1] = rearAxis.fixedTranslation1.frame_b.x;
//   rearAxis.fixedTranslation1.frame_a.y + rearAxis.fixedTranslation1.r0[2] = rearAxis.fixedTranslation1.frame_b.y;
//   rearAxis.fixedTranslation1.frame_a.phi = rearAxis.fixedTranslation1.frame_b.phi;
//   rearAxis.fixedTranslation1.frame_a.fx + rearAxis.fixedTranslation1.frame_b.fx = 0.0;
//   rearAxis.fixedTranslation1.frame_a.fy + rearAxis.fixedTranslation1.frame_b.fy = 0.0;
//   rearAxis.fixedTranslation1.frame_a.t + (rearAxis.fixedTranslation1.frame_b.t + ((-rearAxis.fixedTranslation1.r0[1]) * rearAxis.fixedTranslation1.frame_b.fy + rearAxis.fixedTranslation1.r0[2] * rearAxis.fixedTranslation1.frame_b.fx)) = 0.0;
//   rearAxis.inertia1.phi = rearAxis.inertia1.flange_a.phi;
//   rearAxis.inertia1.phi = rearAxis.inertia1.flange_b.phi;
//   rearAxis.inertia1.w = der(rearAxis.inertia1.phi);
//   rearAxis.inertia1.a = der(rearAxis.inertia1.w);
//   rearAxis.inertia1.J * rearAxis.inertia1.a = rearAxis.inertia1.flange_a.tau + rearAxis.inertia1.flange_b.tau;
//   rearAxis.inertia2.phi = rearAxis.inertia2.flange_a.phi;
//   rearAxis.inertia2.phi = rearAxis.inertia2.flange_b.phi;
//   rearAxis.inertia2.w = der(rearAxis.inertia2.phi);
//   rearAxis.inertia2.a = der(rearAxis.inertia2.w);
//   rearAxis.inertia2.J * rearAxis.inertia2.a = rearAxis.inertia2.flange_a.tau + rearAxis.inertia2.flange_b.tau;
//   rearAxis.WheelJointLeft.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointLeft.cylinder.shapeType);
//   rearAxis.WheelJointLeft.cylinder.rxvisobj[1] = rearAxis.WheelJointLeft.cylinder.R.T[1,1] * rearAxis.WheelJointLeft.cylinder.e_x[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,1] * rearAxis.WheelJointLeft.cylinder.e_x[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,1] * rearAxis.WheelJointLeft.cylinder.e_x[3];
//   rearAxis.WheelJointLeft.cylinder.rxvisobj[2] = rearAxis.WheelJointLeft.cylinder.R.T[1,2] * rearAxis.WheelJointLeft.cylinder.e_x[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,2] * rearAxis.WheelJointLeft.cylinder.e_x[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,2] * rearAxis.WheelJointLeft.cylinder.e_x[3];
//   rearAxis.WheelJointLeft.cylinder.rxvisobj[3] = rearAxis.WheelJointLeft.cylinder.R.T[1,3] * rearAxis.WheelJointLeft.cylinder.e_x[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,3] * rearAxis.WheelJointLeft.cylinder.e_x[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,3] * rearAxis.WheelJointLeft.cylinder.e_x[3];
//   rearAxis.WheelJointLeft.cylinder.ryvisobj[1] = rearAxis.WheelJointLeft.cylinder.R.T[1,1] * rearAxis.WheelJointLeft.cylinder.e_y[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,1] * rearAxis.WheelJointLeft.cylinder.e_y[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,1] * rearAxis.WheelJointLeft.cylinder.e_y[3];
//   rearAxis.WheelJointLeft.cylinder.ryvisobj[2] = rearAxis.WheelJointLeft.cylinder.R.T[1,2] * rearAxis.WheelJointLeft.cylinder.e_y[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,2] * rearAxis.WheelJointLeft.cylinder.e_y[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,2] * rearAxis.WheelJointLeft.cylinder.e_y[3];
//   rearAxis.WheelJointLeft.cylinder.ryvisobj[3] = rearAxis.WheelJointLeft.cylinder.R.T[1,3] * rearAxis.WheelJointLeft.cylinder.e_y[1] + rearAxis.WheelJointLeft.cylinder.R.T[2,3] * rearAxis.WheelJointLeft.cylinder.e_y[2] + rearAxis.WheelJointLeft.cylinder.R.T[3,3] * rearAxis.WheelJointLeft.cylinder.e_y[3];
//   rearAxis.WheelJointLeft.cylinder.rvisobj = rearAxis.WheelJointLeft.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointLeft.cylinder.R.T[1,1],rearAxis.WheelJointLeft.cylinder.R.T[1,2],rearAxis.WheelJointLeft.cylinder.R.T[1,3]},{rearAxis.WheelJointLeft.cylinder.R.T[2,1],rearAxis.WheelJointLeft.cylinder.R.T[2,2],rearAxis.WheelJointLeft.cylinder.R.T[2,3]},{rearAxis.WheelJointLeft.cylinder.R.T[3,1],rearAxis.WheelJointLeft.cylinder.R.T[3,2],rearAxis.WheelJointLeft.cylinder.R.T[3,3]}},{rearAxis.WheelJointLeft.cylinder.r_shape[1],rearAxis.WheelJointLeft.cylinder.r_shape[2],rearAxis.WheelJointLeft.cylinder.r_shape[3]});
//   rearAxis.WheelJointLeft.cylinder.size[1] = rearAxis.WheelJointLeft.cylinder.length;
//   rearAxis.WheelJointLeft.cylinder.size[2] = rearAxis.WheelJointLeft.cylinder.width;
//   rearAxis.WheelJointLeft.cylinder.size[3] = rearAxis.WheelJointLeft.cylinder.height;
//   rearAxis.WheelJointLeft.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointLeft.cylinder.color[1] / 255.0,rearAxis.WheelJointLeft.cylinder.color[2] / 255.0,rearAxis.WheelJointLeft.cylinder.color[3] / 255.0,rearAxis.WheelJointLeft.cylinder.specularCoefficient);
//   rearAxis.WheelJointLeft.cylinder.Extra = rearAxis.WheelJointLeft.cylinder.extra;
//   rearAxis.WheelJointLeft.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointLeft.e0[2],rearAxis.WheelJointLeft.e0[1],0.0},rearAxis.WheelJointLeft.flange_a.phi,0.0);
//   rearAxis.WheelJointLeft.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointLeft.rim1.shapeType);
//   rearAxis.WheelJointLeft.rim1.rxvisobj[1] = rearAxis.WheelJointLeft.rim1.R.T[1,1] * rearAxis.WheelJointLeft.rim1.e_x[1] + rearAxis.WheelJointLeft.rim1.R.T[2,1] * rearAxis.WheelJointLeft.rim1.e_x[2] + rearAxis.WheelJointLeft.rim1.R.T[3,1] * rearAxis.WheelJointLeft.rim1.e_x[3];
//   rearAxis.WheelJointLeft.rim1.rxvisobj[2] = rearAxis.WheelJointLeft.rim1.R.T[1,2] * rearAxis.WheelJointLeft.rim1.e_x[1] + rearAxis.WheelJointLeft.rim1.R.T[2,2] * rearAxis.WheelJointLeft.rim1.e_x[2] + rearAxis.WheelJointLeft.rim1.R.T[3,2] * rearAxis.WheelJointLeft.rim1.e_x[3];
//   rearAxis.WheelJointLeft.rim1.rxvisobj[3] = rearAxis.WheelJointLeft.rim1.R.T[1,3] * rearAxis.WheelJointLeft.rim1.e_x[1] + rearAxis.WheelJointLeft.rim1.R.T[2,3] * rearAxis.WheelJointLeft.rim1.e_x[2] + rearAxis.WheelJointLeft.rim1.R.T[3,3] * rearAxis.WheelJointLeft.rim1.e_x[3];
//   rearAxis.WheelJointLeft.rim1.ryvisobj[1] = rearAxis.WheelJointLeft.rim1.R.T[1,1] * rearAxis.WheelJointLeft.rim1.e_y[1] + rearAxis.WheelJointLeft.rim1.R.T[2,1] * rearAxis.WheelJointLeft.rim1.e_y[2] + rearAxis.WheelJointLeft.rim1.R.T[3,1] * rearAxis.WheelJointLeft.rim1.e_y[3];
//   rearAxis.WheelJointLeft.rim1.ryvisobj[2] = rearAxis.WheelJointLeft.rim1.R.T[1,2] * rearAxis.WheelJointLeft.rim1.e_y[1] + rearAxis.WheelJointLeft.rim1.R.T[2,2] * rearAxis.WheelJointLeft.rim1.e_y[2] + rearAxis.WheelJointLeft.rim1.R.T[3,2] * rearAxis.WheelJointLeft.rim1.e_y[3];
//   rearAxis.WheelJointLeft.rim1.ryvisobj[3] = rearAxis.WheelJointLeft.rim1.R.T[1,3] * rearAxis.WheelJointLeft.rim1.e_y[1] + rearAxis.WheelJointLeft.rim1.R.T[2,3] * rearAxis.WheelJointLeft.rim1.e_y[2] + rearAxis.WheelJointLeft.rim1.R.T[3,3] * rearAxis.WheelJointLeft.rim1.e_y[3];
//   rearAxis.WheelJointLeft.rim1.rvisobj = rearAxis.WheelJointLeft.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointLeft.rim1.R.T[1,1],rearAxis.WheelJointLeft.rim1.R.T[1,2],rearAxis.WheelJointLeft.rim1.R.T[1,3]},{rearAxis.WheelJointLeft.rim1.R.T[2,1],rearAxis.WheelJointLeft.rim1.R.T[2,2],rearAxis.WheelJointLeft.rim1.R.T[2,3]},{rearAxis.WheelJointLeft.rim1.R.T[3,1],rearAxis.WheelJointLeft.rim1.R.T[3,2],rearAxis.WheelJointLeft.rim1.R.T[3,3]}},{rearAxis.WheelJointLeft.rim1.r_shape[1],rearAxis.WheelJointLeft.rim1.r_shape[2],rearAxis.WheelJointLeft.rim1.r_shape[3]});
//   rearAxis.WheelJointLeft.rim1.size[1] = rearAxis.WheelJointLeft.rim1.length;
//   rearAxis.WheelJointLeft.rim1.size[2] = rearAxis.WheelJointLeft.rim1.width;
//   rearAxis.WheelJointLeft.rim1.size[3] = rearAxis.WheelJointLeft.rim1.height;
//   rearAxis.WheelJointLeft.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointLeft.rim1.color[1] / 255.0,rearAxis.WheelJointLeft.rim1.color[2] / 255.0,rearAxis.WheelJointLeft.rim1.color[3] / 255.0,rearAxis.WheelJointLeft.rim1.specularCoefficient);
//   rearAxis.WheelJointLeft.rim1.Extra = rearAxis.WheelJointLeft.rim1.extra;
//   rearAxis.WheelJointLeft.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointLeft.e0[2],rearAxis.WheelJointLeft.e0[1],0.0},1.5707963267949 + rearAxis.WheelJointLeft.flange_a.phi,0.0);
//   rearAxis.WheelJointLeft.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointLeft.rim2.shapeType);
//   rearAxis.WheelJointLeft.rim2.rxvisobj[1] = rearAxis.WheelJointLeft.rim2.R.T[1,1] * rearAxis.WheelJointLeft.rim2.e_x[1] + rearAxis.WheelJointLeft.rim2.R.T[2,1] * rearAxis.WheelJointLeft.rim2.e_x[2] + rearAxis.WheelJointLeft.rim2.R.T[3,1] * rearAxis.WheelJointLeft.rim2.e_x[3];
//   rearAxis.WheelJointLeft.rim2.rxvisobj[2] = rearAxis.WheelJointLeft.rim2.R.T[1,2] * rearAxis.WheelJointLeft.rim2.e_x[1] + rearAxis.WheelJointLeft.rim2.R.T[2,2] * rearAxis.WheelJointLeft.rim2.e_x[2] + rearAxis.WheelJointLeft.rim2.R.T[3,2] * rearAxis.WheelJointLeft.rim2.e_x[3];
//   rearAxis.WheelJointLeft.rim2.rxvisobj[3] = rearAxis.WheelJointLeft.rim2.R.T[1,3] * rearAxis.WheelJointLeft.rim2.e_x[1] + rearAxis.WheelJointLeft.rim2.R.T[2,3] * rearAxis.WheelJointLeft.rim2.e_x[2] + rearAxis.WheelJointLeft.rim2.R.T[3,3] * rearAxis.WheelJointLeft.rim2.e_x[3];
//   rearAxis.WheelJointLeft.rim2.ryvisobj[1] = rearAxis.WheelJointLeft.rim2.R.T[1,1] * rearAxis.WheelJointLeft.rim2.e_y[1] + rearAxis.WheelJointLeft.rim2.R.T[2,1] * rearAxis.WheelJointLeft.rim2.e_y[2] + rearAxis.WheelJointLeft.rim2.R.T[3,1] * rearAxis.WheelJointLeft.rim2.e_y[3];
//   rearAxis.WheelJointLeft.rim2.ryvisobj[2] = rearAxis.WheelJointLeft.rim2.R.T[1,2] * rearAxis.WheelJointLeft.rim2.e_y[1] + rearAxis.WheelJointLeft.rim2.R.T[2,2] * rearAxis.WheelJointLeft.rim2.e_y[2] + rearAxis.WheelJointLeft.rim2.R.T[3,2] * rearAxis.WheelJointLeft.rim2.e_y[3];
//   rearAxis.WheelJointLeft.rim2.ryvisobj[3] = rearAxis.WheelJointLeft.rim2.R.T[1,3] * rearAxis.WheelJointLeft.rim2.e_y[1] + rearAxis.WheelJointLeft.rim2.R.T[2,3] * rearAxis.WheelJointLeft.rim2.e_y[2] + rearAxis.WheelJointLeft.rim2.R.T[3,3] * rearAxis.WheelJointLeft.rim2.e_y[3];
//   rearAxis.WheelJointLeft.rim2.rvisobj = rearAxis.WheelJointLeft.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointLeft.rim2.R.T[1,1],rearAxis.WheelJointLeft.rim2.R.T[1,2],rearAxis.WheelJointLeft.rim2.R.T[1,3]},{rearAxis.WheelJointLeft.rim2.R.T[2,1],rearAxis.WheelJointLeft.rim2.R.T[2,2],rearAxis.WheelJointLeft.rim2.R.T[2,3]},{rearAxis.WheelJointLeft.rim2.R.T[3,1],rearAxis.WheelJointLeft.rim2.R.T[3,2],rearAxis.WheelJointLeft.rim2.R.T[3,3]}},{rearAxis.WheelJointLeft.rim2.r_shape[1],rearAxis.WheelJointLeft.rim2.r_shape[2],rearAxis.WheelJointLeft.rim2.r_shape[3]});
//   rearAxis.WheelJointLeft.rim2.size[1] = rearAxis.WheelJointLeft.rim2.length;
//   rearAxis.WheelJointLeft.rim2.size[2] = rearAxis.WheelJointLeft.rim2.width;
//   rearAxis.WheelJointLeft.rim2.size[3] = rearAxis.WheelJointLeft.rim2.height;
//   rearAxis.WheelJointLeft.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointLeft.rim2.color[1] / 255.0,rearAxis.WheelJointLeft.rim2.color[2] / 255.0,rearAxis.WheelJointLeft.rim2.color[3] / 255.0,rearAxis.WheelJointLeft.rim2.specularCoefficient);
//   rearAxis.WheelJointLeft.rim2.Extra = rearAxis.WheelJointLeft.rim2.extra;
//   rearAxis.WheelJointLeft.R[1,1] = cos(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.R[1,2] = sin(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.R[2,1] = -sin(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.R[2,2] = cos(rearAxis.WheelJointLeft.frame_a.phi);
//   rearAxis.WheelJointLeft.e0[1] = rearAxis.WheelJointLeft.R[1,1] * rearAxis.WheelJointLeft.e[1] + rearAxis.WheelJointLeft.R[1,2] * rearAxis.WheelJointLeft.e[2];
//   rearAxis.WheelJointLeft.e0[2] = rearAxis.WheelJointLeft.R[2,1] * rearAxis.WheelJointLeft.e[1] + rearAxis.WheelJointLeft.R[2,2] * rearAxis.WheelJointLeft.e[2];
//   rearAxis.WheelJointLeft.v[1] = der(rearAxis.WheelJointLeft.frame_a.x);
//   rearAxis.WheelJointLeft.v[2] = der(rearAxis.WheelJointLeft.frame_a.y);
//   rearAxis.WheelJointLeft.w_roll = der(rearAxis.WheelJointLeft.flange_a.phi);
//   rearAxis.WheelJointLeft.v_long = rearAxis.WheelJointLeft.v[1] * rearAxis.WheelJointLeft.e0[1] + rearAxis.WheelJointLeft.v[2] * rearAxis.WheelJointLeft.e0[2];
//   rearAxis.WheelJointLeft.v_lat = (-rearAxis.WheelJointLeft.v[1]) * rearAxis.WheelJointLeft.e0[2] + rearAxis.WheelJointLeft.v[2] * rearAxis.WheelJointLeft.e0[1];
//   rearAxis.WheelJointLeft.v_slip_lat = rearAxis.WheelJointLeft.v_lat;
//   rearAxis.WheelJointLeft.v_slip_long = rearAxis.WheelJointLeft.v_long - rearAxis.WheelJointLeft.radius * rearAxis.WheelJointLeft.w_roll;
//   rearAxis.WheelJointLeft.v_slip = 0.0001 + sqrt(rearAxis.WheelJointLeft.v_slip_long ^ 2.0 + rearAxis.WheelJointLeft.v_slip_lat ^ 2.0);
//   (-rearAxis.WheelJointLeft.f_long) * rearAxis.WheelJointLeft.radius = rearAxis.WheelJointLeft.flange_a.tau;
//   rearAxis.WheelJointLeft.frame_a.t = 0.0;
//   rearAxis.WheelJointLeft.f = rearAxis.WheelJointLeft.N * PlanarMechanicsV4.Utilities.TripleS_Func(rearAxis.WheelJointLeft.vAdhesion,rearAxis.WheelJointLeft.vSlide,rearAxis.WheelJointLeft.mu_A,rearAxis.WheelJointLeft.mu_S,rearAxis.WheelJointLeft.v_slip);
//   rearAxis.WheelJointLeft.f_long = (rearAxis.WheelJointLeft.f * rearAxis.WheelJointLeft.v_slip_long) / rearAxis.WheelJointLeft.v_slip;
//   rearAxis.WheelJointLeft.f_lat = (rearAxis.WheelJointLeft.f * rearAxis.WheelJointLeft.v_slip_lat) / rearAxis.WheelJointLeft.v_slip;
//   rearAxis.WheelJointLeft.f_long = rearAxis.WheelJointLeft.frame_a.fx * rearAxis.WheelJointLeft.e0[1] + rearAxis.WheelJointLeft.frame_a.fy * rearAxis.WheelJointLeft.e0[2];
//   rearAxis.WheelJointLeft.f_lat = rearAxis.WheelJointLeft.frame_a.fy * rearAxis.WheelJointLeft.e0[1] + (-rearAxis.WheelJointLeft.frame_a.fx) * rearAxis.WheelJointLeft.e0[2];
//   rearAxis.WheelJointRight.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointRight.cylinder.shapeType);
//   rearAxis.WheelJointRight.cylinder.rxvisobj[1] = rearAxis.WheelJointRight.cylinder.R.T[1,1] * rearAxis.WheelJointRight.cylinder.e_x[1] + rearAxis.WheelJointRight.cylinder.R.T[2,1] * rearAxis.WheelJointRight.cylinder.e_x[2] + rearAxis.WheelJointRight.cylinder.R.T[3,1] * rearAxis.WheelJointRight.cylinder.e_x[3];
//   rearAxis.WheelJointRight.cylinder.rxvisobj[2] = rearAxis.WheelJointRight.cylinder.R.T[1,2] * rearAxis.WheelJointRight.cylinder.e_x[1] + rearAxis.WheelJointRight.cylinder.R.T[2,2] * rearAxis.WheelJointRight.cylinder.e_x[2] + rearAxis.WheelJointRight.cylinder.R.T[3,2] * rearAxis.WheelJointRight.cylinder.e_x[3];
//   rearAxis.WheelJointRight.cylinder.rxvisobj[3] = rearAxis.WheelJointRight.cylinder.R.T[1,3] * rearAxis.WheelJointRight.cylinder.e_x[1] + rearAxis.WheelJointRight.cylinder.R.T[2,3] * rearAxis.WheelJointRight.cylinder.e_x[2] + rearAxis.WheelJointRight.cylinder.R.T[3,3] * rearAxis.WheelJointRight.cylinder.e_x[3];
//   rearAxis.WheelJointRight.cylinder.ryvisobj[1] = rearAxis.WheelJointRight.cylinder.R.T[1,1] * rearAxis.WheelJointRight.cylinder.e_y[1] + rearAxis.WheelJointRight.cylinder.R.T[2,1] * rearAxis.WheelJointRight.cylinder.e_y[2] + rearAxis.WheelJointRight.cylinder.R.T[3,1] * rearAxis.WheelJointRight.cylinder.e_y[3];
//   rearAxis.WheelJointRight.cylinder.ryvisobj[2] = rearAxis.WheelJointRight.cylinder.R.T[1,2] * rearAxis.WheelJointRight.cylinder.e_y[1] + rearAxis.WheelJointRight.cylinder.R.T[2,2] * rearAxis.WheelJointRight.cylinder.e_y[2] + rearAxis.WheelJointRight.cylinder.R.T[3,2] * rearAxis.WheelJointRight.cylinder.e_y[3];
//   rearAxis.WheelJointRight.cylinder.ryvisobj[3] = rearAxis.WheelJointRight.cylinder.R.T[1,3] * rearAxis.WheelJointRight.cylinder.e_y[1] + rearAxis.WheelJointRight.cylinder.R.T[2,3] * rearAxis.WheelJointRight.cylinder.e_y[2] + rearAxis.WheelJointRight.cylinder.R.T[3,3] * rearAxis.WheelJointRight.cylinder.e_y[3];
//   rearAxis.WheelJointRight.cylinder.rvisobj = rearAxis.WheelJointRight.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointRight.cylinder.R.T[1,1],rearAxis.WheelJointRight.cylinder.R.T[1,2],rearAxis.WheelJointRight.cylinder.R.T[1,3]},{rearAxis.WheelJointRight.cylinder.R.T[2,1],rearAxis.WheelJointRight.cylinder.R.T[2,2],rearAxis.WheelJointRight.cylinder.R.T[2,3]},{rearAxis.WheelJointRight.cylinder.R.T[3,1],rearAxis.WheelJointRight.cylinder.R.T[3,2],rearAxis.WheelJointRight.cylinder.R.T[3,3]}},{rearAxis.WheelJointRight.cylinder.r_shape[1],rearAxis.WheelJointRight.cylinder.r_shape[2],rearAxis.WheelJointRight.cylinder.r_shape[3]});
//   rearAxis.WheelJointRight.cylinder.size[1] = rearAxis.WheelJointRight.cylinder.length;
//   rearAxis.WheelJointRight.cylinder.size[2] = rearAxis.WheelJointRight.cylinder.width;
//   rearAxis.WheelJointRight.cylinder.size[3] = rearAxis.WheelJointRight.cylinder.height;
//   rearAxis.WheelJointRight.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointRight.cylinder.color[1] / 255.0,rearAxis.WheelJointRight.cylinder.color[2] / 255.0,rearAxis.WheelJointRight.cylinder.color[3] / 255.0,rearAxis.WheelJointRight.cylinder.specularCoefficient);
//   rearAxis.WheelJointRight.cylinder.Extra = rearAxis.WheelJointRight.cylinder.extra;
//   rearAxis.WheelJointRight.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointRight.e0[2],rearAxis.WheelJointRight.e0[1],0.0},rearAxis.WheelJointRight.flange_a.phi,0.0);
//   rearAxis.WheelJointRight.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointRight.rim1.shapeType);
//   rearAxis.WheelJointRight.rim1.rxvisobj[1] = rearAxis.WheelJointRight.rim1.R.T[1,1] * rearAxis.WheelJointRight.rim1.e_x[1] + rearAxis.WheelJointRight.rim1.R.T[2,1] * rearAxis.WheelJointRight.rim1.e_x[2] + rearAxis.WheelJointRight.rim1.R.T[3,1] * rearAxis.WheelJointRight.rim1.e_x[3];
//   rearAxis.WheelJointRight.rim1.rxvisobj[2] = rearAxis.WheelJointRight.rim1.R.T[1,2] * rearAxis.WheelJointRight.rim1.e_x[1] + rearAxis.WheelJointRight.rim1.R.T[2,2] * rearAxis.WheelJointRight.rim1.e_x[2] + rearAxis.WheelJointRight.rim1.R.T[3,2] * rearAxis.WheelJointRight.rim1.e_x[3];
//   rearAxis.WheelJointRight.rim1.rxvisobj[3] = rearAxis.WheelJointRight.rim1.R.T[1,3] * rearAxis.WheelJointRight.rim1.e_x[1] + rearAxis.WheelJointRight.rim1.R.T[2,3] * rearAxis.WheelJointRight.rim1.e_x[2] + rearAxis.WheelJointRight.rim1.R.T[3,3] * rearAxis.WheelJointRight.rim1.e_x[3];
//   rearAxis.WheelJointRight.rim1.ryvisobj[1] = rearAxis.WheelJointRight.rim1.R.T[1,1] * rearAxis.WheelJointRight.rim1.e_y[1] + rearAxis.WheelJointRight.rim1.R.T[2,1] * rearAxis.WheelJointRight.rim1.e_y[2] + rearAxis.WheelJointRight.rim1.R.T[3,1] * rearAxis.WheelJointRight.rim1.e_y[3];
//   rearAxis.WheelJointRight.rim1.ryvisobj[2] = rearAxis.WheelJointRight.rim1.R.T[1,2] * rearAxis.WheelJointRight.rim1.e_y[1] + rearAxis.WheelJointRight.rim1.R.T[2,2] * rearAxis.WheelJointRight.rim1.e_y[2] + rearAxis.WheelJointRight.rim1.R.T[3,2] * rearAxis.WheelJointRight.rim1.e_y[3];
//   rearAxis.WheelJointRight.rim1.ryvisobj[3] = rearAxis.WheelJointRight.rim1.R.T[1,3] * rearAxis.WheelJointRight.rim1.e_y[1] + rearAxis.WheelJointRight.rim1.R.T[2,3] * rearAxis.WheelJointRight.rim1.e_y[2] + rearAxis.WheelJointRight.rim1.R.T[3,3] * rearAxis.WheelJointRight.rim1.e_y[3];
//   rearAxis.WheelJointRight.rim1.rvisobj = rearAxis.WheelJointRight.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointRight.rim1.R.T[1,1],rearAxis.WheelJointRight.rim1.R.T[1,2],rearAxis.WheelJointRight.rim1.R.T[1,3]},{rearAxis.WheelJointRight.rim1.R.T[2,1],rearAxis.WheelJointRight.rim1.R.T[2,2],rearAxis.WheelJointRight.rim1.R.T[2,3]},{rearAxis.WheelJointRight.rim1.R.T[3,1],rearAxis.WheelJointRight.rim1.R.T[3,2],rearAxis.WheelJointRight.rim1.R.T[3,3]}},{rearAxis.WheelJointRight.rim1.r_shape[1],rearAxis.WheelJointRight.rim1.r_shape[2],rearAxis.WheelJointRight.rim1.r_shape[3]});
//   rearAxis.WheelJointRight.rim1.size[1] = rearAxis.WheelJointRight.rim1.length;
//   rearAxis.WheelJointRight.rim1.size[2] = rearAxis.WheelJointRight.rim1.width;
//   rearAxis.WheelJointRight.rim1.size[3] = rearAxis.WheelJointRight.rim1.height;
//   rearAxis.WheelJointRight.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointRight.rim1.color[1] / 255.0,rearAxis.WheelJointRight.rim1.color[2] / 255.0,rearAxis.WheelJointRight.rim1.color[3] / 255.0,rearAxis.WheelJointRight.rim1.specularCoefficient);
//   rearAxis.WheelJointRight.rim1.Extra = rearAxis.WheelJointRight.rim1.extra;
//   rearAxis.WheelJointRight.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-rearAxis.WheelJointRight.e0[2],rearAxis.WheelJointRight.e0[1],0.0},1.5707963267949 + rearAxis.WheelJointRight.flange_a.phi,0.0);
//   rearAxis.WheelJointRight.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rearAxis.WheelJointRight.rim2.shapeType);
//   rearAxis.WheelJointRight.rim2.rxvisobj[1] = rearAxis.WheelJointRight.rim2.R.T[1,1] * rearAxis.WheelJointRight.rim2.e_x[1] + rearAxis.WheelJointRight.rim2.R.T[2,1] * rearAxis.WheelJointRight.rim2.e_x[2] + rearAxis.WheelJointRight.rim2.R.T[3,1] * rearAxis.WheelJointRight.rim2.e_x[3];
//   rearAxis.WheelJointRight.rim2.rxvisobj[2] = rearAxis.WheelJointRight.rim2.R.T[1,2] * rearAxis.WheelJointRight.rim2.e_x[1] + rearAxis.WheelJointRight.rim2.R.T[2,2] * rearAxis.WheelJointRight.rim2.e_x[2] + rearAxis.WheelJointRight.rim2.R.T[3,2] * rearAxis.WheelJointRight.rim2.e_x[3];
//   rearAxis.WheelJointRight.rim2.rxvisobj[3] = rearAxis.WheelJointRight.rim2.R.T[1,3] * rearAxis.WheelJointRight.rim2.e_x[1] + rearAxis.WheelJointRight.rim2.R.T[2,3] * rearAxis.WheelJointRight.rim2.e_x[2] + rearAxis.WheelJointRight.rim2.R.T[3,3] * rearAxis.WheelJointRight.rim2.e_x[3];
//   rearAxis.WheelJointRight.rim2.ryvisobj[1] = rearAxis.WheelJointRight.rim2.R.T[1,1] * rearAxis.WheelJointRight.rim2.e_y[1] + rearAxis.WheelJointRight.rim2.R.T[2,1] * rearAxis.WheelJointRight.rim2.e_y[2] + rearAxis.WheelJointRight.rim2.R.T[3,1] * rearAxis.WheelJointRight.rim2.e_y[3];
//   rearAxis.WheelJointRight.rim2.ryvisobj[2] = rearAxis.WheelJointRight.rim2.R.T[1,2] * rearAxis.WheelJointRight.rim2.e_y[1] + rearAxis.WheelJointRight.rim2.R.T[2,2] * rearAxis.WheelJointRight.rim2.e_y[2] + rearAxis.WheelJointRight.rim2.R.T[3,2] * rearAxis.WheelJointRight.rim2.e_y[3];
//   rearAxis.WheelJointRight.rim2.ryvisobj[3] = rearAxis.WheelJointRight.rim2.R.T[1,3] * rearAxis.WheelJointRight.rim2.e_y[1] + rearAxis.WheelJointRight.rim2.R.T[2,3] * rearAxis.WheelJointRight.rim2.e_y[2] + rearAxis.WheelJointRight.rim2.R.T[3,3] * rearAxis.WheelJointRight.rim2.e_y[3];
//   rearAxis.WheelJointRight.rim2.rvisobj = rearAxis.WheelJointRight.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rearAxis.WheelJointRight.rim2.R.T[1,1],rearAxis.WheelJointRight.rim2.R.T[1,2],rearAxis.WheelJointRight.rim2.R.T[1,3]},{rearAxis.WheelJointRight.rim2.R.T[2,1],rearAxis.WheelJointRight.rim2.R.T[2,2],rearAxis.WheelJointRight.rim2.R.T[2,3]},{rearAxis.WheelJointRight.rim2.R.T[3,1],rearAxis.WheelJointRight.rim2.R.T[3,2],rearAxis.WheelJointRight.rim2.R.T[3,3]}},{rearAxis.WheelJointRight.rim2.r_shape[1],rearAxis.WheelJointRight.rim2.r_shape[2],rearAxis.WheelJointRight.rim2.r_shape[3]});
//   rearAxis.WheelJointRight.rim2.size[1] = rearAxis.WheelJointRight.rim2.length;
//   rearAxis.WheelJointRight.rim2.size[2] = rearAxis.WheelJointRight.rim2.width;
//   rearAxis.WheelJointRight.rim2.size[3] = rearAxis.WheelJointRight.rim2.height;
//   rearAxis.WheelJointRight.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rearAxis.WheelJointRight.rim2.color[1] / 255.0,rearAxis.WheelJointRight.rim2.color[2] / 255.0,rearAxis.WheelJointRight.rim2.color[3] / 255.0,rearAxis.WheelJointRight.rim2.specularCoefficient);
//   rearAxis.WheelJointRight.rim2.Extra = rearAxis.WheelJointRight.rim2.extra;
//   rearAxis.WheelJointRight.R[1,1] = cos(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.R[1,2] = sin(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.R[2,1] = -sin(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.R[2,2] = cos(rearAxis.WheelJointRight.frame_a.phi);
//   rearAxis.WheelJointRight.e0[1] = rearAxis.WheelJointRight.R[1,1] * rearAxis.WheelJointRight.e[1] + rearAxis.WheelJointRight.R[1,2] * rearAxis.WheelJointRight.e[2];
//   rearAxis.WheelJointRight.e0[2] = rearAxis.WheelJointRight.R[2,1] * rearAxis.WheelJointRight.e[1] + rearAxis.WheelJointRight.R[2,2] * rearAxis.WheelJointRight.e[2];
//   rearAxis.WheelJointRight.v[1] = der(rearAxis.WheelJointRight.frame_a.x);
//   rearAxis.WheelJointRight.v[2] = der(rearAxis.WheelJointRight.frame_a.y);
//   rearAxis.WheelJointRight.w_roll = der(rearAxis.WheelJointRight.flange_a.phi);
//   rearAxis.WheelJointRight.v_long = rearAxis.WheelJointRight.v[1] * rearAxis.WheelJointRight.e0[1] + rearAxis.WheelJointRight.v[2] * rearAxis.WheelJointRight.e0[2];
//   rearAxis.WheelJointRight.v_lat = (-rearAxis.WheelJointRight.v[1]) * rearAxis.WheelJointRight.e0[2] + rearAxis.WheelJointRight.v[2] * rearAxis.WheelJointRight.e0[1];
//   rearAxis.WheelJointRight.v_slip_lat = rearAxis.WheelJointRight.v_lat;
//   rearAxis.WheelJointRight.v_slip_long = rearAxis.WheelJointRight.v_long - rearAxis.WheelJointRight.radius * rearAxis.WheelJointRight.w_roll;
//   rearAxis.WheelJointRight.v_slip = 0.0001 + sqrt(rearAxis.WheelJointRight.v_slip_long ^ 2.0 + rearAxis.WheelJointRight.v_slip_lat ^ 2.0);
//   (-rearAxis.WheelJointRight.f_long) * rearAxis.WheelJointRight.radius = rearAxis.WheelJointRight.flange_a.tau;
//   rearAxis.WheelJointRight.frame_a.t = 0.0;
//   rearAxis.WheelJointRight.f = rearAxis.WheelJointRight.N * PlanarMechanicsV4.Utilities.TripleS_Func(rearAxis.WheelJointRight.vAdhesion,rearAxis.WheelJointRight.vSlide,rearAxis.WheelJointRight.mu_A,rearAxis.WheelJointRight.mu_S,rearAxis.WheelJointRight.v_slip);
//   rearAxis.WheelJointRight.f_long = (rearAxis.WheelJointRight.f * rearAxis.WheelJointRight.v_slip_long) / rearAxis.WheelJointRight.v_slip;
//   rearAxis.WheelJointRight.f_lat = (rearAxis.WheelJointRight.f * rearAxis.WheelJointRight.v_slip_lat) / rearAxis.WheelJointRight.v_slip;
//   rearAxis.WheelJointRight.f_long = rearAxis.WheelJointRight.frame_a.fx * rearAxis.WheelJointRight.e0[1] + rearAxis.WheelJointRight.frame_a.fy * rearAxis.WheelJointRight.e0[2];
//   rearAxis.WheelJointRight.f_lat = rearAxis.WheelJointRight.frame_a.fy * rearAxis.WheelJointRight.e0[1] + (-rearAxis.WheelJointRight.frame_a.fx) * rearAxis.WheelJointRight.e0[2];
//   frontAxis.leftSteeringRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.leftSteeringRevolute.cylinder.shapeType);
//   frontAxis.leftSteeringRevolute.cylinder.rxvisobj[1] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,1] * frontAxis.leftSteeringRevolute.cylinder.e_x[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,1] * frontAxis.leftSteeringRevolute.cylinder.e_x[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,1] * frontAxis.leftSteeringRevolute.cylinder.e_x[3];
//   frontAxis.leftSteeringRevolute.cylinder.rxvisobj[2] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,2] * frontAxis.leftSteeringRevolute.cylinder.e_x[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,2] * frontAxis.leftSteeringRevolute.cylinder.e_x[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,2] * frontAxis.leftSteeringRevolute.cylinder.e_x[3];
//   frontAxis.leftSteeringRevolute.cylinder.rxvisobj[3] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,3] * frontAxis.leftSteeringRevolute.cylinder.e_x[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,3] * frontAxis.leftSteeringRevolute.cylinder.e_x[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,3] * frontAxis.leftSteeringRevolute.cylinder.e_x[3];
//   frontAxis.leftSteeringRevolute.cylinder.ryvisobj[1] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,1] * frontAxis.leftSteeringRevolute.cylinder.e_y[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,1] * frontAxis.leftSteeringRevolute.cylinder.e_y[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,1] * frontAxis.leftSteeringRevolute.cylinder.e_y[3];
//   frontAxis.leftSteeringRevolute.cylinder.ryvisobj[2] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,2] * frontAxis.leftSteeringRevolute.cylinder.e_y[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,2] * frontAxis.leftSteeringRevolute.cylinder.e_y[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,2] * frontAxis.leftSteeringRevolute.cylinder.e_y[3];
//   frontAxis.leftSteeringRevolute.cylinder.ryvisobj[3] = frontAxis.leftSteeringRevolute.cylinder.R.T[1,3] * frontAxis.leftSteeringRevolute.cylinder.e_y[1] + frontAxis.leftSteeringRevolute.cylinder.R.T[2,3] * frontAxis.leftSteeringRevolute.cylinder.e_y[2] + frontAxis.leftSteeringRevolute.cylinder.R.T[3,3] * frontAxis.leftSteeringRevolute.cylinder.e_y[3];
//   frontAxis.leftSteeringRevolute.cylinder.rvisobj = frontAxis.leftSteeringRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.leftSteeringRevolute.cylinder.R.T[1,1],frontAxis.leftSteeringRevolute.cylinder.R.T[1,2],frontAxis.leftSteeringRevolute.cylinder.R.T[1,3]},{frontAxis.leftSteeringRevolute.cylinder.R.T[2,1],frontAxis.leftSteeringRevolute.cylinder.R.T[2,2],frontAxis.leftSteeringRevolute.cylinder.R.T[2,3]},{frontAxis.leftSteeringRevolute.cylinder.R.T[3,1],frontAxis.leftSteeringRevolute.cylinder.R.T[3,2],frontAxis.leftSteeringRevolute.cylinder.R.T[3,3]}},{frontAxis.leftSteeringRevolute.cylinder.r_shape[1],frontAxis.leftSteeringRevolute.cylinder.r_shape[2],frontAxis.leftSteeringRevolute.cylinder.r_shape[3]});
//   frontAxis.leftSteeringRevolute.cylinder.size[1] = frontAxis.leftSteeringRevolute.cylinder.length;
//   frontAxis.leftSteeringRevolute.cylinder.size[2] = frontAxis.leftSteeringRevolute.cylinder.width;
//   frontAxis.leftSteeringRevolute.cylinder.size[3] = frontAxis.leftSteeringRevolute.cylinder.height;
//   frontAxis.leftSteeringRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.leftSteeringRevolute.cylinder.color[1] / 255.0,frontAxis.leftSteeringRevolute.cylinder.color[2] / 255.0,frontAxis.leftSteeringRevolute.cylinder.color[3] / 255.0,frontAxis.leftSteeringRevolute.cylinder.specularCoefficient);
//   frontAxis.leftSteeringRevolute.cylinder.Extra = frontAxis.leftSteeringRevolute.cylinder.extra;
//   frontAxis.leftSteeringRevolute.phi = frontAxis.leftSteeringRevolute.flange_a.phi;
//   frontAxis.leftSteeringRevolute.w = der(frontAxis.leftSteeringRevolute.phi);
//   frontAxis.leftSteeringRevolute.z = der(frontAxis.leftSteeringRevolute.w);
//   frontAxis.leftSteeringRevolute.t = frontAxis.leftSteeringRevolute.flange_a.tau;
//   frontAxis.leftSteeringRevolute.frame_a.x = frontAxis.leftSteeringRevolute.frame_b.x;
//   frontAxis.leftSteeringRevolute.frame_a.y = frontAxis.leftSteeringRevolute.frame_b.y;
//   frontAxis.leftSteeringRevolute.frame_a.phi + frontAxis.leftSteeringRevolute.phi = frontAxis.leftSteeringRevolute.frame_b.phi;
//   frontAxis.leftSteeringRevolute.frame_a.fx + frontAxis.leftSteeringRevolute.frame_b.fx = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.fy + frontAxis.leftSteeringRevolute.frame_b.fy = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.t + frontAxis.leftSteeringRevolute.frame_b.t = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.t = frontAxis.leftSteeringRevolute.t;
//   frontAxis.rightSteeringRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.rightSteeringRevolute.cylinder.shapeType);
//   frontAxis.rightSteeringRevolute.cylinder.rxvisobj[1] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,1] * frontAxis.rightSteeringRevolute.cylinder.e_x[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,1] * frontAxis.rightSteeringRevolute.cylinder.e_x[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,1] * frontAxis.rightSteeringRevolute.cylinder.e_x[3];
//   frontAxis.rightSteeringRevolute.cylinder.rxvisobj[2] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,2] * frontAxis.rightSteeringRevolute.cylinder.e_x[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,2] * frontAxis.rightSteeringRevolute.cylinder.e_x[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,2] * frontAxis.rightSteeringRevolute.cylinder.e_x[3];
//   frontAxis.rightSteeringRevolute.cylinder.rxvisobj[3] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,3] * frontAxis.rightSteeringRevolute.cylinder.e_x[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,3] * frontAxis.rightSteeringRevolute.cylinder.e_x[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,3] * frontAxis.rightSteeringRevolute.cylinder.e_x[3];
//   frontAxis.rightSteeringRevolute.cylinder.ryvisobj[1] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,1] * frontAxis.rightSteeringRevolute.cylinder.e_y[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,1] * frontAxis.rightSteeringRevolute.cylinder.e_y[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,1] * frontAxis.rightSteeringRevolute.cylinder.e_y[3];
//   frontAxis.rightSteeringRevolute.cylinder.ryvisobj[2] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,2] * frontAxis.rightSteeringRevolute.cylinder.e_y[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,2] * frontAxis.rightSteeringRevolute.cylinder.e_y[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,2] * frontAxis.rightSteeringRevolute.cylinder.e_y[3];
//   frontAxis.rightSteeringRevolute.cylinder.ryvisobj[3] = frontAxis.rightSteeringRevolute.cylinder.R.T[1,3] * frontAxis.rightSteeringRevolute.cylinder.e_y[1] + frontAxis.rightSteeringRevolute.cylinder.R.T[2,3] * frontAxis.rightSteeringRevolute.cylinder.e_y[2] + frontAxis.rightSteeringRevolute.cylinder.R.T[3,3] * frontAxis.rightSteeringRevolute.cylinder.e_y[3];
//   frontAxis.rightSteeringRevolute.cylinder.rvisobj = frontAxis.rightSteeringRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.rightSteeringRevolute.cylinder.R.T[1,1],frontAxis.rightSteeringRevolute.cylinder.R.T[1,2],frontAxis.rightSteeringRevolute.cylinder.R.T[1,3]},{frontAxis.rightSteeringRevolute.cylinder.R.T[2,1],frontAxis.rightSteeringRevolute.cylinder.R.T[2,2],frontAxis.rightSteeringRevolute.cylinder.R.T[2,3]},{frontAxis.rightSteeringRevolute.cylinder.R.T[3,1],frontAxis.rightSteeringRevolute.cylinder.R.T[3,2],frontAxis.rightSteeringRevolute.cylinder.R.T[3,3]}},{frontAxis.rightSteeringRevolute.cylinder.r_shape[1],frontAxis.rightSteeringRevolute.cylinder.r_shape[2],frontAxis.rightSteeringRevolute.cylinder.r_shape[3]});
//   frontAxis.rightSteeringRevolute.cylinder.size[1] = frontAxis.rightSteeringRevolute.cylinder.length;
//   frontAxis.rightSteeringRevolute.cylinder.size[2] = frontAxis.rightSteeringRevolute.cylinder.width;
//   frontAxis.rightSteeringRevolute.cylinder.size[3] = frontAxis.rightSteeringRevolute.cylinder.height;
//   frontAxis.rightSteeringRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.rightSteeringRevolute.cylinder.color[1] / 255.0,frontAxis.rightSteeringRevolute.cylinder.color[2] / 255.0,frontAxis.rightSteeringRevolute.cylinder.color[3] / 255.0,frontAxis.rightSteeringRevolute.cylinder.specularCoefficient);
//   frontAxis.rightSteeringRevolute.cylinder.Extra = frontAxis.rightSteeringRevolute.cylinder.extra;
//   frontAxis.rightSteeringRevolute.phi = frontAxis.rightSteeringRevolute.flange_a.phi;
//   frontAxis.rightSteeringRevolute.w = der(frontAxis.rightSteeringRevolute.phi);
//   frontAxis.rightSteeringRevolute.z = der(frontAxis.rightSteeringRevolute.w);
//   frontAxis.rightSteeringRevolute.t = frontAxis.rightSteeringRevolute.flange_a.tau;
//   frontAxis.rightSteeringRevolute.frame_a.x = frontAxis.rightSteeringRevolute.frame_b.x;
//   frontAxis.rightSteeringRevolute.frame_a.y = frontAxis.rightSteeringRevolute.frame_b.y;
//   frontAxis.rightSteeringRevolute.frame_a.phi + frontAxis.rightSteeringRevolute.phi = frontAxis.rightSteeringRevolute.frame_b.phi;
//   frontAxis.rightSteeringRevolute.frame_a.fx + frontAxis.rightSteeringRevolute.frame_b.fx = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.fy + frontAxis.rightSteeringRevolute.frame_b.fy = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.t + frontAxis.rightSteeringRevolute.frame_b.t = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.t = frontAxis.rightSteeringRevolute.t;
//   frontAxis.leftAxis.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.leftAxis.cylinder.shapeType);
//   frontAxis.leftAxis.cylinder.rxvisobj[1] = frontAxis.leftAxis.cylinder.R.T[1,1] * frontAxis.leftAxis.cylinder.e_x[1] + frontAxis.leftAxis.cylinder.R.T[2,1] * frontAxis.leftAxis.cylinder.e_x[2] + frontAxis.leftAxis.cylinder.R.T[3,1] * frontAxis.leftAxis.cylinder.e_x[3];
//   frontAxis.leftAxis.cylinder.rxvisobj[2] = frontAxis.leftAxis.cylinder.R.T[1,2] * frontAxis.leftAxis.cylinder.e_x[1] + frontAxis.leftAxis.cylinder.R.T[2,2] * frontAxis.leftAxis.cylinder.e_x[2] + frontAxis.leftAxis.cylinder.R.T[3,2] * frontAxis.leftAxis.cylinder.e_x[3];
//   frontAxis.leftAxis.cylinder.rxvisobj[3] = frontAxis.leftAxis.cylinder.R.T[1,3] * frontAxis.leftAxis.cylinder.e_x[1] + frontAxis.leftAxis.cylinder.R.T[2,3] * frontAxis.leftAxis.cylinder.e_x[2] + frontAxis.leftAxis.cylinder.R.T[3,3] * frontAxis.leftAxis.cylinder.e_x[3];
//   frontAxis.leftAxis.cylinder.ryvisobj[1] = frontAxis.leftAxis.cylinder.R.T[1,1] * frontAxis.leftAxis.cylinder.e_y[1] + frontAxis.leftAxis.cylinder.R.T[2,1] * frontAxis.leftAxis.cylinder.e_y[2] + frontAxis.leftAxis.cylinder.R.T[3,1] * frontAxis.leftAxis.cylinder.e_y[3];
//   frontAxis.leftAxis.cylinder.ryvisobj[2] = frontAxis.leftAxis.cylinder.R.T[1,2] * frontAxis.leftAxis.cylinder.e_y[1] + frontAxis.leftAxis.cylinder.R.T[2,2] * frontAxis.leftAxis.cylinder.e_y[2] + frontAxis.leftAxis.cylinder.R.T[3,2] * frontAxis.leftAxis.cylinder.e_y[3];
//   frontAxis.leftAxis.cylinder.ryvisobj[3] = frontAxis.leftAxis.cylinder.R.T[1,3] * frontAxis.leftAxis.cylinder.e_y[1] + frontAxis.leftAxis.cylinder.R.T[2,3] * frontAxis.leftAxis.cylinder.e_y[2] + frontAxis.leftAxis.cylinder.R.T[3,3] * frontAxis.leftAxis.cylinder.e_y[3];
//   frontAxis.leftAxis.cylinder.rvisobj = frontAxis.leftAxis.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.leftAxis.cylinder.R.T[1,1],frontAxis.leftAxis.cylinder.R.T[1,2],frontAxis.leftAxis.cylinder.R.T[1,3]},{frontAxis.leftAxis.cylinder.R.T[2,1],frontAxis.leftAxis.cylinder.R.T[2,2],frontAxis.leftAxis.cylinder.R.T[2,3]},{frontAxis.leftAxis.cylinder.R.T[3,1],frontAxis.leftAxis.cylinder.R.T[3,2],frontAxis.leftAxis.cylinder.R.T[3,3]}},{frontAxis.leftAxis.cylinder.r_shape[1],frontAxis.leftAxis.cylinder.r_shape[2],frontAxis.leftAxis.cylinder.r_shape[3]});
//   frontAxis.leftAxis.cylinder.size[1] = frontAxis.leftAxis.cylinder.length;
//   frontAxis.leftAxis.cylinder.size[2] = frontAxis.leftAxis.cylinder.width;
//   frontAxis.leftAxis.cylinder.size[3] = frontAxis.leftAxis.cylinder.height;
//   frontAxis.leftAxis.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.leftAxis.cylinder.color[1] / 255.0,frontAxis.leftAxis.cylinder.color[2] / 255.0,frontAxis.leftAxis.cylinder.color[3] / 255.0,frontAxis.leftAxis.cylinder.specularCoefficient);
//   frontAxis.leftAxis.cylinder.Extra = frontAxis.leftAxis.cylinder.extra;
//   frontAxis.leftAxis.R[1,1] = cos(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.R[1,2] = sin(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.R[2,1] = -sin(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.R[2,2] = cos(frontAxis.leftAxis.frame_a.phi);
//   frontAxis.leftAxis.r0[1] = frontAxis.leftAxis.R[1,1] * frontAxis.leftAxis.r[1] + frontAxis.leftAxis.R[1,2] * frontAxis.leftAxis.r[2];
//   frontAxis.leftAxis.r0[2] = frontAxis.leftAxis.R[2,1] * frontAxis.leftAxis.r[1] + frontAxis.leftAxis.R[2,2] * frontAxis.leftAxis.r[2];
//   frontAxis.leftAxis.frame_a.x + frontAxis.leftAxis.r0[1] = frontAxis.leftAxis.frame_b.x;
//   frontAxis.leftAxis.frame_a.y + frontAxis.leftAxis.r0[2] = frontAxis.leftAxis.frame_b.y;
//   frontAxis.leftAxis.frame_a.phi = frontAxis.leftAxis.frame_b.phi;
//   frontAxis.leftAxis.frame_a.fx + frontAxis.leftAxis.frame_b.fx = 0.0;
//   frontAxis.leftAxis.frame_a.fy + frontAxis.leftAxis.frame_b.fy = 0.0;
//   frontAxis.leftAxis.frame_a.t + (frontAxis.leftAxis.frame_b.t + ((-frontAxis.leftAxis.r0[1]) * frontAxis.leftAxis.frame_b.fy + frontAxis.leftAxis.r0[2] * frontAxis.leftAxis.frame_b.fx)) = 0.0;
//   frontAxis.rightAxis.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.rightAxis.cylinder.shapeType);
//   frontAxis.rightAxis.cylinder.rxvisobj[1] = frontAxis.rightAxis.cylinder.R.T[1,1] * frontAxis.rightAxis.cylinder.e_x[1] + frontAxis.rightAxis.cylinder.R.T[2,1] * frontAxis.rightAxis.cylinder.e_x[2] + frontAxis.rightAxis.cylinder.R.T[3,1] * frontAxis.rightAxis.cylinder.e_x[3];
//   frontAxis.rightAxis.cylinder.rxvisobj[2] = frontAxis.rightAxis.cylinder.R.T[1,2] * frontAxis.rightAxis.cylinder.e_x[1] + frontAxis.rightAxis.cylinder.R.T[2,2] * frontAxis.rightAxis.cylinder.e_x[2] + frontAxis.rightAxis.cylinder.R.T[3,2] * frontAxis.rightAxis.cylinder.e_x[3];
//   frontAxis.rightAxis.cylinder.rxvisobj[3] = frontAxis.rightAxis.cylinder.R.T[1,3] * frontAxis.rightAxis.cylinder.e_x[1] + frontAxis.rightAxis.cylinder.R.T[2,3] * frontAxis.rightAxis.cylinder.e_x[2] + frontAxis.rightAxis.cylinder.R.T[3,3] * frontAxis.rightAxis.cylinder.e_x[3];
//   frontAxis.rightAxis.cylinder.ryvisobj[1] = frontAxis.rightAxis.cylinder.R.T[1,1] * frontAxis.rightAxis.cylinder.e_y[1] + frontAxis.rightAxis.cylinder.R.T[2,1] * frontAxis.rightAxis.cylinder.e_y[2] + frontAxis.rightAxis.cylinder.R.T[3,1] * frontAxis.rightAxis.cylinder.e_y[3];
//   frontAxis.rightAxis.cylinder.ryvisobj[2] = frontAxis.rightAxis.cylinder.R.T[1,2] * frontAxis.rightAxis.cylinder.e_y[1] + frontAxis.rightAxis.cylinder.R.T[2,2] * frontAxis.rightAxis.cylinder.e_y[2] + frontAxis.rightAxis.cylinder.R.T[3,2] * frontAxis.rightAxis.cylinder.e_y[3];
//   frontAxis.rightAxis.cylinder.ryvisobj[3] = frontAxis.rightAxis.cylinder.R.T[1,3] * frontAxis.rightAxis.cylinder.e_y[1] + frontAxis.rightAxis.cylinder.R.T[2,3] * frontAxis.rightAxis.cylinder.e_y[2] + frontAxis.rightAxis.cylinder.R.T[3,3] * frontAxis.rightAxis.cylinder.e_y[3];
//   frontAxis.rightAxis.cylinder.rvisobj = frontAxis.rightAxis.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.rightAxis.cylinder.R.T[1,1],frontAxis.rightAxis.cylinder.R.T[1,2],frontAxis.rightAxis.cylinder.R.T[1,3]},{frontAxis.rightAxis.cylinder.R.T[2,1],frontAxis.rightAxis.cylinder.R.T[2,2],frontAxis.rightAxis.cylinder.R.T[2,3]},{frontAxis.rightAxis.cylinder.R.T[3,1],frontAxis.rightAxis.cylinder.R.T[3,2],frontAxis.rightAxis.cylinder.R.T[3,3]}},{frontAxis.rightAxis.cylinder.r_shape[1],frontAxis.rightAxis.cylinder.r_shape[2],frontAxis.rightAxis.cylinder.r_shape[3]});
//   frontAxis.rightAxis.cylinder.size[1] = frontAxis.rightAxis.cylinder.length;
//   frontAxis.rightAxis.cylinder.size[2] = frontAxis.rightAxis.cylinder.width;
//   frontAxis.rightAxis.cylinder.size[3] = frontAxis.rightAxis.cylinder.height;
//   frontAxis.rightAxis.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.rightAxis.cylinder.color[1] / 255.0,frontAxis.rightAxis.cylinder.color[2] / 255.0,frontAxis.rightAxis.cylinder.color[3] / 255.0,frontAxis.rightAxis.cylinder.specularCoefficient);
//   frontAxis.rightAxis.cylinder.Extra = frontAxis.rightAxis.cylinder.extra;
//   frontAxis.rightAxis.R[1,1] = cos(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.R[1,2] = sin(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.R[2,1] = -sin(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.R[2,2] = cos(frontAxis.rightAxis.frame_a.phi);
//   frontAxis.rightAxis.r0[1] = frontAxis.rightAxis.R[1,1] * frontAxis.rightAxis.r[1] + frontAxis.rightAxis.R[1,2] * frontAxis.rightAxis.r[2];
//   frontAxis.rightAxis.r0[2] = frontAxis.rightAxis.R[2,1] * frontAxis.rightAxis.r[1] + frontAxis.rightAxis.R[2,2] * frontAxis.rightAxis.r[2];
//   frontAxis.rightAxis.frame_a.x + frontAxis.rightAxis.r0[1] = frontAxis.rightAxis.frame_b.x;
//   frontAxis.rightAxis.frame_a.y + frontAxis.rightAxis.r0[2] = frontAxis.rightAxis.frame_b.y;
//   frontAxis.rightAxis.frame_a.phi = frontAxis.rightAxis.frame_b.phi;
//   frontAxis.rightAxis.frame_a.fx + frontAxis.rightAxis.frame_b.fx = 0.0;
//   frontAxis.rightAxis.frame_a.fy + frontAxis.rightAxis.frame_b.fy = 0.0;
//   frontAxis.rightAxis.frame_a.t + (frontAxis.rightAxis.frame_b.t + ((-frontAxis.rightAxis.r0[1]) * frontAxis.rightAxis.frame_b.fy + frontAxis.rightAxis.r0[2] * frontAxis.rightAxis.frame_b.fx)) = 0.0;
//   frontAxis.leftTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.leftTrail.cylinder.shapeType);
//   frontAxis.leftTrail.cylinder.rxvisobj[1] = frontAxis.leftTrail.cylinder.R.T[1,1] * frontAxis.leftTrail.cylinder.e_x[1] + frontAxis.leftTrail.cylinder.R.T[2,1] * frontAxis.leftTrail.cylinder.e_x[2] + frontAxis.leftTrail.cylinder.R.T[3,1] * frontAxis.leftTrail.cylinder.e_x[3];
//   frontAxis.leftTrail.cylinder.rxvisobj[2] = frontAxis.leftTrail.cylinder.R.T[1,2] * frontAxis.leftTrail.cylinder.e_x[1] + frontAxis.leftTrail.cylinder.R.T[2,2] * frontAxis.leftTrail.cylinder.e_x[2] + frontAxis.leftTrail.cylinder.R.T[3,2] * frontAxis.leftTrail.cylinder.e_x[3];
//   frontAxis.leftTrail.cylinder.rxvisobj[3] = frontAxis.leftTrail.cylinder.R.T[1,3] * frontAxis.leftTrail.cylinder.e_x[1] + frontAxis.leftTrail.cylinder.R.T[2,3] * frontAxis.leftTrail.cylinder.e_x[2] + frontAxis.leftTrail.cylinder.R.T[3,3] * frontAxis.leftTrail.cylinder.e_x[3];
//   frontAxis.leftTrail.cylinder.ryvisobj[1] = frontAxis.leftTrail.cylinder.R.T[1,1] * frontAxis.leftTrail.cylinder.e_y[1] + frontAxis.leftTrail.cylinder.R.T[2,1] * frontAxis.leftTrail.cylinder.e_y[2] + frontAxis.leftTrail.cylinder.R.T[3,1] * frontAxis.leftTrail.cylinder.e_y[3];
//   frontAxis.leftTrail.cylinder.ryvisobj[2] = frontAxis.leftTrail.cylinder.R.T[1,2] * frontAxis.leftTrail.cylinder.e_y[1] + frontAxis.leftTrail.cylinder.R.T[2,2] * frontAxis.leftTrail.cylinder.e_y[2] + frontAxis.leftTrail.cylinder.R.T[3,2] * frontAxis.leftTrail.cylinder.e_y[3];
//   frontAxis.leftTrail.cylinder.ryvisobj[3] = frontAxis.leftTrail.cylinder.R.T[1,3] * frontAxis.leftTrail.cylinder.e_y[1] + frontAxis.leftTrail.cylinder.R.T[2,3] * frontAxis.leftTrail.cylinder.e_y[2] + frontAxis.leftTrail.cylinder.R.T[3,3] * frontAxis.leftTrail.cylinder.e_y[3];
//   frontAxis.leftTrail.cylinder.rvisobj = frontAxis.leftTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.leftTrail.cylinder.R.T[1,1],frontAxis.leftTrail.cylinder.R.T[1,2],frontAxis.leftTrail.cylinder.R.T[1,3]},{frontAxis.leftTrail.cylinder.R.T[2,1],frontAxis.leftTrail.cylinder.R.T[2,2],frontAxis.leftTrail.cylinder.R.T[2,3]},{frontAxis.leftTrail.cylinder.R.T[3,1],frontAxis.leftTrail.cylinder.R.T[3,2],frontAxis.leftTrail.cylinder.R.T[3,3]}},{frontAxis.leftTrail.cylinder.r_shape[1],frontAxis.leftTrail.cylinder.r_shape[2],frontAxis.leftTrail.cylinder.r_shape[3]});
//   frontAxis.leftTrail.cylinder.size[1] = frontAxis.leftTrail.cylinder.length;
//   frontAxis.leftTrail.cylinder.size[2] = frontAxis.leftTrail.cylinder.width;
//   frontAxis.leftTrail.cylinder.size[3] = frontAxis.leftTrail.cylinder.height;
//   frontAxis.leftTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.leftTrail.cylinder.color[1] / 255.0,frontAxis.leftTrail.cylinder.color[2] / 255.0,frontAxis.leftTrail.cylinder.color[3] / 255.0,frontAxis.leftTrail.cylinder.specularCoefficient);
//   frontAxis.leftTrail.cylinder.Extra = frontAxis.leftTrail.cylinder.extra;
//   frontAxis.leftTrail.R[1,1] = cos(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.R[1,2] = sin(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.R[2,1] = -sin(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.R[2,2] = cos(frontAxis.leftTrail.frame_a.phi);
//   frontAxis.leftTrail.r0[1] = frontAxis.leftTrail.R[1,1] * frontAxis.leftTrail.r[1] + frontAxis.leftTrail.R[1,2] * frontAxis.leftTrail.r[2];
//   frontAxis.leftTrail.r0[2] = frontAxis.leftTrail.R[2,1] * frontAxis.leftTrail.r[1] + frontAxis.leftTrail.R[2,2] * frontAxis.leftTrail.r[2];
//   frontAxis.leftTrail.frame_a.x + frontAxis.leftTrail.r0[1] = frontAxis.leftTrail.frame_b.x;
//   frontAxis.leftTrail.frame_a.y + frontAxis.leftTrail.r0[2] = frontAxis.leftTrail.frame_b.y;
//   frontAxis.leftTrail.frame_a.phi = frontAxis.leftTrail.frame_b.phi;
//   frontAxis.leftTrail.frame_a.fx + frontAxis.leftTrail.frame_b.fx = 0.0;
//   frontAxis.leftTrail.frame_a.fy + frontAxis.leftTrail.frame_b.fy = 0.0;
//   frontAxis.leftTrail.frame_a.t + (frontAxis.leftTrail.frame_b.t + ((-frontAxis.leftTrail.r0[1]) * frontAxis.leftTrail.frame_b.fy + frontAxis.leftTrail.r0[2] * frontAxis.leftTrail.frame_b.fx)) = 0.0;
//   frontAxis.rigthtTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.rigthtTrail.cylinder.shapeType);
//   frontAxis.rigthtTrail.cylinder.rxvisobj[1] = frontAxis.rigthtTrail.cylinder.R.T[1,1] * frontAxis.rigthtTrail.cylinder.e_x[1] + frontAxis.rigthtTrail.cylinder.R.T[2,1] * frontAxis.rigthtTrail.cylinder.e_x[2] + frontAxis.rigthtTrail.cylinder.R.T[3,1] * frontAxis.rigthtTrail.cylinder.e_x[3];
//   frontAxis.rigthtTrail.cylinder.rxvisobj[2] = frontAxis.rigthtTrail.cylinder.R.T[1,2] * frontAxis.rigthtTrail.cylinder.e_x[1] + frontAxis.rigthtTrail.cylinder.R.T[2,2] * frontAxis.rigthtTrail.cylinder.e_x[2] + frontAxis.rigthtTrail.cylinder.R.T[3,2] * frontAxis.rigthtTrail.cylinder.e_x[3];
//   frontAxis.rigthtTrail.cylinder.rxvisobj[3] = frontAxis.rigthtTrail.cylinder.R.T[1,3] * frontAxis.rigthtTrail.cylinder.e_x[1] + frontAxis.rigthtTrail.cylinder.R.T[2,3] * frontAxis.rigthtTrail.cylinder.e_x[2] + frontAxis.rigthtTrail.cylinder.R.T[3,3] * frontAxis.rigthtTrail.cylinder.e_x[3];
//   frontAxis.rigthtTrail.cylinder.ryvisobj[1] = frontAxis.rigthtTrail.cylinder.R.T[1,1] * frontAxis.rigthtTrail.cylinder.e_y[1] + frontAxis.rigthtTrail.cylinder.R.T[2,1] * frontAxis.rigthtTrail.cylinder.e_y[2] + frontAxis.rigthtTrail.cylinder.R.T[3,1] * frontAxis.rigthtTrail.cylinder.e_y[3];
//   frontAxis.rigthtTrail.cylinder.ryvisobj[2] = frontAxis.rigthtTrail.cylinder.R.T[1,2] * frontAxis.rigthtTrail.cylinder.e_y[1] + frontAxis.rigthtTrail.cylinder.R.T[2,2] * frontAxis.rigthtTrail.cylinder.e_y[2] + frontAxis.rigthtTrail.cylinder.R.T[3,2] * frontAxis.rigthtTrail.cylinder.e_y[3];
//   frontAxis.rigthtTrail.cylinder.ryvisobj[3] = frontAxis.rigthtTrail.cylinder.R.T[1,3] * frontAxis.rigthtTrail.cylinder.e_y[1] + frontAxis.rigthtTrail.cylinder.R.T[2,3] * frontAxis.rigthtTrail.cylinder.e_y[2] + frontAxis.rigthtTrail.cylinder.R.T[3,3] * frontAxis.rigthtTrail.cylinder.e_y[3];
//   frontAxis.rigthtTrail.cylinder.rvisobj = frontAxis.rigthtTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.rigthtTrail.cylinder.R.T[1,1],frontAxis.rigthtTrail.cylinder.R.T[1,2],frontAxis.rigthtTrail.cylinder.R.T[1,3]},{frontAxis.rigthtTrail.cylinder.R.T[2,1],frontAxis.rigthtTrail.cylinder.R.T[2,2],frontAxis.rigthtTrail.cylinder.R.T[2,3]},{frontAxis.rigthtTrail.cylinder.R.T[3,1],frontAxis.rigthtTrail.cylinder.R.T[3,2],frontAxis.rigthtTrail.cylinder.R.T[3,3]}},{frontAxis.rigthtTrail.cylinder.r_shape[1],frontAxis.rigthtTrail.cylinder.r_shape[2],frontAxis.rigthtTrail.cylinder.r_shape[3]});
//   frontAxis.rigthtTrail.cylinder.size[1] = frontAxis.rigthtTrail.cylinder.length;
//   frontAxis.rigthtTrail.cylinder.size[2] = frontAxis.rigthtTrail.cylinder.width;
//   frontAxis.rigthtTrail.cylinder.size[3] = frontAxis.rigthtTrail.cylinder.height;
//   frontAxis.rigthtTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.rigthtTrail.cylinder.color[1] / 255.0,frontAxis.rigthtTrail.cylinder.color[2] / 255.0,frontAxis.rigthtTrail.cylinder.color[3] / 255.0,frontAxis.rigthtTrail.cylinder.specularCoefficient);
//   frontAxis.rigthtTrail.cylinder.Extra = frontAxis.rigthtTrail.cylinder.extra;
//   frontAxis.rigthtTrail.R[1,1] = cos(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.R[1,2] = sin(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.R[2,1] = -sin(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.R[2,2] = cos(frontAxis.rigthtTrail.frame_a.phi);
//   frontAxis.rigthtTrail.r0[1] = frontAxis.rigthtTrail.R[1,1] * frontAxis.rigthtTrail.r[1] + frontAxis.rigthtTrail.R[1,2] * frontAxis.rigthtTrail.r[2];
//   frontAxis.rigthtTrail.r0[2] = frontAxis.rigthtTrail.R[2,1] * frontAxis.rigthtTrail.r[1] + frontAxis.rigthtTrail.R[2,2] * frontAxis.rigthtTrail.r[2];
//   frontAxis.rigthtTrail.frame_a.x + frontAxis.rigthtTrail.r0[1] = frontAxis.rigthtTrail.frame_b.x;
//   frontAxis.rigthtTrail.frame_a.y + frontAxis.rigthtTrail.r0[2] = frontAxis.rigthtTrail.frame_b.y;
//   frontAxis.rigthtTrail.frame_a.phi = frontAxis.rigthtTrail.frame_b.phi;
//   frontAxis.rigthtTrail.frame_a.fx + frontAxis.rigthtTrail.frame_b.fx = 0.0;
//   frontAxis.rigthtTrail.frame_a.fy + frontAxis.rigthtTrail.frame_b.fy = 0.0;
//   frontAxis.rigthtTrail.frame_a.t + (frontAxis.rigthtTrail.frame_b.t + ((-frontAxis.rigthtTrail.r0[1]) * frontAxis.rigthtTrail.frame_b.fy + frontAxis.rigthtTrail.r0[2] * frontAxis.rigthtTrail.frame_b.fx)) = 0.0;
//   frontAxis.leftInertia.phi = frontAxis.leftInertia.flange_a.phi;
//   frontAxis.leftInertia.phi = frontAxis.leftInertia.flange_b.phi;
//   frontAxis.leftInertia.w = der(frontAxis.leftInertia.phi);
//   frontAxis.leftInertia.a = der(frontAxis.leftInertia.w);
//   frontAxis.leftInertia.J * frontAxis.leftInertia.a = frontAxis.leftInertia.flange_a.tau + frontAxis.leftInertia.flange_b.tau;
//   frontAxis.rightInertia.phi = frontAxis.rightInertia.flange_a.phi;
//   frontAxis.rightInertia.phi = frontAxis.rightInertia.flange_b.phi;
//   frontAxis.rightInertia.w = der(frontAxis.rightInertia.phi);
//   frontAxis.rightInertia.a = der(frontAxis.rightInertia.w);
//   frontAxis.rightInertia.J * frontAxis.rightInertia.a = frontAxis.rightInertia.flange_a.tau + frontAxis.rightInertia.flange_b.tau;
//   frontAxis.SteeringInertia.phi = frontAxis.SteeringInertia.flange_a.phi;
//   frontAxis.SteeringInertia.phi = frontAxis.SteeringInertia.flange_b.phi;
//   frontAxis.SteeringInertia.w = der(frontAxis.SteeringInertia.phi);
//   frontAxis.SteeringInertia.a = der(frontAxis.SteeringInertia.w);
//   frontAxis.SteeringInertia.J * frontAxis.SteeringInertia.a = frontAxis.SteeringInertia.flange_a.tau + frontAxis.SteeringInertia.flange_b.tau;
//   frontAxis.WheelJointLeft.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointLeft.cylinder.shapeType);
//   frontAxis.WheelJointLeft.cylinder.rxvisobj[1] = frontAxis.WheelJointLeft.cylinder.R.T[1,1] * frontAxis.WheelJointLeft.cylinder.e_x[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,1] * frontAxis.WheelJointLeft.cylinder.e_x[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,1] * frontAxis.WheelJointLeft.cylinder.e_x[3];
//   frontAxis.WheelJointLeft.cylinder.rxvisobj[2] = frontAxis.WheelJointLeft.cylinder.R.T[1,2] * frontAxis.WheelJointLeft.cylinder.e_x[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,2] * frontAxis.WheelJointLeft.cylinder.e_x[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,2] * frontAxis.WheelJointLeft.cylinder.e_x[3];
//   frontAxis.WheelJointLeft.cylinder.rxvisobj[3] = frontAxis.WheelJointLeft.cylinder.R.T[1,3] * frontAxis.WheelJointLeft.cylinder.e_x[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,3] * frontAxis.WheelJointLeft.cylinder.e_x[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,3] * frontAxis.WheelJointLeft.cylinder.e_x[3];
//   frontAxis.WheelJointLeft.cylinder.ryvisobj[1] = frontAxis.WheelJointLeft.cylinder.R.T[1,1] * frontAxis.WheelJointLeft.cylinder.e_y[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,1] * frontAxis.WheelJointLeft.cylinder.e_y[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,1] * frontAxis.WheelJointLeft.cylinder.e_y[3];
//   frontAxis.WheelJointLeft.cylinder.ryvisobj[2] = frontAxis.WheelJointLeft.cylinder.R.T[1,2] * frontAxis.WheelJointLeft.cylinder.e_y[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,2] * frontAxis.WheelJointLeft.cylinder.e_y[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,2] * frontAxis.WheelJointLeft.cylinder.e_y[3];
//   frontAxis.WheelJointLeft.cylinder.ryvisobj[3] = frontAxis.WheelJointLeft.cylinder.R.T[1,3] * frontAxis.WheelJointLeft.cylinder.e_y[1] + frontAxis.WheelJointLeft.cylinder.R.T[2,3] * frontAxis.WheelJointLeft.cylinder.e_y[2] + frontAxis.WheelJointLeft.cylinder.R.T[3,3] * frontAxis.WheelJointLeft.cylinder.e_y[3];
//   frontAxis.WheelJointLeft.cylinder.rvisobj = frontAxis.WheelJointLeft.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointLeft.cylinder.R.T[1,1],frontAxis.WheelJointLeft.cylinder.R.T[1,2],frontAxis.WheelJointLeft.cylinder.R.T[1,3]},{frontAxis.WheelJointLeft.cylinder.R.T[2,1],frontAxis.WheelJointLeft.cylinder.R.T[2,2],frontAxis.WheelJointLeft.cylinder.R.T[2,3]},{frontAxis.WheelJointLeft.cylinder.R.T[3,1],frontAxis.WheelJointLeft.cylinder.R.T[3,2],frontAxis.WheelJointLeft.cylinder.R.T[3,3]}},{frontAxis.WheelJointLeft.cylinder.r_shape[1],frontAxis.WheelJointLeft.cylinder.r_shape[2],frontAxis.WheelJointLeft.cylinder.r_shape[3]});
//   frontAxis.WheelJointLeft.cylinder.size[1] = frontAxis.WheelJointLeft.cylinder.length;
//   frontAxis.WheelJointLeft.cylinder.size[2] = frontAxis.WheelJointLeft.cylinder.width;
//   frontAxis.WheelJointLeft.cylinder.size[3] = frontAxis.WheelJointLeft.cylinder.height;
//   frontAxis.WheelJointLeft.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointLeft.cylinder.color[1] / 255.0,frontAxis.WheelJointLeft.cylinder.color[2] / 255.0,frontAxis.WheelJointLeft.cylinder.color[3] / 255.0,frontAxis.WheelJointLeft.cylinder.specularCoefficient);
//   frontAxis.WheelJointLeft.cylinder.Extra = frontAxis.WheelJointLeft.cylinder.extra;
//   frontAxis.WheelJointLeft.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointLeft.e0[2],frontAxis.WheelJointLeft.e0[1],0.0},frontAxis.WheelJointLeft.flange_a.phi,0.0);
//   frontAxis.WheelJointLeft.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointLeft.rim1.shapeType);
//   frontAxis.WheelJointLeft.rim1.rxvisobj[1] = frontAxis.WheelJointLeft.rim1.R.T[1,1] * frontAxis.WheelJointLeft.rim1.e_x[1] + frontAxis.WheelJointLeft.rim1.R.T[2,1] * frontAxis.WheelJointLeft.rim1.e_x[2] + frontAxis.WheelJointLeft.rim1.R.T[3,1] * frontAxis.WheelJointLeft.rim1.e_x[3];
//   frontAxis.WheelJointLeft.rim1.rxvisobj[2] = frontAxis.WheelJointLeft.rim1.R.T[1,2] * frontAxis.WheelJointLeft.rim1.e_x[1] + frontAxis.WheelJointLeft.rim1.R.T[2,2] * frontAxis.WheelJointLeft.rim1.e_x[2] + frontAxis.WheelJointLeft.rim1.R.T[3,2] * frontAxis.WheelJointLeft.rim1.e_x[3];
//   frontAxis.WheelJointLeft.rim1.rxvisobj[3] = frontAxis.WheelJointLeft.rim1.R.T[1,3] * frontAxis.WheelJointLeft.rim1.e_x[1] + frontAxis.WheelJointLeft.rim1.R.T[2,3] * frontAxis.WheelJointLeft.rim1.e_x[2] + frontAxis.WheelJointLeft.rim1.R.T[3,3] * frontAxis.WheelJointLeft.rim1.e_x[3];
//   frontAxis.WheelJointLeft.rim1.ryvisobj[1] = frontAxis.WheelJointLeft.rim1.R.T[1,1] * frontAxis.WheelJointLeft.rim1.e_y[1] + frontAxis.WheelJointLeft.rim1.R.T[2,1] * frontAxis.WheelJointLeft.rim1.e_y[2] + frontAxis.WheelJointLeft.rim1.R.T[3,1] * frontAxis.WheelJointLeft.rim1.e_y[3];
//   frontAxis.WheelJointLeft.rim1.ryvisobj[2] = frontAxis.WheelJointLeft.rim1.R.T[1,2] * frontAxis.WheelJointLeft.rim1.e_y[1] + frontAxis.WheelJointLeft.rim1.R.T[2,2] * frontAxis.WheelJointLeft.rim1.e_y[2] + frontAxis.WheelJointLeft.rim1.R.T[3,2] * frontAxis.WheelJointLeft.rim1.e_y[3];
//   frontAxis.WheelJointLeft.rim1.ryvisobj[3] = frontAxis.WheelJointLeft.rim1.R.T[1,3] * frontAxis.WheelJointLeft.rim1.e_y[1] + frontAxis.WheelJointLeft.rim1.R.T[2,3] * frontAxis.WheelJointLeft.rim1.e_y[2] + frontAxis.WheelJointLeft.rim1.R.T[3,3] * frontAxis.WheelJointLeft.rim1.e_y[3];
//   frontAxis.WheelJointLeft.rim1.rvisobj = frontAxis.WheelJointLeft.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointLeft.rim1.R.T[1,1],frontAxis.WheelJointLeft.rim1.R.T[1,2],frontAxis.WheelJointLeft.rim1.R.T[1,3]},{frontAxis.WheelJointLeft.rim1.R.T[2,1],frontAxis.WheelJointLeft.rim1.R.T[2,2],frontAxis.WheelJointLeft.rim1.R.T[2,3]},{frontAxis.WheelJointLeft.rim1.R.T[3,1],frontAxis.WheelJointLeft.rim1.R.T[3,2],frontAxis.WheelJointLeft.rim1.R.T[3,3]}},{frontAxis.WheelJointLeft.rim1.r_shape[1],frontAxis.WheelJointLeft.rim1.r_shape[2],frontAxis.WheelJointLeft.rim1.r_shape[3]});
//   frontAxis.WheelJointLeft.rim1.size[1] = frontAxis.WheelJointLeft.rim1.length;
//   frontAxis.WheelJointLeft.rim1.size[2] = frontAxis.WheelJointLeft.rim1.width;
//   frontAxis.WheelJointLeft.rim1.size[3] = frontAxis.WheelJointLeft.rim1.height;
//   frontAxis.WheelJointLeft.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointLeft.rim1.color[1] / 255.0,frontAxis.WheelJointLeft.rim1.color[2] / 255.0,frontAxis.WheelJointLeft.rim1.color[3] / 255.0,frontAxis.WheelJointLeft.rim1.specularCoefficient);
//   frontAxis.WheelJointLeft.rim1.Extra = frontAxis.WheelJointLeft.rim1.extra;
//   frontAxis.WheelJointLeft.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointLeft.e0[2],frontAxis.WheelJointLeft.e0[1],0.0},1.5707963267949 + frontAxis.WheelJointLeft.flange_a.phi,0.0);
//   frontAxis.WheelJointLeft.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointLeft.rim2.shapeType);
//   frontAxis.WheelJointLeft.rim2.rxvisobj[1] = frontAxis.WheelJointLeft.rim2.R.T[1,1] * frontAxis.WheelJointLeft.rim2.e_x[1] + frontAxis.WheelJointLeft.rim2.R.T[2,1] * frontAxis.WheelJointLeft.rim2.e_x[2] + frontAxis.WheelJointLeft.rim2.R.T[3,1] * frontAxis.WheelJointLeft.rim2.e_x[3];
//   frontAxis.WheelJointLeft.rim2.rxvisobj[2] = frontAxis.WheelJointLeft.rim2.R.T[1,2] * frontAxis.WheelJointLeft.rim2.e_x[1] + frontAxis.WheelJointLeft.rim2.R.T[2,2] * frontAxis.WheelJointLeft.rim2.e_x[2] + frontAxis.WheelJointLeft.rim2.R.T[3,2] * frontAxis.WheelJointLeft.rim2.e_x[3];
//   frontAxis.WheelJointLeft.rim2.rxvisobj[3] = frontAxis.WheelJointLeft.rim2.R.T[1,3] * frontAxis.WheelJointLeft.rim2.e_x[1] + frontAxis.WheelJointLeft.rim2.R.T[2,3] * frontAxis.WheelJointLeft.rim2.e_x[2] + frontAxis.WheelJointLeft.rim2.R.T[3,3] * frontAxis.WheelJointLeft.rim2.e_x[3];
//   frontAxis.WheelJointLeft.rim2.ryvisobj[1] = frontAxis.WheelJointLeft.rim2.R.T[1,1] * frontAxis.WheelJointLeft.rim2.e_y[1] + frontAxis.WheelJointLeft.rim2.R.T[2,1] * frontAxis.WheelJointLeft.rim2.e_y[2] + frontAxis.WheelJointLeft.rim2.R.T[3,1] * frontAxis.WheelJointLeft.rim2.e_y[3];
//   frontAxis.WheelJointLeft.rim2.ryvisobj[2] = frontAxis.WheelJointLeft.rim2.R.T[1,2] * frontAxis.WheelJointLeft.rim2.e_y[1] + frontAxis.WheelJointLeft.rim2.R.T[2,2] * frontAxis.WheelJointLeft.rim2.e_y[2] + frontAxis.WheelJointLeft.rim2.R.T[3,2] * frontAxis.WheelJointLeft.rim2.e_y[3];
//   frontAxis.WheelJointLeft.rim2.ryvisobj[3] = frontAxis.WheelJointLeft.rim2.R.T[1,3] * frontAxis.WheelJointLeft.rim2.e_y[1] + frontAxis.WheelJointLeft.rim2.R.T[2,3] * frontAxis.WheelJointLeft.rim2.e_y[2] + frontAxis.WheelJointLeft.rim2.R.T[3,3] * frontAxis.WheelJointLeft.rim2.e_y[3];
//   frontAxis.WheelJointLeft.rim2.rvisobj = frontAxis.WheelJointLeft.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointLeft.rim2.R.T[1,1],frontAxis.WheelJointLeft.rim2.R.T[1,2],frontAxis.WheelJointLeft.rim2.R.T[1,3]},{frontAxis.WheelJointLeft.rim2.R.T[2,1],frontAxis.WheelJointLeft.rim2.R.T[2,2],frontAxis.WheelJointLeft.rim2.R.T[2,3]},{frontAxis.WheelJointLeft.rim2.R.T[3,1],frontAxis.WheelJointLeft.rim2.R.T[3,2],frontAxis.WheelJointLeft.rim2.R.T[3,3]}},{frontAxis.WheelJointLeft.rim2.r_shape[1],frontAxis.WheelJointLeft.rim2.r_shape[2],frontAxis.WheelJointLeft.rim2.r_shape[3]});
//   frontAxis.WheelJointLeft.rim2.size[1] = frontAxis.WheelJointLeft.rim2.length;
//   frontAxis.WheelJointLeft.rim2.size[2] = frontAxis.WheelJointLeft.rim2.width;
//   frontAxis.WheelJointLeft.rim2.size[3] = frontAxis.WheelJointLeft.rim2.height;
//   frontAxis.WheelJointLeft.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointLeft.rim2.color[1] / 255.0,frontAxis.WheelJointLeft.rim2.color[2] / 255.0,frontAxis.WheelJointLeft.rim2.color[3] / 255.0,frontAxis.WheelJointLeft.rim2.specularCoefficient);
//   frontAxis.WheelJointLeft.rim2.Extra = frontAxis.WheelJointLeft.rim2.extra;
//   frontAxis.WheelJointLeft.R[1,1] = cos(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.R[1,2] = sin(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.R[2,1] = -sin(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.R[2,2] = cos(frontAxis.WheelJointLeft.frame_a.phi);
//   frontAxis.WheelJointLeft.e0[1] = frontAxis.WheelJointLeft.R[1,1] * frontAxis.WheelJointLeft.e[1] + frontAxis.WheelJointLeft.R[1,2] * frontAxis.WheelJointLeft.e[2];
//   frontAxis.WheelJointLeft.e0[2] = frontAxis.WheelJointLeft.R[2,1] * frontAxis.WheelJointLeft.e[1] + frontAxis.WheelJointLeft.R[2,2] * frontAxis.WheelJointLeft.e[2];
//   frontAxis.WheelJointLeft.v[1] = der(frontAxis.WheelJointLeft.frame_a.x);
//   frontAxis.WheelJointLeft.v[2] = der(frontAxis.WheelJointLeft.frame_a.y);
//   frontAxis.WheelJointLeft.w_roll = der(frontAxis.WheelJointLeft.flange_a.phi);
//   frontAxis.WheelJointLeft.v_long = frontAxis.WheelJointLeft.v[1] * frontAxis.WheelJointLeft.e0[1] + frontAxis.WheelJointLeft.v[2] * frontAxis.WheelJointLeft.e0[2];
//   frontAxis.WheelJointLeft.v_lat = (-frontAxis.WheelJointLeft.v[1]) * frontAxis.WheelJointLeft.e0[2] + frontAxis.WheelJointLeft.v[2] * frontAxis.WheelJointLeft.e0[1];
//   frontAxis.WheelJointLeft.v_slip_lat = frontAxis.WheelJointLeft.v_lat;
//   frontAxis.WheelJointLeft.v_slip_long = frontAxis.WheelJointLeft.v_long - frontAxis.WheelJointLeft.radius * frontAxis.WheelJointLeft.w_roll;
//   frontAxis.WheelJointLeft.v_slip = 0.0001 + sqrt(frontAxis.WheelJointLeft.v_slip_long ^ 2.0 + frontAxis.WheelJointLeft.v_slip_lat ^ 2.0);
//   (-frontAxis.WheelJointLeft.f_long) * frontAxis.WheelJointLeft.radius = frontAxis.WheelJointLeft.flange_a.tau;
//   frontAxis.WheelJointLeft.frame_a.t = 0.0;
//   frontAxis.WheelJointLeft.f = frontAxis.WheelJointLeft.N * PlanarMechanicsV4.Utilities.TripleS_Func(frontAxis.WheelJointLeft.vAdhesion,frontAxis.WheelJointLeft.vSlide,frontAxis.WheelJointLeft.mu_A,frontAxis.WheelJointLeft.mu_S,frontAxis.WheelJointLeft.v_slip);
//   frontAxis.WheelJointLeft.f_long = (frontAxis.WheelJointLeft.f * frontAxis.WheelJointLeft.v_slip_long) / frontAxis.WheelJointLeft.v_slip;
//   frontAxis.WheelJointLeft.f_lat = (frontAxis.WheelJointLeft.f * frontAxis.WheelJointLeft.v_slip_lat) / frontAxis.WheelJointLeft.v_slip;
//   frontAxis.WheelJointLeft.f_long = frontAxis.WheelJointLeft.frame_a.fx * frontAxis.WheelJointLeft.e0[1] + frontAxis.WheelJointLeft.frame_a.fy * frontAxis.WheelJointLeft.e0[2];
//   frontAxis.WheelJointLeft.f_lat = frontAxis.WheelJointLeft.frame_a.fy * frontAxis.WheelJointLeft.e0[1] + (-frontAxis.WheelJointLeft.frame_a.fx) * frontAxis.WheelJointLeft.e0[2];
//   frontAxis.WheelJointRight.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointRight.cylinder.shapeType);
//   frontAxis.WheelJointRight.cylinder.rxvisobj[1] = frontAxis.WheelJointRight.cylinder.R.T[1,1] * frontAxis.WheelJointRight.cylinder.e_x[1] + frontAxis.WheelJointRight.cylinder.R.T[2,1] * frontAxis.WheelJointRight.cylinder.e_x[2] + frontAxis.WheelJointRight.cylinder.R.T[3,1] * frontAxis.WheelJointRight.cylinder.e_x[3];
//   frontAxis.WheelJointRight.cylinder.rxvisobj[2] = frontAxis.WheelJointRight.cylinder.R.T[1,2] * frontAxis.WheelJointRight.cylinder.e_x[1] + frontAxis.WheelJointRight.cylinder.R.T[2,2] * frontAxis.WheelJointRight.cylinder.e_x[2] + frontAxis.WheelJointRight.cylinder.R.T[3,2] * frontAxis.WheelJointRight.cylinder.e_x[3];
//   frontAxis.WheelJointRight.cylinder.rxvisobj[3] = frontAxis.WheelJointRight.cylinder.R.T[1,3] * frontAxis.WheelJointRight.cylinder.e_x[1] + frontAxis.WheelJointRight.cylinder.R.T[2,3] * frontAxis.WheelJointRight.cylinder.e_x[2] + frontAxis.WheelJointRight.cylinder.R.T[3,3] * frontAxis.WheelJointRight.cylinder.e_x[3];
//   frontAxis.WheelJointRight.cylinder.ryvisobj[1] = frontAxis.WheelJointRight.cylinder.R.T[1,1] * frontAxis.WheelJointRight.cylinder.e_y[1] + frontAxis.WheelJointRight.cylinder.R.T[2,1] * frontAxis.WheelJointRight.cylinder.e_y[2] + frontAxis.WheelJointRight.cylinder.R.T[3,1] * frontAxis.WheelJointRight.cylinder.e_y[3];
//   frontAxis.WheelJointRight.cylinder.ryvisobj[2] = frontAxis.WheelJointRight.cylinder.R.T[1,2] * frontAxis.WheelJointRight.cylinder.e_y[1] + frontAxis.WheelJointRight.cylinder.R.T[2,2] * frontAxis.WheelJointRight.cylinder.e_y[2] + frontAxis.WheelJointRight.cylinder.R.T[3,2] * frontAxis.WheelJointRight.cylinder.e_y[3];
//   frontAxis.WheelJointRight.cylinder.ryvisobj[3] = frontAxis.WheelJointRight.cylinder.R.T[1,3] * frontAxis.WheelJointRight.cylinder.e_y[1] + frontAxis.WheelJointRight.cylinder.R.T[2,3] * frontAxis.WheelJointRight.cylinder.e_y[2] + frontAxis.WheelJointRight.cylinder.R.T[3,3] * frontAxis.WheelJointRight.cylinder.e_y[3];
//   frontAxis.WheelJointRight.cylinder.rvisobj = frontAxis.WheelJointRight.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointRight.cylinder.R.T[1,1],frontAxis.WheelJointRight.cylinder.R.T[1,2],frontAxis.WheelJointRight.cylinder.R.T[1,3]},{frontAxis.WheelJointRight.cylinder.R.T[2,1],frontAxis.WheelJointRight.cylinder.R.T[2,2],frontAxis.WheelJointRight.cylinder.R.T[2,3]},{frontAxis.WheelJointRight.cylinder.R.T[3,1],frontAxis.WheelJointRight.cylinder.R.T[3,2],frontAxis.WheelJointRight.cylinder.R.T[3,3]}},{frontAxis.WheelJointRight.cylinder.r_shape[1],frontAxis.WheelJointRight.cylinder.r_shape[2],frontAxis.WheelJointRight.cylinder.r_shape[3]});
//   frontAxis.WheelJointRight.cylinder.size[1] = frontAxis.WheelJointRight.cylinder.length;
//   frontAxis.WheelJointRight.cylinder.size[2] = frontAxis.WheelJointRight.cylinder.width;
//   frontAxis.WheelJointRight.cylinder.size[3] = frontAxis.WheelJointRight.cylinder.height;
//   frontAxis.WheelJointRight.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointRight.cylinder.color[1] / 255.0,frontAxis.WheelJointRight.cylinder.color[2] / 255.0,frontAxis.WheelJointRight.cylinder.color[3] / 255.0,frontAxis.WheelJointRight.cylinder.specularCoefficient);
//   frontAxis.WheelJointRight.cylinder.Extra = frontAxis.WheelJointRight.cylinder.extra;
//   frontAxis.WheelJointRight.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointRight.e0[2],frontAxis.WheelJointRight.e0[1],0.0},frontAxis.WheelJointRight.flange_a.phi,0.0);
//   frontAxis.WheelJointRight.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointRight.rim1.shapeType);
//   frontAxis.WheelJointRight.rim1.rxvisobj[1] = frontAxis.WheelJointRight.rim1.R.T[1,1] * frontAxis.WheelJointRight.rim1.e_x[1] + frontAxis.WheelJointRight.rim1.R.T[2,1] * frontAxis.WheelJointRight.rim1.e_x[2] + frontAxis.WheelJointRight.rim1.R.T[3,1] * frontAxis.WheelJointRight.rim1.e_x[3];
//   frontAxis.WheelJointRight.rim1.rxvisobj[2] = frontAxis.WheelJointRight.rim1.R.T[1,2] * frontAxis.WheelJointRight.rim1.e_x[1] + frontAxis.WheelJointRight.rim1.R.T[2,2] * frontAxis.WheelJointRight.rim1.e_x[2] + frontAxis.WheelJointRight.rim1.R.T[3,2] * frontAxis.WheelJointRight.rim1.e_x[3];
//   frontAxis.WheelJointRight.rim1.rxvisobj[3] = frontAxis.WheelJointRight.rim1.R.T[1,3] * frontAxis.WheelJointRight.rim1.e_x[1] + frontAxis.WheelJointRight.rim1.R.T[2,3] * frontAxis.WheelJointRight.rim1.e_x[2] + frontAxis.WheelJointRight.rim1.R.T[3,3] * frontAxis.WheelJointRight.rim1.e_x[3];
//   frontAxis.WheelJointRight.rim1.ryvisobj[1] = frontAxis.WheelJointRight.rim1.R.T[1,1] * frontAxis.WheelJointRight.rim1.e_y[1] + frontAxis.WheelJointRight.rim1.R.T[2,1] * frontAxis.WheelJointRight.rim1.e_y[2] + frontAxis.WheelJointRight.rim1.R.T[3,1] * frontAxis.WheelJointRight.rim1.e_y[3];
//   frontAxis.WheelJointRight.rim1.ryvisobj[2] = frontAxis.WheelJointRight.rim1.R.T[1,2] * frontAxis.WheelJointRight.rim1.e_y[1] + frontAxis.WheelJointRight.rim1.R.T[2,2] * frontAxis.WheelJointRight.rim1.e_y[2] + frontAxis.WheelJointRight.rim1.R.T[3,2] * frontAxis.WheelJointRight.rim1.e_y[3];
//   frontAxis.WheelJointRight.rim1.ryvisobj[3] = frontAxis.WheelJointRight.rim1.R.T[1,3] * frontAxis.WheelJointRight.rim1.e_y[1] + frontAxis.WheelJointRight.rim1.R.T[2,3] * frontAxis.WheelJointRight.rim1.e_y[2] + frontAxis.WheelJointRight.rim1.R.T[3,3] * frontAxis.WheelJointRight.rim1.e_y[3];
//   frontAxis.WheelJointRight.rim1.rvisobj = frontAxis.WheelJointRight.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointRight.rim1.R.T[1,1],frontAxis.WheelJointRight.rim1.R.T[1,2],frontAxis.WheelJointRight.rim1.R.T[1,3]},{frontAxis.WheelJointRight.rim1.R.T[2,1],frontAxis.WheelJointRight.rim1.R.T[2,2],frontAxis.WheelJointRight.rim1.R.T[2,3]},{frontAxis.WheelJointRight.rim1.R.T[3,1],frontAxis.WheelJointRight.rim1.R.T[3,2],frontAxis.WheelJointRight.rim1.R.T[3,3]}},{frontAxis.WheelJointRight.rim1.r_shape[1],frontAxis.WheelJointRight.rim1.r_shape[2],frontAxis.WheelJointRight.rim1.r_shape[3]});
//   frontAxis.WheelJointRight.rim1.size[1] = frontAxis.WheelJointRight.rim1.length;
//   frontAxis.WheelJointRight.rim1.size[2] = frontAxis.WheelJointRight.rim1.width;
//   frontAxis.WheelJointRight.rim1.size[3] = frontAxis.WheelJointRight.rim1.height;
//   frontAxis.WheelJointRight.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointRight.rim1.color[1] / 255.0,frontAxis.WheelJointRight.rim1.color[2] / 255.0,frontAxis.WheelJointRight.rim1.color[3] / 255.0,frontAxis.WheelJointRight.rim1.specularCoefficient);
//   frontAxis.WheelJointRight.rim1.Extra = frontAxis.WheelJointRight.rim1.extra;
//   frontAxis.WheelJointRight.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-frontAxis.WheelJointRight.e0[2],frontAxis.WheelJointRight.e0[1],0.0},1.5707963267949 + frontAxis.WheelJointRight.flange_a.phi,0.0);
//   frontAxis.WheelJointRight.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(frontAxis.WheelJointRight.rim2.shapeType);
//   frontAxis.WheelJointRight.rim2.rxvisobj[1] = frontAxis.WheelJointRight.rim2.R.T[1,1] * frontAxis.WheelJointRight.rim2.e_x[1] + frontAxis.WheelJointRight.rim2.R.T[2,1] * frontAxis.WheelJointRight.rim2.e_x[2] + frontAxis.WheelJointRight.rim2.R.T[3,1] * frontAxis.WheelJointRight.rim2.e_x[3];
//   frontAxis.WheelJointRight.rim2.rxvisobj[2] = frontAxis.WheelJointRight.rim2.R.T[1,2] * frontAxis.WheelJointRight.rim2.e_x[1] + frontAxis.WheelJointRight.rim2.R.T[2,2] * frontAxis.WheelJointRight.rim2.e_x[2] + frontAxis.WheelJointRight.rim2.R.T[3,2] * frontAxis.WheelJointRight.rim2.e_x[3];
//   frontAxis.WheelJointRight.rim2.rxvisobj[3] = frontAxis.WheelJointRight.rim2.R.T[1,3] * frontAxis.WheelJointRight.rim2.e_x[1] + frontAxis.WheelJointRight.rim2.R.T[2,3] * frontAxis.WheelJointRight.rim2.e_x[2] + frontAxis.WheelJointRight.rim2.R.T[3,3] * frontAxis.WheelJointRight.rim2.e_x[3];
//   frontAxis.WheelJointRight.rim2.ryvisobj[1] = frontAxis.WheelJointRight.rim2.R.T[1,1] * frontAxis.WheelJointRight.rim2.e_y[1] + frontAxis.WheelJointRight.rim2.R.T[2,1] * frontAxis.WheelJointRight.rim2.e_y[2] + frontAxis.WheelJointRight.rim2.R.T[3,1] * frontAxis.WheelJointRight.rim2.e_y[3];
//   frontAxis.WheelJointRight.rim2.ryvisobj[2] = frontAxis.WheelJointRight.rim2.R.T[1,2] * frontAxis.WheelJointRight.rim2.e_y[1] + frontAxis.WheelJointRight.rim2.R.T[2,2] * frontAxis.WheelJointRight.rim2.e_y[2] + frontAxis.WheelJointRight.rim2.R.T[3,2] * frontAxis.WheelJointRight.rim2.e_y[3];
//   frontAxis.WheelJointRight.rim2.ryvisobj[3] = frontAxis.WheelJointRight.rim2.R.T[1,3] * frontAxis.WheelJointRight.rim2.e_y[1] + frontAxis.WheelJointRight.rim2.R.T[2,3] * frontAxis.WheelJointRight.rim2.e_y[2] + frontAxis.WheelJointRight.rim2.R.T[3,3] * frontAxis.WheelJointRight.rim2.e_y[3];
//   frontAxis.WheelJointRight.rim2.rvisobj = frontAxis.WheelJointRight.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{frontAxis.WheelJointRight.rim2.R.T[1,1],frontAxis.WheelJointRight.rim2.R.T[1,2],frontAxis.WheelJointRight.rim2.R.T[1,3]},{frontAxis.WheelJointRight.rim2.R.T[2,1],frontAxis.WheelJointRight.rim2.R.T[2,2],frontAxis.WheelJointRight.rim2.R.T[2,3]},{frontAxis.WheelJointRight.rim2.R.T[3,1],frontAxis.WheelJointRight.rim2.R.T[3,2],frontAxis.WheelJointRight.rim2.R.T[3,3]}},{frontAxis.WheelJointRight.rim2.r_shape[1],frontAxis.WheelJointRight.rim2.r_shape[2],frontAxis.WheelJointRight.rim2.r_shape[3]});
//   frontAxis.WheelJointRight.rim2.size[1] = frontAxis.WheelJointRight.rim2.length;
//   frontAxis.WheelJointRight.rim2.size[2] = frontAxis.WheelJointRight.rim2.width;
//   frontAxis.WheelJointRight.rim2.size[3] = frontAxis.WheelJointRight.rim2.height;
//   frontAxis.WheelJointRight.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(frontAxis.WheelJointRight.rim2.color[1] / 255.0,frontAxis.WheelJointRight.rim2.color[2] / 255.0,frontAxis.WheelJointRight.rim2.color[3] / 255.0,frontAxis.WheelJointRight.rim2.specularCoefficient);
//   frontAxis.WheelJointRight.rim2.Extra = frontAxis.WheelJointRight.rim2.extra;
//   frontAxis.WheelJointRight.R[1,1] = cos(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.R[1,2] = sin(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.R[2,1] = -sin(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.R[2,2] = cos(frontAxis.WheelJointRight.frame_a.phi);
//   frontAxis.WheelJointRight.e0[1] = frontAxis.WheelJointRight.R[1,1] * frontAxis.WheelJointRight.e[1] + frontAxis.WheelJointRight.R[1,2] * frontAxis.WheelJointRight.e[2];
//   frontAxis.WheelJointRight.e0[2] = frontAxis.WheelJointRight.R[2,1] * frontAxis.WheelJointRight.e[1] + frontAxis.WheelJointRight.R[2,2] * frontAxis.WheelJointRight.e[2];
//   frontAxis.WheelJointRight.v[1] = der(frontAxis.WheelJointRight.frame_a.x);
//   frontAxis.WheelJointRight.v[2] = der(frontAxis.WheelJointRight.frame_a.y);
//   frontAxis.WheelJointRight.w_roll = der(frontAxis.WheelJointRight.flange_a.phi);
//   frontAxis.WheelJointRight.v_long = frontAxis.WheelJointRight.v[1] * frontAxis.WheelJointRight.e0[1] + frontAxis.WheelJointRight.v[2] * frontAxis.WheelJointRight.e0[2];
//   frontAxis.WheelJointRight.v_lat = (-frontAxis.WheelJointRight.v[1]) * frontAxis.WheelJointRight.e0[2] + frontAxis.WheelJointRight.v[2] * frontAxis.WheelJointRight.e0[1];
//   frontAxis.WheelJointRight.v_slip_lat = frontAxis.WheelJointRight.v_lat;
//   frontAxis.WheelJointRight.v_slip_long = frontAxis.WheelJointRight.v_long - frontAxis.WheelJointRight.radius * frontAxis.WheelJointRight.w_roll;
//   frontAxis.WheelJointRight.v_slip = 0.0001 + sqrt(frontAxis.WheelJointRight.v_slip_long ^ 2.0 + frontAxis.WheelJointRight.v_slip_lat ^ 2.0);
//   (-frontAxis.WheelJointRight.f_long) * frontAxis.WheelJointRight.radius = frontAxis.WheelJointRight.flange_a.tau;
//   frontAxis.WheelJointRight.frame_a.t = 0.0;
//   frontAxis.WheelJointRight.f = frontAxis.WheelJointRight.N * PlanarMechanicsV4.Utilities.TripleS_Func(frontAxis.WheelJointRight.vAdhesion,frontAxis.WheelJointRight.vSlide,frontAxis.WheelJointRight.mu_A,frontAxis.WheelJointRight.mu_S,frontAxis.WheelJointRight.v_slip);
//   frontAxis.WheelJointRight.f_long = (frontAxis.WheelJointRight.f * frontAxis.WheelJointRight.v_slip_long) / frontAxis.WheelJointRight.v_slip;
//   frontAxis.WheelJointRight.f_lat = (frontAxis.WheelJointRight.f * frontAxis.WheelJointRight.v_slip_lat) / frontAxis.WheelJointRight.v_slip;
//   frontAxis.WheelJointRight.f_long = frontAxis.WheelJointRight.frame_a.fx * frontAxis.WheelJointRight.e0[1] + frontAxis.WheelJointRight.frame_a.fy * frontAxis.WheelJointRight.e0[2];
//   frontAxis.WheelJointRight.f_lat = frontAxis.WheelJointRight.frame_a.fy * frontAxis.WheelJointRight.e0[1] + (-frontAxis.WheelJointRight.frame_a.fx) * frontAxis.WheelJointRight.e0[2];
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   torque1.flange.tau = -torque1.tau;
//   torque1.phi_support = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_a.x = simpleChassis3D.planarToMultiBody.frame_b.r_0[1];
//   simpleChassis3D.planarToMultiBody.frame_a.y = simpleChassis3D.planarToMultiBody.frame_b.r_0[2];
//   0.0 = simpleChassis3D.planarToMultiBody.frame_b.r_0[3];
//   Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},-simpleChassis3D.planarToMultiBody.frame_a.phi,-der(simpleChassis3D.planarToMultiBody.frame_a.phi)) = simpleChassis3D.planarToMultiBody.frame_b.R;
//   simpleChassis3D.planarToMultiBody.f0[1] = simpleChassis3D.planarToMultiBody.frame_a.fx;
//   simpleChassis3D.planarToMultiBody.f0[2] = simpleChassis3D.planarToMultiBody.frame_a.fy;
//   simpleChassis3D.planarToMultiBody.f0[3] = simpleChassis3D.planarToMultiBody.fz;
//   simpleChassis3D.planarToMultiBody.f0[1] * simpleChassis3D.planarToMultiBody.frame_b.R.T[1,1] + simpleChassis3D.planarToMultiBody.f0[2] * simpleChassis3D.planarToMultiBody.frame_b.R.T[2,1] + simpleChassis3D.planarToMultiBody.f0[3] * simpleChassis3D.planarToMultiBody.frame_b.R.T[3,1] + simpleChassis3D.planarToMultiBody.frame_b.f[1] = 0.0;
//   simpleChassis3D.planarToMultiBody.f0[1] * simpleChassis3D.planarToMultiBody.frame_b.R.T[1,2] + simpleChassis3D.planarToMultiBody.f0[2] * simpleChassis3D.planarToMultiBody.frame_b.R.T[2,2] + simpleChassis3D.planarToMultiBody.f0[3] * simpleChassis3D.planarToMultiBody.frame_b.R.T[3,2] + simpleChassis3D.planarToMultiBody.frame_b.f[2] = 0.0;
//   simpleChassis3D.planarToMultiBody.f0[1] * simpleChassis3D.planarToMultiBody.frame_b.R.T[1,3] + simpleChassis3D.planarToMultiBody.f0[2] * simpleChassis3D.planarToMultiBody.frame_b.R.T[2,3] + simpleChassis3D.planarToMultiBody.f0[3] * simpleChassis3D.planarToMultiBody.frame_b.R.T[3,3] + simpleChassis3D.planarToMultiBody.frame_b.f[3] = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.t[3] - simpleChassis3D.planarToMultiBody.frame_a.t = 0.0;
//   simpleChassis3D.toCenterOfGravity.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.toCenterOfGravity.shape.shapeType);
//   simpleChassis3D.toCenterOfGravity.shape.rxvisobj[1] = simpleChassis3D.toCenterOfGravity.shape.R.T[1,1] * simpleChassis3D.toCenterOfGravity.shape.e_x[1] + simpleChassis3D.toCenterOfGravity.shape.R.T[2,1] * simpleChassis3D.toCenterOfGravity.shape.e_x[2] + simpleChassis3D.toCenterOfGravity.shape.R.T[3,1] * simpleChassis3D.toCenterOfGravity.shape.e_x[3];
//   simpleChassis3D.toCenterOfGravity.shape.rxvisobj[2] = simpleChassis3D.toCenterOfGravity.shape.R.T[1,2] * simpleChassis3D.toCenterOfGravity.shape.e_x[1] + simpleChassis3D.toCenterOfGravity.shape.R.T[2,2] * simpleChassis3D.toCenterOfGravity.shape.e_x[2] + simpleChassis3D.toCenterOfGravity.shape.R.T[3,2] * simpleChassis3D.toCenterOfGravity.shape.e_x[3];
//   simpleChassis3D.toCenterOfGravity.shape.rxvisobj[3] = simpleChassis3D.toCenterOfGravity.shape.R.T[1,3] * simpleChassis3D.toCenterOfGravity.shape.e_x[1] + simpleChassis3D.toCenterOfGravity.shape.R.T[2,3] * simpleChassis3D.toCenterOfGravity.shape.e_x[2] + simpleChassis3D.toCenterOfGravity.shape.R.T[3,3] * simpleChassis3D.toCenterOfGravity.shape.e_x[3];
//   simpleChassis3D.toCenterOfGravity.shape.ryvisobj[1] = simpleChassis3D.toCenterOfGravity.shape.R.T[1,1] * simpleChassis3D.toCenterOfGravity.shape.e_y[1] + simpleChassis3D.toCenterOfGravity.shape.R.T[2,1] * simpleChassis3D.toCenterOfGravity.shape.e_y[2] + simpleChassis3D.toCenterOfGravity.shape.R.T[3,1] * simpleChassis3D.toCenterOfGravity.shape.e_y[3];
//   simpleChassis3D.toCenterOfGravity.shape.ryvisobj[2] = simpleChassis3D.toCenterOfGravity.shape.R.T[1,2] * simpleChassis3D.toCenterOfGravity.shape.e_y[1] + simpleChassis3D.toCenterOfGravity.shape.R.T[2,2] * simpleChassis3D.toCenterOfGravity.shape.e_y[2] + simpleChassis3D.toCenterOfGravity.shape.R.T[3,2] * simpleChassis3D.toCenterOfGravity.shape.e_y[3];
//   simpleChassis3D.toCenterOfGravity.shape.ryvisobj[3] = simpleChassis3D.toCenterOfGravity.shape.R.T[1,3] * simpleChassis3D.toCenterOfGravity.shape.e_y[1] + simpleChassis3D.toCenterOfGravity.shape.R.T[2,3] * simpleChassis3D.toCenterOfGravity.shape.e_y[2] + simpleChassis3D.toCenterOfGravity.shape.R.T[3,3] * simpleChassis3D.toCenterOfGravity.shape.e_y[3];
//   simpleChassis3D.toCenterOfGravity.shape.rvisobj = simpleChassis3D.toCenterOfGravity.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.toCenterOfGravity.shape.R.T[1,1],simpleChassis3D.toCenterOfGravity.shape.R.T[1,2],simpleChassis3D.toCenterOfGravity.shape.R.T[1,3]},{simpleChassis3D.toCenterOfGravity.shape.R.T[2,1],simpleChassis3D.toCenterOfGravity.shape.R.T[2,2],simpleChassis3D.toCenterOfGravity.shape.R.T[2,3]},{simpleChassis3D.toCenterOfGravity.shape.R.T[3,1],simpleChassis3D.toCenterOfGravity.shape.R.T[3,2],simpleChassis3D.toCenterOfGravity.shape.R.T[3,3]}},{simpleChassis3D.toCenterOfGravity.shape.r_shape[1],simpleChassis3D.toCenterOfGravity.shape.r_shape[2],simpleChassis3D.toCenterOfGravity.shape.r_shape[3]});
//   simpleChassis3D.toCenterOfGravity.shape.size[1] = simpleChassis3D.toCenterOfGravity.shape.length;
//   simpleChassis3D.toCenterOfGravity.shape.size[2] = simpleChassis3D.toCenterOfGravity.shape.width;
//   simpleChassis3D.toCenterOfGravity.shape.size[3] = simpleChassis3D.toCenterOfGravity.shape.height;
//   simpleChassis3D.toCenterOfGravity.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.toCenterOfGravity.shape.color[1] / 255.0,simpleChassis3D.toCenterOfGravity.shape.color[2] / 255.0,simpleChassis3D.toCenterOfGravity.shape.color[3] / 255.0,simpleChassis3D.toCenterOfGravity.shape.specularCoefficient);
//   simpleChassis3D.toCenterOfGravity.shape.Extra = simpleChassis3D.toCenterOfGravity.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   simpleChassis3D.toCenterOfGravity.frame_b.r_0 = simpleChassis3D.toCenterOfGravity.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(simpleChassis3D.toCenterOfGravity.frame_a.R,{simpleChassis3D.toCenterOfGravity.r[1],simpleChassis3D.toCenterOfGravity.r[2],simpleChassis3D.toCenterOfGravity.r[3]});
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,1];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,2];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,3];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,1];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,2];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,3];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,1];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,2];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,3];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.w[1] = simpleChassis3D.toCenterOfGravity.frame_a.R.w[1];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.w[2] = simpleChassis3D.toCenterOfGravity.frame_a.R.w[2];
//   simpleChassis3D.toCenterOfGravity.frame_b.R.w[3] = simpleChassis3D.toCenterOfGravity.frame_a.R.w[3];
//   0.0 = simpleChassis3D.toCenterOfGravity.frame_a.f[1] + simpleChassis3D.toCenterOfGravity.frame_b.f[1];
//   0.0 = simpleChassis3D.toCenterOfGravity.frame_a.f[2] + simpleChassis3D.toCenterOfGravity.frame_b.f[2];
//   0.0 = simpleChassis3D.toCenterOfGravity.frame_a.f[3] + simpleChassis3D.toCenterOfGravity.frame_b.f[3];
//   0.0 = simpleChassis3D.toCenterOfGravity.frame_a.t[1] + simpleChassis3D.toCenterOfGravity.frame_b.t[1] + (simpleChassis3D.toCenterOfGravity.r[2] * simpleChassis3D.toCenterOfGravity.frame_b.f[3] - simpleChassis3D.toCenterOfGravity.r[3] * simpleChassis3D.toCenterOfGravity.frame_b.f[2]);
//   0.0 = simpleChassis3D.toCenterOfGravity.frame_a.t[2] + simpleChassis3D.toCenterOfGravity.frame_b.t[2] + (simpleChassis3D.toCenterOfGravity.r[3] * simpleChassis3D.toCenterOfGravity.frame_b.f[1] - simpleChassis3D.toCenterOfGravity.r[1] * simpleChassis3D.toCenterOfGravity.frame_b.f[3]);
//   0.0 = simpleChassis3D.toCenterOfGravity.frame_a.t[3] + simpleChassis3D.toCenterOfGravity.frame_b.t[3] + (simpleChassis3D.toCenterOfGravity.r[1] * simpleChassis3D.toCenterOfGravity.frame_b.f[2] - simpleChassis3D.toCenterOfGravity.r[2] * simpleChassis3D.toCenterOfGravity.frame_b.f[1]);
//   simpleChassis3D.roll.fixed.flange.phi = simpleChassis3D.roll.fixed.phi0;
//   simpleChassis3D.roll.internalAxis.flange.tau = simpleChassis3D.roll.internalAxis.tau;
//   simpleChassis3D.roll.internalAxis.flange.phi = simpleChassis3D.roll.internalAxis.phi;
//   simpleChassis3D.roll.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.roll.cylinder.shapeType);
//   simpleChassis3D.roll.cylinder.rxvisobj[1] = simpleChassis3D.roll.cylinder.R.T[1,1] * simpleChassis3D.roll.cylinder.e_x[1] + simpleChassis3D.roll.cylinder.R.T[2,1] * simpleChassis3D.roll.cylinder.e_x[2] + simpleChassis3D.roll.cylinder.R.T[3,1] * simpleChassis3D.roll.cylinder.e_x[3];
//   simpleChassis3D.roll.cylinder.rxvisobj[2] = simpleChassis3D.roll.cylinder.R.T[1,2] * simpleChassis3D.roll.cylinder.e_x[1] + simpleChassis3D.roll.cylinder.R.T[2,2] * simpleChassis3D.roll.cylinder.e_x[2] + simpleChassis3D.roll.cylinder.R.T[3,2] * simpleChassis3D.roll.cylinder.e_x[3];
//   simpleChassis3D.roll.cylinder.rxvisobj[3] = simpleChassis3D.roll.cylinder.R.T[1,3] * simpleChassis3D.roll.cylinder.e_x[1] + simpleChassis3D.roll.cylinder.R.T[2,3] * simpleChassis3D.roll.cylinder.e_x[2] + simpleChassis3D.roll.cylinder.R.T[3,3] * simpleChassis3D.roll.cylinder.e_x[3];
//   simpleChassis3D.roll.cylinder.ryvisobj[1] = simpleChassis3D.roll.cylinder.R.T[1,1] * simpleChassis3D.roll.cylinder.e_y[1] + simpleChassis3D.roll.cylinder.R.T[2,1] * simpleChassis3D.roll.cylinder.e_y[2] + simpleChassis3D.roll.cylinder.R.T[3,1] * simpleChassis3D.roll.cylinder.e_y[3];
//   simpleChassis3D.roll.cylinder.ryvisobj[2] = simpleChassis3D.roll.cylinder.R.T[1,2] * simpleChassis3D.roll.cylinder.e_y[1] + simpleChassis3D.roll.cylinder.R.T[2,2] * simpleChassis3D.roll.cylinder.e_y[2] + simpleChassis3D.roll.cylinder.R.T[3,2] * simpleChassis3D.roll.cylinder.e_y[3];
//   simpleChassis3D.roll.cylinder.ryvisobj[3] = simpleChassis3D.roll.cylinder.R.T[1,3] * simpleChassis3D.roll.cylinder.e_y[1] + simpleChassis3D.roll.cylinder.R.T[2,3] * simpleChassis3D.roll.cylinder.e_y[2] + simpleChassis3D.roll.cylinder.R.T[3,3] * simpleChassis3D.roll.cylinder.e_y[3];
//   simpleChassis3D.roll.cylinder.rvisobj = simpleChassis3D.roll.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.roll.cylinder.R.T[1,1],simpleChassis3D.roll.cylinder.R.T[1,2],simpleChassis3D.roll.cylinder.R.T[1,3]},{simpleChassis3D.roll.cylinder.R.T[2,1],simpleChassis3D.roll.cylinder.R.T[2,2],simpleChassis3D.roll.cylinder.R.T[2,3]},{simpleChassis3D.roll.cylinder.R.T[3,1],simpleChassis3D.roll.cylinder.R.T[3,2],simpleChassis3D.roll.cylinder.R.T[3,3]}},{simpleChassis3D.roll.cylinder.r_shape[1],simpleChassis3D.roll.cylinder.r_shape[2],simpleChassis3D.roll.cylinder.r_shape[3]});
//   simpleChassis3D.roll.cylinder.size[1] = simpleChassis3D.roll.cylinder.length;
//   simpleChassis3D.roll.cylinder.size[2] = simpleChassis3D.roll.cylinder.width;
//   simpleChassis3D.roll.cylinder.size[3] = simpleChassis3D.roll.cylinder.height;
//   simpleChassis3D.roll.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.roll.cylinder.color[1] / 255.0,simpleChassis3D.roll.cylinder.color[2] / 255.0,simpleChassis3D.roll.cylinder.color[3] / 255.0,simpleChassis3D.roll.cylinder.specularCoefficient);
//   simpleChassis3D.roll.cylinder.Extra = simpleChassis3D.roll.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   simpleChassis3D.roll.angle = simpleChassis3D.roll.phi;
//   simpleChassis3D.roll.w = der(simpleChassis3D.roll.phi);
//   simpleChassis3D.roll.a = der(simpleChassis3D.roll.w);
//   simpleChassis3D.roll.frame_b.r_0[1] = simpleChassis3D.roll.frame_a.r_0[1];
//   simpleChassis3D.roll.frame_b.r_0[2] = simpleChassis3D.roll.frame_a.r_0[2];
//   simpleChassis3D.roll.frame_b.r_0[3] = simpleChassis3D.roll.frame_a.r_0[3];
//   simpleChassis3D.roll.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({simpleChassis3D.roll.e[1],simpleChassis3D.roll.e[2],simpleChassis3D.roll.e[3]},simpleChassis3D.roll.phi,simpleChassis3D.roll.w);
//   simpleChassis3D.roll.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(simpleChassis3D.roll.frame_a.R,simpleChassis3D.roll.R_rel);
//   simpleChassis3D.roll.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(simpleChassis3D.roll.R_rel,{simpleChassis3D.roll.frame_b.f[1],simpleChassis3D.roll.frame_b.f[2],simpleChassis3D.roll.frame_b.f[3]});
//   simpleChassis3D.roll.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(simpleChassis3D.roll.R_rel,{simpleChassis3D.roll.frame_b.t[1],simpleChassis3D.roll.frame_b.t[2],simpleChassis3D.roll.frame_b.t[3]});
//   simpleChassis3D.roll.tau = (-simpleChassis3D.roll.frame_b.t[1]) * simpleChassis3D.roll.e[1] + ((-simpleChassis3D.roll.frame_b.t[2]) * simpleChassis3D.roll.e[2] + (-simpleChassis3D.roll.frame_b.t[3]) * simpleChassis3D.roll.e[3]);
//   simpleChassis3D.roll.phi = simpleChassis3D.roll.internalAxis.phi;
//   simpleChassis3D.pitch.fixed.flange.phi = simpleChassis3D.pitch.fixed.phi0;
//   simpleChassis3D.pitch.internalAxis.flange.tau = simpleChassis3D.pitch.internalAxis.tau;
//   simpleChassis3D.pitch.internalAxis.flange.phi = simpleChassis3D.pitch.internalAxis.phi;
//   simpleChassis3D.pitch.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.pitch.cylinder.shapeType);
//   simpleChassis3D.pitch.cylinder.rxvisobj[1] = simpleChassis3D.pitch.cylinder.R.T[1,1] * simpleChassis3D.pitch.cylinder.e_x[1] + simpleChassis3D.pitch.cylinder.R.T[2,1] * simpleChassis3D.pitch.cylinder.e_x[2] + simpleChassis3D.pitch.cylinder.R.T[3,1] * simpleChassis3D.pitch.cylinder.e_x[3];
//   simpleChassis3D.pitch.cylinder.rxvisobj[2] = simpleChassis3D.pitch.cylinder.R.T[1,2] * simpleChassis3D.pitch.cylinder.e_x[1] + simpleChassis3D.pitch.cylinder.R.T[2,2] * simpleChassis3D.pitch.cylinder.e_x[2] + simpleChassis3D.pitch.cylinder.R.T[3,2] * simpleChassis3D.pitch.cylinder.e_x[3];
//   simpleChassis3D.pitch.cylinder.rxvisobj[3] = simpleChassis3D.pitch.cylinder.R.T[1,3] * simpleChassis3D.pitch.cylinder.e_x[1] + simpleChassis3D.pitch.cylinder.R.T[2,3] * simpleChassis3D.pitch.cylinder.e_x[2] + simpleChassis3D.pitch.cylinder.R.T[3,3] * simpleChassis3D.pitch.cylinder.e_x[3];
//   simpleChassis3D.pitch.cylinder.ryvisobj[1] = simpleChassis3D.pitch.cylinder.R.T[1,1] * simpleChassis3D.pitch.cylinder.e_y[1] + simpleChassis3D.pitch.cylinder.R.T[2,1] * simpleChassis3D.pitch.cylinder.e_y[2] + simpleChassis3D.pitch.cylinder.R.T[3,1] * simpleChassis3D.pitch.cylinder.e_y[3];
//   simpleChassis3D.pitch.cylinder.ryvisobj[2] = simpleChassis3D.pitch.cylinder.R.T[1,2] * simpleChassis3D.pitch.cylinder.e_y[1] + simpleChassis3D.pitch.cylinder.R.T[2,2] * simpleChassis3D.pitch.cylinder.e_y[2] + simpleChassis3D.pitch.cylinder.R.T[3,2] * simpleChassis3D.pitch.cylinder.e_y[3];
//   simpleChassis3D.pitch.cylinder.ryvisobj[3] = simpleChassis3D.pitch.cylinder.R.T[1,3] * simpleChassis3D.pitch.cylinder.e_y[1] + simpleChassis3D.pitch.cylinder.R.T[2,3] * simpleChassis3D.pitch.cylinder.e_y[2] + simpleChassis3D.pitch.cylinder.R.T[3,3] * simpleChassis3D.pitch.cylinder.e_y[3];
//   simpleChassis3D.pitch.cylinder.rvisobj = simpleChassis3D.pitch.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.pitch.cylinder.R.T[1,1],simpleChassis3D.pitch.cylinder.R.T[1,2],simpleChassis3D.pitch.cylinder.R.T[1,3]},{simpleChassis3D.pitch.cylinder.R.T[2,1],simpleChassis3D.pitch.cylinder.R.T[2,2],simpleChassis3D.pitch.cylinder.R.T[2,3]},{simpleChassis3D.pitch.cylinder.R.T[3,1],simpleChassis3D.pitch.cylinder.R.T[3,2],simpleChassis3D.pitch.cylinder.R.T[3,3]}},{simpleChassis3D.pitch.cylinder.r_shape[1],simpleChassis3D.pitch.cylinder.r_shape[2],simpleChassis3D.pitch.cylinder.r_shape[3]});
//   simpleChassis3D.pitch.cylinder.size[1] = simpleChassis3D.pitch.cylinder.length;
//   simpleChassis3D.pitch.cylinder.size[2] = simpleChassis3D.pitch.cylinder.width;
//   simpleChassis3D.pitch.cylinder.size[3] = simpleChassis3D.pitch.cylinder.height;
//   simpleChassis3D.pitch.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.pitch.cylinder.color[1] / 255.0,simpleChassis3D.pitch.cylinder.color[2] / 255.0,simpleChassis3D.pitch.cylinder.color[3] / 255.0,simpleChassis3D.pitch.cylinder.specularCoefficient);
//   simpleChassis3D.pitch.cylinder.Extra = simpleChassis3D.pitch.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   simpleChassis3D.pitch.angle = simpleChassis3D.pitch.phi;
//   simpleChassis3D.pitch.w = der(simpleChassis3D.pitch.phi);
//   simpleChassis3D.pitch.a = der(simpleChassis3D.pitch.w);
//   simpleChassis3D.pitch.frame_b.r_0[1] = simpleChassis3D.pitch.frame_a.r_0[1];
//   simpleChassis3D.pitch.frame_b.r_0[2] = simpleChassis3D.pitch.frame_a.r_0[2];
//   simpleChassis3D.pitch.frame_b.r_0[3] = simpleChassis3D.pitch.frame_a.r_0[3];
//   simpleChassis3D.pitch.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({simpleChassis3D.pitch.e[1],simpleChassis3D.pitch.e[2],simpleChassis3D.pitch.e[3]},simpleChassis3D.pitch.phi,simpleChassis3D.pitch.w);
//   simpleChassis3D.pitch.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(simpleChassis3D.pitch.frame_a.R,simpleChassis3D.pitch.R_rel);
//   simpleChassis3D.pitch.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(simpleChassis3D.pitch.R_rel,{simpleChassis3D.pitch.frame_b.f[1],simpleChassis3D.pitch.frame_b.f[2],simpleChassis3D.pitch.frame_b.f[3]});
//   simpleChassis3D.pitch.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(simpleChassis3D.pitch.R_rel,{simpleChassis3D.pitch.frame_b.t[1],simpleChassis3D.pitch.frame_b.t[2],simpleChassis3D.pitch.frame_b.t[3]});
//   simpleChassis3D.pitch.tau = (-simpleChassis3D.pitch.frame_b.t[1]) * simpleChassis3D.pitch.e[1] + ((-simpleChassis3D.pitch.frame_b.t[2]) * simpleChassis3D.pitch.e[2] + (-simpleChassis3D.pitch.frame_b.t[3]) * simpleChassis3D.pitch.e[3]);
//   simpleChassis3D.pitch.phi = simpleChassis3D.pitch.internalAxis.phi;
//   simpleChassis3D.fixedTranslationFront.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.fixedTranslationFront.cylinder.shapeType);
//   simpleChassis3D.fixedTranslationFront.cylinder.rxvisobj[1] = simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,1] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[1] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,1] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[2] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,1] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[3];
//   simpleChassis3D.fixedTranslationFront.cylinder.rxvisobj[2] = simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,2] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[1] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,2] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[2] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,2] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[3];
//   simpleChassis3D.fixedTranslationFront.cylinder.rxvisobj[3] = simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,3] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[1] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,3] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[2] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,3] * simpleChassis3D.fixedTranslationFront.cylinder.e_x[3];
//   simpleChassis3D.fixedTranslationFront.cylinder.ryvisobj[1] = simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,1] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[1] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,1] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[2] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,1] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[3];
//   simpleChassis3D.fixedTranslationFront.cylinder.ryvisobj[2] = simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,2] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[1] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,2] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[2] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,2] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[3];
//   simpleChassis3D.fixedTranslationFront.cylinder.ryvisobj[3] = simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,3] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[1] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,3] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[2] + simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,3] * simpleChassis3D.fixedTranslationFront.cylinder.e_y[3];
//   simpleChassis3D.fixedTranslationFront.cylinder.rvisobj = simpleChassis3D.fixedTranslationFront.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,1],simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,2],simpleChassis3D.fixedTranslationFront.cylinder.R.T[1,3]},{simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,1],simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,2],simpleChassis3D.fixedTranslationFront.cylinder.R.T[2,3]},{simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,1],simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,2],simpleChassis3D.fixedTranslationFront.cylinder.R.T[3,3]}},{simpleChassis3D.fixedTranslationFront.cylinder.r_shape[1],simpleChassis3D.fixedTranslationFront.cylinder.r_shape[2],simpleChassis3D.fixedTranslationFront.cylinder.r_shape[3]});
//   simpleChassis3D.fixedTranslationFront.cylinder.size[1] = simpleChassis3D.fixedTranslationFront.cylinder.length;
//   simpleChassis3D.fixedTranslationFront.cylinder.size[2] = simpleChassis3D.fixedTranslationFront.cylinder.width;
//   simpleChassis3D.fixedTranslationFront.cylinder.size[3] = simpleChassis3D.fixedTranslationFront.cylinder.height;
//   simpleChassis3D.fixedTranslationFront.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.fixedTranslationFront.cylinder.color[1] / 255.0,simpleChassis3D.fixedTranslationFront.cylinder.color[2] / 255.0,simpleChassis3D.fixedTranslationFront.cylinder.color[3] / 255.0,simpleChassis3D.fixedTranslationFront.cylinder.specularCoefficient);
//   simpleChassis3D.fixedTranslationFront.cylinder.Extra = simpleChassis3D.fixedTranslationFront.cylinder.extra;
//   simpleChassis3D.fixedTranslationFront.R[1,1] = cos(simpleChassis3D.fixedTranslationFront.frame_a.phi);
//   simpleChassis3D.fixedTranslationFront.R[1,2] = sin(simpleChassis3D.fixedTranslationFront.frame_a.phi);
//   simpleChassis3D.fixedTranslationFront.R[2,1] = -sin(simpleChassis3D.fixedTranslationFront.frame_a.phi);
//   simpleChassis3D.fixedTranslationFront.R[2,2] = cos(simpleChassis3D.fixedTranslationFront.frame_a.phi);
//   simpleChassis3D.fixedTranslationFront.r0[1] = simpleChassis3D.fixedTranslationFront.R[1,1] * simpleChassis3D.fixedTranslationFront.r[1] + simpleChassis3D.fixedTranslationFront.R[1,2] * simpleChassis3D.fixedTranslationFront.r[2];
//   simpleChassis3D.fixedTranslationFront.r0[2] = simpleChassis3D.fixedTranslationFront.R[2,1] * simpleChassis3D.fixedTranslationFront.r[1] + simpleChassis3D.fixedTranslationFront.R[2,2] * simpleChassis3D.fixedTranslationFront.r[2];
//   simpleChassis3D.fixedTranslationFront.frame_a.x + simpleChassis3D.fixedTranslationFront.r0[1] = simpleChassis3D.fixedTranslationFront.frame_b.x;
//   simpleChassis3D.fixedTranslationFront.frame_a.y + simpleChassis3D.fixedTranslationFront.r0[2] = simpleChassis3D.fixedTranslationFront.frame_b.y;
//   simpleChassis3D.fixedTranslationFront.frame_a.phi = simpleChassis3D.fixedTranslationFront.frame_b.phi;
//   simpleChassis3D.fixedTranslationFront.frame_a.fx + simpleChassis3D.fixedTranslationFront.frame_b.fx = 0.0;
//   simpleChassis3D.fixedTranslationFront.frame_a.fy + simpleChassis3D.fixedTranslationFront.frame_b.fy = 0.0;
//   simpleChassis3D.fixedTranslationFront.frame_a.t + (simpleChassis3D.fixedTranslationFront.frame_b.t + ((-simpleChassis3D.fixedTranslationFront.r0[1]) * simpleChassis3D.fixedTranslationFront.frame_b.fy + simpleChassis3D.fixedTranslationFront.r0[2] * simpleChassis3D.fixedTranslationFront.frame_b.fx)) = 0.0;
//   simpleChassis3D.fixedTranslationRear.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.fixedTranslationRear.cylinder.shapeType);
//   simpleChassis3D.fixedTranslationRear.cylinder.rxvisobj[1] = simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,1] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[1] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,1] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[2] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,1] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[3];
//   simpleChassis3D.fixedTranslationRear.cylinder.rxvisobj[2] = simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,2] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[1] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,2] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[2] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,2] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[3];
//   simpleChassis3D.fixedTranslationRear.cylinder.rxvisobj[3] = simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,3] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[1] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,3] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[2] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,3] * simpleChassis3D.fixedTranslationRear.cylinder.e_x[3];
//   simpleChassis3D.fixedTranslationRear.cylinder.ryvisobj[1] = simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,1] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[1] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,1] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[2] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,1] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[3];
//   simpleChassis3D.fixedTranslationRear.cylinder.ryvisobj[2] = simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,2] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[1] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,2] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[2] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,2] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[3];
//   simpleChassis3D.fixedTranslationRear.cylinder.ryvisobj[3] = simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,3] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[1] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,3] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[2] + simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,3] * simpleChassis3D.fixedTranslationRear.cylinder.e_y[3];
//   simpleChassis3D.fixedTranslationRear.cylinder.rvisobj = simpleChassis3D.fixedTranslationRear.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,1],simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,2],simpleChassis3D.fixedTranslationRear.cylinder.R.T[1,3]},{simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,1],simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,2],simpleChassis3D.fixedTranslationRear.cylinder.R.T[2,3]},{simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,1],simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,2],simpleChassis3D.fixedTranslationRear.cylinder.R.T[3,3]}},{simpleChassis3D.fixedTranslationRear.cylinder.r_shape[1],simpleChassis3D.fixedTranslationRear.cylinder.r_shape[2],simpleChassis3D.fixedTranslationRear.cylinder.r_shape[3]});
//   simpleChassis3D.fixedTranslationRear.cylinder.size[1] = simpleChassis3D.fixedTranslationRear.cylinder.length;
//   simpleChassis3D.fixedTranslationRear.cylinder.size[2] = simpleChassis3D.fixedTranslationRear.cylinder.width;
//   simpleChassis3D.fixedTranslationRear.cylinder.size[3] = simpleChassis3D.fixedTranslationRear.cylinder.height;
//   simpleChassis3D.fixedTranslationRear.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.fixedTranslationRear.cylinder.color[1] / 255.0,simpleChassis3D.fixedTranslationRear.cylinder.color[2] / 255.0,simpleChassis3D.fixedTranslationRear.cylinder.color[3] / 255.0,simpleChassis3D.fixedTranslationRear.cylinder.specularCoefficient);
//   simpleChassis3D.fixedTranslationRear.cylinder.Extra = simpleChassis3D.fixedTranslationRear.cylinder.extra;
//   simpleChassis3D.fixedTranslationRear.R[1,1] = cos(simpleChassis3D.fixedTranslationRear.frame_a.phi);
//   simpleChassis3D.fixedTranslationRear.R[1,2] = sin(simpleChassis3D.fixedTranslationRear.frame_a.phi);
//   simpleChassis3D.fixedTranslationRear.R[2,1] = -sin(simpleChassis3D.fixedTranslationRear.frame_a.phi);
//   simpleChassis3D.fixedTranslationRear.R[2,2] = cos(simpleChassis3D.fixedTranslationRear.frame_a.phi);
//   simpleChassis3D.fixedTranslationRear.r0[1] = simpleChassis3D.fixedTranslationRear.R[1,1] * simpleChassis3D.fixedTranslationRear.r[1] + simpleChassis3D.fixedTranslationRear.R[1,2] * simpleChassis3D.fixedTranslationRear.r[2];
//   simpleChassis3D.fixedTranslationRear.r0[2] = simpleChassis3D.fixedTranslationRear.R[2,1] * simpleChassis3D.fixedTranslationRear.r[1] + simpleChassis3D.fixedTranslationRear.R[2,2] * simpleChassis3D.fixedTranslationRear.r[2];
//   simpleChassis3D.fixedTranslationRear.frame_a.x + simpleChassis3D.fixedTranslationRear.r0[1] = simpleChassis3D.fixedTranslationRear.frame_b.x;
//   simpleChassis3D.fixedTranslationRear.frame_a.y + simpleChassis3D.fixedTranslationRear.r0[2] = simpleChassis3D.fixedTranslationRear.frame_b.y;
//   simpleChassis3D.fixedTranslationRear.frame_a.phi = simpleChassis3D.fixedTranslationRear.frame_b.phi;
//   simpleChassis3D.fixedTranslationRear.frame_a.fx + simpleChassis3D.fixedTranslationRear.frame_b.fx = 0.0;
//   simpleChassis3D.fixedTranslationRear.frame_a.fy + simpleChassis3D.fixedTranslationRear.frame_b.fy = 0.0;
//   simpleChassis3D.fixedTranslationRear.frame_a.t + (simpleChassis3D.fixedTranslationRear.frame_b.t + ((-simpleChassis3D.fixedTranslationRear.r0[1]) * simpleChassis3D.fixedTranslationRear.frame_b.fy + simpleChassis3D.fixedTranslationRear.r0[2] * simpleChassis3D.fixedTranslationRear.frame_b.fx)) = 0.0;
//   simpleChassis3D.dynamicLoad.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.dynamicLoad.cylinder.shapeType);
//   simpleChassis3D.dynamicLoad.cylinder.rxvisobj[1] = simpleChassis3D.dynamicLoad.cylinder.R.T[1,1] * simpleChassis3D.dynamicLoad.cylinder.e_x[1] + simpleChassis3D.dynamicLoad.cylinder.R.T[2,1] * simpleChassis3D.dynamicLoad.cylinder.e_x[2] + simpleChassis3D.dynamicLoad.cylinder.R.T[3,1] * simpleChassis3D.dynamicLoad.cylinder.e_x[3];
//   simpleChassis3D.dynamicLoad.cylinder.rxvisobj[2] = simpleChassis3D.dynamicLoad.cylinder.R.T[1,2] * simpleChassis3D.dynamicLoad.cylinder.e_x[1] + simpleChassis3D.dynamicLoad.cylinder.R.T[2,2] * simpleChassis3D.dynamicLoad.cylinder.e_x[2] + simpleChassis3D.dynamicLoad.cylinder.R.T[3,2] * simpleChassis3D.dynamicLoad.cylinder.e_x[3];
//   simpleChassis3D.dynamicLoad.cylinder.rxvisobj[3] = simpleChassis3D.dynamicLoad.cylinder.R.T[1,3] * simpleChassis3D.dynamicLoad.cylinder.e_x[1] + simpleChassis3D.dynamicLoad.cylinder.R.T[2,3] * simpleChassis3D.dynamicLoad.cylinder.e_x[2] + simpleChassis3D.dynamicLoad.cylinder.R.T[3,3] * simpleChassis3D.dynamicLoad.cylinder.e_x[3];
//   simpleChassis3D.dynamicLoad.cylinder.ryvisobj[1] = simpleChassis3D.dynamicLoad.cylinder.R.T[1,1] * simpleChassis3D.dynamicLoad.cylinder.e_y[1] + simpleChassis3D.dynamicLoad.cylinder.R.T[2,1] * simpleChassis3D.dynamicLoad.cylinder.e_y[2] + simpleChassis3D.dynamicLoad.cylinder.R.T[3,1] * simpleChassis3D.dynamicLoad.cylinder.e_y[3];
//   simpleChassis3D.dynamicLoad.cylinder.ryvisobj[2] = simpleChassis3D.dynamicLoad.cylinder.R.T[1,2] * simpleChassis3D.dynamicLoad.cylinder.e_y[1] + simpleChassis3D.dynamicLoad.cylinder.R.T[2,2] * simpleChassis3D.dynamicLoad.cylinder.e_y[2] + simpleChassis3D.dynamicLoad.cylinder.R.T[3,2] * simpleChassis3D.dynamicLoad.cylinder.e_y[3];
//   simpleChassis3D.dynamicLoad.cylinder.ryvisobj[3] = simpleChassis3D.dynamicLoad.cylinder.R.T[1,3] * simpleChassis3D.dynamicLoad.cylinder.e_y[1] + simpleChassis3D.dynamicLoad.cylinder.R.T[2,3] * simpleChassis3D.dynamicLoad.cylinder.e_y[2] + simpleChassis3D.dynamicLoad.cylinder.R.T[3,3] * simpleChassis3D.dynamicLoad.cylinder.e_y[3];
//   simpleChassis3D.dynamicLoad.cylinder.rvisobj = simpleChassis3D.dynamicLoad.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.dynamicLoad.cylinder.R.T[1,1],simpleChassis3D.dynamicLoad.cylinder.R.T[1,2],simpleChassis3D.dynamicLoad.cylinder.R.T[1,3]},{simpleChassis3D.dynamicLoad.cylinder.R.T[2,1],simpleChassis3D.dynamicLoad.cylinder.R.T[2,2],simpleChassis3D.dynamicLoad.cylinder.R.T[2,3]},{simpleChassis3D.dynamicLoad.cylinder.R.T[3,1],simpleChassis3D.dynamicLoad.cylinder.R.T[3,2],simpleChassis3D.dynamicLoad.cylinder.R.T[3,3]}},{simpleChassis3D.dynamicLoad.cylinder.r_shape[1],simpleChassis3D.dynamicLoad.cylinder.r_shape[2],simpleChassis3D.dynamicLoad.cylinder.r_shape[3]});
//   simpleChassis3D.dynamicLoad.cylinder.size[1] = simpleChassis3D.dynamicLoad.cylinder.length;
//   simpleChassis3D.dynamicLoad.cylinder.size[2] = simpleChassis3D.dynamicLoad.cylinder.width;
//   simpleChassis3D.dynamicLoad.cylinder.size[3] = simpleChassis3D.dynamicLoad.cylinder.height;
//   simpleChassis3D.dynamicLoad.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.dynamicLoad.cylinder.color[1] / 255.0,simpleChassis3D.dynamicLoad.cylinder.color[2] / 255.0,simpleChassis3D.dynamicLoad.cylinder.color[3] / 255.0,simpleChassis3D.dynamicLoad.cylinder.specularCoefficient);
//   simpleChassis3D.dynamicLoad.cylinder.Extra = simpleChassis3D.dynamicLoad.cylinder.extra;
//   simpleChassis3D.dynamicLoad.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.dynamicLoad.sphere.shapeType);
//   simpleChassis3D.dynamicLoad.sphere.rxvisobj[1] = simpleChassis3D.dynamicLoad.sphere.R.T[1,1] * simpleChassis3D.dynamicLoad.sphere.e_x[1] + simpleChassis3D.dynamicLoad.sphere.R.T[2,1] * simpleChassis3D.dynamicLoad.sphere.e_x[2] + simpleChassis3D.dynamicLoad.sphere.R.T[3,1] * simpleChassis3D.dynamicLoad.sphere.e_x[3];
//   simpleChassis3D.dynamicLoad.sphere.rxvisobj[2] = simpleChassis3D.dynamicLoad.sphere.R.T[1,2] * simpleChassis3D.dynamicLoad.sphere.e_x[1] + simpleChassis3D.dynamicLoad.sphere.R.T[2,2] * simpleChassis3D.dynamicLoad.sphere.e_x[2] + simpleChassis3D.dynamicLoad.sphere.R.T[3,2] * simpleChassis3D.dynamicLoad.sphere.e_x[3];
//   simpleChassis3D.dynamicLoad.sphere.rxvisobj[3] = simpleChassis3D.dynamicLoad.sphere.R.T[1,3] * simpleChassis3D.dynamicLoad.sphere.e_x[1] + simpleChassis3D.dynamicLoad.sphere.R.T[2,3] * simpleChassis3D.dynamicLoad.sphere.e_x[2] + simpleChassis3D.dynamicLoad.sphere.R.T[3,3] * simpleChassis3D.dynamicLoad.sphere.e_x[3];
//   simpleChassis3D.dynamicLoad.sphere.ryvisobj[1] = simpleChassis3D.dynamicLoad.sphere.R.T[1,1] * simpleChassis3D.dynamicLoad.sphere.e_y[1] + simpleChassis3D.dynamicLoad.sphere.R.T[2,1] * simpleChassis3D.dynamicLoad.sphere.e_y[2] + simpleChassis3D.dynamicLoad.sphere.R.T[3,1] * simpleChassis3D.dynamicLoad.sphere.e_y[3];
//   simpleChassis3D.dynamicLoad.sphere.ryvisobj[2] = simpleChassis3D.dynamicLoad.sphere.R.T[1,2] * simpleChassis3D.dynamicLoad.sphere.e_y[1] + simpleChassis3D.dynamicLoad.sphere.R.T[2,2] * simpleChassis3D.dynamicLoad.sphere.e_y[2] + simpleChassis3D.dynamicLoad.sphere.R.T[3,2] * simpleChassis3D.dynamicLoad.sphere.e_y[3];
//   simpleChassis3D.dynamicLoad.sphere.ryvisobj[3] = simpleChassis3D.dynamicLoad.sphere.R.T[1,3] * simpleChassis3D.dynamicLoad.sphere.e_y[1] + simpleChassis3D.dynamicLoad.sphere.R.T[2,3] * simpleChassis3D.dynamicLoad.sphere.e_y[2] + simpleChassis3D.dynamicLoad.sphere.R.T[3,3] * simpleChassis3D.dynamicLoad.sphere.e_y[3];
//   simpleChassis3D.dynamicLoad.sphere.rvisobj = simpleChassis3D.dynamicLoad.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.dynamicLoad.sphere.R.T[1,1],simpleChassis3D.dynamicLoad.sphere.R.T[1,2],simpleChassis3D.dynamicLoad.sphere.R.T[1,3]},{simpleChassis3D.dynamicLoad.sphere.R.T[2,1],simpleChassis3D.dynamicLoad.sphere.R.T[2,2],simpleChassis3D.dynamicLoad.sphere.R.T[2,3]},{simpleChassis3D.dynamicLoad.sphere.R.T[3,1],simpleChassis3D.dynamicLoad.sphere.R.T[3,2],simpleChassis3D.dynamicLoad.sphere.R.T[3,3]}},{simpleChassis3D.dynamicLoad.sphere.r_shape[1],simpleChassis3D.dynamicLoad.sphere.r_shape[2],simpleChassis3D.dynamicLoad.sphere.r_shape[3]});
//   simpleChassis3D.dynamicLoad.sphere.size[1] = simpleChassis3D.dynamicLoad.sphere.length;
//   simpleChassis3D.dynamicLoad.sphere.size[2] = simpleChassis3D.dynamicLoad.sphere.width;
//   simpleChassis3D.dynamicLoad.sphere.size[3] = simpleChassis3D.dynamicLoad.sphere.height;
//   simpleChassis3D.dynamicLoad.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.dynamicLoad.sphere.color[1] / 255.0,simpleChassis3D.dynamicLoad.sphere.color[2] / 255.0,simpleChassis3D.dynamicLoad.sphere.color[3] / 255.0,simpleChassis3D.dynamicLoad.sphere.specularCoefficient);
//   simpleChassis3D.dynamicLoad.sphere.Extra = simpleChassis3D.dynamicLoad.sphere.extra;
//   simpleChassis3D.dynamicLoad.r_0[1] = simpleChassis3D.dynamicLoad.frame_a.r_0[1];
//   simpleChassis3D.dynamicLoad.r_0[2] = simpleChassis3D.dynamicLoad.frame_a.r_0[2];
//   simpleChassis3D.dynamicLoad.r_0[3] = simpleChassis3D.dynamicLoad.frame_a.r_0[3];
//   if true then
//   simpleChassis3D.dynamicLoad.Q[1] = 0.0;
//   simpleChassis3D.dynamicLoad.Q[2] = 0.0;
//   simpleChassis3D.dynamicLoad.Q[3] = 0.0;
//   simpleChassis3D.dynamicLoad.Q[4] = 1.0;
//   simpleChassis3D.dynamicLoad.phi[1] = 0.0;
//   simpleChassis3D.dynamicLoad.phi[2] = 0.0;
//   simpleChassis3D.dynamicLoad.phi[3] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_d[1] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_d[2] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_d[3] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_dd[1] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_dd[2] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_dd[3] = 0.0;
//   elseif simpleChassis3D.dynamicLoad.useQuaternions then
//   simpleChassis3D.dynamicLoad.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({simpleChassis3D.dynamicLoad.Q[1],simpleChassis3D.dynamicLoad.Q[2],simpleChassis3D.dynamicLoad.Q[3],simpleChassis3D.dynamicLoad.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({simpleChassis3D.dynamicLoad.Q[1],simpleChassis3D.dynamicLoad.Q[2],simpleChassis3D.dynamicLoad.Q[3],simpleChassis3D.dynamicLoad.Q[4]},{der(simpleChassis3D.dynamicLoad.Q[1]),der(simpleChassis3D.dynamicLoad.Q[2]),der(simpleChassis3D.dynamicLoad.Q[3]),der(simpleChassis3D.dynamicLoad.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({simpleChassis3D.dynamicLoad.Q[1],simpleChassis3D.dynamicLoad.Q[2],simpleChassis3D.dynamicLoad.Q[3],simpleChassis3D.dynamicLoad.Q[4]});
//   simpleChassis3D.dynamicLoad.phi[1] = 0.0;
//   simpleChassis3D.dynamicLoad.phi[2] = 0.0;
//   simpleChassis3D.dynamicLoad.phi[3] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_d[1] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_d[2] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_d[3] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_dd[1] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_dd[2] = 0.0;
//   simpleChassis3D.dynamicLoad.phi_dd[3] = 0.0;
//   else
//   simpleChassis3D.dynamicLoad.phi_d[1] = der(simpleChassis3D.dynamicLoad.phi[1]);
//   simpleChassis3D.dynamicLoad.phi_d[2] = der(simpleChassis3D.dynamicLoad.phi[2]);
//   simpleChassis3D.dynamicLoad.phi_d[3] = der(simpleChassis3D.dynamicLoad.phi[3]);
//   simpleChassis3D.dynamicLoad.phi_dd[1] = der(simpleChassis3D.dynamicLoad.phi_d[1]);
//   simpleChassis3D.dynamicLoad.phi_dd[2] = der(simpleChassis3D.dynamicLoad.phi_d[2]);
//   simpleChassis3D.dynamicLoad.phi_dd[3] = der(simpleChassis3D.dynamicLoad.phi_d[3]);
//   simpleChassis3D.dynamicLoad.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({simpleChassis3D.dynamicLoad.sequence_angleStates[1],simpleChassis3D.dynamicLoad.sequence_angleStates[2],simpleChassis3D.dynamicLoad.sequence_angleStates[3]},{simpleChassis3D.dynamicLoad.phi[1],simpleChassis3D.dynamicLoad.phi[2],simpleChassis3D.dynamicLoad.phi[3]},{simpleChassis3D.dynamicLoad.phi_d[1],simpleChassis3D.dynamicLoad.phi_d[2],simpleChassis3D.dynamicLoad.phi_d[3]});
//   simpleChassis3D.dynamicLoad.Q[1] = 0.0;
//   simpleChassis3D.dynamicLoad.Q[2] = 0.0;
//   simpleChassis3D.dynamicLoad.Q[3] = 0.0;
//   simpleChassis3D.dynamicLoad.Q[4] = 1.0;
//   end if;
//   simpleChassis3D.dynamicLoad.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({simpleChassis3D.dynamicLoad.frame_a.r_0[1],simpleChassis3D.dynamicLoad.frame_a.r_0[2],simpleChassis3D.dynamicLoad.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(simpleChassis3D.dynamicLoad.frame_a.R,{simpleChassis3D.dynamicLoad.r_CM[1],simpleChassis3D.dynamicLoad.r_CM[2],simpleChassis3D.dynamicLoad.r_CM[3]}),world.gravityType,Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13) * world.g,world.mue);
//   simpleChassis3D.dynamicLoad.v_0[1] = der(simpleChassis3D.dynamicLoad.frame_a.r_0[1]);
//   simpleChassis3D.dynamicLoad.v_0[2] = der(simpleChassis3D.dynamicLoad.frame_a.r_0[2]);
//   simpleChassis3D.dynamicLoad.v_0[3] = der(simpleChassis3D.dynamicLoad.frame_a.r_0[3]);
//   simpleChassis3D.dynamicLoad.a_0[1] = der(simpleChassis3D.dynamicLoad.v_0[1]);
//   simpleChassis3D.dynamicLoad.a_0[2] = der(simpleChassis3D.dynamicLoad.v_0[2]);
//   simpleChassis3D.dynamicLoad.a_0[3] = der(simpleChassis3D.dynamicLoad.v_0[3]);
//   simpleChassis3D.dynamicLoad.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(simpleChassis3D.dynamicLoad.frame_a.R);
//   simpleChassis3D.dynamicLoad.z_a[1] = der(simpleChassis3D.dynamicLoad.w_a[1]);
//   simpleChassis3D.dynamicLoad.z_a[2] = der(simpleChassis3D.dynamicLoad.w_a[2]);
//   simpleChassis3D.dynamicLoad.z_a[3] = der(simpleChassis3D.dynamicLoad.w_a[3]);
//   simpleChassis3D.dynamicLoad.frame_a.f = (Modelica.Mechanics.MultiBody.Frames.resolve2(simpleChassis3D.dynamicLoad.frame_a.R,{simpleChassis3D.dynamicLoad.a_0[1] - simpleChassis3D.dynamicLoad.g_0[1],simpleChassis3D.dynamicLoad.a_0[2] - simpleChassis3D.dynamicLoad.g_0[2],simpleChassis3D.dynamicLoad.a_0[3] - simpleChassis3D.dynamicLoad.g_0[3]}) + {simpleChassis3D.dynamicLoad.z_a[2] * simpleChassis3D.dynamicLoad.r_CM[3] - simpleChassis3D.dynamicLoad.z_a[3] * simpleChassis3D.dynamicLoad.r_CM[2],simpleChassis3D.dynamicLoad.z_a[3] * simpleChassis3D.dynamicLoad.r_CM[1] - simpleChassis3D.dynamicLoad.z_a[1] * simpleChassis3D.dynamicLoad.r_CM[3],simpleChassis3D.dynamicLoad.z_a[1] * simpleChassis3D.dynamicLoad.r_CM[2] - simpleChassis3D.dynamicLoad.z_a[2] * simpleChassis3D.dynamicLoad.r_CM[1]} + {simpleChassis3D.dynamicLoad.w_a[2] * (simpleChassis3D.dynamicLoad.w_a[1] * simpleChassis3D.dynamicLoad.r_CM[2] - simpleChassis3D.dynamicLoad.w_a[2] * simpleChassis3D.dynamicLoad.r_CM[1]) - simpleChassis3D.dynamicLoad.w_a[3] * (simpleChassis3D.dynamicLoad.w_a[3] * simpleChassis3D.dynamicLoad.r_CM[1] - simpleChassis3D.dynamicLoad.w_a[1] * simpleChassis3D.dynamicLoad.r_CM[3]),simpleChassis3D.dynamicLoad.w_a[3] * (simpleChassis3D.dynamicLoad.w_a[2] * simpleChassis3D.dynamicLoad.r_CM[3] - simpleChassis3D.dynamicLoad.w_a[3] * simpleChassis3D.dynamicLoad.r_CM[2]) - simpleChassis3D.dynamicLoad.w_a[1] * (simpleChassis3D.dynamicLoad.w_a[1] * simpleChassis3D.dynamicLoad.r_CM[2] - simpleChassis3D.dynamicLoad.w_a[2] * simpleChassis3D.dynamicLoad.r_CM[1]),simpleChassis3D.dynamicLoad.w_a[1] * (simpleChassis3D.dynamicLoad.w_a[3] * simpleChassis3D.dynamicLoad.r_CM[1] - simpleChassis3D.dynamicLoad.w_a[1] * simpleChassis3D.dynamicLoad.r_CM[3]) - simpleChassis3D.dynamicLoad.w_a[2] * (simpleChassis3D.dynamicLoad.w_a[2] * simpleChassis3D.dynamicLoad.r_CM[3] - simpleChassis3D.dynamicLoad.w_a[3] * simpleChassis3D.dynamicLoad.r_CM[2])}) * simpleChassis3D.dynamicLoad.m;
//   simpleChassis3D.dynamicLoad.frame_a.t[1] = simpleChassis3D.dynamicLoad.I[1,1] * simpleChassis3D.dynamicLoad.z_a[1] + simpleChassis3D.dynamicLoad.I[1,2] * simpleChassis3D.dynamicLoad.z_a[2] + simpleChassis3D.dynamicLoad.I[1,3] * simpleChassis3D.dynamicLoad.z_a[3] + (simpleChassis3D.dynamicLoad.w_a[2] * (simpleChassis3D.dynamicLoad.I[3,1] * simpleChassis3D.dynamicLoad.w_a[1] + simpleChassis3D.dynamicLoad.I[3,2] * simpleChassis3D.dynamicLoad.w_a[2] + simpleChassis3D.dynamicLoad.I[3,3] * simpleChassis3D.dynamicLoad.w_a[3]) - simpleChassis3D.dynamicLoad.w_a[3] * (simpleChassis3D.dynamicLoad.I[2,1] * simpleChassis3D.dynamicLoad.w_a[1] + simpleChassis3D.dynamicLoad.I[2,2] * simpleChassis3D.dynamicLoad.w_a[2] + simpleChassis3D.dynamicLoad.I[2,3] * simpleChassis3D.dynamicLoad.w_a[3])) + (simpleChassis3D.dynamicLoad.r_CM[2] * simpleChassis3D.dynamicLoad.frame_a.f[3] - simpleChassis3D.dynamicLoad.r_CM[3] * simpleChassis3D.dynamicLoad.frame_a.f[2]);
//   simpleChassis3D.dynamicLoad.frame_a.t[2] = simpleChassis3D.dynamicLoad.I[2,1] * simpleChassis3D.dynamicLoad.z_a[1] + simpleChassis3D.dynamicLoad.I[2,2] * simpleChassis3D.dynamicLoad.z_a[2] + simpleChassis3D.dynamicLoad.I[2,3] * simpleChassis3D.dynamicLoad.z_a[3] + (simpleChassis3D.dynamicLoad.w_a[3] * (simpleChassis3D.dynamicLoad.I[1,1] * simpleChassis3D.dynamicLoad.w_a[1] + simpleChassis3D.dynamicLoad.I[1,2] * simpleChassis3D.dynamicLoad.w_a[2] + simpleChassis3D.dynamicLoad.I[1,3] * simpleChassis3D.dynamicLoad.w_a[3]) - simpleChassis3D.dynamicLoad.w_a[1] * (simpleChassis3D.dynamicLoad.I[3,1] * simpleChassis3D.dynamicLoad.w_a[1] + simpleChassis3D.dynamicLoad.I[3,2] * simpleChassis3D.dynamicLoad.w_a[2] + simpleChassis3D.dynamicLoad.I[3,3] * simpleChassis3D.dynamicLoad.w_a[3])) + (simpleChassis3D.dynamicLoad.r_CM[3] * simpleChassis3D.dynamicLoad.frame_a.f[1] - simpleChassis3D.dynamicLoad.r_CM[1] * simpleChassis3D.dynamicLoad.frame_a.f[3]);
//   simpleChassis3D.dynamicLoad.frame_a.t[3] = simpleChassis3D.dynamicLoad.I[3,1] * simpleChassis3D.dynamicLoad.z_a[1] + simpleChassis3D.dynamicLoad.I[3,2] * simpleChassis3D.dynamicLoad.z_a[2] + simpleChassis3D.dynamicLoad.I[3,3] * simpleChassis3D.dynamicLoad.z_a[3] + (simpleChassis3D.dynamicLoad.w_a[1] * (simpleChassis3D.dynamicLoad.I[2,1] * simpleChassis3D.dynamicLoad.w_a[1] + simpleChassis3D.dynamicLoad.I[2,2] * simpleChassis3D.dynamicLoad.w_a[2] + simpleChassis3D.dynamicLoad.I[2,3] * simpleChassis3D.dynamicLoad.w_a[3]) - simpleChassis3D.dynamicLoad.w_a[2] * (simpleChassis3D.dynamicLoad.I[1,1] * simpleChassis3D.dynamicLoad.w_a[1] + simpleChassis3D.dynamicLoad.I[1,2] * simpleChassis3D.dynamicLoad.w_a[2] + simpleChassis3D.dynamicLoad.I[1,3] * simpleChassis3D.dynamicLoad.w_a[3])) + (simpleChassis3D.dynamicLoad.r_CM[1] * simpleChassis3D.dynamicLoad.frame_a.f[2] - simpleChassis3D.dynamicLoad.r_CM[2] * simpleChassis3D.dynamicLoad.frame_a.f[1]);
//   simpleChassis3D.rollSpringDamper.tau = simpleChassis3D.rollSpringDamper.c * (simpleChassis3D.rollSpringDamper.phi_rel - simpleChassis3D.rollSpringDamper.phi_rel0) + simpleChassis3D.rollSpringDamper.d * simpleChassis3D.rollSpringDamper.w_rel;
//   simpleChassis3D.rollSpringDamper.phi_rel = simpleChassis3D.rollSpringDamper.flange_b.phi - simpleChassis3D.rollSpringDamper.flange_a.phi;
//   simpleChassis3D.rollSpringDamper.w_rel = der(simpleChassis3D.rollSpringDamper.phi_rel);
//   simpleChassis3D.rollSpringDamper.a_rel = der(simpleChassis3D.rollSpringDamper.w_rel);
//   simpleChassis3D.rollSpringDamper.flange_b.tau = simpleChassis3D.rollSpringDamper.tau;
//   simpleChassis3D.rollSpringDamper.flange_a.tau = -simpleChassis3D.rollSpringDamper.tau;
//   simpleChassis3D.pitchSpringDamper.tau = simpleChassis3D.pitchSpringDamper.c * (simpleChassis3D.pitchSpringDamper.phi_rel - simpleChassis3D.pitchSpringDamper.phi_rel0) + simpleChassis3D.pitchSpringDamper.d * simpleChassis3D.pitchSpringDamper.w_rel;
//   simpleChassis3D.pitchSpringDamper.phi_rel = simpleChassis3D.pitchSpringDamper.flange_b.phi - simpleChassis3D.pitchSpringDamper.flange_a.phi;
//   simpleChassis3D.pitchSpringDamper.w_rel = der(simpleChassis3D.pitchSpringDamper.phi_rel);
//   simpleChassis3D.pitchSpringDamper.a_rel = der(simpleChassis3D.pitchSpringDamper.w_rel);
//   simpleChassis3D.pitchSpringDamper.flange_b.tau = simpleChassis3D.pitchSpringDamper.tau;
//   simpleChassis3D.pitchSpringDamper.flange_a.tau = -simpleChassis3D.pitchSpringDamper.tau;
//   simpleChassis3D.baseLoad.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(simpleChassis3D.baseLoad.sphere.shapeType);
//   simpleChassis3D.baseLoad.sphere.rxvisobj[1] = simpleChassis3D.baseLoad.sphere.R.T[1,1] * simpleChassis3D.baseLoad.sphere.e_x[1] + simpleChassis3D.baseLoad.sphere.R.T[2,1] * simpleChassis3D.baseLoad.sphere.e_x[2] + simpleChassis3D.baseLoad.sphere.R.T[3,1] * simpleChassis3D.baseLoad.sphere.e_x[3];
//   simpleChassis3D.baseLoad.sphere.rxvisobj[2] = simpleChassis3D.baseLoad.sphere.R.T[1,2] * simpleChassis3D.baseLoad.sphere.e_x[1] + simpleChassis3D.baseLoad.sphere.R.T[2,2] * simpleChassis3D.baseLoad.sphere.e_x[2] + simpleChassis3D.baseLoad.sphere.R.T[3,2] * simpleChassis3D.baseLoad.sphere.e_x[3];
//   simpleChassis3D.baseLoad.sphere.rxvisobj[3] = simpleChassis3D.baseLoad.sphere.R.T[1,3] * simpleChassis3D.baseLoad.sphere.e_x[1] + simpleChassis3D.baseLoad.sphere.R.T[2,3] * simpleChassis3D.baseLoad.sphere.e_x[2] + simpleChassis3D.baseLoad.sphere.R.T[3,3] * simpleChassis3D.baseLoad.sphere.e_x[3];
//   simpleChassis3D.baseLoad.sphere.ryvisobj[1] = simpleChassis3D.baseLoad.sphere.R.T[1,1] * simpleChassis3D.baseLoad.sphere.e_y[1] + simpleChassis3D.baseLoad.sphere.R.T[2,1] * simpleChassis3D.baseLoad.sphere.e_y[2] + simpleChassis3D.baseLoad.sphere.R.T[3,1] * simpleChassis3D.baseLoad.sphere.e_y[3];
//   simpleChassis3D.baseLoad.sphere.ryvisobj[2] = simpleChassis3D.baseLoad.sphere.R.T[1,2] * simpleChassis3D.baseLoad.sphere.e_y[1] + simpleChassis3D.baseLoad.sphere.R.T[2,2] * simpleChassis3D.baseLoad.sphere.e_y[2] + simpleChassis3D.baseLoad.sphere.R.T[3,2] * simpleChassis3D.baseLoad.sphere.e_y[3];
//   simpleChassis3D.baseLoad.sphere.ryvisobj[3] = simpleChassis3D.baseLoad.sphere.R.T[1,3] * simpleChassis3D.baseLoad.sphere.e_y[1] + simpleChassis3D.baseLoad.sphere.R.T[2,3] * simpleChassis3D.baseLoad.sphere.e_y[2] + simpleChassis3D.baseLoad.sphere.R.T[3,3] * simpleChassis3D.baseLoad.sphere.e_y[3];
//   simpleChassis3D.baseLoad.sphere.rvisobj = simpleChassis3D.baseLoad.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{simpleChassis3D.baseLoad.sphere.R.T[1,1],simpleChassis3D.baseLoad.sphere.R.T[1,2],simpleChassis3D.baseLoad.sphere.R.T[1,3]},{simpleChassis3D.baseLoad.sphere.R.T[2,1],simpleChassis3D.baseLoad.sphere.R.T[2,2],simpleChassis3D.baseLoad.sphere.R.T[2,3]},{simpleChassis3D.baseLoad.sphere.R.T[3,1],simpleChassis3D.baseLoad.sphere.R.T[3,2],simpleChassis3D.baseLoad.sphere.R.T[3,3]}},{simpleChassis3D.baseLoad.sphere.r_shape[1],simpleChassis3D.baseLoad.sphere.r_shape[2],simpleChassis3D.baseLoad.sphere.r_shape[3]});
//   simpleChassis3D.baseLoad.sphere.size[1] = simpleChassis3D.baseLoad.sphere.length;
//   simpleChassis3D.baseLoad.sphere.size[2] = simpleChassis3D.baseLoad.sphere.width;
//   simpleChassis3D.baseLoad.sphere.size[3] = simpleChassis3D.baseLoad.sphere.height;
//   simpleChassis3D.baseLoad.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(simpleChassis3D.baseLoad.sphere.color[1] / 255.0,simpleChassis3D.baseLoad.sphere.color[2] / 255.0,simpleChassis3D.baseLoad.sphere.color[3] / 255.0,simpleChassis3D.baseLoad.sphere.specularCoefficient);
//   simpleChassis3D.baseLoad.sphere.Extra = simpleChassis3D.baseLoad.sphere.extra;
//   simpleChassis3D.baseLoad.r[1] = simpleChassis3D.baseLoad.frame_a.x;
//   simpleChassis3D.baseLoad.r[2] = simpleChassis3D.baseLoad.frame_a.y;
//   simpleChassis3D.baseLoad.v[1] = der(simpleChassis3D.baseLoad.r[1]);
//   simpleChassis3D.baseLoad.v[2] = der(simpleChassis3D.baseLoad.r[2]);
//   simpleChassis3D.baseLoad.w = der(simpleChassis3D.baseLoad.frame_a.phi);
//   simpleChassis3D.baseLoad.a[1] = der(simpleChassis3D.baseLoad.v[1]);
//   simpleChassis3D.baseLoad.a[2] = der(simpleChassis3D.baseLoad.v[2]);
//   simpleChassis3D.baseLoad.z = der(simpleChassis3D.baseLoad.w);
//   simpleChassis3D.baseLoad.f[1] = simpleChassis3D.baseLoad.frame_a.fx;
//   simpleChassis3D.baseLoad.f[2] = simpleChassis3D.baseLoad.frame_a.fy;
//   simpleChassis3D.baseLoad.f[1] + simpleChassis3D.baseLoad.m * simpleChassis3D.baseLoad.g[1] = simpleChassis3D.baseLoad.m * simpleChassis3D.baseLoad.a[1];
//   simpleChassis3D.baseLoad.f[2] + simpleChassis3D.baseLoad.m * simpleChassis3D.baseLoad.g[2] = simpleChassis3D.baseLoad.m * simpleChassis3D.baseLoad.a[2];
//   simpleChassis3D.baseLoad.frame_a.t = simpleChassis3D.baseLoad.I * simpleChassis3D.baseLoad.z;
//   world.frame_b.t[1] = 0.0;
//   world.frame_b.t[2] = 0.0;
//   world.frame_b.t[3] = 0.0;
//   world.frame_b.f[1] = 0.0;
//   world.frame_b.f[2] = 0.0;
//   world.frame_b.f[3] = 0.0;
//   torque.flange.tau + rearAxis.flange_b.tau = 0.0;
//   rearAxis.frame_a.t + simpleChassis3D.frame_a.t = 0.0;
//   rearAxis.frame_a.fy + simpleChassis3D.frame_a.fy = 0.0;
//   rearAxis.frame_a.fx + simpleChassis3D.frame_a.fx = 0.0;
//   rearAxis.differentialGear.idealPlanetary.sun.tau + -rearAxis.differentialGear.flange_left.tau = 0.0;
//   rearAxis.differentialGear.idealPlanetary.carrier.tau + -rearAxis.differentialGear.flange_right.tau = 0.0;
//   rearAxis.differentialGear.idealPlanetary.ring.tau + -rearAxis.differentialGear.flange_b.tau = 0.0;
//   -rearAxis.flange_b.tau + rearAxis.differentialGear.flange_b.tau = 0.0;
//   rearAxis.differentialGear.flange_left.tau + rearAxis.inertia1.flange_b.tau + rearAxis.WheelJointLeft.flange_a.tau = 0.0;
//   rearAxis.differentialGear.flange_right.tau + rearAxis.inertia2.flange_b.tau + rearAxis.WheelJointRight.flange_a.tau = 0.0;
//   rearAxis.differentialGear.flange_b.phi = rearAxis.differentialGear.idealPlanetary.ring.phi;
//   rearAxis.differentialGear.flange_right.phi = rearAxis.differentialGear.idealPlanetary.carrier.phi;
//   rearAxis.differentialGear.flange_left.phi = rearAxis.differentialGear.idealPlanetary.sun.phi;
//   rearAxis.fixedTranslation2.frame_a.t + rearAxis.WheelJointLeft.frame_a.t = 0.0;
//   rearAxis.fixedTranslation2.frame_a.fy + rearAxis.WheelJointLeft.frame_a.fy = 0.0;
//   rearAxis.fixedTranslation2.frame_a.fx + rearAxis.WheelJointLeft.frame_a.fx = 0.0;
//   -rearAxis.frame_a.t + rearAxis.fixedTranslation2.frame_b.t + rearAxis.fixedTranslation1.frame_a.t = 0.0;
//   -rearAxis.frame_a.fy + rearAxis.fixedTranslation2.frame_b.fy + rearAxis.fixedTranslation1.frame_a.fy = 0.0;
//   -rearAxis.frame_a.fx + rearAxis.fixedTranslation2.frame_b.fx + rearAxis.fixedTranslation1.frame_a.fx = 0.0;
//   rearAxis.fixedTranslation1.frame_b.t + rearAxis.WheelJointRight.frame_a.t = 0.0;
//   rearAxis.fixedTranslation1.frame_b.fy + rearAxis.WheelJointRight.frame_a.fy = 0.0;
//   rearAxis.fixedTranslation1.frame_b.fx + rearAxis.WheelJointRight.frame_a.fx = 0.0;
//   rearAxis.inertia1.flange_a.tau = 0.0;
//   rearAxis.inertia2.flange_a.tau = 0.0;
//   rearAxis.WheelJointLeft.flange_a.phi = rearAxis.differentialGear.flange_left.phi;
//   rearAxis.WheelJointLeft.flange_a.phi = rearAxis.inertia1.flange_b.phi;
//   rearAxis.WheelJointLeft.frame_a.x = rearAxis.fixedTranslation2.frame_a.x;
//   rearAxis.WheelJointLeft.frame_a.y = rearAxis.fixedTranslation2.frame_a.y;
//   rearAxis.WheelJointLeft.frame_a.phi = rearAxis.fixedTranslation2.frame_a.phi;
//   rearAxis.WheelJointRight.flange_a.phi = rearAxis.differentialGear.flange_right.phi;
//   rearAxis.WheelJointRight.flange_a.phi = rearAxis.inertia2.flange_b.phi;
//   rearAxis.WheelJointRight.frame_a.x = rearAxis.fixedTranslation1.frame_b.x;
//   rearAxis.WheelJointRight.frame_a.y = rearAxis.fixedTranslation1.frame_b.y;
//   rearAxis.WheelJointRight.frame_a.phi = rearAxis.fixedTranslation1.frame_b.phi;
//   rearAxis.fixedTranslation1.frame_a.x = rearAxis.fixedTranslation2.frame_b.x;
//   rearAxis.fixedTranslation1.frame_a.x = rearAxis.frame_a.x;
//   rearAxis.fixedTranslation1.frame_a.y = rearAxis.fixedTranslation2.frame_b.y;
//   rearAxis.fixedTranslation1.frame_a.y = rearAxis.frame_a.y;
//   rearAxis.fixedTranslation1.frame_a.phi = rearAxis.fixedTranslation2.frame_b.phi;
//   rearAxis.fixedTranslation1.frame_a.phi = rearAxis.frame_a.phi;
//   rearAxis.differentialGear.flange_b.phi = rearAxis.flange_b.phi;
//   frontAxis.flange_b.tau + torque1.flange.tau = 0.0;
//   frontAxis.frame_a.t + simpleChassis3D.frame_b.t = 0.0;
//   frontAxis.frame_a.fy + simpleChassis3D.frame_b.fy = 0.0;
//   frontAxis.frame_a.fx + simpleChassis3D.frame_b.fx = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.t + frontAxis.leftTrail.frame_a.t = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.fy + frontAxis.leftTrail.frame_a.fy = 0.0;
//   frontAxis.leftSteeringRevolute.frame_a.fx + frontAxis.leftTrail.frame_a.fx = 0.0;
//   frontAxis.leftSteeringRevolute.frame_b.t + frontAxis.leftAxis.frame_a.t = 0.0;
//   frontAxis.leftSteeringRevolute.frame_b.fy + frontAxis.leftAxis.frame_a.fy = 0.0;
//   frontAxis.leftSteeringRevolute.frame_b.fx + frontAxis.leftAxis.frame_a.fx = 0.0;
//   frontAxis.leftSteeringRevolute.flange_a.tau + frontAxis.rightSteeringRevolute.flange_a.tau + frontAxis.SteeringInertia.flange_b.tau = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.t + frontAxis.rigthtTrail.frame_a.t = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.fy + frontAxis.rigthtTrail.frame_a.fy = 0.0;
//   frontAxis.rightSteeringRevolute.frame_a.fx + frontAxis.rigthtTrail.frame_a.fx = 0.0;
//   frontAxis.rightSteeringRevolute.frame_b.t + frontAxis.rightAxis.frame_b.t = 0.0;
//   frontAxis.rightSteeringRevolute.frame_b.fy + frontAxis.rightAxis.frame_b.fy = 0.0;
//   frontAxis.rightSteeringRevolute.frame_b.fx + frontAxis.rightAxis.frame_b.fx = 0.0;
//   -frontAxis.frame_a.t + frontAxis.leftAxis.frame_b.t + frontAxis.rightAxis.frame_a.t = 0.0;
//   -frontAxis.frame_a.fy + frontAxis.leftAxis.frame_b.fy + frontAxis.rightAxis.frame_a.fy = 0.0;
//   -frontAxis.frame_a.fx + frontAxis.leftAxis.frame_b.fx + frontAxis.rightAxis.frame_a.fx = 0.0;
//   frontAxis.leftTrail.frame_b.t + frontAxis.WheelJointLeft.frame_a.t = 0.0;
//   frontAxis.leftTrail.frame_b.fy + frontAxis.WheelJointLeft.frame_a.fy = 0.0;
//   frontAxis.leftTrail.frame_b.fx + frontAxis.WheelJointLeft.frame_a.fx = 0.0;
//   frontAxis.rigthtTrail.frame_b.t + frontAxis.WheelJointRight.frame_a.t = 0.0;
//   frontAxis.rigthtTrail.frame_b.fy + frontAxis.WheelJointRight.frame_a.fy = 0.0;
//   frontAxis.rigthtTrail.frame_b.fx + frontAxis.WheelJointRight.frame_a.fx = 0.0;
//   frontAxis.leftInertia.flange_a.tau = 0.0;
//   frontAxis.leftInertia.flange_b.tau + frontAxis.WheelJointLeft.flange_a.tau = 0.0;
//   frontAxis.rightInertia.flange_a.tau = 0.0;
//   frontAxis.rightInertia.flange_b.tau + frontAxis.WheelJointRight.flange_a.tau = 0.0;
//   -frontAxis.flange_b.tau + frontAxis.SteeringInertia.flange_a.tau = 0.0;
//   frontAxis.WheelJointLeft.flange_a.phi = frontAxis.leftInertia.flange_b.phi;
//   frontAxis.WheelJointRight.flange_a.phi = frontAxis.rightInertia.flange_b.phi;
//   frontAxis.frame_a.x = frontAxis.leftAxis.frame_b.x;
//   frontAxis.frame_a.x = frontAxis.rightAxis.frame_a.x;
//   frontAxis.frame_a.y = frontAxis.leftAxis.frame_b.y;
//   frontAxis.frame_a.y = frontAxis.rightAxis.frame_a.y;
//   frontAxis.frame_a.phi = frontAxis.leftAxis.frame_b.phi;
//   frontAxis.frame_a.phi = frontAxis.rightAxis.frame_a.phi;
//   frontAxis.SteeringInertia.flange_b.phi = frontAxis.leftSteeringRevolute.flange_a.phi;
//   frontAxis.SteeringInertia.flange_b.phi = frontAxis.rightSteeringRevolute.flange_a.phi;
//   frontAxis.leftAxis.frame_a.x = frontAxis.leftSteeringRevolute.frame_b.x;
//   frontAxis.leftAxis.frame_a.y = frontAxis.leftSteeringRevolute.frame_b.y;
//   frontAxis.leftAxis.frame_a.phi = frontAxis.leftSteeringRevolute.frame_b.phi;
//   frontAxis.rightAxis.frame_b.x = frontAxis.rightSteeringRevolute.frame_b.x;
//   frontAxis.rightAxis.frame_b.y = frontAxis.rightSteeringRevolute.frame_b.y;
//   frontAxis.rightAxis.frame_b.phi = frontAxis.rightSteeringRevolute.frame_b.phi;
//   frontAxis.SteeringInertia.flange_a.phi = frontAxis.flange_b.phi;
//   frontAxis.leftSteeringRevolute.frame_a.x = frontAxis.leftTrail.frame_a.x;
//   frontAxis.leftSteeringRevolute.frame_a.y = frontAxis.leftTrail.frame_a.y;
//   frontAxis.leftSteeringRevolute.frame_a.phi = frontAxis.leftTrail.frame_a.phi;
//   frontAxis.WheelJointLeft.frame_a.x = frontAxis.leftTrail.frame_b.x;
//   frontAxis.WheelJointLeft.frame_a.y = frontAxis.leftTrail.frame_b.y;
//   frontAxis.WheelJointLeft.frame_a.phi = frontAxis.leftTrail.frame_b.phi;
//   frontAxis.rightSteeringRevolute.frame_a.x = frontAxis.rigthtTrail.frame_a.x;
//   frontAxis.rightSteeringRevolute.frame_a.y = frontAxis.rigthtTrail.frame_a.y;
//   frontAxis.rightSteeringRevolute.frame_a.phi = frontAxis.rigthtTrail.frame_a.phi;
//   frontAxis.WheelJointRight.frame_a.x = frontAxis.rigthtTrail.frame_b.x;
//   frontAxis.WheelJointRight.frame_a.y = frontAxis.rigthtTrail.frame_b.y;
//   frontAxis.WheelJointRight.frame_a.phi = frontAxis.rigthtTrail.frame_b.phi;
//   simpleChassis3D.planarToMultiBody.frame_a.t + simpleChassis3D.fixedTranslationFront.frame_a.t + simpleChassis3D.fixedTranslationRear.frame_b.t + simpleChassis3D.baseLoad.frame_a.t = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_a.fy + simpleChassis3D.fixedTranslationFront.frame_a.fy + simpleChassis3D.fixedTranslationRear.frame_b.fy + simpleChassis3D.baseLoad.frame_a.fy = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_a.fx + simpleChassis3D.fixedTranslationFront.frame_a.fx + simpleChassis3D.fixedTranslationRear.frame_b.fx + simpleChassis3D.baseLoad.frame_a.fx = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.t[1] + simpleChassis3D.roll.frame_a.t[1] = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.t[2] + simpleChassis3D.roll.frame_a.t[2] = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.t[3] + simpleChassis3D.roll.frame_a.t[3] = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.f[1] + simpleChassis3D.roll.frame_a.f[1] = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.f[2] + simpleChassis3D.roll.frame_a.f[2] = 0.0;
//   simpleChassis3D.planarToMultiBody.frame_b.f[3] + simpleChassis3D.roll.frame_a.f[3] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_a.t[1] + simpleChassis3D.pitch.frame_b.t[1] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_a.t[2] + simpleChassis3D.pitch.frame_b.t[2] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_a.t[3] + simpleChassis3D.pitch.frame_b.t[3] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_a.f[1] + simpleChassis3D.pitch.frame_b.f[1] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_a.f[2] + simpleChassis3D.pitch.frame_b.f[2] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_a.f[3] + simpleChassis3D.pitch.frame_b.f[3] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_b.t[1] + simpleChassis3D.dynamicLoad.frame_a.t[1] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_b.t[2] + simpleChassis3D.dynamicLoad.frame_a.t[2] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_b.t[3] + simpleChassis3D.dynamicLoad.frame_a.t[3] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_b.f[1] + simpleChassis3D.dynamicLoad.frame_a.f[1] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_b.f[2] + simpleChassis3D.dynamicLoad.frame_a.f[2] = 0.0;
//   simpleChassis3D.toCenterOfGravity.frame_b.f[3] + simpleChassis3D.dynamicLoad.frame_a.f[3] = 0.0;
//   simpleChassis3D.roll.frame_b.t[1] + simpleChassis3D.pitch.frame_a.t[1] = 0.0;
//   simpleChassis3D.roll.frame_b.t[2] + simpleChassis3D.pitch.frame_a.t[2] = 0.0;
//   simpleChassis3D.roll.frame_b.t[3] + simpleChassis3D.pitch.frame_a.t[3] = 0.0;
//   simpleChassis3D.roll.frame_b.f[1] + simpleChassis3D.pitch.frame_a.f[1] = 0.0;
//   simpleChassis3D.roll.frame_b.f[2] + simpleChassis3D.pitch.frame_a.f[2] = 0.0;
//   simpleChassis3D.roll.frame_b.f[3] + simpleChassis3D.pitch.frame_a.f[3] = 0.0;
//   simpleChassis3D.roll.fixed.flange.tau + -simpleChassis3D.roll.support.tau = 0.0;
//   simpleChassis3D.roll.axis.tau + simpleChassis3D.rollSpringDamper.flange_b.tau = 0.0;
//   simpleChassis3D.roll.support.tau + simpleChassis3D.rollSpringDamper.flange_a.tau = 0.0;
//   -simpleChassis3D.roll.axis.tau + simpleChassis3D.roll.internalAxis.flange.tau = 0.0;
//   simpleChassis3D.roll.fixed.flange.phi = simpleChassis3D.roll.support.phi;
//   simpleChassis3D.roll.axis.phi = simpleChassis3D.roll.internalAxis.flange.phi;
//   simpleChassis3D.pitch.fixed.flange.tau + -simpleChassis3D.pitch.support.tau = 0.0;
//   simpleChassis3D.pitch.axis.tau + simpleChassis3D.pitchSpringDamper.flange_b.tau = 0.0;
//   simpleChassis3D.pitch.support.tau + simpleChassis3D.pitchSpringDamper.flange_a.tau = 0.0;
//   -simpleChassis3D.pitch.axis.tau + simpleChassis3D.pitch.internalAxis.flange.tau = 0.0;
//   simpleChassis3D.pitch.fixed.flange.phi = simpleChassis3D.pitch.support.phi;
//   simpleChassis3D.pitch.axis.phi = simpleChassis3D.pitch.internalAxis.flange.phi;
//   -simpleChassis3D.frame_b.t + simpleChassis3D.fixedTranslationFront.frame_b.t = 0.0;
//   -simpleChassis3D.frame_b.fy + simpleChassis3D.fixedTranslationFront.frame_b.fy = 0.0;
//   -simpleChassis3D.frame_b.fx + simpleChassis3D.fixedTranslationFront.frame_b.fx = 0.0;
//   -simpleChassis3D.frame_a.t + simpleChassis3D.fixedTranslationRear.frame_a.t = 0.0;
//   -simpleChassis3D.frame_a.fy + simpleChassis3D.fixedTranslationRear.frame_a.fy = 0.0;
//   -simpleChassis3D.frame_a.fx + simpleChassis3D.fixedTranslationRear.frame_a.fx = 0.0;
//   simpleChassis3D.baseLoad.frame_a.x = simpleChassis3D.fixedTranslationFront.frame_a.x;
//   simpleChassis3D.baseLoad.frame_a.x = simpleChassis3D.fixedTranslationRear.frame_b.x;
//   simpleChassis3D.baseLoad.frame_a.x = simpleChassis3D.planarToMultiBody.frame_a.x;
//   simpleChassis3D.baseLoad.frame_a.y = simpleChassis3D.fixedTranslationFront.frame_a.y;
//   simpleChassis3D.baseLoad.frame_a.y = simpleChassis3D.fixedTranslationRear.frame_b.y;
//   simpleChassis3D.baseLoad.frame_a.y = simpleChassis3D.planarToMultiBody.frame_a.y;
//   simpleChassis3D.baseLoad.frame_a.phi = simpleChassis3D.fixedTranslationFront.frame_a.phi;
//   simpleChassis3D.baseLoad.frame_a.phi = simpleChassis3D.fixedTranslationRear.frame_b.phi;
//   simpleChassis3D.baseLoad.frame_a.phi = simpleChassis3D.planarToMultiBody.frame_a.phi;
//   simpleChassis3D.planarToMultiBody.frame_b.r_0[3] = simpleChassis3D.roll.frame_a.r_0[3];
//   simpleChassis3D.planarToMultiBody.frame_b.r_0[2] = simpleChassis3D.roll.frame_a.r_0[2];
//   simpleChassis3D.planarToMultiBody.frame_b.r_0[1] = simpleChassis3D.roll.frame_a.r_0[1];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[3,3] = simpleChassis3D.roll.frame_a.R.T[3,3];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[3,2] = simpleChassis3D.roll.frame_a.R.T[3,2];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[3,1] = simpleChassis3D.roll.frame_a.R.T[3,1];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[2,3] = simpleChassis3D.roll.frame_a.R.T[2,3];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[2,2] = simpleChassis3D.roll.frame_a.R.T[2,2];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[2,1] = simpleChassis3D.roll.frame_a.R.T[2,1];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[1,3] = simpleChassis3D.roll.frame_a.R.T[1,3];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[1,2] = simpleChassis3D.roll.frame_a.R.T[1,2];
//   simpleChassis3D.planarToMultiBody.frame_b.R.T[1,1] = simpleChassis3D.roll.frame_a.R.T[1,1];
//   simpleChassis3D.planarToMultiBody.frame_b.R.w[3] = simpleChassis3D.roll.frame_a.R.w[3];
//   simpleChassis3D.planarToMultiBody.frame_b.R.w[2] = simpleChassis3D.roll.frame_a.R.w[2];
//   simpleChassis3D.planarToMultiBody.frame_b.R.w[1] = simpleChassis3D.roll.frame_a.R.w[1];
//   simpleChassis3D.dynamicLoad.frame_a.r_0[3] = simpleChassis3D.toCenterOfGravity.frame_b.r_0[3];
//   simpleChassis3D.dynamicLoad.frame_a.r_0[2] = simpleChassis3D.toCenterOfGravity.frame_b.r_0[2];
//   simpleChassis3D.dynamicLoad.frame_a.r_0[1] = simpleChassis3D.toCenterOfGravity.frame_b.r_0[1];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[3,3] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,3];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[3,2] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,2];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[3,1] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[3,1];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[2,3] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,3];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[2,2] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,2];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[2,1] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[2,1];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[1,3] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,3];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[1,2] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,2];
//   simpleChassis3D.dynamicLoad.frame_a.R.T[1,1] = simpleChassis3D.toCenterOfGravity.frame_b.R.T[1,1];
//   simpleChassis3D.dynamicLoad.frame_a.R.w[3] = simpleChassis3D.toCenterOfGravity.frame_b.R.w[3];
//   simpleChassis3D.dynamicLoad.frame_a.R.w[2] = simpleChassis3D.toCenterOfGravity.frame_b.R.w[2];
//   simpleChassis3D.dynamicLoad.frame_a.R.w[1] = simpleChassis3D.toCenterOfGravity.frame_b.R.w[1];
//   simpleChassis3D.pitch.frame_a.r_0[3] = simpleChassis3D.roll.frame_b.r_0[3];
//   simpleChassis3D.pitch.frame_a.r_0[2] = simpleChassis3D.roll.frame_b.r_0[2];
//   simpleChassis3D.pitch.frame_a.r_0[1] = simpleChassis3D.roll.frame_b.r_0[1];
//   simpleChassis3D.pitch.frame_a.R.T[3,3] = simpleChassis3D.roll.frame_b.R.T[3,3];
//   simpleChassis3D.pitch.frame_a.R.T[3,2] = simpleChassis3D.roll.frame_b.R.T[3,2];
//   simpleChassis3D.pitch.frame_a.R.T[3,1] = simpleChassis3D.roll.frame_b.R.T[3,1];
//   simpleChassis3D.pitch.frame_a.R.T[2,3] = simpleChassis3D.roll.frame_b.R.T[2,3];
//   simpleChassis3D.pitch.frame_a.R.T[2,2] = simpleChassis3D.roll.frame_b.R.T[2,2];
//   simpleChassis3D.pitch.frame_a.R.T[2,1] = simpleChassis3D.roll.frame_b.R.T[2,1];
//   simpleChassis3D.pitch.frame_a.R.T[1,3] = simpleChassis3D.roll.frame_b.R.T[1,3];
//   simpleChassis3D.pitch.frame_a.R.T[1,2] = simpleChassis3D.roll.frame_b.R.T[1,2];
//   simpleChassis3D.pitch.frame_a.R.T[1,1] = simpleChassis3D.roll.frame_b.R.T[1,1];
//   simpleChassis3D.pitch.frame_a.R.w[3] = simpleChassis3D.roll.frame_b.R.w[3];
//   simpleChassis3D.pitch.frame_a.R.w[2] = simpleChassis3D.roll.frame_b.R.w[2];
//   simpleChassis3D.pitch.frame_a.R.w[1] = simpleChassis3D.roll.frame_b.R.w[1];
//   simpleChassis3D.pitch.frame_b.r_0[3] = simpleChassis3D.toCenterOfGravity.frame_a.r_0[3];
//   simpleChassis3D.pitch.frame_b.r_0[2] = simpleChassis3D.toCenterOfGravity.frame_a.r_0[2];
//   simpleChassis3D.pitch.frame_b.r_0[1] = simpleChassis3D.toCenterOfGravity.frame_a.r_0[1];
//   simpleChassis3D.pitch.frame_b.R.T[3,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,3];
//   simpleChassis3D.pitch.frame_b.R.T[3,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,2];
//   simpleChassis3D.pitch.frame_b.R.T[3,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[3,1];
//   simpleChassis3D.pitch.frame_b.R.T[2,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,3];
//   simpleChassis3D.pitch.frame_b.R.T[2,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,2];
//   simpleChassis3D.pitch.frame_b.R.T[2,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[2,1];
//   simpleChassis3D.pitch.frame_b.R.T[1,3] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,3];
//   simpleChassis3D.pitch.frame_b.R.T[1,2] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,2];
//   simpleChassis3D.pitch.frame_b.R.T[1,1] = simpleChassis3D.toCenterOfGravity.frame_a.R.T[1,1];
//   simpleChassis3D.pitch.frame_b.R.w[3] = simpleChassis3D.toCenterOfGravity.frame_a.R.w[3];
//   simpleChassis3D.pitch.frame_b.R.w[2] = simpleChassis3D.toCenterOfGravity.frame_a.R.w[2];
//   simpleChassis3D.pitch.frame_b.R.w[1] = simpleChassis3D.toCenterOfGravity.frame_a.R.w[1];
//   simpleChassis3D.fixedTranslationFront.frame_b.x = simpleChassis3D.frame_b.x;
//   simpleChassis3D.fixedTranslationFront.frame_b.y = simpleChassis3D.frame_b.y;
//   simpleChassis3D.fixedTranslationFront.frame_b.phi = simpleChassis3D.frame_b.phi;
//   simpleChassis3D.fixedTranslationRear.frame_a.x = simpleChassis3D.frame_a.x;
//   simpleChassis3D.fixedTranslationRear.frame_a.y = simpleChassis3D.frame_a.y;
//   simpleChassis3D.fixedTranslationRear.frame_a.phi = simpleChassis3D.frame_a.phi;
//   simpleChassis3D.pitch.support.phi = simpleChassis3D.pitchSpringDamper.flange_a.phi;
//   simpleChassis3D.roll.axis.phi = simpleChassis3D.rollSpringDamper.flange_b.phi;
//   simpleChassis3D.pitch.axis.phi = simpleChassis3D.pitchSpringDamper.flange_b.phi;
//   simpleChassis3D.roll.support.phi = simpleChassis3D.rollSpringDamper.flange_a.phi;
//   frontAxis.flange_b.phi = torque1.flange.phi;
//   rearAxis.frame_a.x = simpleChassis3D.frame_a.x;
//   rearAxis.frame_a.y = simpleChassis3D.frame_a.y;
//   rearAxis.frame_a.phi = simpleChassis3D.frame_a.phi;
//   frontAxis.frame_a.x = simpleChassis3D.frame_b.x;
//   frontAxis.frame_a.y = simpleChassis3D.frame_b.y;
//   frontAxis.frame_a.phi = simpleChassis3D.frame_b.phi;
//   rearAxis.flange_b.phi = torque.flange.phi;
//   ramp.y = torque.tau;
//   pulse.y = torque1.tau;
// end PlanarMechanicsV4.Examples.TwoTrackStaticLoad3D;
// "
// "[parts.mo:600:5-603:76:writable] Warning: Variable simpleChassis3D.dynamicLoad.r_0: Non-array modification 'if simpleChassis3D.dynamicLoad.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable simpleChassis3D.dynamicLoad.v_0: Non-array modification 'if simpleChassis3D.dynamicLoad.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable simpleChassis3D.dynamicLoad.w_a: Non-array modification 'if simpleChassis3D.dynamicLoad.enforceStates then if simpleChassis3D.dynamicLoad.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable simpleChassis3D.dynamicLoad.Q: Non-array modification 'if simpleChassis3D.dynamicLoad.enforceStates then if simpleChassis3D.dynamicLoad.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable simpleChassis3D.dynamicLoad.phi: Non-array modification 'if simpleChassis3D.dynamicLoad.enforceStates then if simpleChassis3D.dynamicLoad.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable simpleChassis3D.dynamicLoad.phi_d: Non-array modification 'if simpleChassis3D.dynamicLoad.enforceStates then if simpleChassis3D.dynamicLoad.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// "
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.ControlledCraneCrab
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 70.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 2.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 250.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.0 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0);
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   Real angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real angleSensor.phi \"Absolute angle of flange\";
//   Real actuatedRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.69813170079773;
//   parameter Real actuatedRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real actuatedRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real actuatedRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute.animate = true \"enable Animation\";
//   Real actuatedRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute.cylinder.lengthDirection[1],actuatedRevolute.cylinder.lengthDirection[2],actuatedRevolute.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else actuatedRevolute.cylinder.lengthDirection[1] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute.cylinder.lengthDirection[2] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute.cylinder.lengthDirection[3] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[3] - actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[2];
//   protected Real actuatedRevolute.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[1] - actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[3];
//   protected Real actuatedRevolute.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[2] - actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[1];
//   protected Real actuatedRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute.cylinder.Form;
//   output Real actuatedRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.Material;
//   protected output Real actuatedRevolute.cylinder.Extra;
//   parameter Boolean force.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real force.s(quantity = \"Length\", unit = \"m\") = force.flange.s - force.s_support \"distance between flange and support (= flange.s - support.s)\";
//   Real force.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real force.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   protected Real force.s_support(quantity = \"Length\", unit = \"m\") \"Absolute position of support flange\";
//   input Real force.f \"driving force as input signal\";
//   input Real PID.u \"Connector of Real input signal\";
//   output Real PID.y \"Connector of Real output signal\";
//   parameter Real PID.k = 15696.0 \"Gain\";
//   parameter Real PID.Ti(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 0.5) = 1000000000000 \"Time Constant of Integrator\";
//   parameter Real PID.Td(quantity = \"Time\", unit = \"s\", min = 0.0, start = 0.1) = 0.2 \"Time Constant of Derivative block\";
//   parameter Real PID.Nd(min = 1e-60) = 10.0 \"The higher Nd, the more ideal the derivative block\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput, DoNotUse_InitialIntegratorState) PID.initType = Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real PID.xi_start = 0.0 \"Initial or guess value value for integrator output (= integrator state)\";
//   parameter Real PID.xd_start = 0.0 \"Initial or guess value for state of derivative block\";
//   parameter Real PID.y_start = 0.0 \"Initial value of output\";
//   parameter Real PID.P.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real PID.P.u \"Input signal connector\";
//   output Real PID.P.y \"Output signal connector\";
//   input Real PID.I.u \"Connector of Real input signal\";
//   parameter Real PID.I.k = 1.0 / PID.Ti \"Integrator gain\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) PID.I.initType = if PID.initType == Modelica.Blocks.Types.InitPID.SteadyState then Modelica.Blocks.Types.Init.SteadyState else if PID.initType == Modelica.Blocks.Types.InitPID.InitialState or PID.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState then Modelica.Blocks.Types.Init.InitialState else Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\";
//   parameter Real PID.I.y_start = PID.xi_start \"Initial or guess value of output (= state)\";
//   output Real PID.I.y(start = PID.I.y_start) \"Connector of Real output signal\";
//   input Real PID.D.u \"Connector of Real input signal\";
//   output Real PID.D.y \"Connector of Real output signal\";
//   parameter Real PID.D.k = PID.Td \"Gains\";
//   parameter Real PID.D.T(quantity = \"Time\", unit = \"s\", min = 1e-60) = max({{PID.Td / PID.Nd,1e-13}}) \"Time constants (T>0 required; T=0 is ideal derivative block)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) PID.D.initType = if PID.initType == Modelica.Blocks.Types.InitPID.SteadyState or PID.initType == Modelica.Blocks.Types.InitPID.InitialOutput then Modelica.Blocks.Types.Init.SteadyState else if PID.initType == Modelica.Blocks.Types.InitPID.InitialState then Modelica.Blocks.Types.Init.InitialState else Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real PID.D.x_start = PID.xd_start \"Initial or guess value of state\";
//   parameter Real PID.D.y_start = 0.0 \"Initial value of output (= state)\";
//   protected parameter Boolean PID.D.zeroGain = abs(PID.D.k) < 1e-15;
//   output Real PID.D.x(start = PID.D.x_start) \"State of block\";
//   parameter Real PID.Add.k1 = 1.0 \"Gain of upper input\";
//   parameter Real PID.Add.k2 = 1.0 \"Gain of middle input\";
//   parameter Real PID.Add.k3 = 1.0 \"Gain of lower input\";
//   input Real PID.Add.u1 \"Connector 1 of Real input signals\";
//   input Real PID.Add.u2 \"Connector 2 of Real input signals\";
//   input Real PID.Add.u3 \"Connector 3 of Real input signals\";
//   output Real PID.Add.y \"Connector of Real output signals\";
//   parameter Real PID.Gain.k(start = 1.0) = PID.k \"Gain value multiplied with input signal\";
//   input Real PID.Gain.u \"Input signal connector\";
//   output Real PID.Gain.y \"Output signal connector\";
// initial equation
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
//   actuatedRevolute.phi = actuatedRevolute.phi_start;
//   actuatedRevolute.w = actuatedRevolute.w_start;
//   PID.I.y = PID.I.y_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.r0[1] = actuatedPrismatic.s * (actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2]);
//   actuatedPrismatic.r0[2] = actuatedPrismatic.s * (actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2]);
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * (actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2]) + actuatedPrismatic.frame_a.fy * (actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2]) = actuatedPrismatic.f;
//   angleSensor.phi = angleSensor.flange.phi;
//   0.0 = angleSensor.flange.tau;
//   actuatedRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute.cylinder.shapeType);
//   actuatedRevolute.cylinder.rxvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.ryvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.rvisobj = actuatedRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute.cylinder.R.T[1,1],actuatedRevolute.cylinder.R.T[1,2],actuatedRevolute.cylinder.R.T[1,3]},{actuatedRevolute.cylinder.R.T[2,1],actuatedRevolute.cylinder.R.T[2,2],actuatedRevolute.cylinder.R.T[2,3]},{actuatedRevolute.cylinder.R.T[3,1],actuatedRevolute.cylinder.R.T[3,2],actuatedRevolute.cylinder.R.T[3,3]}},{actuatedRevolute.cylinder.r_shape[1],actuatedRevolute.cylinder.r_shape[2],actuatedRevolute.cylinder.r_shape[3]});
//   actuatedRevolute.cylinder.size[1] = actuatedRevolute.cylinder.length;
//   actuatedRevolute.cylinder.size[2] = actuatedRevolute.cylinder.width;
//   actuatedRevolute.cylinder.size[3] = actuatedRevolute.cylinder.height;
//   actuatedRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute.cylinder.color[1] / 255.0,actuatedRevolute.cylinder.color[2] / 255.0,actuatedRevolute.cylinder.color[3] / 255.0,actuatedRevolute.cylinder.specularCoefficient);
//   actuatedRevolute.cylinder.Extra = actuatedRevolute.cylinder.extra;
//   actuatedRevolute.phi = actuatedRevolute.flange_a.phi;
//   actuatedRevolute.w = der(actuatedRevolute.phi);
//   actuatedRevolute.z = der(actuatedRevolute.w);
//   actuatedRevolute.t = actuatedRevolute.flange_a.tau;
//   actuatedRevolute.frame_a.x = actuatedRevolute.frame_b.x;
//   actuatedRevolute.frame_a.y = actuatedRevolute.frame_b.y;
//   actuatedRevolute.frame_a.phi + actuatedRevolute.phi = actuatedRevolute.frame_b.phi;
//   actuatedRevolute.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   actuatedRevolute.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   actuatedRevolute.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   actuatedRevolute.frame_a.t = actuatedRevolute.t;
//   force.flange.f = -force.f;
//   force.s_support = 0.0;
//   PID.P.y = PID.P.k * PID.P.u;
//   der(PID.I.y) = PID.I.k * PID.I.u;
//   der(PID.D.x) = if PID.D.zeroGain then 0.0 else (PID.D.u - PID.D.x) / PID.D.T;
//   PID.D.y = if PID.D.zeroGain then 0.0 else ((PID.D.u - PID.D.x) * PID.D.k) / PID.D.T;
//   PID.Add.y = PID.Add.k1 * PID.Add.u1 + (PID.Add.k2 * PID.Add.u2 + PID.Add.k3 * PID.Add.u3);
//   PID.Gain.y = PID.Gain.k * PID.Gain.u;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   fixedTranslation.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   body1.frame_a.t + actuatedPrismatic.frame_b.t + actuatedRevolute.frame_a.t = 0.0;
//   body1.frame_a.fy + actuatedPrismatic.frame_b.fy + actuatedRevolute.frame_a.fy = 0.0;
//   body1.frame_a.fx + actuatedPrismatic.frame_b.fx + actuatedRevolute.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + force.flange.f = 0.0;
//   angleSensor.flange.tau + actuatedRevolute.flange_a.tau = 0.0;
//   PID.D.u = PID.I.u;
//   PID.D.u = PID.P.u;
//   PID.D.u = PID.u;
//   PID.Add.u1 = PID.P.y;
//   PID.Add.u2 = PID.I.y;
//   PID.Add.u3 = PID.D.y;
//   PID.Add.y = PID.Gain.u;
//   PID.Gain.y = PID.y;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_b.x = actuatedRevolute.frame_a.x;
//   actuatedPrismatic.frame_b.x = body1.frame_a.x;
//   actuatedPrismatic.frame_b.y = actuatedRevolute.frame_a.y;
//   actuatedPrismatic.frame_b.y = body1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = actuatedRevolute.frame_a.phi;
//   actuatedPrismatic.frame_b.phi = body1.frame_a.phi;
//   actuatedRevolute.frame_b.x = fixedTranslation.frame_a.x;
//   actuatedRevolute.frame_b.y = fixedTranslation.frame_a.y;
//   actuatedRevolute.frame_b.phi = fixedTranslation.frame_a.phi;
//   actuatedRevolute.flange_a.phi = angleSensor.flange.phi;
//   actuatedPrismatic.flange_a.s = force.flange.s;
//   PID.y = force.f;
//   PID.u = angleSensor.phi;
// end PlanarMechanicsV4.Examples.ControlledCraneCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsV4.Examples.InvertedCraneCrab
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.5 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 1e-10) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 1e-10) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0);
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\") \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 1e-10) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   Real actuatedRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.34906585039887;
//   parameter Real actuatedRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real actuatedRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real actuatedRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute.animate = true \"enable Animation\";
//   Real actuatedRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute.cylinder.lengthDirection[1],actuatedRevolute.cylinder.lengthDirection[2],actuatedRevolute.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 1.0 else actuatedRevolute.cylinder.lengthDirection[1] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute.cylinder.lengthDirection[2] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 1e-10) then 0.0 else actuatedRevolute.cylinder.lengthDirection[3] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[3] - actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[2];
//   protected Real actuatedRevolute.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[1] - actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[3];
//   protected Real actuatedRevolute.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[2] - actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[1];
//   protected Real actuatedRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute.cylinder.Form;
//   output Real actuatedRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.Material;
//   protected output Real actuatedRevolute.cylinder.Extra;
//   parameter Boolean force.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real force.s(quantity = \"Length\", unit = \"m\") = force.flange.s - force.s_support \"distance between flange and support (= flange.s - support.s)\";
//   Real force.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real force.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   protected Real force.s_support(quantity = \"Length\", unit = \"m\") \"Absolute position of support flange\";
//   input Real force.f \"driving force as input signal\";
//   Real angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real angleSensor.phi \"Absolute angle of flange\";
//   input Real inverseBlockConstraints.u1 \"Input signal 1 (u1 = u2)\";
//   input Real inverseBlockConstraints.u2 \"Input signal 2 (u1 = u2)\";
//   output Real inverseBlockConstraints.y1 \"Output signal 1 (y1 = y2)\";
//   output Real inverseBlockConstraints.y2 \"Output signal 2 (y2 = y2)\";
//   output Real ramp.y \"Connector of Real output signal\";
//   parameter Real ramp.height = -0.5 \"Height of ramps\";
//   parameter Real ramp.duration(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 2.0) = 0.5 \"Durations of ramp\";
//   parameter Real ramp.offset = 0.5 \"Offset of output signal\";
//   parameter Real ramp.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Output = offset for time < startTime\";
//   input Real firstOrder.u \"Connector of Real input signal\";
//   parameter Real firstOrder.k = 1.0 \"Gain\";
//   parameter Real firstOrder.T(quantity = \"Time\", unit = \"s\", start = 1.0) = 0.1 \"Time Constant\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) firstOrder.initType = Modelica.Blocks.Types.Init.SteadyState \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\";
//   parameter Real firstOrder.y_start = 0.0 \"Initial or guess value of output (= state)\";
//   output Real firstOrder.y(start = firstOrder.y_start) \"Connector of Real output signal\";
// initial equation
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
//   der(firstOrder.y) = 0.0;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.m * body.g[1] = body.m * body.a[1];
//   body.f[2] + body.m * body.g[2] = body.m * body.a[2];
//   body.frame_a.t = body.I * body.z;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.m * body1.g[1] = body1.m * body1.a[1];
//   body1.f[2] + body1.m * body1.g[2] = body1.m * body1.a[2];
//   body1.frame_a.t = body1.I * body1.z;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.r0[1] = actuatedPrismatic.s * (actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2]);
//   actuatedPrismatic.r0[2] = actuatedPrismatic.s * (actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2]);
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * (actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2]) + actuatedPrismatic.frame_a.fy * (actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2]) = actuatedPrismatic.f;
//   actuatedRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute.cylinder.shapeType);
//   actuatedRevolute.cylinder.rxvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.ryvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.rvisobj = actuatedRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute.cylinder.R.T[1,1],actuatedRevolute.cylinder.R.T[1,2],actuatedRevolute.cylinder.R.T[1,3]},{actuatedRevolute.cylinder.R.T[2,1],actuatedRevolute.cylinder.R.T[2,2],actuatedRevolute.cylinder.R.T[2,3]},{actuatedRevolute.cylinder.R.T[3,1],actuatedRevolute.cylinder.R.T[3,2],actuatedRevolute.cylinder.R.T[3,3]}},{actuatedRevolute.cylinder.r_shape[1],actuatedRevolute.cylinder.r_shape[2],actuatedRevolute.cylinder.r_shape[3]});
//   actuatedRevolute.cylinder.size[1] = actuatedRevolute.cylinder.length;
//   actuatedRevolute.cylinder.size[2] = actuatedRevolute.cylinder.width;
//   actuatedRevolute.cylinder.size[3] = actuatedRevolute.cylinder.height;
//   actuatedRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute.cylinder.color[1] / 255.0,actuatedRevolute.cylinder.color[2] / 255.0,actuatedRevolute.cylinder.color[3] / 255.0,actuatedRevolute.cylinder.specularCoefficient);
//   actuatedRevolute.cylinder.Extra = actuatedRevolute.cylinder.extra;
//   actuatedRevolute.phi = actuatedRevolute.flange_a.phi;
//   actuatedRevolute.w = der(actuatedRevolute.phi);
//   actuatedRevolute.z = der(actuatedRevolute.w);
//   actuatedRevolute.t = actuatedRevolute.flange_a.tau;
//   actuatedRevolute.frame_a.x = actuatedRevolute.frame_b.x;
//   actuatedRevolute.frame_a.y = actuatedRevolute.frame_b.y;
//   actuatedRevolute.frame_a.phi + actuatedRevolute.phi = actuatedRevolute.frame_b.phi;
//   actuatedRevolute.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   actuatedRevolute.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   actuatedRevolute.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   actuatedRevolute.frame_a.t = actuatedRevolute.t;
//   force.flange.f = -force.f;
//   force.s_support = 0.0;
//   angleSensor.phi = angleSensor.flange.phi;
//   0.0 = angleSensor.flange.tau;
//   inverseBlockConstraints.u1 = inverseBlockConstraints.u2;
//   inverseBlockConstraints.y1 = inverseBlockConstraints.y2;
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   der(firstOrder.y) = (firstOrder.k * firstOrder.u - firstOrder.y) / firstOrder.T;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   fixedTranslation.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   body1.frame_a.t + actuatedPrismatic.frame_b.t + actuatedRevolute.frame_a.t = 0.0;
//   body1.frame_a.fy + actuatedPrismatic.frame_b.fy + actuatedRevolute.frame_a.fy = 0.0;
//   body1.frame_a.fx + actuatedPrismatic.frame_b.fx + actuatedRevolute.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + force.flange.f = 0.0;
//   actuatedRevolute.flange_a.tau + angleSensor.flange.tau = 0.0;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_b.x = actuatedRevolute.frame_a.x;
//   actuatedPrismatic.frame_b.x = body1.frame_a.x;
//   actuatedPrismatic.frame_b.y = actuatedRevolute.frame_a.y;
//   actuatedPrismatic.frame_b.y = body1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = actuatedRevolute.frame_a.phi;
//   actuatedPrismatic.frame_b.phi = body1.frame_a.phi;
//   actuatedRevolute.frame_b.x = fixedTranslation.frame_a.x;
//   actuatedRevolute.frame_b.y = fixedTranslation.frame_a.y;
//   actuatedRevolute.frame_b.phi = fixedTranslation.frame_a.phi;
//   actuatedPrismatic.flange_a.s = force.flange.s;
//   actuatedRevolute.flange_a.phi = angleSensor.flange.phi;
//   angleSensor.phi = inverseBlockConstraints.u1;
//   force.f = inverseBlockConstraints.y1;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   firstOrder.u = ramp.y;
//   firstOrder.y = inverseBlockConstraints.u2;
// end PlanarMechanicsV4.Examples.InvertedCraneCrab;
// "
// ""
// endResult
