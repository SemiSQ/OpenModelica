// name:     SiemensPower.Components.Pipes.Tests.tube_test.mos
// keywords: SiemensPower fluid
// status:   correct
// teardown_comment:
//
//
//

loadModel(Modelica, {"3.2"}); getErrorString();
loadFile("SiemensPower/package.mo"); getErrorString();

instantiateModel(SiemensPower.Components.Pipes.Tests.tube_test); getErrorString();
checkModel(SiemensPower.Components.Pipes.Tests.tube_test); getErrorString();

// Result:
// true
// ""
// true
// ""
// "function Modelica.Blocks.Sources.TimeTable.getInterpolationCoefficients \"Determine interpolation coefficients and next time event\"
//   input Real[:, 2] table \"Table for interpolation\";
//   input Real offset \"y-offset\";
//   input Real startTime \"time-offset\";
//   input Real t \"Actual time instant\";
//   input Integer last \"Last used lower grid index\";
//   input Real TimeEps \"Relative epsilon to check for identical time instants\";
//   output Real a \"Interpolation coefficients a (y=a*x + b)\";
//   output Real b \"Interpolation coefficients b (y=a*x + b)\";
//   output Real nextEvent \"Next event instant\";
//   output Integer next \"New lower grid index\";
//   protected Integer columns = 2 \"Column to be interpolated\";
//   protected Integer ncol = 2 \"Number of columns to be interpolated\";
//   protected Integer nrow = size(table, 1) \"Number of table rows\";
//   protected Integer next0;
//   protected Real tp;
//   protected Real dt;
// algorithm
//   next := last;
//   nextEvent := t - TimeEps * abs(t);
//   tp := t + TimeEps * abs(t) - startTime;
//   if tp < 0.0 then
//     nextEvent := startTime;
//     a := 0.0;
//     b := offset;
//   elseif nrow < 2 then
//     a := 0.0;
//     b := offset + table[1, columns];
//   else
//     while next < nrow and tp >= table[next, 1] loop
//       next := 1 + next;
//     end while;
//     if next < nrow then
//       nextEvent := startTime + table[next, 1];
//     end if;
//     next0 := next + -1;
//     dt := table[next, 1] - table[next0, 1];
//     if dt <= TimeEps * abs(table[next, 1]) then
//       a := 0.0;
//       b := offset + table[next, columns];
//     else
//       a := (table[next, columns] - table[next0, columns]) / dt;
//       b := offset + table[next0, columns] - a * table[next0, 1];
//     end if;
//   end if;
//   b := b - a * startTime;
// end Modelica.Blocks.Sources.TimeTable.getInterpolationCoefficients;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_con\"
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") d_hyd = 0.1;
//   input Real(quantity=\"Length\", unit=\"m\") L = 1.0;
//   input enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF;
//   output kc_laminar_IN_con res;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_con;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_var\"
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"DynamicViscosity\", unit=\"Pa.s\", min=0.0) eta;
//   input Real(quantity=\"ThermalConductivity\", unit=\"W/(m.K)\") lambda;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   input Real(quantity=\"MassFlowRate\", unit=\"kg/s\") m_flow;
//   output kc_laminar_IN_var res;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_var;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_KC \"Mean heat transfer coefficient of straight pipe | uniform wall temperature or uniform heat flux | hydrodynamically developed or undeveloped laminar flow regime\"
//   input Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_con IN_con \"Input record for function kc_laminar_KC\";
//   input Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_IN_var IN_var \"Input record for function kc_laminar_KC\";
//   output Real kc(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") \"Output for function kc_laminar_KC\";
//   protected Real MIN = 0.000000000000001;
//   protected Real A_cross(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * IN_con.d_hyd ^ 2.0 \"Circular cross sectional area\";
//   protected Real Nu0 = if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF or IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuUFF then 0.7 else if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuDFF or IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF then 0.6 else 0.0 \"Help variable for mean Nusselt number\";
//   protected Real Nu1 = if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF or IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuUFF then 3.66 else if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuDFF or IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF then 4.364 else 0.0 \"Help variable for mean Nusselt number\";
//   protected Real velocity(quantity = \"Velocity\", unit = \"m/s\") = abs(IN_var.m_flow) / max(MIN, IN_var.rho * A_cross) \"Mean velocity\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") = max(0.001, IN_var.rho * velocity * IN_con.d_hyd / max(MIN, IN_var.eta));
//   protected Real Pr(quantity = \"PrandtlNumber\", unit = \"1\") = abs(IN_var.eta * IN_var.cp / max(MIN, IN_var.lambda));
//   protected Real Nu2(quantity = \"NusseltNumber\", unit = \"1\") = if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF or IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuUFF then 1.615 * (Re * Pr * IN_con.d_hyd / IN_con.L) ^ 0.3333333333333333 else if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuDFF or IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF then 1.953 * (Re * Pr * IN_con.d_hyd / IN_con.L) ^ 0.3333333333333333 else 0.0 \"Help variable for mean Nusselt number\";
//   protected Real Nu3(quantity = \"NusseltNumber\", unit = \"1\") = if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuUFF then (2.0 / (1.0 + 22.0 * Pr)) ^ 0.16666666666666666 * (Re * Pr * IN_con.d_hyd / IN_con.L) ^ 0.5 else if IN_con.target == Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF then 1.953 * (Re * Pr * IN_con.d_hyd / IN_con.L) ^ 0.3333333333333333 else 0.0 \"Help variable for mean Nusselt number\";
//   protected Real Nu(quantity = \"NusseltNumber\", unit = \"1\") = (Nu1 ^ 3.0 + Nu0 ^ 3.0 + (Nu2 - Nu0) ^ 3.0 + Nu3 ^ 3.0) ^ 0.3333333333333333 \"Mean Nusselt number\";
// algorithm
//   kc := Nu * IN_var.lambda / max(MIN, IN_con.d_hyd);
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_KC;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_con\"
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") d_hyd = 0.1;
//   input Real(quantity=\"Length\", unit=\"m\") L = 1.0;
//   input enumeration(Neglected, Considered) roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered;
//   input Real(quantity=\"Length\", unit=\"m\") K = 0.0;
//   input enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UWTuDFF;
//   output kc_overall_IN_con res;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_con;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_var\"
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"DynamicViscosity\", unit=\"Pa.s\", min=0.0) eta;
//   input Real(quantity=\"ThermalConductivity\", unit=\"W/(m.K)\") lambda;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   input Real(quantity=\"MassFlowRate\", unit=\"kg/s\") m_flow;
//   output kc_overall_IN_var res;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_var;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC \"Mean heat transfer coefficient of straight pipe | uniform wall temperature or uniform heat flux | hydrodynamically developed or undeveloped overall flow regime| pressure loss dependence\"
//   input Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_con IN_con \"Input record for function kc_overall_KC\";
//   input Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_IN_var IN_var \"Input record for function kc_overall_KC\";
//   output Real kc(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") \"Output for function kc_overall_KC\";
//   protected Real MIN = 0.000000000000001;
//   protected Real laminar = 2200.0 \"Maximum Reynolds number for laminar regime\";
//   protected Real turbulent = 10000.0 \"Minimum Reynolds number for turbulent regime\";
//   protected Real A_cross(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * IN_con.d_hyd ^ 2.0 \"Cross sectional area\";
//   protected Real velocity(quantity = \"Velocity\", unit = \"m/s\") = abs(IN_var.m_flow) / max(MIN, IN_var.rho * A_cross) \"Mean velocity\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") = max(0.001, IN_var.rho * velocity * IN_con.d_hyd / max(MIN, IN_var.eta));
//   protected Real Pr(quantity = \"PrandtlNumber\", unit = \"1\") = abs(IN_var.eta * IN_var.cp / max(MIN, IN_var.lambda));
// algorithm
//   kc := Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother(laminar, turbulent, Re) * Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_laminar_KC(IN_con, IN_var) + Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother(turbulent, laminar, Re) * Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_KC(IN_con, IN_var);
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_con\"
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") d_hyd = 0.1;
//   input Real(quantity=\"Length\", unit=\"m\") L = 1.0;
//   input enumeration(Neglected, Considered) roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered;
//   input Real(quantity=\"Length\", unit=\"m\") K = 0.0;
//   output kc_turbulent_IN_con res;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_con;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_var\"
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"DynamicViscosity\", unit=\"Pa.s\", min=0.0) eta;
//   input Real(quantity=\"ThermalConductivity\", unit=\"W/(m.K)\") lambda;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   input Real(quantity=\"MassFlowRate\", unit=\"kg/s\") m_flow;
//   output kc_turbulent_IN_var res;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_var;
// 
// function Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_KC \"Mean heat transfer coefficient of straight pipe | hydrodynamically developed turbulent flow regime | pressure loss dependence\"
//   input Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_con IN_con \"Input record for function kc_turbulent_KC\";
//   input Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_IN_var IN_var \"Input record for function kc_turbulent_KC\";
//   output Real kc(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") \"Output for function kc_turbulent_KC\";
//   protected Real MIN = 0.000000000000001;
//   protected Real A_cross(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * IN_con.d_hyd ^ 2.0 \"Circular cross sectional area\";
//   protected Real velocity(quantity = \"Velocity\", unit = \"m/s\") = abs(IN_var.m_flow) / (A_cross * IN_var.rho) \"Mean velocity\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") = max(2.6, IN_var.rho * velocity * IN_con.d_hyd / IN_var.eta);
//   protected Real Pr(quantity = \"PrandtlNumber\", unit = \"1\") = abs(IN_var.eta * IN_var.cp / IN_var.lambda);
//   protected Real zeta = abs(max(MIN, 1.8 * log10(abs(Re)) + -1.5) ^ -2.0) \"Pressure loss coefficient\";
// algorithm
//   kc := if IN_con.roughness == Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Neglected then 0.023 * abs(IN_var.lambda / IN_con.d_hyd) * Re ^ 0.8 * Pr ^ 0.3333333333333333 else if IN_con.roughness == Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered then (1.0 + (IN_con.d_hyd / IN_con.L) ^ 0.6666666666666666) * abs(Pr) * abs(Re) * abs(IN_var.lambda / IN_con.d_hyd) * abs(zeta) / (8.0 + 101.6 * (abs(zeta) / 8.0) ^ 0.5 * (-1.0 + abs(Pr) ^ 0.6666666666666666)) else 0.0;
// end Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_turbulent_KC;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP \"Generic pressure loss | calculate pressure loss | pressure loss coefficient (zeta_TOT)\"
//   input Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_con IN_con \"Input record for dp_pressureLossCoefficient_DP\";
//   input Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_var IN_var \"Input record for dp_pressureLossCoefficient_DP\";
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate\";
//   output Real DP(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Output for function dp_pressureLossCoefficient_DP\";
// algorithm
//   DP := 0.5 * IN_var.zeta_TOT * Modelica.Fluid.Dissipation.Utilities.Functions.General.SmoothPower(m_flow, 1.4142135623730951 * (IN_con.dp_smooth / (IN_var.rho * IN_var.zeta_TOT)) ^ 0.5 * IN_var.rho * IN_con.A_cross, 2.0) / (IN_con.A_cross ^ 2.0 * IN_var.rho);
// end Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_con\"
//   input Real(quantity=\"Area\", unit=\"m2\") A_cross = 0.007853981633974483;
//   input Real(quantity=\"Pressure\", unit=\"Pa\", min=-1000000000.0, max=1000000000.0, nominal=100000.0, start=100000.0, displayUnit=\"bar\") dp_smooth = 1.0;
//   output dp_pressureLossCoefficient_IN_con res;
// end Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_con;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_var\"
//   input (Modelica.Icons.TypeReal type bc:Real(quantity=\"Pressure loss coefficient | zeta_tot = zeta_loc + zeta_fri\", unit=\"1\", min=0.0, max=1111.0)) zeta_TOT = 0.19999999999999998;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   output dp_pressureLossCoefficient_IN_var res;
// end Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_IN_var;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP \"Pressure loss of straight pipe | calculate pressure loss| laminar flow regime (Hagen-Poiseuille)\"
//   input Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_con IN_con \"Input record for function dp_laminar_DP\";
//   input Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_var IN_var \"Input record for function dp_laminar_DP\";
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate\";
//   output Real DP(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Output for function dp_laminar_DP\";
//   protected Real MIN = 0.000000000000001;
//   protected Real d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = IN_con.d_hyd \"Hydraulic diameter\";
//   protected Real A_cross(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * IN_con.d_hyd ^ 2.0 \"Circular cross sectional area\";
//   protected Real velocity(quantity = \"Velocity\", unit = \"m/s\") = m_flow / max(MIN, IN_var.rho * A_cross) \"Mean velocity\";
// algorithm
//   DP := 32.0 * IN_var.eta * velocity * IN_con.L / d_hyd ^ 2.0;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_con\"
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") d_hyd = 0.1;
//   input Real(quantity=\"Length\", unit=\"m\") L = 1.0;
//   output dp_laminar_IN_con res;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_con;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_var\"
//   input Real(quantity=\"DynamicViscosity\", unit=\"Pa.s\", min=0.0) eta;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   output dp_laminar_IN_var res;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_IN_var;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP \"Pressure loss of straight pipe | calculate pressure loss | overall flow regime | surface roughness\"
//   input Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_con IN_con \"Input record for function dp_overall_DP\";
//   input Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_var IN_var \"Input record for function dp_overall_DP\";
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate\";
//   output Real DP(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Output for function dp_overall_DP\";
//   protected Real MIN = 0.000000000000001;
//   protected Real d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = max(MIN, IN_con.d_hyd) \"Hydraulic diameter\";
//   protected Real A_cross(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * IN_con.d_hyd ^ 2.0 \"Circular cross sectional area\";
//   protected Real k = max(MIN, abs(IN_con.K) / IN_con.d_hyd) \"Relative roughness\";
//   protected Real perimeter(quantity = \"Length\", unit = \"m\") = 3.141592653589793 * IN_con.d_hyd \"Perimeter\";
//   protected Real Re_lam_min(quantity = \"ReynoldsNumber\", unit = \"1\") = 1000.0 \"Minimum Reynolds number for laminar regime\";
//   protected Real Re_lam_max(quantity = \"ReynoldsNumber\", unit = \"1\") = 2090.0 * (1.0 / max(0.007, k)) ^ 0.0635 \"Maximum Reynolds number for laminar regime\";
//   protected Real Re_lam_leave(quantity = \"ReynoldsNumber\", unit = \"1\") = min(Re_lam_max, max(Re_lam_min, 754.0 * exp(if k <= 0.007 then 0.9285714285714285 else 0.0065 / k))) \"Start of transition regime for increasing Reynolds number (leaving laminar regime)\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") = Modelica.Fluid.Dissipation.Utilities.Functions.General.ReynoldsNumber(A_cross, perimeter, IN_var.rho, IN_var.eta, m_flow)[1];
// algorithm
//   DP := Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother(Re_lam_min, Re_lam_max, Re) * Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_laminar_DP(IN_con, IN_var, m_flow) + Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother(Re_lam_max, Re_lam_min, Re) * Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP(IN_con, IN_var, m_flow);
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_con\"
//   input enumeration(Neglected, Considered) roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Neglected;
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") d_hyd = 0.1;
//   input Real(quantity=\"Length\", unit=\"m\") L = 1.0;
//   input Real(quantity=\"Length\", unit=\"m\") K = 0.0;
//   output dp_overall_IN_con res;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_con;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_var\"
//   input Real(quantity=\"DynamicViscosity\", unit=\"Pa.s\", min=0.0) eta;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   output dp_overall_IN_var res;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_IN_var;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP \"Pressure loss of straight pipe | calculate pressure loss | turbulent flow regime | surface roughness\"
//   input Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_con IN_con \"Input record for function dp_turbulent_DP\";
//   input Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_var IN_var \"Input record for function dp_turbulent_DP\";
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate\";
//   output Real DP(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Output for function dp_turbulent_DP\";
//   protected Real MIN = 0.000000000000001;
//   protected Real Re_min(quantity = \"ReynoldsNumber\", unit = \"1\") = 1.0;
//   protected Real v_min(quantity = \"Velocity\", unit = \"m/s\") = Re_min * IN_var.eta / (IN_con.d_hyd * IN_var.rho);
//   protected Real d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = IN_con.d_hyd \"Hydraulic diameter\";
//   protected Real A_cross(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * IN_con.d_hyd ^ 2.0 \"Circular cross sectional area\";
//   protected Real k = max(MIN, abs(IN_con.K) / IN_con.d_hyd) \"Relative roughness\";
//   protected Real Re_lam_min(quantity = \"ReynoldsNumber\", unit = \"1\") = 1000.0 \"Minimum Reynolds number for laminar regime\";
//   protected Real Re_lam_max(quantity = \"ReynoldsNumber\", unit = \"1\") = 2090.0 * (1.0 / max(0.007, k)) ^ 0.0635 \"Maximum Reynolds number for laminar regime\";
//   protected Real Re_turb_min(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Minimum Reynolds number for turbulent regime\";
//   protected Real Re_lam_leave(quantity = \"ReynoldsNumber\", unit = \"1\") = min(Re_lam_max, max(Re_lam_min, 754.0 * exp(if k <= 0.007 then 0.9285714285714285 else 0.0065 / k))) \"Start of transition regime for increasing Reynolds number (leaving laminar regime)\";
//   protected Real velocity(quantity = \"Velocity\", unit = \"m/s\") = m_flow / (A_cross * IN_var.rho) \"Mean velocity\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") = max(Re_min, IN_var.rho * abs(velocity) * d_hyd / IN_var.eta);
//   protected Real lambda_FRI_smooth(quantity = \"Darcy friction factor | lambda_fri = zeta_fri / (length/diameter)\", unit = \"1\", min = 0.0, max = 1111.0) = 0.3164 * Re ^ 1.75 \"Darcy friction factor neglecting surface roughness (Blasius)\";
//   protected Real lambda_FRI_rough(quantity = \"Darcy friction factor | lambda_fri = zeta_fri / (length/diameter)\", unit = \"1\", min = 0.0, max = 1111.0) = 0.25 * (max(Re, Re_lam_leave) / log10(k / 3.7 + 5.74 / max(Re, Re_lam_leave) ^ 0.9)) ^ 2.0 \"Darcy friction factor considering surface roughness\";
//   protected Real lambda_FRI(quantity = \"Darcy friction factor | lambda_fri = zeta_fri / (length/diameter)\", unit = \"1\", min = 0.0, max = 1111.0) = if IN_con.roughness == Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Neglected then lambda_FRI_smooth else lambda_FRI_rough \"Darcy friction factor\";
//   protected Real lambda_FRI_calc(quantity = \"Darcy friction factor | lambda_fri = zeta_fri / (length/diameter)\", unit = \"1\", min = 0.0, max = 1111.0) = if Re < Re_lam_leave then 64.0 / Re else if Re > Re_turb_min then lambda_FRI / Re ^ 2.0 else Modelica.Fluid.Dissipation.Utilities.Functions.General.CubicInterpolation_MFLOW(Re, Re_lam_leave, Re_turb_min, k) / Re ^ 2.0 \"Darcy friction factor\";
//   protected Real zeta_TOT(quantity = \"Pressure loss coefficient | zeta_tot = zeta_loc + zeta_fri\", unit = \"1\", min = 0.0, max = 1111.0) = lambda_FRI_calc * IN_con.L / d_hyd \"Pressure loss coefficient\";
// algorithm
//   DP := Modelica.Fluid.Dissipation.Utilities.Functions.General.SmoothPower(velocity, v_min, 2.0) * zeta_TOT * IN_var.rho / 2.0;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_DP;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_con \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_con\"
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") d_hyd = 0.1;
//   input Real(quantity=\"Length\", unit=\"m\") L = 1.0;
//   input enumeration(Neglected, Considered) roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Neglected;
//   input Real(quantity=\"Length\", unit=\"m\") K = 0.0;
//   output dp_turbulent_IN_con res;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_con;
// 
// function Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_var \"Automatically generated record constructor for Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_var\"
//   input Real(quantity=\"DynamicViscosity\", unit=\"Pa.s\", min=0.0) eta;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   output dp_turbulent_IN_var res;
// end Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_turbulent_IN_var;
// 
// function Modelica.Fluid.Dissipation.Utilities.Functions.General.CubicInterpolation_MFLOW
//   input Real Re(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Delta;
//   output Real lambda2;
//   protected Real x1 = log10(Re1);
//   protected Real y1 = log10(64.0 * Re1);
//   protected Real yd1 = 1.0;
//   protected Real aux1 = 1.1217826467560994;
//   protected Real aux2 = Delta / 3.7 + 5.74 / Re2 ^ 0.9;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real aux5 = -2.0 * sqrt(L2) * log10(aux4);
//   protected Real x2 = log10(Re2);
//   protected Real y2 = log10(L2);
//   protected Real yd2 = 2.0 + 4.0 * aux1 / (Re2 ^ 0.9 * aux2 * aux3);
//   protected Real diff_x = x2 - x1;
//   protected Real m = (y2 - y1) / diff_x;
//   protected Real c2 = (3.0 * m + -2.0 * yd1 - yd2) / diff_x;
//   protected Real c3 = (yd1 + yd2 + -2.0 * m) / diff_x ^ 2.0;
//   protected Real dx = log10(Re / Re1);
// algorithm
//   lambda2 := 64.0 * Re1 * (Re / Re1) ^ (1.0 + dx * (c2 + dx * c3));
// end Modelica.Fluid.Dissipation.Utilities.Functions.General.CubicInterpolation_MFLOW;
// 
// function Modelica.Fluid.Dissipation.Utilities.Functions.General.ReynoldsNumber \"calculation of Reynolds number\"
//   input Real A_cross(quantity = \"Area\", unit = \"m2\") \"Cross sectional area\";
//   input Real perimeter(quantity = \"Length\", unit = \"m\") \"Wetted perimeter\";
//   input Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"Density of fluid\";
//   input Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity of fluid\";
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate\";
//   output Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   output Real velocity(quantity = \"Velocity\", unit = \"m/s\") \"Mean velocity\";
//   protected Real d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = 4.0 * A_cross / max(0.000000000000001, perimeter) \"Hydraulic diameter\";
// algorithm
//   Re := 4.0 * abs(m_flow) / max(0.000000000000001, perimeter * eta);
//   velocity := m_flow / max(0.000000000000001, rho * A_cross);
// end Modelica.Fluid.Dissipation.Utilities.Functions.General.ReynoldsNumber;
// 
// function Modelica.Fluid.Dissipation.Utilities.Functions.General.SmoothPower \"Limiting the derivative of function y = if x>=0 then x^pow else -(-x)^pow\"
//   input Real x \"input variable\";
//   input Real deltax \"range for interpolation\";
//   input Real pow \"exponent for x\";
//   output Real y \"output variable\";
//   protected Real adeltax = abs(deltax);
//   protected Real C3 = (-0.5 + pow / 2.0) * adeltax ^ (-3.0 + pow);
//   protected Real C1 = (1.5 + (-pow) / 2.0) * adeltax ^ (-1.0 + pow);
// algorithm
//   y := if x >= adeltax then x ^ pow else if x <= (-adeltax) then -(-x) ^ pow else (C1 + C3 * x ^ 2.0) * x;
// end Modelica.Fluid.Dissipation.Utilities.Functions.General.SmoothPower;
// 
// function Modelica.Fluid.Dissipation.Utilities.Functions.General.SmoothPower_der \"The derivative of function SmoothPower\"
//   input Real x \"input variable\";
//   input Real deltax \"range of interpolation\";
//   input Real pow \"exponent for x\";
//   input Real dx \"derivative of x\";
//   input Real ddeltax \"derivative of deltax\";
//   input Real dpow \"derivative of pow\";
//   output Real dy \"derivative of SmoothPower\";
//   protected Real C3;
//   protected Real C1;
//   protected Real adeltax;
// algorithm
//   adeltax := abs(deltax);
//   if noEvent(x >= adeltax) then
//     dy := dx * pow * x ^ (-1.0 + pow);
//   elseif noEvent(x <= (-adeltax)) then
//     dy := (-dx) * pow * (-x) ^ (-1.0 + pow);
//   else
//     C3 := (-0.5 + pow / 2.0) * adeltax ^ (-3.0 + pow);
//     C1 := (1.5 + (-pow) / 2.0) * adeltax ^ (-1.0 + pow);
//     dy := (C1 + 3.0 * C3 * x ^ 2.0) * dx;
//   end if;
// end Modelica.Fluid.Dissipation.Utilities.Functions.General.SmoothPower_der;
// 
// function Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother \"Continuous interpolation for x \"
//   input Real func \"input value for that result = 100%\";
//   input Real nofunc \"input value for that result = 0%\";
//   input Real x \"input variable for continuous interpolation\";
//   output Real result \"output value\";
//   protected Real m = 3.141592653589793 / (func - nofunc);
//   protected Real b = -1.5707963267948966 - m * nofunc;
//   protected Real r_1 = tan(m * x + b);
// algorithm
//   result := if x >= 0.999999 * (func - nofunc) + nofunc and func > nofunc or x <= 0.999999 * (func - nofunc) + nofunc and nofunc > func then 1.0 else if x <= 0.000001 * (func - nofunc) + nofunc and func > nofunc or x >= 0.000001 * (func - nofunc) + nofunc and nofunc > func then 0.0 else 0.5 + 0.5 * (exp(r_1) - exp(-r_1)) / (exp(r_1) + exp(-r_1));
// end Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother;
// 
// function Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother_der \"Derivative of function Stepsmoother\"
//   input Real func \"input for that result = 100%\";
//   input Real nofunc \"input for that result = 0%\";
//   input Real x \"input for interpolation\";
//   input Real dfunc \"derivative of func\";
//   input Real dnofunc \"derivative of nofunc\";
//   input Real dx \"derivative of x\";
//   output Real dresult;
//   protected Real m = 3.141592653589793 / (func - nofunc);
//   protected Real b = -1.5707963267948966 - m * nofunc;
// algorithm
//   dresult := if x >= 0.999 * (func - nofunc) + nofunc and func > nofunc or x <= 0.999 * (func - nofunc) + nofunc and nofunc > func or x <= 0.001 * (func - nofunc) + nofunc and func > nofunc or x >= 0.001 * (func - nofunc) + nofunc and nofunc > func then 0.0 else (1.0 - tanh(tan(m * x + b)) ^ 2.0) * (1.0 + tan(m * x + b) ^ 2.0) * m * dx;
// end Modelica.Fluid.Dissipation.Utilities.Functions.General.Stepsmoother_der;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState\"
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Fluid.Interfaces.FluidPort.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// end Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPort.Medium.setState_pTX(p, T, X));
// end Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-10000000000.0, max=10000000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p, T, 0);
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.density_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState(1, Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pT(p, T, 0), Modelica.Fluid.Interfaces.FluidPort_a.Medium.density_pT(p, T, 0), T, p);
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p, T, 0);
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPort_a.Medium.setState_pTX(p, T, X, phase));
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-10000000000.0, max=10000000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p, T, 0);
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.density_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState(1, Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pT(p, T, 0), Modelica.Fluid.Interfaces.FluidPort_b.Medium.density_pT(p, T, 0), T, p);
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p, T, 0);
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPort_b.Medium.setState_pTX(p, T, X, phase));
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPorts_b.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPorts_b.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-10000000000.0, max=10000000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPorts_b.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPorts_b.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p, T, 0);
// end Modelica.Fluid.Interfaces.FluidPorts_b.Medium.density_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPorts_b.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPorts_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Interfaces.FluidPorts_b.Medium.ThermodynamicState(1, Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy_pT(p, T, 0), Modelica.Fluid.Interfaces.FluidPorts_b.Medium.density_pT(p, T, 0), T, p);
// end Modelica.Fluid.Interfaces.FluidPorts_b.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPorts_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p, T, 0);
// end Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPorts_b.Medium.setState_pTX(p, T, X, phase));
// end Modelica.Fluid.Interfaces.FluidPorts_b.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.SaturationProperties \"Automatically generated record constructor for Modelica.Fluid.Sources.MassFlowSource_h.Medium.SaturationProperties\"
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") psat;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") Tsat;
//   output SaturationProperties res;
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.SaturationProperties;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Sources.MassFlowSource_h.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-10000000000.0, max=10000000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.bubbleEnthalpy \"boiling curve specific enthalpy of water\"
//   input Modelica.Fluid.Sources.MassFlowSource_h.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"boiling curve specific enthalpy\";
// algorithm
//   hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(sat.psat);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.bubbleEnthalpy;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p, T, 0);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.density_pT;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p, h, phase, 0);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.density_ph;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.dewEnthalpy \"dew curve specific enthalpy of water\"
//   input Modelica.Fluid.Sources.MassFlowSource_h.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"dew curve specific enthalpy\";
// algorithm
//   hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(sat.psat);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.dewEnthalpy;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.saturationTemperature \"saturation temperature of water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.saturationTemperature;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Sources.MassFlowSource_h.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Sources.MassFlowSource_h.Medium.ThermodynamicState(1, Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy_pT(p, T, 0), Modelica.Fluid.Sources.MassFlowSource_h.Medium.density_pT(p, T, 0), T, p);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.setState_pTX;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Sources.MassFlowSource_h.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p, T, 0);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy(Modelica.Fluid.Sources.MassFlowSource_h.Medium.setState_pTX(p, T, X, phase));
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Sources.MassFlowSource_h.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p, h, phase, 0);
// end Modelica.Fluid.Sources.MassFlowSource_h.Medium.temperature_ph;
// 
// function Modelica.Fluid.Utilities.checkBoundary \"Check whether boundary definition is correct\"
//   input String mediumName;
//   input String[:] substanceNames \"Names of substances\";
//   input Boolean singleState;
//   input Boolean define_p;
//   input Real[:] X_boundary;
//   input String modelName = \"??? boundary ???\";
//   protected Integer nX = size(X_boundary, 1);
//   protected String X_str;
// algorithm
//   assert( not singleState or singleState and define_p, \"
// Wrong value of parameter define_p (= false) in model \\\"\" + modelName + \"\\\":
// The selected medium \\\"\" + mediumName + \"\\\" has Medium.singleState=true.
// Therefore, an boundary density cannot be defined and
// define_p = true is required.
// \");
//   for i in 1:nX loop
//     assert( X_boundary[i] >= 0.0, \"
// Wrong boundary mass fractions in medium \\\"\" + mediumName + \"\\\" in model \\\"\" + modelName + \"\\\":
// The boundary value X_boundary(\" + String(i, 0, true) + \") = \" + String(X_boundary[i], 0, true, 6) + \"
// is negative. It must be positive.
// \");
//   end for;
//   if nX > 0 and abs(sum(X_boundary) + -1.0) > 0.0000000001 then
//     X_str := \"\";
//     for i in 1:nX loop
//       X_str := X_str + \"   X_boundary[\" + String(i, 0, true) + \"] = \" + String(X_boundary[i], 0, true, 6) + \" \\\"\" + substanceNames[i] + \"\\\"
// \";
//     end for;
//     Modelica.Utilities.Streams.error(\"The boundary mass fractions in medium \\\"\" + mediumName + \"\\\" in model \\\"\" + modelName + \"\\\"
// \" + \"do not sum up to 1. Instead, sum(X_boundary) = \" + String(sum(X_boundary), 0, true, 6) + \":
// \" + X_str);
//   end if;
// end Modelica.Fluid.Utilities.checkBoundary;
// 
// function Modelica.Media.Common.GibbsDerivs \"Automatically generated record constructor for Modelica.Media.Common.GibbsDerivs\"
//   input Real(quantity=\"Pressure\", unit=\"Pa\", min=-1000000000.0, max=1000000000.0, nominal=100000.0, start=100000.0, displayUnit=\"bar\") p;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=1.0, max=6000.0, start=288.15, nominal=300.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(unit=\"1\") pi;
//   input Real(unit=\"1\") tau;
//   input Real(unit=\"1\") g;
//   input Real(unit=\"1\") gpi;
//   input Real(unit=\"1\") gpipi;
//   input Real(unit=\"1\") gtau;
//   input Real(unit=\"1\") gtautau;
//   input Real(unit=\"1\") gtaupi;
//   output GibbsDerivs res;
// end Modelica.Media.Common.GibbsDerivs;
// 
// function Modelica.Media.Common.HelmholtzDerivs \"Automatically generated record constructor for Modelica.Media.Common.HelmholtzDerivs\"
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) d;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=1.0, max=6000.0, start=288.15, nominal=300.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(unit=\"1\") delta;
//   input Real(unit=\"1\") tau;
//   input Real(unit=\"1\") f;
//   input Real(unit=\"1\") fdelta;
//   input Real(unit=\"1\") fdeltadelta;
//   input Real(unit=\"1\") ftau;
//   input Real(unit=\"1\") ftautau;
//   input Real(unit=\"1\") fdeltatau;
//   output HelmholtzDerivs res;
// end Modelica.Media.Common.HelmholtzDerivs;
// 
// function Modelica.Media.Common.Helmholtz_pT \"function to calculate analytic derivatives for computing d and t given p and t\"
//   input Modelica.Media.Common.HelmholtzDerivs f \"dimensionless derivatives of Helmholtz function\";
//   output Modelica.Media.Common.NewtonDerivatives_pT nderivs \"derivatives for Newton iteration to compute d and t from p and t\";
// algorithm
//   nderivs.p := f.d * f.R * f.T * f.delta * f.fdelta;
//   nderivs.pd := f.R * f.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
// end Modelica.Media.Common.Helmholtz_pT;
// 
// function Modelica.Media.Common.Helmholtz_ph \"function to calculate analytic derivatives for computing d and t given p and h\"
//   input Modelica.Media.Common.HelmholtzDerivs f \"dimensionless derivatives of Helmholtz function\";
//   output Modelica.Media.Common.NewtonDerivatives_ph nderivs \"derivatives for Newton iteration to calculate d and t from p and h\";
//   protected Real cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"isochoric heat capacity\";
// algorithm
//   cv := (-f.R) * f.tau ^ 2.0 * f.ftautau;
//   nderivs.p := f.d * f.R * f.T * f.delta * f.fdelta;
//   nderivs.h := f.R * f.T * (f.tau * f.ftau + f.delta * f.fdelta);
//   nderivs.pd := f.R * f.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//   nderivs.pt := f.R * f.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//   nderivs.ht := cv + nderivs.pt / f.d;
//   nderivs.hd := (nderivs.pd + (-f.T) * nderivs.pt / f.d) / f.d;
// end Modelica.Media.Common.Helmholtz_ph;
// 
// function Modelica.Media.Common.IF97BaseTwoPhase \"Automatically generated record constructor for Modelica.Media.Common.IF97BaseTwoPhase\"
//   input Integer phase = 0;
//   input Integer(min=1, max=5) region;
//   input Real(quantity=\"Pressure\", unit=\"Pa\", min=-1000000000.0, max=1000000000.0, nominal=100000.0, start=100000.0, displayUnit=\"bar\") p;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=1.0, max=6000.0, start=288.15, nominal=300.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\", nominal=1000000.0) h;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) rho;
//   input Real(quantity=\"SpecificEntropy\", unit=\"J/(kg.K)\", nominal=1000.0) s;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   input Real vt;
//   input Real vp;
//   input Real x;
//   input Real dpT;
//   output IF97BaseTwoPhase res;
// end Modelica.Media.Common.IF97BaseTwoPhase;
// 
// function Modelica.Media.Common.IF97PhaseBoundaryProperties \"Automatically generated record constructor for Modelica.Media.Common.IF97PhaseBoundaryProperties\"
//   input Boolean region3boundary;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=1.0, max=6000.0, start=288.15, nominal=300.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) d;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\", nominal=1000000.0) h;
//   input Real(quantity=\"SpecificEntropy\", unit=\"J/(kg.K)\", nominal=1000.0) s;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") dpT;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   input Real(unit=\"m3/(kg.K)\") vt;
//   input Real(unit=\"m3/(kg.Pa)\") vp;
//   output IF97PhaseBoundaryProperties res;
// end Modelica.Media.Common.IF97PhaseBoundaryProperties;
// 
// function Modelica.Media.Common.NewtonDerivatives_pT \"Automatically generated record constructor for Modelica.Media.Common.NewtonDerivatives_pT\"
//   input Real(quantity=\"Pressure\", unit=\"Pa\", min=-1000000000.0, max=1000000000.0, nominal=100000.0, start=100000.0, displayUnit=\"bar\") p;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   output NewtonDerivatives_pT res;
// end Modelica.Media.Common.NewtonDerivatives_pT;
// 
// function Modelica.Media.Common.NewtonDerivatives_ph \"Automatically generated record constructor for Modelica.Media.Common.NewtonDerivatives_ph\"
//   input Real(quantity=\"Pressure\", unit=\"Pa\", min=-1000000000.0, max=1000000000.0, nominal=100000.0, start=100000.0, displayUnit=\"bar\") p;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\", nominal=1000000.0) h;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real hd;
//   input Real ht;
//   output NewtonDerivatives_ph res;
// end Modelica.Media.Common.NewtonDerivatives_ph;
// 
// function Modelica.Media.Common.PhaseBoundaryProperties \"Automatically generated record constructor for Modelica.Media.Common.PhaseBoundaryProperties\"
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.000001, max=30000.0) d;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\", nominal=1000000.0) h;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\", nominal=1000000.0) u;
//   input Real(quantity=\"SpecificEntropy\", unit=\"J/(kg.K)\", nominal=1000.0) s;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   output PhaseBoundaryProperties res;
// end Modelica.Media.Common.PhaseBoundaryProperties;
// 
// function Modelica.Media.Common.cv2Phase \"compute isochoric specific heat capacity inside the two-phase region\"
//   input Modelica.Media.Common.PhaseBoundaryProperties liq \"properties on the boiling curve\";
//   input Modelica.Media.Common.PhaseBoundaryProperties vap \"properties on the condensation curve\";
//   input Real x(quantity = \"MassFraction\", unit = \"1\", min = 0.0, max = 1.0, start = 0.2, nominal = 0.01) \"vapour mass fraction\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"preoperties\";
//   output Real cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"isochoric specific heat capacity\";
//   protected Real dpT \"derivative of pressure w.r.t. temperature\";
//   protected Real dxv \"derivative of vapour mass fraction w.r.t. specific volume\";
//   protected Real dvTl \"derivative of liquid specific volume w.r.t. temperature\";
//   protected Real dvTv \"derivative of vapour specific volume w.r.t. temperature\";
//   protected Real duTl \"derivative of liquid specific inner energy w.r.t. temperature\";
//   protected Real duTv \"derivative of vapour specific inner energy w.r.t. temperature\";
//   protected Real dxt \"derivative of vapour mass fraction w.r.t. temperature\";
// algorithm
//   dxv := if liq.d <> vap.d then liq.d * vap.d / (liq.d - vap.d) else 0.0;
//   dpT := (vap.s - liq.s) * dxv;
//   dvTl := (liq.pt - dpT) / (liq.d ^ 2.0 * liq.pd);
//   dvTv := (vap.pt - dpT) / (vap.d ^ 2.0 * vap.pd);
//   dxt := (-dxv) * (dvTl + x * (dvTv - dvTl));
//   duTl := liq.cv + (T * liq.pt - p) * dvTl;
//   duTv := vap.cv + (T * vap.pt - p) * dvTv;
//   cv := duTl + x * (duTv - duTl) + dxt * (vap.u - liq.u);
// end Modelica.Media.Common.cv2Phase;
// 
// function Modelica.Media.Common.gibbsToBoundaryProps \"calulate phase boundary property record from dimensionless Gibbs function\"
//   input Modelica.Media.Common.GibbsDerivs g \"dimensionless derivatives of Gibbs function\";
//   output Modelica.Media.Common.PhaseBoundaryProperties sat \"phase boundary properties\";
//   protected Real vt \"derivative of specific volume w.r.t. temperature\";
//   protected Real vp \"derivative of specific volume w.r.t. pressure\";
// algorithm
//   sat.d := g.p / (g.gpi * g.pi * g.T * g.R);
//   sat.h := g.R * g.T * g.tau * g.gtau;
//   sat.u := g.T * g.R * (g.tau * g.gtau - g.pi * g.gpi);
//   sat.s := g.R * (g.tau * g.gtau - g.g);
//   sat.cp := (-g.R) * g.tau ^ 2.0 * g.gtautau;
//   sat.cv := g.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//   vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * g.R / g.p;
//   vp := g.gpipi * g.pi ^ 2.0 * g.R * g.T / g.p ^ 2.0;
//   sat.pt := (g.tau * g.gtaupi - g.gpi) * g.p / (g.pi * g.gpipi * g.T);
//   sat.pd := (-g.R) * g.T * g.gpi ^ 2.0 / g.gpipi;
// end Modelica.Media.Common.gibbsToBoundaryProps;
// 
// function Modelica.Media.Common.helmholtzToBoundaryProps \"calulate phase boundary property record from dimensionless Helmholtz function\"
//   input Modelica.Media.Common.HelmholtzDerivs f \"dimensionless derivatives of Helmholtz function\";
//   output Modelica.Media.Common.PhaseBoundaryProperties sat \"phase boundary property record\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
// algorithm
//   p := f.R * f.d * f.T * f.delta * f.fdelta;
//   sat.d := f.d;
//   sat.h := f.R * f.T * (f.tau * f.ftau + f.delta * f.fdelta);
//   sat.s := f.R * (f.tau * f.ftau - f.f);
//   sat.u := f.R * f.T * f.tau * f.ftau;
//   sat.cp := f.R * ((-f.tau ^ 2.0) * f.ftautau + (f.delta * (f.fdelta - f.tau * f.fdeltatau)) ^ 2.0 / (2.0 * f.delta * f.fdelta + f.delta ^ 2.0 * f.fdeltadelta));
//   sat.cv := f.R * (-f.tau ^ 2.0) * f.ftautau;
//   sat.pt := f.R * f.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//   sat.pd := f.R * f.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
// end Modelica.Media.Common.helmholtzToBoundaryProps;
// 
// function Modelica.Media.Interfaces.PartialMedium.ThermodynamicState \"Automatically generated record constructor for Modelica.Media.Interfaces.PartialMedium.ThermodynamicState\"
//   output ThermodynamicState res;
// end Modelica.Media.Interfaces.PartialMedium.ThermodynamicState;
// 
// function Modelica.Media.Interfaces.PartialMedium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Media.Interfaces.PartialMedium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Media.Interfaces.PartialMedium.setState_pTX;
// 
// function Modelica.Media.Interfaces.PartialMedium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Media.Interfaces.PartialMedium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// end Modelica.Media.Interfaces.PartialMedium.specificEnthalpy;
// 
// function Modelica.Media.Interfaces.PartialMedium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := Modelica.Media.Interfaces.PartialMedium.specificEnthalpy(Modelica.Media.Interfaces.PartialMedium.setState_pTX(p, T, X));
// end Modelica.Media.Interfaces.PartialMedium.specificEnthalpy_pTX;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState \"Automatically generated record constructor for Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   output ThermodynamicState res;
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.setState_pTX;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy(Modelica.Media.Interfaces.PartialTwoPhaseMedium.setState_pTX(p, T, X, 0));
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy_pTX;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3a_ph \"Region 3 a: inverse function T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Temperature\";
//   protected constant Real[31] n = {-0.000000133645667811215, 0.00000455912656802978, -0.0000146294640700979, 0.0063934131297008, 372.783927268847, -7186.54377460447, 573494.7521034, -2675693.29111439, -0.0000334066283302614, -0.0245479214069597, 47.8087847764996, 0.00000764664131818904, 0.00128350627676972, 0.0171219081377331, -8.51007304583213, -0.0136513461629781, -0.00000384460997596657, 0.00337423807911655, -0.551624873066791, 0.72920227710747, -0.00992522757376041, -0.119308831407288, 0.793929190615421, 0.454270731799386, 0.20999859125991, -0.00642109823904738, -0.023515586860454, 0.00252233108341612, -0.00764885133368119, 0.0136176427574291, -0.0133027883575669};
//   protected constant Real[31] I = {-12.0, -12.0, -12.0, -12.0, -12.0, -12.0, -12.0, -12.0, -10.0, -10.0, -10.0, -8.0, -8.0, -8.0, -8.0, -5.0, -3.0, -2.0, -2.0, -2.0, -1.0, -1.0, 0.0, 0.0, 1.0, 3.0, 3.0, 4.0, 4.0, 10.0, 12.0};
//   protected constant Real[31] J = {0.0, 1.0, 2.0, 6.0, 14.0, 16.0, 20.0, 22.0, 1.0, 5.0, 12.0, 0.0, 2.0, 4.0, 10.0, 2.0, 0.0, 1.0, 3.0, 4.0, 0.0, 2.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 3.0, 4.0, 5.0};
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = 2300000.0 \"normalization enthalpy\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 100000000.0 \"normalization pressure\";
//   protected constant Real Tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 760.0 \"normalization temperature\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2300000.0 \"normalized specific enthalpy\";
// algorithm
//   T := 391.06004482468694 + 760.0 * (-0.000000133645667811215 / (0.24 + pi) ^ 12.0 + 0.00000455912656802978 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) + -0.0000146294640700979 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) ^ 2.0 + 0.0063934131297008 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) ^ 6.0 + 372.783927268847 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) ^ 14.0 + -7186.54377460447 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) ^ 16.0 + 573494.7521034 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) ^ 20.0 + -2675693.29111439 * (0.24 + pi) ^ -12.0 * (-0.615 + eta) ^ 22.0 + -0.0000334066283302614 * (0.24 + pi) ^ -10.0 * (-0.615 + eta) + -0.0245479214069597 * (0.24 + pi) ^ -10.0 * (-0.615 + eta) ^ 5.0 + 47.8087847764996 * (0.24 + pi) ^ -10.0 * (-0.615 + eta) ^ 12.0 + 0.00000764664131818904 / (0.24 + pi) ^ 8.0 + 0.00128350627676972 * (0.24 + pi) ^ -8.0 * (-0.615 + eta) ^ 2.0 + 0.0171219081377331 * (0.24 + pi) ^ -8.0 * (-0.615 + eta) ^ 4.0 + -8.51007304583213 * (0.24 + pi) ^ -8.0 * (-0.615 + eta) ^ 10.0 + -0.0136513461629781 * (0.24 + pi) ^ -5.0 * (-0.615 + eta) ^ 2.0 + -0.00000384460997596657 / (0.24 + pi) ^ 3.0 + 0.00337423807911655 * (0.24 + pi) ^ -2.0 * (-0.615 + eta) + -0.551624873066791 * (0.24 + pi) ^ -2.0 * (-0.615 + eta) ^ 3.0 + 0.72920227710747 * (0.24 + pi) ^ -2.0 * (-0.615 + eta) ^ 4.0 + -0.00992522757376041 / (0.24 + pi) + -0.119308831407288 * (-0.615 + eta) ^ 2.0 / (0.24 + pi) + 0.454270731799386 * eta + 0.20999859125991 * (0.24 + pi) * (-0.615 + eta) + -0.00642109823904738 * (0.24 + pi) ^ 3.0 + -0.023515586860454 * (0.24 + pi) ^ 3.0 * (-0.615 + eta) + 0.00252233108341612 * (0.24 + pi) ^ 4.0 + -0.00764885133368119 * (0.24 + pi) ^ 4.0 * (-0.615 + eta) ^ 3.0 + 0.0136176427574291 * (0.24 + pi) ^ 10.0 * (-0.615 + eta) ^ 4.0 + -0.0133027883575669 * (0.24 + pi) ^ 12.0 * (-0.615 + eta) ^ 5.0);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3a_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3b_ph \"Region 3 b: inverse function T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Temperature\";
//   protected constant Real[33] n = {0.000032325457364492, -0.000127575556587181, -0.000475851877356068, 0.00156183014181602, 0.105724860113781, -85.8514221132534, 724.140095480911, 0.00296475810273257, -0.00592721983365988, -0.0126305422818666, -0.115716196364853, 84.9000969739595, -0.0108602260086615, 0.0154304475328851, 0.0750455441524466, 0.0252520973612982, -0.0602507901232996, -3.07622221350501, -0.0574011959864879, 5.03471360939849, -0.925081888584834, 3.91733882917546, -77.314600713019, 9493.08762098587, -1410437.19679409, 8491662.30819026, 0.861095729446704, 0.32334644281172, 0.873281936020439, -0.436653048526683, 0.286596714529479, -0.131778331276228, 0.00676682064330275};
//   protected constant Real[33] I = {-12.0, -12.0, -10.0, -10.0, -10.0, -10.0, -10.0, -8.0, -8.0, -8.0, -8.0, -8.0, -6.0, -6.0, -6.0, -4.0, -4.0, -3.0, -2.0, -2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 0.0, 1.0, 3.0, 5.0, 6.0, 8.0};
//   protected constant Real[33] J = {0.0, 1.0, 0.0, 1.0, 5.0, 10.0, 12.0, 0.0, 1.0, 2.0, 4.0, 10.0, 0.0, 1.0, 2.0, 0.0, 1.0, 5.0, 0.0, 4.0, 2.0, 4.0, 6.0, 10.0, 14.0, 16.0, 0.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0};
//   protected constant Real Tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 860.0 \"normalization temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 100000000.0 \"normalization pressure\";
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = 2800000.0 \"normalization enthalpy\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2800000.0 \"normalized specific enthalpy\";
// algorithm
//   T := 740.5423273241654 + 860.0 * (0.000032325457364492 / (0.298 + pi) ^ 12.0 + -0.000127575556587181 * (0.298 + pi) ^ -12.0 * (-0.72 + eta) + -0.000475851877356068 / (0.298 + pi) ^ 10.0 + 0.00156183014181602 * (0.298 + pi) ^ -10.0 * (-0.72 + eta) + 0.105724860113781 * (0.298 + pi) ^ -10.0 * (-0.72 + eta) ^ 5.0 + -85.8514221132534 * (0.298 + pi) ^ -10.0 * (-0.72 + eta) ^ 10.0 + 724.140095480911 * (0.298 + pi) ^ -10.0 * (-0.72 + eta) ^ 12.0 + 0.00296475810273257 / (0.298 + pi) ^ 8.0 + -0.00592721983365988 * (0.298 + pi) ^ -8.0 * (-0.72 + eta) + -0.0126305422818666 * (0.298 + pi) ^ -8.0 * (-0.72 + eta) ^ 2.0 + -0.115716196364853 * (0.298 + pi) ^ -8.0 * (-0.72 + eta) ^ 4.0 + 84.9000969739595 * (0.298 + pi) ^ -8.0 * (-0.72 + eta) ^ 10.0 + -0.0108602260086615 / (0.298 + pi) ^ 6.0 + 0.0154304475328851 * (0.298 + pi) ^ -6.0 * (-0.72 + eta) + 0.0750455441524466 * (0.298 + pi) ^ -6.0 * (-0.72 + eta) ^ 2.0 + 0.0252520973612982 / (0.298 + pi) ^ 4.0 + -0.0602507901232996 * (0.298 + pi) ^ -4.0 * (-0.72 + eta) + -3.07622221350501 * (0.298 + pi) ^ -3.0 * (-0.72 + eta) ^ 5.0 + -0.0574011959864879 / (0.298 + pi) ^ 2.0 + 5.03471360939849 * (0.298 + pi) ^ -2.0 * (-0.72 + eta) ^ 4.0 + -0.925081888584834 * (-0.72 + eta) ^ 2.0 / (0.298 + pi) + 3.91733882917546 * (-0.72 + eta) ^ 4.0 / (0.298 + pi) + -77.314600713019 * (-0.72 + eta) ^ 6.0 / (0.298 + pi) + 9493.08762098587 * (-0.72 + eta) ^ 10.0 / (0.298 + pi) + -1410437.19679409 * (-0.72 + eta) ^ 14.0 / (0.298 + pi) + 8491662.30819026 * (-0.72 + eta) ^ 16.0 / (0.298 + pi) + 0.32334644281172 * (-0.72 + eta) ^ 2.0 + 0.873281936020439 * (0.298 + pi) * (-0.72 + eta) + -0.436653048526683 * (0.298 + pi) ^ 3.0 * (-0.72 + eta) + 0.286596714529479 * (0.298 + pi) ^ 5.0 * (-0.72 + eta) + -0.131778331276228 * (0.298 + pi) ^ 6.0 * (-0.72 + eta) + 0.00676682064330275 * (0.298 + pi) ^ 8.0 * (-0.72 + eta));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3b_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT \"derivative of pressure w.r.t. temperature along the saturation pressure curve\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real dpt(unit = \"Pa/K\") \"temperature derivative of pressure\";
//   protected Real[31] o \"vector of auxiliary variables\";
//   protected Real Tlim \"temeprature limited to TCRIT\";
// algorithm
//   Tlim := min(T, 647.096);
//   o[1] := -650.17534844798 + Tlim;
//   o[2] := 1.0 / o[1];
//   o[3] := -0.23855557567849 * o[2];
//   o[4] := o[3] + Tlim;
//   o[5] := -4823.2657361591 * o[4];
//   o[6] := o[4] ^ 2.0;
//   o[7] := 14.91510861353 * o[6];
//   o[8] := 405113.40542057 + o[5] + o[7];
//   o[9] := o[8] ^ 2.0;
//   o[10] := o[9] ^ 2.0;
//   o[11] := o[1] ^ 2.0;
//   o[12] := 1.0 / o[11];
//   o[13] := 0.23855557567849 * o[12];
//   o[14] := 1.0 + o[13];
//   o[15] := 12020.82470247 * o[4];
//   o[16] := -17.073846940092 * o[6];
//   o[17] := -3232555.0322333 + o[15] + o[16];
//   o[18] := -4823.2657361591 * o[14];
//   o[19] := 29.83021722706 * o[14] * o[4];
//   o[20] := o[18] + o[19];
//   o[21] := 1167.0521452767 * o[4];
//   o[22] := -724213.16703206 + o[21] + o[6];
//   o[23] := o[17] ^ 2.0;
//   o[24] := -4.0 * o[22] * o[8];
//   o[25] := o[23] + o[24];
//   o[26] := sqrt(o[25]);
//   o[27] := -12020.82470247 * o[4];
//   o[28] := 17.073846940092 * o[6];
//   o[29] := 3232555.0322333 + o[26] + o[27] + o[28];
//   o[30] := o[29] ^ 2.0;
//   o[31] := o[30] ^ 2.0;
//   dpt := 1000000.0 * (-64.0 * o[10] * (-12020.82470247 * o[14] + 34.147693880184 * o[14] * o[4] + 0.5 * (-4.0 * o[20] * o[22] + 2.0 * o[17] * (12020.82470247 * o[14] + -34.147693880184 * o[14] * o[4]) + -4.0 * (1167.0521452767 * o[14] + 2.0 * o[14] * o[4]) * o[8]) / o[26]) / (o[31] * o[29]) + 64.0 * o[20] * o[8] * o[9] / o[31]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dtsatofp \"derivative of saturation temperature w.r.t. pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real dtsat(unit = \"K/Pa\") \"derivative of T w.r.t. p\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real[49] o \"vector of auxiliary variables\";
// algorithm
//   pi := max(1e-60, 0.000001 * p);
//   o[1] := pi ^ 0.75;
//   o[2] := 1.0 / o[1];
//   o[3] := -4.268461735023 * o[2];
//   o[4] := sqrt(pi);
//   o[5] := 1.0 / o[4];
//   o[6] := 0.5 * o[5];
//   o[7] := o[3] + o[6];
//   o[8] := pi ^ 0.25;
//   o[9] := -3232555.0322333 * o[8];
//   o[10] := -724213.16703206 * o[4];
//   o[11] := 405113.40542057 + o[10] + o[9];
//   o[12] := -4.0 * o[11] * o[7];
//   o[13] := -808138.758058325 * o[2];
//   o[14] := -362106.58351603 * o[5];
//   o[15] := o[13] + o[14];
//   o[16] := -17.073846940092 * o[8];
//   o[17] := 14.91510861353 + o[16] + o[4];
//   o[18] := -4.0 * o[15] * o[17];
//   o[19] := 3005.2061756175 * o[2];
//   o[20] := 583.52607263835 * o[5];
//   o[21] := o[19] + o[20];
//   o[22] := 12020.82470247 * o[8];
//   o[23] := 1167.0521452767 * o[4];
//   o[24] := -4823.2657361591 + o[22] + o[23];
//   o[25] := 2.0 * o[21] * o[24];
//   o[26] := o[12] + o[18] + o[25];
//   o[27] := -4.0 * o[11] * o[17];
//   o[28] := o[24] ^ 2.0;
//   o[29] := o[27] + o[28];
//   o[30] := sqrt(o[29]);
//   o[31] := 1.0 / o[30];
//   o[32] := -o[30];
//   o[33] := -12020.82470247 * o[8];
//   o[34] := -1167.0521452767 * o[4];
//   o[35] := 4823.2657361591 + o[32] + o[33] + o[34];
//   o[36] := o[30];
//   o[37] := -4823.2657361591 + o[22] + o[23] + o[36];
//   o[38] := o[37] ^ 2.0;
//   o[39] := 1.0 / o[38];
//   o[40] := -1.72207339365771 * o[30];
//   o[41] := 21592.2055343628 * o[8];
//   o[42] := o[30] * o[8];
//   o[43] := -8192.87114842946 * o[4];
//   o[44] := -0.510632954559659 * o[30] * o[4];
//   o[45] := -3100.02526152368 * o[1];
//   o[46] := pi;
//   o[47] := 1295.95640782102 * o[46];
//   o[48] := 2862.09212505088 + o[40] + o[41] + o[42] + o[43] + o[44] + o[45] + o[47];
//   o[49] := o[35] ^ -2.0;
//   dtsat := 0.0000005 * (2.0 * o[15] / o[35] + -2.0 * o[11] * (-3005.2061756175 * o[2] + -0.5 * o[26] * o[31] + -583.52607263835 * o[5]) * o[49] + -20953.46356643991 * (o[39] * (1295.95640782102 + 5398.05138359071 * o[2] + 0.25 * o[2] * o[30] + -0.861036696828853 * o[26] * o[31] + -0.255316477279829 * o[26] * o[31] * o[4] + -4096.43557421473 * o[5] + -0.255316477279829 * o[30] * o[5] + -2325.01894614276 / o[8] + 0.5 * o[26] * o[31] * o[8]) + -2.0 * (o[19] + o[20] + 0.5 * o[26] * o[31]) * o[48] / o[37] ^ 3.0) / sqrt(o[39] * o[48]));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dtsatofp;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3 \"Helmholtz function for region 3: f(d,T)\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Real[40] o \"vector of auxiliary variables\";
// algorithm
//   f.T := T;
//   f.d := d;
//   f.R := 461.526;
//   f.tau := 647.096 / T;
//   f.delta := if d == 322.0 and T == 647.096 then 0.999999999999999 else abs(d / 322.0);
//   o[1] := f.tau ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] * f.tau;
//   o[4] := o[1] * f.tau;
//   o[5] := o[2] ^ 2.0;
//   o[6] := o[1] * o[5] * f.tau;
//   o[7] := o[5] * f.tau;
//   o[8] := -0.64207765181607 * o[1];
//   o[9] := 0.88521043984318 + o[8];
//   o[10] := o[7] * o[9];
//   o[11] := -1.1524407806681 + o[10];
//   o[12] := o[11] * o[2];
//   o[13] := -1.2654315477714 + o[12];
//   o[14] := o[1] * o[13];
//   o[15] := o[1] * o[2] * o[5] * f.tau;
//   o[16] := o[2] * o[5];
//   o[17] := o[1] * o[5];
//   o[18] := o[5] ^ 2.0;
//   o[19] := o[1] * o[18] * o[2];
//   o[20] := o[1] * o[18] * o[2] * f.tau;
//   o[21] := o[18] * o[5];
//   o[22] := o[1] * o[18] * o[5];
//   o[23] := 0.25116816848616 * o[2];
//   o[24] := 0.078841073758308 + o[23];
//   o[25] := o[15] * o[24];
//   o[26] := -6.100523451393 + o[25];
//   o[27] := o[26] * f.tau;
//   o[28] := 9.7944563083754 + o[27];
//   o[29] := o[2] * o[28];
//   o[30] := -1.70429417648412 + o[29];
//   o[31] := o[1] * o[30];
//   o[32] := f.delta ^ 2.0;
//   o[33] := -10.9153200808732 * o[1];
//   o[34] := 13.2781565976477 + o[33];
//   o[35] := o[34] * o[7];
//   o[36] := -6.9146446840086 + o[35];
//   o[37] := o[2] * o[36];
//   o[38] := -2.5308630955428 + o[37];
//   o[39] := o[38] * f.tau;
//   o[40] := o[18] * o[5] * f.tau;
//   f.f := -15.732845290239 + f.tau * (20.944396974307 + (-7.6867707878716 + o[3] * (2.6185947787954 + o[4] * (-2.808078114862 + o[1] * (1.2053369696517 + -0.0084566812812502 * o[6])))) * f.tau) + f.delta * (o[14] + f.delta * (0.38493460186671 + o[1] * (-0.85214708824206 + o[2] * (4.8972281541877 + (-3.0502617256965 + o[15] * (0.039420536879154 + 0.12558408424308 * o[2])) * f.tau)) + f.delta * (-0.2799932969871 + o[1] * (1.389979956946 + o[1] * (-2.018991502357 + o[16] * (-0.0082147637173963 + -0.47596035734923 * o[17]))) + f.delta * (0.0439840744735 + o[1] * (-0.44476435428739 + o[1] * (0.90572070719733 + 0.70522450087967 * o[19])) + f.delta * (f.delta * (-0.022175400873096 + o[1] * (0.094260751665092 + 0.16436278447961 * o[21]) + f.delta * (-0.013503372241348 * o[1] + f.delta * (-0.014834345352472 * o[22] + f.delta * (o[1] * (0.00057922953628084 + 0.0032308904703711 * o[21]) + f.delta * (0.000080964802996215 + -0.000044923899061815 * f.delta * o[22] + -0.00016557679795037 * f.tau))))) + (0.10770512626332 + o[1] * (-0.32913623258954 + -0.50871062041158 * o[20])) * f.tau))))) + 1.0658070028513 * log(f.delta);
//   f.fdelta := (1.0658070028513 + f.delta * (o[14] + f.delta * (0.76986920373342 + o[31] + f.delta * (-0.8399798909613 + o[1] * (4.169939870838 + o[1] * (-6.056974507071 + o[16] * (-0.0246442911521889 + -1.42788107204769 * o[17]))) + f.delta * (0.175936297894 + o[1] * (-1.77905741714956 + o[1] * (3.6228828287893 + 2.82089800351868 * o[19])) + f.delta * (f.delta * (-0.133052405238576 + o[1] * (0.56556450999055 + 0.98617670687766 * o[21]) + f.delta * (-0.094523605689436 * o[1] + f.delta * (-0.118674762819776 * o[22] + f.delta * (o[1] * (0.0052130658265276 + 0.0290780142333399 * o[21]) + f.delta * (0.00080964802996215 + -0.00049416288967996 * f.delta * o[22] + -0.0016557679795037 * f.tau))))) + (0.5385256313166 + o[1] * (-1.6456811629477 + -2.5435531020579 * o[20])) * f.tau)))))) / f.delta;
//   f.fdeltadelta := (-1.0658070028513 + o[32] * (0.76986920373342 + o[31] + f.delta * (-1.6799597819226 + o[1] * (8.339879741676 + o[1] * (-12.113949014142 + o[16] * (-0.049288582304378 + -2.85576214409538 * o[17]))) + f.delta * (0.527808893682 + o[1] * (-5.3371722514487 + o[1] * (10.868648486368 + 8.462694010556 * o[19])) + f.delta * (f.delta * (-0.66526202619288 + o[1] * (2.82782254995276 + 4.9308835343883 * o[21]) + f.delta * (-0.56714163413662 * o[1] + f.delta * (-0.83072333973843 * o[22] + f.delta * (o[1] * (0.04170452661222 + 0.232624113866719 * o[21]) + f.delta * (0.0072868322696594 + -0.0049416288967996 * f.delta * o[22] + -0.0149019118155333 * f.tau))))) + (2.1541025252664 + o[1] * (-6.5827246517908 + -10.1742124082316 * o[20])) * f.tau))))) / o[32];
//   f.ftau := 20.944396974307 + (-15.3735415757432 + o[3] * (18.3301634515678 + o[4] * (-28.08078114862 + o[1] * (14.4640436358204 + -0.194503669468755 * o[6])))) * f.tau + f.delta * (o[39] + f.delta * (f.tau * (-1.70429417648412 + o[2] * (29.3833689251262 + (-21.3518320798755 + o[15] * (0.86725181134139 + 3.2651861903201 * o[2])) * f.tau)) + f.delta * ((2.779959913892 + o[1] * (-8.075966009428 + o[16] * (-0.131436219478341 + -12.37496929108 * o[17]))) * f.tau + f.delta * ((-0.88952870857478 + o[1] * (3.6228828287893 + 18.3358370228714 * o[19])) * f.tau + f.delta * (0.10770512626332 + o[1] * (-0.98740869776862 + -13.2264761307011 * o[20]) + f.delta * ((0.188521503330184 + 4.2734323964699 * o[21]) * f.tau + f.delta * (-0.027006744482696 * f.tau + f.delta * (-0.38569297916427 * o[40] + f.delta * (f.delta * (-0.00016557679795037 + -0.00116802137560719 * f.delta * o[40]) + (0.00115845907256168 + 0.084003152229649 * o[21]) * f.tau)))))))));
//   f.ftautau := -15.3735415757432 + o[3] * (109.980980709407 + o[4] * (-252.72703033758 + o[1] * (159.104479994024 + -4.2790807283126 * o[6]))) + f.delta * (-2.5308630955428 + o[2] * (-34.573223420043 + (185.894192367068 + -174.645121293971 * o[1]) * o[7]) + f.delta * (-1.70429417648412 + o[2] * (146.916844625631 + (-128.110992479253 + o[15] * (18.2122880381691 + 81.629654758002 * o[2])) * f.tau) + f.delta * (2.779959913892 + o[1] * (-24.227898028284 + o[16] * (-1.97154329217511 + -309.374232277 * o[17])) + f.delta * (-0.88952870857478 + o[1] * (10.868648486368 + 458.39592557179 * o[19]) + f.delta * (f.delta * (0.188521503330184 + 106.835809911747 * o[21] + f.delta * (-0.027006744482696 + f.delta * (-9.6423244791068 * o[21] + f.delta * (0.00115845907256168 + 2.10007880574121 * o[21] + -0.0292005343901797 * o[21] * o[32])))) + (-1.97481739553724 + -330.66190326753 * o[20]) * f.tau)))));
//   f.fdeltatau := o[39] + f.delta * (f.tau * (-3.4085883529682 + o[2] * (58.766737850252 + (-42.703664159751 + o[15] * (1.73450362268278 + 6.5303723806402 * o[2])) * f.tau)) + f.delta * ((8.339879741676 + o[1] * (-24.227898028284 + o[16] * (-0.39430865843502 + -37.12490787324 * o[17]))) * f.tau + f.delta * ((-3.5581148342991 + o[1] * (14.4915313151573 + 73.343348091486 * o[19])) * f.tau + f.delta * (0.5385256313166 + o[1] * (-4.9370434888431 + -66.132380653505 * o[20]) + f.delta * ((1.1311290199811 + 25.6405943788192 * o[21]) * f.tau + f.delta * (-0.189047211378872 * f.tau + f.delta * (-3.08554383331418 * o[40] + f.delta * (f.delta * (-0.0016557679795037 + -0.0128482351316791 * f.delta * o[40]) + (0.0104261316530551 + 0.75602837006684 * o[21]) * f.tau))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1 \"Gibbs function for region 1: g(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real tau1 \"dimensionless temperature\";
//   protected Real[45] o \"vector of auxiliary variables\";
//   protected Real pl \"auxiliary variable\";
// algorithm
//   pl := min(p, 22063999.0);
//   assert( p > 611.657, \"IF97 medium function g1 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   assert( p <= 100000000.0, \"IF97 medium function g1: the input pressure (= \" + String(p, 0, true, 6) + \" Pa) is higher than 100 Mpa\");
//   assert( T >= 273.15, \"IF97 medium function g1: the temperature (= \" + String(T, 0, true, 6) + \" K)  is lower than 273.15 K!\");
//   g.p := p;
//   g.T := T;
//   g.R := 461.526;
//   g.pi := p / 16530000.0;
//   g.tau := 1386.0 / T;
//   pi1 := 7.1 - g.pi;
//   tau1 := -1.222 + g.tau;
//   o[1] := tau1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   o[4] := o[3] * tau1;
//   o[5] := 1.0 / o[4];
//   o[6] := o[1] * o[2];
//   o[7] := o[1] * tau1;
//   o[8] := 1.0 / o[7];
//   o[9] := o[1] * o[2] * o[3];
//   o[10] := 1.0 / o[2];
//   o[11] := o[2] * tau1;
//   o[12] := 1.0 / o[11];
//   o[13] := o[2] * o[3];
//   o[14] := 1.0 / o[3];
//   o[15] := pi1 ^ 2.0;
//   o[16] := o[15] * pi1;
//   o[17] := o[15] ^ 2.0;
//   o[18] := o[17] ^ 2.0;
//   o[19] := o[17] * o[18] * pi1;
//   o[20] := o[15] * o[17];
//   o[21] := o[3] ^ 2.0;
//   o[22] := o[21] ^ 2.0;
//   o[23] := o[22] * o[3] * tau1;
//   o[24] := 1.0 / o[23];
//   o[25] := o[22] * o[3];
//   o[26] := 1.0 / o[25];
//   o[27] := o[1] * o[2] * o[22] * tau1;
//   o[28] := 1.0 / o[27];
//   o[29] := o[1] * o[2] * o[22];
//   o[30] := 1.0 / o[29];
//   o[31] := o[1] * o[2] * o[21] * o[3] * tau1;
//   o[32] := 1.0 / o[31];
//   o[33] := o[2] * o[21] * o[3] * tau1;
//   o[34] := 1.0 / o[33];
//   o[35] := o[1] * o[3] * tau1;
//   o[36] := 1.0 / o[35];
//   o[37] := o[1] * o[3];
//   o[38] := 1.0 / o[37];
//   o[39] := 1.0 / o[6];
//   o[40] := o[1] * o[22] * o[3];
//   o[41] := 1.0 / o[40];
//   o[42] := 1.0 / o[22];
//   o[43] := o[1] * o[2] * o[21] * o[3];
//   o[44] := 1.0 / o[43];
//   o[45] := 1.0 / o[13];
//   g.g := pi1 * (pi1 * (pi1 * (o[10] * (-0.000031679644845054 + o[2] * (-0.0000028270797985312 + -0.00000000085205128120103 * o[6])) + pi1 * (o[12] * (-0.0000022425281908 + (-0.00000065171222895601 + -0.00000000000014341729937924 * o[13]) * o[7]) + pi1 * (-0.00000040516996860117 * o[14] + o[16] * ((-0.0000000012734301741641 + -0.00000000017424871230634 * o[11]) * o[36] + o[19] * (-0.00000000000000000068762131295531 * o[34] + o[15] * (0.000000000000000000014478307828521 * o[32] + o[20] * (0.000000000000000000000026335781662795 * o[30] + pi1 * (-0.000000000000000000000011947622640071 * o[28] + pi1 * (0.0000000000000000000000018228094581404 * o[26] + -0.000000000000000000000000093537087292458 * o[24] * pi1))))))))) + o[8] * (-0.00047184321073267 + o[7] * (-0.00030001780793026 + (0.000047661393906987 + o[1] * (-0.0000044141845330846 + -0.00000000000000072694996297594 * o[9])) * tau1))) + o[5] * (0.00028319080123804 + o[1] * (-0.00060706301565874 + o[6] * (-0.018990068218419 + tau1 * (-0.032529748770505 + (-0.021841717175414 + -0.00005283835796993 * o[1]) * tau1))))) + (0.14632971213167 + tau1 * (-0.84548187169114 + tau1 * (-3.756360367204 + tau1 * (3.3855169168385 + tau1 * (-0.95791963387872 + tau1 * (0.15772038513228 + (-0.016616417199501 + 0.00081214629983568 * tau1) * tau1)))))) / o[1];
//   g.gpi := pi1 * (pi1 * (o[10] * (0.000095038934535162 + o[2] * (0.0000084812393955936 + 0.00000000255615384360309 * o[6])) + pi1 * (o[12] * (0.0000089701127632 + (0.00000260684891582404 + 0.00000000000057366919751696 * o[13]) * o[7]) + pi1 * (0.00000202584984300585 * o[14] + o[16] * ((0.0000000101874413933128 + 0.00000000139398969845072 * o[11]) * o[36] + o[19] * (0.0000000000000000144400475720615 * o[34] + o[15] * (-0.00000000000000000033300108005598 * o[32] + o[20] * (-0.00000000000000000000076373766822106 * o[30] + pi1 * (0.00000000000000000000035842867920213 * o[28] + pi1 * (-0.000000000000000000000056507093202352 * o[26] + 0.00000000000000000000000299318679335866 * o[24] * pi1))))))))) + o[8] * (0.00094368642146534 + o[7] * (0.00060003561586052 + (-0.000095322787813974 + o[1] * (0.0000088283690661692 + 0.00000000000000145389992595188 * o[9])) * tau1))) + o[5] * (-0.00028319080123804 + o[1] * (0.00060706301565874 + o[6] * (0.018990068218419 + tau1 * (0.032529748770505 + (0.021841717175414 + 0.00005283835796993 * o[1]) * tau1))));
//   g.gpipi := pi1 * (o[10] * (-0.000190077869070324 + o[2] * (-0.0000169624787911872 + -0.0000000051123076872062 * o[6])) + pi1 * (o[12] * (-0.0000269103382896 + (-0.0000078205467474721 + -0.00000000000172100759255088 * o[13]) * o[7]) + pi1 * (-0.0000081033993720234 * o[14] + o[16] * ((-0.00000007131208975319 + -0.000000009757927889155 * o[11]) * o[36] + o[19] * (-0.00000000000000028880095144123 * o[34] + o[15] * (0.0000000000000000073260237612316 * o[32] + o[20] * (0.0000000000000000000213846547101895 * o[30] + pi1 * (-0.0000000000000000000103944316968618 * o[28] + pi1 * (0.00000000000000000000169521279607057 * o[26] + -0.000000000000000000000092788790594118 * o[24] * pi1))))))))) + o[8] * (-0.00094368642146534 + o[7] * (-0.00060003561586052 + (0.000095322787813974 + o[1] * (-0.0000088283690661692 + -0.00000000000000145389992595188 * o[9])) * tau1));
//   g.gtau := pi1 * (o[38] * (-0.00254871721114236 + o[1] * (0.0042494411096112 + (0.018990068218419 + (-0.021841717175414 + -0.00015851507390979 * o[1]) * o[1]) * o[6])) + pi1 * (o[10] * (0.00141552963219801 + o[2] * (0.000047661393906987 + o[1] * (-0.0000132425535992538 + -0.000000000000012358149370591 * o[9]))) + pi1 * (o[12] * (0.000126718579380216 + -0.0000000051123076872062 * o[37]) + pi1 * (o[39] * (0.000011212640954 + (0.00000130342445791202 + -0.0000000000014341729937924 * o[13]) * o[7]) + pi1 * (0.0000032413597488094 * o[5] + o[16] * ((0.0000000140077319158051 + 0.00000000104549227383804 * o[11]) * o[45] + o[19] * (0.000000000000000019941018075704 * o[44] + o[15] * (-0.00000000000000000044882754268415 * o[42] + o[20] * (-0.00000000000000000000100075970318621 * o[28] + pi1 * (0.00000000000000000000046595728296277 * o[26] + pi1 * (-0.000000000000000000000072912378325616 * o[24] + 0.0000000000000000000000038350205789908 * o[41] * pi1))))))))))) + o[8] * (-0.29265942426334 + tau1 * (0.84548187169114 + o[1] * (3.3855169168385 + tau1 * (-1.91583926775744 + tau1 * (0.47316115539684 + (-0.066465668798004 + 0.0040607314991784 * tau1) * tau1)))));
//   g.gtautau := pi1 * (o[36] * (0.0254871721114236 + o[1] * (-0.033995528876889 + (-0.037980136436838 + -0.00031703014781958 * o[2]) * o[6])) + pi1 * (o[12] * (-0.005662118528792 + o[6] * (-0.0000264851071985076 + -0.000000000000197730389929456 * o[9])) + pi1 * ((-0.00063359289690108 + -0.0000000255615384360309 * o[37]) * o[39] + pi1 * (pi1 * (-0.0000291722377392842 * o[38] + o[16] * (o[19] * (-0.00000000000000059823054227112 * o[32] + o[15] * (o[20] * (0.000000000000000000039029628424262 * o[26] + pi1 * (-0.0000000000000000000186382913185108 * o[24] + pi1 * (0.00000000000000000000298940751135026 * o[41] + -0.000000000000000000000161070864317613 * pi1 / (o[1] * o[22] * o[3] * tau1)))) + 0.0000000000000000143624813658928 / (o[22] * tau1))) + (-0.000000168092782989661 + -0.0000000073184459168663 * o[11]) / (o[2] * o[3] * tau1))) + (-0.000067275845724 + (-0.0000039102733737361 + -0.0000000000129075569441316 * o[13]) * o[7]) / (o[1] * o[2] * tau1))))) + o[10] * (0.87797827279002 + tau1 * (-1.69096374338228 + o[7] * (-1.91583926775744 + tau1 * (0.94632231079368 + (-0.199397006394012 + 0.0162429259967136 * tau1) * tau1))));
//   g.gtaupi := o[38] * (0.00254871721114236 + o[1] * (-0.0042494411096112 + (-0.018990068218419 + (0.021841717175414 + 0.00015851507390979 * o[1]) * o[1]) * o[6])) + pi1 * (o[10] * (-0.00283105926439602 + o[2] * (-0.000095322787813974 + o[1] * (0.0000264851071985076 + 0.000000000000024716298741182 * o[9]))) + pi1 * (o[12] * (-0.00038015573814065 + 0.0000000153369230616185 * o[37]) + pi1 * (o[39] * (-0.000044850563816 + (-0.0000052136978316481 + 0.0000000000057366919751696 * o[13]) * o[7]) + pi1 * (-0.0000162067987440468 * o[5] + o[16] * ((-0.000000112061855326441 + -0.0000000083639381907043 * o[11]) * o[45] + o[19] * (-0.00000000000000041876137958978 * o[44] + o[15] * (0.0000000000000000103230334817355 * o[42] + o[20] * (0.0000000000000000000290220313924001 * o[28] + pi1 * (-0.0000000000000000000139787184888831 * o[26] + pi1 * (0.0000000000000000000022602837280941 * o[24] + -0.000000000000000000000122720658527705 * o[41] * pi1))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2 \"Gibbs function for region 2: g(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Real tau2 \"dimensionless temperature\";
//   protected Real[55] o \"vector of auxiliary variables\";
// algorithm
//   g.p := p;
//   g.T := T;
//   g.R := 461.526;
//   assert( p > 611.657, \"IF97 medium function g2 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   assert( p <= 100000000.0, \"IF97 medium function g2: the input pressure (= \" + String(p, 0, true, 6) + \" Pa) is higher than 100 Mpa\");
//   assert( T >= 273.15, \"IF97 medium function g2: the temperature (= \" + String(T, 0, true, 6) + \" K) is lower than 273.15 K!\");
//   assert( T <= 1073.15, \"IF97 medium function g2: the input temperature (= \" + String(T, 0, true, 6) + \" K) is higher than the limit of 1073.15 K\");
//   g.pi := p / 1000000.0;
//   g.tau := 540.0 / T;
//   tau2 := -0.5 + g.tau;
//   o[1] := tau2 ^ 2.0;
//   o[2] := o[1] * tau2;
//   o[3] := -0.05032527872793 * o[2];
//   o[4] := -0.057581259083432 + o[3];
//   o[5] := o[4] * tau2;
//   o[6] := -0.045996013696365 + o[5];
//   o[7] := o[6] * tau2;
//   o[8] := -0.017834862292358 + o[7];
//   o[9] := o[8] * tau2;
//   o[10] := o[1] ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   o[12] := o[11] ^ 2.0;
//   o[13] := o[10] * o[11] * o[12] * tau2;
//   o[14] := o[1] * o[10] * tau2;
//   o[15] := o[10] * o[11] * tau2;
//   o[16] := o[1] * o[12] * tau2;
//   o[17] := o[1] * o[11] * tau2;
//   o[18] := o[1] * o[10] * o[11];
//   o[19] := o[10] * o[11] * o[12];
//   o[20] := o[1] * o[10];
//   o[21] := g.pi ^ 2.0;
//   o[22] := o[21] ^ 2.0;
//   o[23] := o[21] * o[22];
//   o[24] := o[10] * o[12] * tau2;
//   o[25] := o[12] ^ 2.0;
//   o[26] := o[11] * o[12] * o[25] * tau2;
//   o[27] := o[10] * o[12];
//   o[28] := o[1] * o[10] * o[11] * tau2;
//   o[29] := o[10] * o[12] * o[25] * tau2;
//   o[30] := o[1] * o[10] * o[25] * tau2;
//   o[31] := o[1] * o[11] * o[12];
//   o[32] := o[1] * o[12];
//   o[33] := g.tau ^ 2.0;
//   o[34] := o[33] ^ 2.0;
//   o[35] := -0.000053349095828174 * o[13];
//   o[36] := -0.087594591301146 + o[35];
//   o[37] := o[2] * o[36];
//   o[38] := -0.007878555448671 + o[37];
//   o[39] := o[1] * o[38];
//   o[40] := -0.0003789797503263 + o[39];
//   o[41] := o[40] * tau2;
//   o[42] := -0.000066065283340406 + o[41];
//   o[43] := o[42] * tau2;
//   o[44] := 0.0000057870447262208 * tau2;
//   o[45] := -0.30195167236758 * o[2];
//   o[46] := -0.172743777250296 + o[45];
//   o[47] := o[46] * tau2;
//   o[48] := -0.09199202739273 + o[47];
//   o[49] := o[48] * tau2;
//   o[50] := o[1] * o[11];
//   o[51] := o[10] * o[11];
//   o[52] := o[11] * o[12] * o[25];
//   o[53] := o[10] * o[12] * o[25];
//   o[54] := o[1] * o[10] * o[25];
//   o[55] := o[11] * o[12] * tau2;
//   g.g := g.pi * (-0.0017731742473213 + o[9] + g.pi * (tau2 * (-0.000033032641670203 + (-0.00018948987516315 + o[1] * (-0.0039392777243355 + (-0.043797295650573 + -0.000026674547914087 * o[13]) * o[2])) * tau2) + g.pi * (0.000000020481737692309 + (0.00000043870667284435 + o[1] * (-0.00003227767723857 + (-0.0015033924542148 + -0.040668253562649 * o[13]) * o[2])) * tau2 + g.pi * (g.pi * (0.0000022922076337661 * o[14] + g.pi * ((-0.000000000016714766451061 + o[15] * (-0.0021171472321355 + -23.895741934104 * o[16])) * o[2] + g.pi * (-0.000000000000000005905956432427 + o[17] * (-0.0000012621808899101 + -0.038946842435739 * o[18]) + g.pi * (o[11] * (0.000000000011256211360459 + -8.2311340897998 * o[19]) + g.pi * (0.000000019809712802088 * o[15] + g.pi * (o[10] * (0.00000000000000000010406965210174 + (-0.00000000000010234747095929 + -0.0000000010018179379511 * o[10]) * o[20]) + o[23] * (o[13] * (-0.000000000080882908646985 + 0.10693031879409 * o[24]) + o[21] * (-0.33662250574171 * o[26] + o[21] * (o[27] * (0.00000000000000000000000089185845355421 + (0.00000000000030629316876232 + -0.0000042002467698208 * o[15]) * o[28]) + g.pi * (-0.000000000000000000000000059056029685639 * o[24] + g.pi * (0.0000037826947613457 * o[29] + g.pi * (-0.0000000000000012768608934681 * o[30] + o[31] * (0.000000000000000000000000000073087610595061 + o[18] * (0.000000000000000055414715350778 + -0.0000009436970724121 * o[32])) * g.pi)))))))))))) + tau2 * (-0.00000000078847309559367 + (0.000000012790717852285 + 0.00000048225372718507 * tau2) * tau2))))) + (-0.00560879118302 + g.tau * (0.07145273881455 + g.tau * (-0.4071049823928 + g.tau * (1.424081971444 + g.tau * (-4.38395111945 + g.tau * (-9.692768600217 + g.tau * (10.08665568018 + (-0.2840863260772 + 0.02126846353307 * g.tau) * g.tau) + log(g.pi))))))) / (o[34] * g.tau);
//   g.gpi := (1.0 + g.pi * (-0.0017731742473213 + o[9] + g.pi * (o[43] + g.pi * (0.000000061445213076927 + (0.00000131612001853305 + o[1] * (-0.00009683303171571 + (-0.0045101773626444 + -0.122004760687947 * o[13]) * o[2])) * tau2 + g.pi * (g.pi * (0.0000114610381688305 * o[14] + g.pi * ((-0.000000000100288598706366 + o[15] * (-0.012702883392813 + -143.374451604624 * o[16])) * o[2] + g.pi * (-0.000000000000000041341695026989 + o[17] * (-0.0000088352662293707 + -0.272627897050173 * o[18]) + g.pi * (o[11] * (0.000000000090049690883672 + -65.849072718398 * o[19]) + g.pi * (0.000000178287415218792 * o[15] + g.pi * (o[10] * (0.0000000000000000010406965210174 + (-0.0000000000010234747095929 + -0.000000010018179379511 * o[10]) * o[20]) + o[23] * (o[13] * (-0.00000000129412653835176 + 1.71088510070544 * o[24]) + o[21] * (-6.0592051033508 * o[26] + o[21] * (o[27] * (0.0000000000000000000000178371690710842 + (0.0000000000061258633752464 + -0.000084004935396416 * o[15]) * o[28]) + g.pi * (-0.00000000000000000000000124017662339842 * o[24] + g.pi * (0.000083219284749605 * o[29] + g.pi * (-0.0000000000000293678005497663 * o[30] + o[31] * (0.00000000000000000000000000175410265428146 + o[18] * (0.00000000000000132995316841867 + -0.0000226487297378904 * o[32])) * g.pi)))))))))))) + tau2 * (-0.00000000315389238237468 + (0.00000005116287140914 + 0.00000192901490874028 * tau2) * tau2)))))) / g.pi;
//   g.gpipi := (-1.0 + o[21] * (o[43] + g.pi * (0.000000122890426153854 + (0.0000026322400370661 + o[1] * (-0.00019366606343142 + (-0.0090203547252888 + -0.244009521375894 * o[13]) * o[2])) * tau2 + g.pi * (g.pi * (0.000045844152675322 * o[14] + g.pi * ((-0.00000000050144299353183 + o[15] * (-0.063514416964065 + -716.87225802312 * o[16])) * o[2] + g.pi * (-0.000000000000000248050170161934 + o[17] * (-0.000053011597376224 + -1.63576738230104 * o[18]) + g.pi * (o[11] * (0.0000000006303478361857 + -460.94350902879 * o[19]) + g.pi * (0.00000142629932175034 * o[15] + g.pi * (o[10] * (0.0000000000000000093662686891566 + (-0.0000000000092112723863361 + -0.000000090163614415599 * o[10]) * o[20]) + o[23] * (o[13] * (-0.0000000194118980752764 + 25.6632765105816 * o[24]) + o[21] * (-103.006486756963 * o[26] + o[21] * (o[27] * (0.0000000000000000000003389062123506 + (0.000000000116391404129682 + -0.0015960937725319 * o[15]) * o[28]) + g.pi * (-0.0000000000000000000000248035324679684 * o[24] + g.pi * (0.00174760497974171 * o[29] + g.pi * (-0.00000000000064609161209486 * o[30] + o[31] * (0.000000000000000000000000040344361048474 + o[18] * (0.0000000000000305889228736295 + -0.00052092078397148 * o[32])) * g.pi)))))))))))) + tau2 * (-0.000000009461677147124 + (0.00000015348861422742 + o[44]) * tau2))))) / o[21];
//   g.gtau := (0.0280439559151 + g.tau * (-0.2858109552582 + g.tau * (1.2213149471784 + g.tau * (-2.848163942888 + g.tau * (4.38395111945 + o[33] * (10.08665568018 + (-0.5681726521544 + 0.06380539059921 * g.tau) * g.tau)))))) / (o[33] * o[34]) + g.pi * (-0.017834862292358 + o[49] + g.pi * (-0.000033032641670203 + (-0.0003789797503263 + o[1] * (-0.015757110897342 + (-0.306581069554011 + -0.00096028372490713 * o[13]) * o[2])) * tau2 + g.pi * (0.00000043870667284435 + o[1] * (-0.00009683303171571 + (-0.0090203547252888 + -1.42338887469272 * o[13]) * o[2]) + g.pi * (-0.00000000078847309559367 + g.pi * (0.0000160454534363627 * o[20] + g.pi * (o[1] * (-0.000000000050144299353183 + o[15] * (-0.033874355714168 + -836.35096769364 * o[16])) + g.pi * ((-0.0000138839897890111 + -0.97367106089347 * o[18]) * o[50] + g.pi * (o[14] * (0.000000000090049690883672 + -296.320827232793 * o[19]) + g.pi * (0.000000257526266427144 * o[51] + g.pi * (o[2] * (0.00000000000000000041627860840696 + (-0.0000000000010234747095929 + -0.0000000140254511313154 * o[10]) * o[20]) + o[23] * (o[19] * (-0.00000000234560435076256 + 5.3465159397045 * o[24]) + o[21] * (-19.1874828272775 * o[52] + o[21] * (o[16] * (0.0000000000000000000000178371690710842 + (0.0000000000107202609066812 + -0.000201611844951398 * o[15]) * o[28]) + g.pi * (-0.00000000000000000000000124017662339842 * o[27] + g.pi * (0.000200482822351322 * o[53] + g.pi * (-0.000000000000049797574845256 * o[54] + (0.00000000000000000000000000190027787547159 + o[18] * (0.00000000000000221658861403112 + -0.000054734430199902 * o[32])) * o[55] * g.pi)))))))))))) + (0.00000002558143570457 + 0.00000144676118155521 * tau2) * tau2))));
//   g.gtautau := (-0.1682637354906 + g.tau * (1.429054776291 + g.tau * (-4.8852597887136 + g.tau * (8.544491828664 + g.tau * (-8.7679022389 + o[33] * (-0.5681726521544 + 0.12761078119842 * g.tau) * g.tau))))) / (o[33] * o[34] * g.tau) + g.pi * (-0.09199202739273 + (-0.34548755450059 + -1.5097583618379 * o[2]) * tau2 + g.pi * (-0.0003789797503263 + o[1] * (-0.047271332692026 + (-1.83948641732407 + -0.03360993037175 * o[13]) * o[2]) + g.pi * ((-0.00019366606343142 + (-0.045101773626444 + -48.395221739552 * o[13]) * o[2]) * tau2 + g.pi * (0.00000002558143570457 + 0.00000289352236311042 * tau2 + g.pi * (0.000096272720618176 * o[10] * tau2 + g.pi * ((-0.000000000100288598706366 + o[15] * (-0.50811533571252 + -28435.9329015838 * o[16])) * tau2 + g.pi * (o[11] * (-0.000138839897890111 + -23.3681054614434 * o[18]) * tau2 + g.pi * ((0.0000000006303478361857 + -10371.2289531477 * o[19]) * o[20] + g.pi * (0.00000309031519712573 * o[17] + g.pi * (o[1] * (0.00000000000000000124883582522088 + (-0.0000000000092112723863361 + -0.0000001823308647071 * o[10]) * o[20]) + o[23] * (o[1] * o[11] * o[12] * (-0.000000065676921821352 + 261.979281045521 * o[24]) * tau2 + o[21] * (-1074.49903832754 * o[1] * o[10] * o[12] * o[25] * tau2 + o[21] * ((0.0000000000000000000003389062123506 + (0.00000000036448887082716 + -0.0094757567127157 * o[15]) * o[28]) * o[32] + g.pi * (-0.0000000000000000000000248035324679684 * o[16] + g.pi * (0.0104251067622687 * o[1] * o[12] * o[25] * tau2 + g.pi * (o[11] * o[12] * (0.00000000000000000000000004750694688679 + o[18] * (0.000000000000086446955947214 + -0.0031198625213944 * o[32])) * g.pi + -0.00000000000189230784411972 * o[10] * o[25] * tau2))))))))))))))));
//   g.gtaupi := -0.017834862292358 + o[49] + g.pi * (-0.000066065283340406 + (-0.0007579595006526 + o[1] * (-0.031514221794684 + (-0.61316213910802 + -0.00192056744981426 * o[13]) * o[2])) * tau2 + g.pi * (0.00000131612001853305 + o[1] * (-0.00029049909514713 + (-0.0270610641758664 + -4.2701666240781 * o[13]) * o[2]) + g.pi * (-0.00000000315389238237468 + g.pi * (0.000080227267181813 * o[20] + g.pi * (o[1] * (-0.000000000300865796119098 + o[15] * (-0.203246134285008 + -5018.1058061618 * o[16])) + g.pi * ((-0.000097187928523078 + -6.8156974262543 * o[18]) * o[50] + g.pi * (o[14] * (0.00000000072039752706938 + -2370.56661786234 * o[19]) + g.pi * (0.0000023177363978443 * o[51] + g.pi * (o[2] * (0.0000000000000000041627860840696 + (-0.000000000010234747095929 + -0.000000140254511313154 * o[10]) * o[20]) + o[23] * (o[19] * (-0.000000037529669612201 + 85.544255035272 * o[24]) + o[21] * (-345.37469089099 * o[52] + o[21] * (o[16] * (0.00000000000000000000035674338142168 + (0.000000000214405218133624 + -0.004032236899028 * o[15]) * o[28]) + g.pi * (-0.0000000000000000000000260437090913668 * o[27] + g.pi * (0.0044106220917291 * o[53] + g.pi * (-0.00000000000114534422144089 * o[54] + (0.000000000000000000000000045606669011318 + o[18] * (0.000000000000053198126736747 + -0.00131362632479764 * o[32])) * o[55] * g.pi)))))))))))) + (0.00000010232574281828 + o[44]) * tau2)));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5 \"base function for region 5: g(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Real[11] o \"vector of auxiliary variables\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function g5 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   assert( p <= 10000000.0, \"IF97 medium function g5: input pressure (= \" + String(p, 0, true, 6) + \" Pa) is higher than 10 Mpa in region 5\");
//   assert( T <= 2273.15, \"IF97 medium function g5: input temperature (= \" + String(T, 0, true, 6) + \" K) is higher than limit of 2273.15K in region 5\");
//   g.p := p;
//   g.T := T;
//   g.R := 461.526;
//   g.pi := p / 1000000.0;
//   g.tau := 1000.0 / T;
//   o[1] := g.tau ^ 2.0;
//   o[2] := -0.004594282089991 * o[1];
//   o[3] := 0.0021774678714571 + o[2];
//   o[4] := o[3] * g.tau;
//   o[5] := o[1] * g.tau;
//   o[6] := o[1] ^ 2.0;
//   o[7] := o[6] ^ 2.0;
//   o[8] := o[7] * g.tau;
//   o[9] := -0.0000079449656719138 * o[8];
//   o[10] := g.pi ^ 2.0;
//   o[11] := -0.013782846269973 * o[1];
//   g.g := g.pi * (-0.00012563183589592 + o[4] + g.pi * (-0.0000039724828359569 * o[8] + 0.00000012919228289784 * o[5] * g.pi)) + (-0.024805148933466 + g.tau * (0.36901534980333 + g.tau * (-3.1161318213925 + g.tau * (-13.179983674201 + (6.8540841634434 + -0.32961626538917 * g.tau) * g.tau + log(g.pi))))) / o[5];
//   g.gpi := (1.0 + g.pi * (-0.00012563183589592 + o[4] + g.pi * (o[9] + 0.00000038757684869352 * o[5] * g.pi))) / g.pi;
//   g.gpipi := (-1.0 + o[10] * (o[9] + 0.00000077515369738704 * o[5] * g.pi)) / o[10];
//   g.gtau := g.pi * (0.0021774678714571 + o[11] + g.pi * (-0.000035752345523612 * o[7] + 0.00000038757684869352 * o[1] * g.pi)) + (0.074415446800398 + g.tau * (-0.73803069960666 + (3.1161318213925 + o[1] * (6.8540841634434 + -0.65923253077834 * g.tau)) * g.tau)) / o[6];
//   g.gtautau := (-0.297661787201592 + g.tau * (2.21409209881998 + (-6.232263642785 + -0.65923253077834 * o[5]) * g.tau)) / (o[6] * g.tau) + g.pi * (-0.027565692539946 * g.tau + g.pi * (-0.000286018764188897 * o[1] * o[6] * g.tau + 0.00000077515369738704 * g.pi * g.tau));
//   g.gtaupi := 0.0021774678714571 + o[11] + g.pi * (-0.000071504691047224 * o[7] + 0.00000116273054608056 * o[1] * g.pi);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.h3ab_p \"ergion 3 a b boundary for pressure/enthalpy\"
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"Enthalpy\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   protected constant Real[4] n = {2014.64004206875, 3.74696550136983, -0.0219921901054187, 0.000087513168600995};
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = 1000.0 \"normalization enthalpy\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 1000000.0 \"normalization pressure\";
//   protected Real pi = p / 1000000.0 \"normalized specific pressure\";
// algorithm
//   h := 2014640.0420687501 + 1000.0 * (3.74696550136983 * pi + -0.0219921901054187 * pi ^ 2.0 + 0.000087513168600995 * pi ^ 3.0);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.h3ab_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat \"region 4 saturation pressure as a functionx of temperature\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real p_sat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   protected Real[8] o \"vector of auxiliary variables\";
//   protected Real Tlim = min(T, 647.096);
// algorithm
//   assert( T >= 273.16, \"IF97 medium function psat: input temperature (= 611.657 K).
// lower than the triple point temperature 273.16 K\");
//   o[1] := -650.17534844798 + Tlim;
//   o[2] := 1.0 / o[1];
//   o[3] := -0.23855557567849 * o[2];
//   o[4] := o[3] + Tlim;
//   o[5] := -4823.2657361591 * o[4];
//   o[6] := o[4] ^ 2.0;
//   o[7] := 14.91510861353 * o[6];
//   o[8] := 405113.40542057 + o[5] + o[7];
//   p_sat := 16000000.0 * o[8] ^ 4.0 / (3232555.0322333 + -12020.82470247 * o[4] + 17.073846940092 * o[6] + ((2896852.66812824 + -4.0 * (1167.0521452767 * o[4] + o[6])) * o[8] + (-3232555.0322333 + 12020.82470247 * o[4] + -17.073846940092 * o[6]) ^ 2.0) ^ 0.5) ^ 4.0;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat_der \"derivative function for psat\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Real der_T(unit = \"K/s\") \"temperature derivative\";
//   output Real der_psat(unit = \"Pa/s\") \"pressure\";
//   protected Real dpt;
// algorithm
//   dpt := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(T);
//   der_psat := dpt * der_T;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat_der;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1 \"inverse function for region 1: T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real eta1 \"dimensionless specific enthalpy\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function tph1 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   pi := p / 1000000.0;
//   eta1 := 1.0 + h / 2500000.0;
//   o[1] := eta1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   T := -238.72489924521 + -13.391744872602 * pi + eta1 * (404.21188637945 + 43.211039183559 * pi + eta1 * (113.49746881718 + -54.010067170506 * pi + eta1 * (30.535892203916 * pi + eta1 * (-6.5964749423638 * pi + o[1] * (-5.8457616048039 + o[2] * (pi * (0.0093965400878363 + (-0.000025858641282073 + 0.000000066456186191635 * pi) * pi) + o[2] * o[3] * (-0.0001528548241314 + o[1] * o[3] * (-0.0000010866707695377 + pi * (0.0000001157364750534 + pi * (-0.0000000040644363084799 + pi * (0.000000000080670734103027 + pi * (-0.00000000000093477771213947 + (0.0000000000000058265442020601 + -0.000000000000000015020185953503 * pi) * pi))))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2 \"reverse function for region 2: T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real pi2b \"dimensionless pressure\";
//   protected Real pi2c \"dimensionless pressure\";
//   protected Real eta \"dimensionless specific enthalpy\";
//   protected Real etabc \"dimensionless specific enthalpy\";
//   protected Real eta2a \"dimensionless specific enthalpy\";
//   protected Real eta2b \"dimensionless specific enthalpy\";
//   protected Real eta2c \"dimensionless specific enthalpy\";
//   protected Real[8] o \"vector of auxiliary variables\";
// algorithm
//   pi := 0.000001 * p;
//   eta := 0.0000005 * h;
//   etabc := 0.001 * h;
//   if pi < 4.0 then
//     eta2a := eta + -2.1;
//     o[1] := eta2a ^ 2.0;
//     o[2] := o[1] ^ 2.0;
//     o[3] := pi ^ 2.0;
//     o[4] := o[3] ^ 2.0;
//     o[5] := o[3] * pi;
//     T := 1089.8952318288 + (1.844574935579 + -0.0061707422868339 * pi) * pi + eta2a * (849.51654495535 + -4.1792700549624 * pi + eta2a * (-107.81748091826 + (6.2478196935812 + -0.31078046629583 * pi) * pi + eta2a * (33.153654801263 + -17.344563108114 * pi + o[2] * (-7.4232016790248 + pi * (-200.58176862096 + 11.670873077107 * pi) + o[1] * (271.96065473796 * pi + o[1] * (-455.11318285818 * pi + eta2a * (1.3865724283226 * o[4] + o[1] * o[2] * (3091.9688604755 * pi + o[1] * (11.765048724356 + o[2] * (-13551.334240775 * o[5] + o[2] * (-62.459855192507 * o[3] * o[4] * pi + o[2] * (o[4] * (235988.32556514 + 7399.9835474766 * pi) + o[1] * (19127.72923966 * o[3] * o[4] + o[1] * (o[3] * (128127984.04046 + -551966.9703006 * o[5]) + o[1] * (-985549096.23276 * o[3] + o[1] * (2822454697.3002 * o[3] + o[1] * (o[3] * (-3594897141.0703 + 3715408.5996233 * o[5]) + o[1] * pi * (252266.40357872 + pi * (1722734991.3197 + pi * (12848734.66465 + (-13105236.545054 + -415351.64835634 * o[3]) * pi))))))))))))))))))));
//   elseif pi < 905.84278514723 + (-0.67955786399241 + 0.00012809002730136 * etabc) * etabc then
//     eta2b := eta + -2.6;
//     pi2b := pi + -2.0;
//     o[1] := pi2b ^ 2.0;
//     o[2] := o[1] * pi2b;
//     o[3] := o[1] ^ 2.0;
//     o[4] := eta2b ^ 2.0;
//     o[5] := o[4] ^ 2.0;
//     o[6] := o[4] * o[5];
//     o[7] := o[5] ^ 2.0;
//     T := 1489.5041079516 + 0.93747147377932 * pi2b + eta2b * (743.07798314034 + o[2] * (0.00011032831789999 + -0.0000000000000000017565233969407 * o[1] * o[3]) + eta2b * (-97.708318797837 + pi2b * (3.3593118604916 + pi2b * (-0.021810755324761 + pi2b * (0.00018955248387902 + (0.00000028640237477456 + -0.000000000000081456365207833 * o[2]) * pi2b))) + o[5] * (3.3809355601454 * pi2b + o[4] * (-0.10829784403677 * o[1] + o[5] * (2.4742464705674 + (0.16844539671904 + o[1] * (0.0030891541160537 + -0.000010779857357512 * pi2b)) * pi2b + o[6] * (-0.63281320016026 + pi2b * (0.73875745236695 + (-0.046333324635812 + o[1] * (-0.000076462712454814 + 0.0000002821728163504 * pi2b)) * pi2b) + o[6] * (1.1385952129658 + pi2b * (-0.47128737436186 + o[1] * (0.0013555504554949 + (0.000014052392818316 + 0.0000012704902271945 * pi2b) * pi2b)) + o[5] * (-0.47811863648625 + (0.15020273139707 + o[2] * (-0.000031083814331434 + o[1] * (-0.000000011030139238909 + -0.000000000025180545682962 * pi2b))) * pi2b + o[5] * o[7] * (0.0085208123431544 + pi2b * (-0.002176411421975 + pi2b * (0.000071280351959551 + o[1] * (-0.0000010302738212103 + (0.000000073803353468292 + 0.0000000000000086934156344163 * o[3]) * pi2b))))))))))));
//   else
//     eta2c := eta + -1.8;
//     pi2c := 25.0 + pi;
//     o[1] := pi2c ^ 2.0;
//     o[2] := o[1] ^ 2.0;
//     o[3] := o[1] * o[2] * pi2c;
//     o[4] := 1.0 / o[3];
//     o[5] := o[1] * o[2];
//     o[6] := eta2c ^ 2.0;
//     o[7] := o[2] ^ 2.0;
//     o[8] := o[6] ^ 2.0;
//     T := eta2c * ((859777.2253558 + o[1] * (482.19755109255 + 0.000000000001126159740723 * o[5])) / o[1] + eta2c * ((-583401318515.9 + (20825544563.171 + 31081.088422714 * o[2]) * pi2c) / o[5] + o[6] * (o[8] * (o[6] * (0.00000012324579690832 * o[5] + o[6] * (-0.0000011606921130984 * o[5] + o[8] * (0.000027846367088554 * o[5] + (-0.00059270038474176 * o[5] + 0.0012918582991878 * o[5] * o[6]) * o[8]))) + -10.842984880077 * pi2c) + o[4] * (7326335090218.1 + o[7] * (3.7966001272486 + (-0.04536417267666 + -0.000000000017804982240686 * o[2]) * pi2c))))) + o[4] * (-3236839855524.2 + pi2c * (358250899454.47 + pi2c * (-10783068217.47 + o[1] * pi2c * (610747.83564516 + pi2c * (-25745.72360417 + (1208.2315865936 + 0.00000000000014559115658698 * o[5]) * pi2c)))));
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat \"region 4 saturation temperature as a function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real t_sat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real[20] o \"vector of auxiliary variables\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function tsat called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   pi := 0.000001 * min(p, 22064000.0);
//   o[1] := pi ^ 0.25;
//   o[2] := -3232555.0322333 * o[1];
//   o[3] := pi ^ 0.5;
//   o[4] := -724213.16703206 * o[3];
//   o[5] := 405113.40542057 + o[2] + o[4];
//   o[6] := -17.073846940092 * o[1];
//   o[7] := 14.91510861353 + o[3] + o[6];
//   o[8] := -4.0 * o[5] * o[7];
//   o[9] := 12020.82470247 * o[1];
//   o[10] := 1167.0521452767 * o[3];
//   o[11] := -4823.2657361591 + o[10] + o[9];
//   o[12] := o[11] ^ 2.0;
//   o[13] := o[12] + o[8];
//   o[14] := o[13] ^ 0.5;
//   o[15] := -o[14];
//   o[16] := -12020.82470247 * o[1];
//   o[17] := -1167.0521452767 * o[3];
//   o[18] := 4823.2657361591 + o[15] + o[16] + o[17];
//   o[19] := 1.0 / o[18];
//   o[20] := 2.0 * o[19] * o[5];
//   t_sat := 325.08767422399 + 0.5 * (o[20] - (0.95422230271396 + -5201.40278758384 * o[19] * o[5] + (650.17534844798 + o[20]) ^ 2.0) ^ 0.5);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat_der \"derivative function for tsat\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real der_p(unit = \"Pa/s\") \"pressure derivatrive\";
//   output Real der_tsat(unit = \"K/s\") \"temperature derivative\";
//   protected Real dtp;
// algorithm
//   dtp := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dtsatofp(p);
//   der_tsat := dtp * der_p;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat_der;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3a_ph \"Region 3 a: inverse function v(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   output Real v(quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0) \"specific volume\";
//   protected constant Real[32] n = {0.00529944062966028, -0.170099690234461, 11.1323814312927, -2178.98123145125, -0.000506061827980875, 0.556495239685324, -9.43672726094016, -0.297856807561527, 93.9353943717186, 0.0192944939465981, 0.421740664704763, -3689141.2628233, -0.00737566847600639, -0.354753242424366, -1.99768169338727, 1.15456297059049, 5683.6687581596, 0.00808169540124668, 0.172416341519307, 1.04270175292927, -0.297691372792847, 0.560394465163593, 0.275234661176914, -0.148347894866012, -0.0651142513478515, -2.92468715386302, 0.0664876096952665, 3.52335014263844, -0.0146340792313332, -2.24503486668184, 1.10533464706142, -0.0408757344495612};
//   protected constant Real[32] I = {-12.0, -12.0, -12.0, -12.0, -10.0, -10.0, -10.0, -8.0, -8.0, -6.0, -6.0, -6.0, -4.0, -4.0, -3.0, -2.0, -2.0, -1.0, -1.0, -1.0, -1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 3.0, 4.0, 5.0, 8.0};
//   protected constant Real[32] J = {6.0, 8.0, 12.0, 18.0, 4.0, 7.0, 10.0, 5.0, 12.0, 3.0, 4.0, 22.0, 2.0, 3.0, 7.0, 3.0, 16.0, 0.0, 1.0, 2.0, 3.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 2.0, 2.0};
//   protected constant Real vstar(quantity = \"Volume\", unit = \"m3\") = 0.0028 \"normalization temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 100000000.0 \"normalization pressure\";
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = 2100000.0 \"normalization enthalpy\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2100000.0 \"normalized specific enthalpy\";
// algorithm
//   v := 0.0009556689406463557 + 0.0028 * (0.00529944062966028 * (0.128 + pi) ^ -12.0 * (-0.727 + eta) ^ 6.0 + -0.170099690234461 * (0.128 + pi) ^ -12.0 * (-0.727 + eta) ^ 8.0 + 11.1323814312927 * (0.128 + pi) ^ -12.0 * (-0.727 + eta) ^ 12.0 + -2178.98123145125 * (0.128 + pi) ^ -12.0 * (-0.727 + eta) ^ 18.0 + -0.000506061827980875 * (0.128 + pi) ^ -10.0 * (-0.727 + eta) ^ 4.0 + 0.556495239685324 * (0.128 + pi) ^ -10.0 * (-0.727 + eta) ^ 7.0 + -9.43672726094016 * (0.128 + pi) ^ -10.0 * (-0.727 + eta) ^ 10.0 + -0.297856807561527 * (0.128 + pi) ^ -8.0 * (-0.727 + eta) ^ 5.0 + 93.9353943717186 * (0.128 + pi) ^ -8.0 * (-0.727 + eta) ^ 12.0 + 0.0192944939465981 * (0.128 + pi) ^ -6.0 * (-0.727 + eta) ^ 3.0 + 0.421740664704763 * (0.128 + pi) ^ -6.0 * (-0.727 + eta) ^ 4.0 + -3689141.2628233 * (0.128 + pi) ^ -6.0 * (-0.727 + eta) ^ 22.0 + -0.00737566847600639 * (0.128 + pi) ^ -4.0 * (-0.727 + eta) ^ 2.0 + -0.354753242424366 * (0.128 + pi) ^ -4.0 * (-0.727 + eta) ^ 3.0 + -1.99768169338727 * (0.128 + pi) ^ -3.0 * (-0.727 + eta) ^ 7.0 + 1.15456297059049 * (0.128 + pi) ^ -2.0 * (-0.727 + eta) ^ 3.0 + 5683.6687581596 * (0.128 + pi) ^ -2.0 * (-0.727 + eta) ^ 16.0 + 0.00808169540124668 / (0.128 + pi) + (-0.1253466802845362 + 0.172416341519307 * eta) / (0.128 + pi) + 1.04270175292927 * (-0.727 + eta) ^ 2.0 / (0.128 + pi) + -0.297691372792847 * (-0.727 + eta) ^ 3.0 / (0.128 + pi) + 0.275234661176914 * eta + -0.148347894866012 * pi + -0.0651142513478515 * (0.128 + pi) * (-0.727 + eta) + -2.92468715386302 * (0.128 + pi) * (-0.727 + eta) ^ 2.0 + 0.0664876096952665 * (0.128 + pi) ^ 2.0 + 3.52335014263844 * ((0.128 + pi) * (-0.727 + eta)) ^ 2.0 + -0.0146340792313332 * (0.128 + pi) ^ 3.0 + -2.24503486668184 * (0.128 + pi) ^ 4.0 * (-0.727 + eta) ^ 2.0 + 1.10533464706142 * (0.128 + pi) ^ 5.0 * (-0.727 + eta) ^ 2.0 + -0.0408757344495612 * (0.128 + pi) ^ 8.0 * (-0.727 + eta) ^ 2.0);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3a_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3b_ph \"Region 3 b: inverse function v(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   output Real v(quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0) \"specific volume\";
//   protected constant Real[30] n = {-0.00000000225196934336318, 0.0000000140674363313486, 0.0000023378408528056, -0.0000331833715229001, 0.00107956778514318, -0.271382067378863, 1.07202262490333, -0.853821329075382, -0.0000215214194340526, 0.00076965608822273, -0.00431136580433864, 0.453342167309331, -0.507749535873652, -100.475154528389, -0.219201924648793, -3.21087965668917, 607.567815637771, 0.000557686450685932, 0.18749904002955, 0.00905368030448107, 0.285417173048685, 0.0329924030996098, 0.239897419685483, 4.82754995951394, -11.8035753702231, 0.169490044091791, -0.0179967222507787, 0.0371810116332674, -0.0536288335065096, 1.6069710109252};
//   protected constant Real[30] I = {-12.0, -12.0, -8.0, -8.0, -8.0, -8.0, -8.0, -8.0, -6.0, -6.0, -6.0, -6.0, -6.0, -6.0, -4.0, -4.0, -4.0, -3.0, -3.0, -2.0, -2.0, -1.0, -1.0, -1.0, -1.0, 0.0, 1.0, 1.0, 2.0, 2.0};
//   protected constant Real[30] J = {0.0, 1.0, 0.0, 1.0, 3.0, 6.0, 7.0, 8.0, 0.0, 1.0, 2.0, 5.0, 6.0, 10.0, 3.0, 6.0, 10.0, 0.0, 2.0, 1.0, 2.0, 0.0, 1.0, 4.0, 5.0, 0.0, 0.0, 1.0, 2.0, 6.0};
//   protected constant Real vstar(quantity = \"Volume\", unit = \"m3\") = 0.0088 \"normalization temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 100000000.0 \"normalization pressure\";
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = 2800000.0 \"normalization enthalpy\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2800000.0 \"normalized specific enthalpy\";
// algorithm
//   v := 0.0014810440546089278 + 0.0088 * (-0.00000000225196934336318 / (0.0661 + pi) ^ 12.0 + 0.0000000140674363313486 * (0.0661 + pi) ^ -12.0 * (-0.72 + eta) + 0.0000023378408528056 / (0.0661 + pi) ^ 8.0 + -0.0000331833715229001 * (0.0661 + pi) ^ -8.0 * (-0.72 + eta) + 0.00107956778514318 * (0.0661 + pi) ^ -8.0 * (-0.72 + eta) ^ 3.0 + -0.271382067378863 * (0.0661 + pi) ^ -8.0 * (-0.72 + eta) ^ 6.0 + 1.07202262490333 * (0.0661 + pi) ^ -8.0 * (-0.72 + eta) ^ 7.0 + -0.853821329075382 * (0.0661 + pi) ^ -8.0 * (-0.72 + eta) ^ 8.0 + -0.0000215214194340526 / (0.0661 + pi) ^ 6.0 + 0.00076965608822273 * (0.0661 + pi) ^ -6.0 * (-0.72 + eta) + -0.00431136580433864 * (0.0661 + pi) ^ -6.0 * (-0.72 + eta) ^ 2.0 + 0.453342167309331 * (0.0661 + pi) ^ -6.0 * (-0.72 + eta) ^ 5.0 + -0.507749535873652 * (0.0661 + pi) ^ -6.0 * (-0.72 + eta) ^ 6.0 + -100.475154528389 * (0.0661 + pi) ^ -6.0 * (-0.72 + eta) ^ 10.0 + -0.219201924648793 * (0.0661 + pi) ^ -4.0 * (-0.72 + eta) ^ 3.0 + -3.21087965668917 * (0.0661 + pi) ^ -4.0 * (-0.72 + eta) ^ 6.0 + 607.567815637771 * (0.0661 + pi) ^ -4.0 * (-0.72 + eta) ^ 10.0 + 0.000557686450685932 / (0.0661 + pi) ^ 3.0 + 0.18749904002955 * (0.0661 + pi) ^ -3.0 * (-0.72 + eta) ^ 2.0 + 0.00905368030448107 * (0.0661 + pi) ^ -2.0 * (-0.72 + eta) + 0.285417173048685 * (0.0661 + pi) ^ -2.0 * (-0.72 + eta) ^ 2.0 + 0.0329924030996098 / (0.0661 + pi) + (-0.17272614217354776 + 0.239897419685483 * eta) / (0.0661 + pi) + 4.82754995951394 * (-0.72 + eta) ^ 4.0 / (0.0661 + pi) + -11.8035753702231 * (-0.72 + eta) ^ 5.0 / (0.0661 + pi) + -0.0179967222507787 * pi + 0.0371810116332674 * (0.0661 + pi) * (-0.72 + eta) + -0.0536288335065096 * ((0.0661 + pi) * (-0.72 + eta)) ^ 2.0 + 1.6069710109252 * (0.0661 + pi) ^ 2.0 * (-0.72 + eta) ^ 6.0);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3b_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp13 \"density at the boundary between regions 1 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   protected Real p2 \"auxiliary variable\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   p2 := 7.1 + -0.0000000604960677555959 * p;
//   o[1] := p2 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   d := 57.4756752485113 / (0.0737412153522555 + p2 * (0.00145092247736023 + p2 * (0.000102697173772229 + p2 * (0.0000114683182476084 + p2 * (0.00000199080616601101 + o[1] * p2 * (0.0000000113217858826367 + o[2] * o[3] * p2 * (0.0000000000000000135549330686006 + o[1] * (-0.000000000000000000311228834832975 + o[1] * o[2] * (-0.000000000000000000000702987180039442 + p2 * (0.000000000000000000000329199117056433 + (-0.0000000000000000000000517859076694812 + 0.00000000000000000000000273712834080283 * p2) * p2))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp13;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp23 \"density at the boundary between regions 2 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   protected Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0);
//   protected Real[13] o \"vector of auxiliary variables\";
//   protected Real taug \"auxiliary variable\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real gpi23 \"derivative of g w.r.t. pi on the boundary between regions 2 and 3\";
// algorithm
//   pi := p / 1000000.0;
//   T := 572.54459862746 + 31.3220101646784 * (-13.91883977887 + pi) ^ 0.5;
//   o[1] := (-13.91883977887 + pi) ^ 0.5;
//   taug := -0.5 + 540.0 / (572.54459862746 + 31.3220101646784 * o[1]);
//   o[2] := taug ^ 2.0;
//   o[3] := o[2] * taug;
//   o[4] := o[2] ^ 2.0;
//   o[5] := o[4] ^ 2.0;
//   o[6] := o[5] ^ 2.0;
//   o[7] := o[4] * o[5] * o[6] * taug;
//   o[8] := o[4] * o[5] * taug;
//   o[9] := o[2] * o[4] * o[5];
//   o[10] := pi ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   o[12] := o[4] * o[6] * taug;
//   o[13] := o[6] ^ 2.0;
//   gpi23 := (1.0 + pi * (-0.0017731742473213 + taug * (-0.017834862292358 + taug * (-0.045996013696365 + (-0.057581259083432 + -0.05032527872793 * o[3]) * taug)) + pi * (taug * (-0.000066065283340406 + (-0.0003789797503263 + o[2] * (-0.007878555448671 + o[3] * (-0.087594591301146 + -0.000053349095828174 * o[7]))) * taug) + pi * (0.000000061445213076927 + (0.00000131612001853305 + o[2] * (-0.00009683303171571 + o[3] * (-0.0045101773626444 + -0.122004760687947 * o[7]))) * taug + pi * (taug * (-0.00000000315389238237468 + (0.00000005116287140914 + 0.00000192901490874028 * taug) * taug) + pi * (0.0000114610381688305 * o[2] * o[4] * taug + pi * (o[3] * (-0.000000000100288598706366 + o[8] * (-0.012702883392813 + -143.374451604624 * o[2] * o[6] * taug)) + pi * (-0.000000000000000041341695026989 + o[2] * o[5] * (-0.0000088352662293707 + -0.272627897050173 * o[9]) * taug + pi * (o[5] * (0.000000000090049690883672 + -65.8490727183984 * o[4] * o[5] * o[6]) + pi * (0.000000178287415218792 * o[8] + pi * (o[4] * (0.0000000000000000010406965210174 + o[2] * (-0.0000000000010234747095929 + -0.000000010018179379511 * o[4]) * o[4]) + o[10] * o[11] * ((-0.00000000129412653835176 + 1.71088510070544 * o[12]) * o[7] + o[10] * (-6.05920510335078 * o[13] * o[5] * o[6] * taug + o[10] * (o[4] * o[6] * (0.0000000000000000000000178371690710842 + o[2] * o[4] * o[5] * (0.0000000000061258633752464 + -0.000084004935396416 * o[8]) * taug) + pi * (-0.00000000000000000000000124017662339842 * o[12] + pi * (0.0000832192847496054 * o[13] * o[4] * o[6] * taug + pi * (o[2] * o[5] * o[6] * (0.00000000000000000000000000175410265428146 + (0.00000000000000132995316841867 + -0.0000226487297378904 * o[2] * o[6]) * o[9]) * pi + -0.0000000000000293678005497663 * o[13] * o[2] * o[4] * taug))))))))))))))))) / pi;
//   d := p / (gpi23 * pi * T * 461.526);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp23;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofpt3 \"inverse iteration in region 3: (d) = f(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Real delp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"iteration converged if (p-pre(p) < delp)\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   output Integer error = 0 \"error flag: iteration failed if different from 0\";
//   protected Real dguess(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"guess density\";
//   protected Integer i = 0 \"loop counter\";
//   protected Real dp \"pressure difference\";
//   protected Real deld(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density step\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Modelica.Media.Common.NewtonDerivatives_pT nDerivs \"derivatives needed in Newton iteration\";
//   protected Boolean found = false \"flag for iteration success\";
//   protected Boolean supercritical \"flag, true for supercritical states\";
//   protected Boolean liquid \"flag, true for liquid states\";
//   protected Real dmin(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"lower density limit\";
//   protected Real dmax(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"upper density limit\";
//   protected Real Tmax(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"maximum temperature\";
// algorithm
//   assert( p >= 16529200.0, \"BaseIF97.dofpt3: function called outside of region 3! p too low
// p = \" + String(p, 0, true, 6) + \" Pa < \" + String(16529200.0, 0, true, 6) + \" Pa\");
//   assert( T >= 623.15, \"BaseIF97.dofpt3: function called outside of region 3! T too low
// T = \" + String(T, 0, true, 6) + \" K < \" + String(623.15, 0, true, 6) + \" K\");
//   assert( p >= Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT(T), \"BaseIF97.dofpt3: function called outside of region 3! T too high
// p = \" + String(p, 0, true, 6) + \" Pa, T = \" + String(T, 0, true, 6) + \" K\");
//   supercritical := p > 22064000.0;
//   dmax := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp13(p);
//   dmin := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp23(p);
//   Tmax := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp(p);
//   if supercritical then
//     dguess := dmin + (dmax - dmin) * (-623.15 + T) / (623.15 - Tmax);
//   else
//     liquid := T < Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
//     if liquid then
//       dguess := 0.5 * (Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(p) + dmax);
//     else
//       dguess := 0.5 * (Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(p) + dmin);
//     end if;
//   end if;
//   while i < 50 and not found loop
//     d := dguess;
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d, T);
//     nDerivs := Modelica.Media.Common.Helmholtz_pT(f);
//     dp := nDerivs.p - p;
//     if abs(dp / p) <= delp then
//       found := true;
//     end if;
//     deld := dp / nDerivs.pd;
//     d := d - deld;
//     if d > dmin and d < dmax then
//       dguess := d;
//     else
//       if d > dmax then
//         dguess := dmax + -0.00000003162277660168379;
//       else
//         dguess := 0.00000003162277660168379 + dmin;
//       end if;
//     end if;
//     i := 1 + i;
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function dofpt3: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofpt3;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dtofph3 \"inverse iteration in region 3: (d,T) = f(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Real delp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"iteration accuracy\";
//   input Real delh(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"iteration accuracy\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Integer error \"error flag: iteration failed if different from 0\";
//   protected Real Tguess(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"initial temperature\";
//   protected Real dguess(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"initial density\";
//   protected Integer i \"iteration counter\";
//   protected Real dh \"Newton-error in h-direction\";
//   protected Real dp \"Newton-error in p-direction\";
//   protected Real det \"determinant of directional derivatives\";
//   protected Real deld \"Newton-step in d-direction\";
//   protected Real delt \"Newton-step in T-direction\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Modelica.Media.Common.NewtonDerivatives_ph nDerivs \"derivatives needed in Newton iteration\";
//   protected Boolean found \"flag for iteration success\";
//   protected Integer subregion \"1 for subregion 3a, 2 for subregion 3b\";
// algorithm
//   if p < 22064000.0 then
//     subregion := if h < 10.0 + Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(p) then 1 else if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(p) + -10.0 then 2 else 0;
//     assert( subregion <> 0, \"inverse iteration of dt from ph called in 2 phase region: this can not work\");
//   else
//     subregion := if h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.h3ab_p(p) then 1 else 2;
//   end if;
//   T := if subregion == 1 then Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3a_ph(p, h) else Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3b_ph(p, h);
//   d := if subregion == 1 then 1.0 / Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3a_ph(p, h) else 1.0 / Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3b_ph(p, h);
//   i := 0;
//   error := 0;
//   while i < 50 and not found loop
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d, T);
//     nDerivs := Modelica.Media.Common.Helmholtz_ph(f);
//     dh := nDerivs.h - h;
//     dp := nDerivs.p - p;
//     if abs(dh / h) <= delh and abs(dp / p) <= delp then
//       found := true;
//     end if;
//     det := nDerivs.ht * nDerivs.pd - nDerivs.pt * nDerivs.hd;
//     delt := (nDerivs.pd * dh - nDerivs.hd * dp) / det;
//     deld := (nDerivs.ht * dp - nDerivs.pt * dh) / det;
//     T := T - delt;
//     d := d - deld;
//     dguess := d;
//     Tguess := T;
//     i := 1 + i;
//     (d, T) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.fixdT(dguess, Tguess);
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function dtofph3: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dtofph3;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.fixdT \"region limits for inverse iteration in region 3\"
//   input Real din(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real Tin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   output Real dout(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   output Real Tout(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   protected Real Tmin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"approximation of minimum temperature\";
//   protected Real Tmax(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"approximation of maximum temperature\";
// algorithm
//   if din > 765.0 then
//     dout := 765.0;
//   elseif din < 110.0 then
//     dout := 110.0;
//   else
//     dout := din;
//   end if;
//   if dout < 390.0 then
//     Tmax := 554.3557377 + 0.809344262 * dout;
//   else
//     Tmax := 1116.85 + -0.632948717 * dout;
//   end if;
//   if dout < 322.0 then
//     Tmin := 647.096 + -0.000647096 * (-322.0 + dout) ^ 2.0;
//   else
//     Tmin := 647.096 + -0.0004493722222222222 * (-322.0 + dout) ^ 2.0;
//   end if;
//   if Tin < Tmin then
//     Tout := Tmin;
//   elseif Tin > Tmax then
//     Tout := Tmax;
//   else
//     Tout := Tin;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.fixdT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.pofdt125 \"inverse iteration in region 1,2 and 5: p = g(d,T)\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Real reldd(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"relative iteration accuracy of density\";
//   input Integer region \"region in IAPWS/IF97 in which inverse should be calculated\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Integer error \"error flag: iteration failed if different from 0\";
//   protected Integer i \"counter for while-loop\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Boolean found \"flag if iteration has been successful\";
//   protected Real dd \"difference between density for  guessed p and the current density\";
//   protected Real delp \"step in p in Newton-iteration\";
//   protected Real relerr \"relative error in d\";
//   protected Real pguess1(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 1000000.0 \"initial pressure guess in region 1\";
//   protected Real pguess2(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"initial pressure guess in region 2\";
//   protected constant Real pguess5(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 500000.0 \"initial pressure guess in region 5\";
// algorithm
//   i := 0;
//   error := 0;
//   pguess2 := 42800.0 * d;
//   found := false;
//   if region == 1 then
//     p := pguess1;
//   elseif region == 2 then
//     p := pguess2;
//   else
//     p := 500000.0;
//   end if;
//   while i < 50 and not found loop
//     if region == 1 then
//       g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p, T);
//     elseif region == 2 then
//       g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p, T);
//     else
//       g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(p, T);
//     end if;
//     dd := p / (T * g.pi * g.gpi * 461.526) - d;
//     relerr := dd / d;
//     if abs(relerr) < reldd then
//       found := true;
//     end if;
//     delp := (-dd) * p ^ 2.0 / ((d * g.pi) ^ 2.0 * T * g.gpipi * 461.526);
//     p := p - delp;
//     i := 1 + i;
//     if not found then
//       if p < 611.657 then
//         p := 1223.314;
//       end if;
//       if p > 100000000.0 then
//         p := 95000000.0;
//       end if;
//     end if;
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function pofdt125: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.pofdt125;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.tofph5 \"inverse iteration in region 5: (p,T) = f(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Real reldh(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"iteration accuracy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Integer error \"error flag: iteration failed if different from 0\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Real proh(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"h for current guess in T\";
//   protected constant Real Tguess(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 1500.0 \"initial temperature\";
//   protected Integer i \"iteration counter\";
//   protected Real relerr \"relative error in h\";
//   protected Real dh \"Newton-error in h-direction\";
//   protected Real dT \"Newton-step in T-direction\";
//   protected Boolean found \"flag for iteration success\";
// algorithm
//   i := 0;
//   error := 0;
//   T := 1500.0;
//   found := false;
//   while i < 50 and not found loop
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(p, T);
//     proh := 461.526 * T * g.tau * g.gtau;
//     dh := proh - h;
//     relerr := dh / h;
//     if abs(relerr) < reldh then
//       found := true;
//     end if;
//     dT := dh / (g.tau ^ 2.0 * g.gtautau * -461.526);
//     T := T - dT;
//     i := 1 + i;
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function tofph5: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.tofph5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT1 \"intermediate function for isentropic specific enthalpy in region 1\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real[13] o \"vector of auxiliary variables\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau1 \"dimensionless temperature\";
// algorithm
//   tau := 1386.0 / T;
//   pi1 := 7.1 + (-p) / 16530000.0;
//   assert( p > 611.657, \"IF97 medium function hofpT1  called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   tau1 := -1.222 + tau;
//   o[1] := tau1 ^ 2.0;
//   o[2] := o[1] * tau1;
//   o[3] := o[1] ^ 2.0;
//   o[4] := o[3] ^ 2.0;
//   o[5] := o[1] * o[4];
//   o[6] := o[1] * o[3];
//   o[7] := o[3] * tau1;
//   o[8] := o[3] * o[4];
//   o[9] := pi1 ^ 2.0;
//   o[10] := o[9] ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   o[12] := o[4] ^ 2.0;
//   o[13] := o[12] ^ 2.0;
//   h := 461.526 * T * tau * (pi1 * ((-0.00254871721114236 + o[1] * (0.00424944110961118 + (0.018990068218419 + (-0.021841717175414 + -0.00015851507390979 * o[1]) * o[1]) * o[6])) / o[5] + pi1 * ((0.00141552963219801 + o[3] * (0.000047661393906987 + o[1] * (-0.0000132425535992538 + -0.000000000000012358149370591 * o[1] * o[3] * o[4]))) / o[3] + pi1 * ((0.000126718579380216 + -0.00000000511230768720618 * o[5]) / o[7] + pi1 * ((0.000011212640954 + o[2] * (0.00000130342445791202 + -0.0000000000014341729937924 * o[8])) / o[6] + pi1 * (o[9] * pi1 * ((0.0000000140077319158051 + 0.00000000104549227383804 * o[7]) / o[8] + o[10] * o[11] * pi1 * (0.000000000000000019941018075704 / (o[4] * o[3] * o[12] * o[1]) + o[9] * (-0.000000000000000000448827542684151 / o[13] + o[10] * o[9] * (pi1 * (0.000000000000000000000465957282962769 / (o[4] * o[13]) + pi1 * (0.00000000000000000000000383502057899078 * pi1 / (o[4] * o[13] * o[1]) + -0.000000000000000000000072912378325616 / (tau1 * o[4] * o[13]))) + -0.00000000000000000000100075970318621 / (tau1 * o[3] * o[13] * o[1]))))) + 0.00000324135974880936 / (tau1 * o[4])))))) + (-0.29265942426334 + tau1 * (0.84548187169114 + o[1] * (3.3855169168385 + tau1 * (-1.91583926775744 + tau1 * (0.47316115539684 + (-0.066465668798004 + 0.0040607314991784 * tau1) * tau1))))) / o[2]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT2 \"intermediate function for isentropic specific enthalpy in region 2\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real[16] o \"vector of auxiliary variables\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau2 \"dimensionless temperature\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function hofpT2 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   pi := p / 1000000.0;
//   tau := 540.0 / T;
//   tau2 := -0.5 + tau;
//   o[1] := tau ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := tau2 ^ 2.0;
//   o[4] := o[3] * tau2;
//   o[5] := o[3] ^ 2.0;
//   o[6] := o[5] ^ 2.0;
//   o[7] := o[6] ^ 2.0;
//   o[8] := o[5] * o[6] * o[7] * tau2;
//   o[9] := o[3] * o[5];
//   o[10] := o[5] * o[6] * tau2;
//   o[11] := o[3] * o[7] * tau2;
//   o[12] := o[3] * o[5] * o[6];
//   o[13] := o[5] * o[6] * o[7];
//   o[14] := pi ^ 2.0;
//   o[15] := o[14] ^ 2.0;
//   o[16] := o[7] ^ 2.0;
//   h := 461.526 * T * tau * ((0.0280439559151 + tau * (-0.2858109552582 + tau * (1.2213149471784 + tau * (-2.848163942888 + tau * (4.38395111945 + o[1] * (10.08665568018 + (-0.5681726521544 + 0.06380539059921 * tau) * tau)))))) / (o[2] * o[1]) + pi * (-0.017834862292358 + tau2 * (-0.09199202739273 + (-0.172743777250296 + -0.30195167236758 * o[4]) * tau2) + pi * (-0.000033032641670203 + (-0.0003789797503263 + o[3] * (-0.015757110897342 + o[4] * (-0.306581069554011 + -0.000960283724907132 * o[8]))) * tau2 + pi * (0.00000043870667284435 + o[3] * (-0.00009683303171571 + o[4] * (-0.0090203547252888 + -1.42338887469272 * o[8])) + pi * (-0.00000000078847309559367 + (0.00000002558143570457 + 0.00000144676118155521 * tau2) * tau2 + pi * (0.0000160454534363627 * o[9] + pi * ((-0.000000000050144299353183 + o[10] * (-0.033874355714168 + -836.35096769364 * o[11])) * o[3] + pi * ((-0.0000138839897890111 + -0.973671060893475 * o[12]) * o[3] * o[6] + pi * ((0.000000000090049690883672 + -296.320827232793 * o[13]) * o[3] * o[5] * tau2 + pi * (0.000000257526266427144 * o[5] * o[6] + pi * (o[4] * (0.00000000000000000041627860840696 + (-0.0000000000010234747095929 + -0.0000000140254511313154 * o[5]) * o[9]) + o[14] * o[15] * (o[13] * (-0.00000000234560435076256 + 5.3465159397045 * o[5] * o[7] * tau2) + o[14] * (-19.1874828272775 * o[16] * o[6] * o[7] + o[14] * (o[11] * (0.0000000000000000000000178371690710842 + (0.0000000000107202609066812 + -0.000201611844951398 * o[10]) * o[3] * o[5] * o[6] * tau2) + pi * (-0.00000000000000000000000124017662339842 * o[5] * o[7] + pi * (0.000200482822351322 * o[16] * o[5] * o[7] + pi * (-0.0000000000000497975748452559 * o[16] * o[3] * o[5] + o[6] * o[7] * (0.00000000000000000000000000190027787547159 + o[12] * (0.00000000000000221658861403112 + -0.0000547344301999018 * o[3] * o[7])) * pi * tau2)))))))))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p \"properties on the boiling curve\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives\";
//   protected Real plim(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = min(p, 22063999.9999999) \"pressure limited to critical pressure - epsilon\";
// algorithm
//   bpro.R := 461.526;
//   bpro.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(plim);
//   bpro.dpT := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(bpro.T);
//   bpro.region3boundary := bpro.T > 623.15;
//   if not bpro.region3boundary then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p, bpro.T);
//     bpro.d := p / (g.gpi * g.pi * bpro.T * bpro.R);
//     bpro.h := if p > plim then 2087546.84511715 else bpro.R * bpro.T * g.tau * g.gtau;
//     bpro.s := g.R * (g.tau * g.gtau - g.g);
//     bpro.cp := (-bpro.R) * g.tau ^ 2.0 * g.gtautau;
//     bpro.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * bpro.R / p;
//     bpro.vp := g.gpipi * g.pi ^ 2.0 * bpro.R * bpro.T / p ^ 2.0;
//     bpro.pt := (g.tau * g.gtaupi - g.gpi) * p / (g.pi * g.gpipi * bpro.T);
//     bpro.pd := (-bpro.R) * bpro.T * g.gpi ^ 2.0 / g.gpipi;
//   else
//     bpro.d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(plim);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(bpro.d, bpro.T);
//     bpro.h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p_R4b(plim);
//     bpro.s := f.R * (f.tau * f.ftau - f.f);
//     bpro.cv := bpro.R * (-f.tau ^ 2.0) * f.ftautau;
//     bpro.pt := bpro.R * bpro.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     bpro.pd := bpro.R * bpro.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT \"boundary function for region boundary between regions 2 and 3 (input temperature)\"
//   input Real t(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   protected constant Real[5] n = {348.05185628969, -1.1671859879975, 0.0010192970039326, 572.54459862746, 13.91883977887};
// algorithm
//   p := 348051856.28969 + 1000000.0 * t * (-1.1671859879975 + 0.0010192970039326 * t);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp \"boundary function for region boundary between regions 2 and 3 (input pressure)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real t(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   protected constant Real[5] n = {348.05185628969, -1.1671859879975, 0.0010192970039326, 572.54459862746, 13.91883977887};
//   protected Real pi \"dimensionless pressure\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function boundary23ofp called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   t := 572.54459862746 + (-13655.332768730837 + pi / 0.0010192970039326) ^ 0.5;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n \"density in region 1 as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau1 \"dimensionless temperature\";
//   protected Real gpi \"dimensionless Gibbs-derivative w.r.t. pi\";
//   protected Real[11] o \"auxiliary variables\";
// algorithm
//   pi := p / 16530000.0;
//   tau := 1386.0 / T;
//   pi1 := 7.1 - pi;
//   tau1 := tau + -1.222;
//   o[1] := tau1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   o[4] := o[1] * o[2];
//   o[5] := o[1] * tau1;
//   o[6] := o[2] * tau1;
//   o[7] := pi1 ^ 2.0;
//   o[8] := o[7] ^ 2.0;
//   o[9] := o[8] ^ 2.0;
//   o[10] := o[3] ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   gpi := pi1 * (pi1 * ((0.000095038934535162 + o[2] * (0.0000084812393955936 + 0.00000000255615384360309 * o[4])) / o[2] + pi1 * ((0.0000089701127632 + (0.00000260684891582404 + 0.00000000000057366919751696 * o[2] * o[3]) * o[5]) / o[6] + pi1 * (0.00000202584984300585 / o[3] + o[7] * pi1 * (o[8] * o[9] * pi1 * (o[7] * (o[7] * o[8] * (-0.000000000000000000000763737668221055 / (o[1] * o[11] * o[2]) + pi1 * (pi1 * (-0.0000000000000000000000565070932023524 / (o[11] * o[3]) + 0.00000000000000000000000299318679335866 * pi1 / (o[11] * o[3] * tau1)) + 0.00000000000000000000035842867920213 / (o[1] * o[11] * o[2] * tau1))) + -0.000000000000000000333001080055983 / (o[1] * o[10] * o[2] * o[3] * tau1)) + 0.0000000000000000144400475720615 / (o[10] * o[2] * o[3] * tau1)) + (0.0000000101874413933128 + 0.00000000139398969845072 * o[6]) / (o[1] * o[3] * tau1))))) + (0.00094368642146534 + o[5] * (0.00060003561586052 + (-0.000095322787813974 + o[1] * (0.0000088283690661692 + 0.00000000000000145389992595188 * o[1] * o[2] * o[3])) * tau1)) / o[5]) + (-0.00028319080123804 + o[1] * (0.00060706301565874 + o[4] * (0.018990068218419 + tau1 * (0.032529748770505 + (0.021841717175414 + 0.00005283835796993 * o[1]) * tau1)))) / (o[3] * tau1);
//   d := p / (gpi * pi * T * 461.526);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n \"density in region 2  as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau2 \"dimensionless temperature\";
//   protected Real gpi \"dimensionless Gibbs-derivative w.r.t. pi\";
//   protected Real[12] o \"auxiliary variables\";
// algorithm
//   pi := p / 1000000.0;
//   tau := 540.0 / T;
//   tau2 := tau + -0.5;
//   o[1] := tau2 ^ 2.0;
//   o[2] := o[1] * tau2;
//   o[3] := o[1] ^ 2.0;
//   o[4] := o[3] ^ 2.0;
//   o[5] := o[4] ^ 2.0;
//   o[6] := o[3] * o[4] * o[5] * tau2;
//   o[7] := o[3] * o[4] * tau2;
//   o[8] := o[1] * o[3] * o[4];
//   o[9] := pi ^ 2.0;
//   o[10] := o[9] ^ 2.0;
//   o[11] := o[3] * o[5] * tau2;
//   o[12] := o[5] ^ 2.0;
//   gpi := (1.0 + pi * (-0.0017731742473213 + tau2 * (-0.017834862292358 + tau2 * (-0.045996013696365 + (-0.057581259083432 + -0.05032527872793 * o[2]) * tau2)) + pi * (tau2 * (-0.000066065283340406 + (-0.0003789797503263 + o[1] * (-0.007878555448671 + o[2] * (-0.087594591301146 + -0.000053349095828174 * o[6]))) * tau2) + pi * (0.000000061445213076927 + (0.00000131612001853305 + o[1] * (-0.00009683303171571 + o[2] * (-0.0045101773626444 + -0.122004760687947 * o[6]))) * tau2 + pi * (tau2 * (-0.00000000315389238237468 + (0.00000005116287140914 + 0.00000192901490874028 * tau2) * tau2) + pi * (0.0000114610381688305 * o[1] * o[3] * tau2 + pi * (o[2] * (-0.000000000100288598706366 + o[7] * (-0.012702883392813 + -143.374451604624 * o[1] * o[5] * tau2)) + pi * (-0.000000000000000041341695026989 + o[1] * o[4] * (-0.0000088352662293707 + -0.272627897050173 * o[8]) * tau2 + pi * (o[4] * (0.000000000090049690883672 + -65.8490727183984 * o[3] * o[4] * o[5]) + pi * (0.000000178287415218792 * o[7] + pi * (o[3] * (0.0000000000000000010406965210174 + o[1] * (-0.0000000000010234747095929 + -0.000000010018179379511 * o[3]) * o[3]) + o[10] * o[9] * ((-0.00000000129412653835176 + 1.71088510070544 * o[11]) * o[6] + o[9] * (-6.05920510335078 * o[12] * o[4] * o[5] * tau2 + o[9] * (o[3] * o[5] * (0.0000000000000000000000178371690710842 + o[1] * o[3] * o[4] * (0.0000000000061258633752464 + -0.000084004935396416 * o[7]) * tau2) + pi * (-0.00000000000000000000000124017662339842 * o[11] + pi * (0.0000832192847496054 * o[12] * o[3] * o[5] * tau2 + pi * (o[1] * o[4] * o[5] * (0.00000000000000000000000000175410265428146 + (0.00000000000000132995316841867 + -0.0000226487297378904 * o[1] * o[5]) * o[8]) * pi + -0.0000000000000293678005497663 * o[1] * o[12] * o[3] * tau2))))))))))))))))) / pi;
//   d := p / (gpi * pi * T * 461.526);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p \"properties on the dew curve\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives\";
//   protected Real plim(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = min(p, 22063999.9999999) \"pressure limited to critical pressure - epsilon\";
// algorithm
//   bpro.R := 461.526;
//   bpro.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(plim);
//   bpro.dpT := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(bpro.T);
//   bpro.region3boundary := bpro.T > 623.15;
//   if not bpro.region3boundary then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p, bpro.T);
//     bpro.d := p / (g.gpi * g.pi * bpro.T * bpro.R);
//     bpro.h := if p > plim then 2087546.84511715 else bpro.R * bpro.T * g.tau * g.gtau;
//     bpro.s := g.R * (g.tau * g.gtau - g.g);
//     bpro.cp := (-bpro.R) * g.tau ^ 2.0 * g.gtautau;
//     bpro.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * bpro.R / p;
//     bpro.vp := g.gpipi * g.pi ^ 2.0 * bpro.R * bpro.T / p ^ 2.0;
//     bpro.pt := (g.tau * g.gtaupi - g.gpi) * p / (g.pi * g.gpipi * bpro.T);
//     bpro.pd := (-bpro.R) * bpro.T * g.gpi ^ 2.0 / g.gpipi;
//   else
//     bpro.d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(plim);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(bpro.d, bpro.T);
//     bpro.h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p_R4b(plim);
//     bpro.s := f.R * (f.tau * f.ftau - f.f);
//     bpro.cv := bpro.R * (-f.tau ^ 2.0) * f.ftautau;
//     bpro.pt := bpro.R * bpro.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     bpro.pd := bpro.R * bpro.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p \"liquid specific enthalpy on the boundary between regions 4 and 3 or 1\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p, Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p_R4b \"explicit approximation of liquid specific enthalpy on the boundary between regions 4 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   x := acos(p / 22064000.0);
//   h := 2087546.84511715 + 2087546.84511715 * x * (-0.4945586958175176 + x * (1.346800016564904 + x * (-3.889388153209752 + x * (6.679385472887931 + x * (-6.75820241066552 + x * (3.558919744656498 + (-0.717981855497894 + -0.0001152032945617821 * x) * x))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp1 \"explicit lower specific enthalpy limit of region 1 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   pi1 := 7.1 + (-p) / 16530000.0;
//   assert( p > 611.657, \"IF97 medium function hlowerofp1 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   o[1] := pi1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   h := 110906.48730252562 + 639675.036 * pi1 * (-0.022914084306349 + pi1 * (-0.00017146768241932 + pi1 * (-0.00000418695814670391 + pi1 * (-0.000000241630417490008 + pi1 * (0.0000000000173545618580828 + o[1] * pi1 * (0.0000000000000843755552264362 + o[2] * o[3] * pi1 * (5.35429206228374e-35 + o[1] * (-8.12140581014818e-38 + o[1] * o[2] * (-1.43870236842915e-44 + pi1 * (1.73894459122923e-45 + (-7.06381628462585e-47 + 9.64504638626269e-49 * pi1) * pi1))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp2 \"explicit lower specific enthalpy limit of region 2 as function of pressure (meets region 4 saturation pressure curve at 623.15 K)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real q1 \"auxiliary variable\";
//   protected Real q2 \"auxiliary variable\";
//   protected Real[18] o \"vector of auxiliary variables\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hlowerofp2 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   q1 := 572.54459862746 + 31.3220101646784 * (-13.91883977887 + pi) ^ 0.5;
//   q2 := -0.5 + 540.0 / q1;
//   o[1] := q1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   o[4] := pi ^ 2.0;
//   o[5] := o[4] ^ 2.0;
//   o[6] := q2 ^ 2.0;
//   o[7] := o[6] ^ 2.0;
//   o[8] := o[6] * o[7];
//   o[9] := o[5] ^ 2.0;
//   o[10] := o[7] ^ 2.0;
//   o[11] := o[9] ^ 2.0;
//   o[12] := o[10] ^ 2.0;
//   o[13] := o[12] ^ 2.0;
//   o[14] := o[7] * q2;
//   o[15] := o[6] * q2;
//   o[16] := o[10] * o[6];
//   o[17] := o[13] * o[6];
//   o[18] := o[13] * o[6] * q2;
//   h := (4636975733.03507 + 3.74686560065793 * o[2] + 0.00000357966647812489 * o[1] * o[2] + 0.000000000000281881548488163 * o[3] + -76465233.2452145 * q1 + -0.00450789338787835 * o[2] * q1 + -0.00000000155131504410292 * o[1] * o[2] * q1 + o[1] * (2513837.07870341 + -4781981.98764471 * o[10] * o[11] * o[12] * o[13] * o[4] + 49.9651389369988 * o[11] * o[12] * o[13] * o[4] * o[5] * o[7] + o[15] * o[4] * (0.000000000000103746636552761 + -0.00349547959376899 * o[16] + -0.000000255074501962569 * o[8]) * o[9] + (-242662.235426958 * o[10] * o[12] + -3.46022402653609 * o[16]) * o[4] * o[5] * pi + o[4] * (0.109336249381227 + -2248.08924686956 * o[14] + -354742.725841972 * o[17] + -24.1331193696374 * o[6]) * pi + -0.000000000000000000309081828396912 * o[11] * o[12] * o[5] * o[7] * pi + -0.0000000124107527851371 * o[11] * o[13] * o[4] * o[5] * o[6] * o[7] * pi + 3.99891272904219 * o[5] * o[8] * pi + 0.0641817365250892 * o[10] * o[7] * o[9] * pi + pi * (-4444.87643334512 + -75253.6156722047 * o[14] + -43051.9020511789 * o[6] + -22926.6247146068 * q2) + o[4] * (-8.23252840892034 + -3927.0508365636 * o[15] + -239.325789467604 * o[18] + -76407.3727417716 * o[8] + -94.4508644545118 * q2) + 0.360567666582363 * o[5] * (-0.0161221195808321 + q2) * (0.0338039844460968 + q2) + o[11] * (-0.000584580992538624 * o[10] * o[12] * o[7] + 1332480.30241755 * o[12] * o[13] * q2) + o[9] * (-73850273.6990986 * o[18] + 0.0000224425477627799 * o[6] * o[7] * q2) + o[4] * o[5] * (-208438767.026518 * o[17] + -0.0000124971648677697 * o[6] + -8442.30378348203 * o[10] * o[6] * o[7] * q2) + o[11] * (o[9] * (0.000000000000000000000473594929247646 * o[10] * o[12] * q2 + -13.6411358215175 * o[10] * o[12] * o[13] * q2 + 0.000000000552427169406836 * o[13] * o[6] * o[7] * q2) + o[5] * (0.00000267174673301715 * o[17] + 0.00000000000000000444545133805865 * o[12] * o[6] * q2 + -50.2465185106411 * o[10] * o[13] * o[6] * o[7] * q2)))) / o[1];
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp5 \"explicit lower specific enthalpy limit of region 5 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hlowerofp5 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   h := 4160681.2903082645 + 461526.0 * pi * (-0.00979043490246092 + (-0.0000203245575263501 + 0.000000336540214679088 * pi) * pi);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp1 \"explicit upper specific enthalpy limit of region 1 as function of pressure (meets region 4 saturation pressure curve at 623.15 K)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   pi1 := 7.1 + (-p) / 16530000.0;
//   assert( p > 611.657, \"IF97 medium function hupperofp1 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   o[1] := pi1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   h := 1553751.0098956071 + 639675.036 * pi1 * (-0.00141131225285294 + pi1 * (0.00143759406818289 + pi1 * (0.000125338925082983 + pi1 * (0.0000123617764767172 + pi1 * (0.00000317834967400818 + o[1] * pi1 * (0.0000000146754947271665 + o[2] * o[3] * pi1 * (0.0000000000000000186779322717506 + o[1] * (-0.000000000000000000418568363667416 + o[1] * o[2] * (-0.000000000000000000000919148577641497 + pi1 * (0.000000000000000000000427026404402408 + (-0.0000000000000000000000666749357417962 + 0.00000000000000000000000349930466305574 * pi1) * pi1))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp2 \"explicit upper specific enthalpy limit of region 2 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real[2] o \"vector of auxiliary variables\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hupperofp2 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   o[1] := pi ^ 2.0;
//   o[2] := o[1] ^ 3.0;
//   h := 4160663.37647071 + pi * (-4518.48617188327 + pi * (-8.53409968320258 + pi * (0.109090430596056 + pi * (-0.000172486052272327 + pi * (0.0000000000000042261295097284 + pi * (-0.000000000127295130636232 + pi * (-0.000000000000000000000000379407294691742 + pi * (0.0000000000000000000000756960433802525 + pi * (7.16825117265975e-32 + pi * (0.00000000000000000000337267475986401 + (-7.5656940729795e-74 + o[1] * (-8.00969737237617e-134 + (1.6746290980312e-65 + pi * (-3.71600586812966e-69 + pi * (8.06630589170884e-129 + (-1.76117969553159e-103 + 1.88543121025106e-84 * pi) * pi))) * o[1])) * o[2]))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5 \"explicit upper specific enthalpy limit of region 5 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hupperofp5 called with too low pressure
// p = \" + String(p, 0, true, 6) + \" Pa <= \" + String(611.657, 0, true, 6) + \" Pa (triple point pressure)\");
//   h := 7376980.419242963 + 461526.0 * pi * (-0.000489898813722568 + (-0.0000000501510211858761 + 0.000000075006972718273 * pi) * pi);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p \"vapour specific enthalpy on the boundary between regions 4 and 3 or 2\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p, Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p_R4b \"explicit approximation of vapour specific enthalpy on the boundary between regions 4 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   x := acos(p / 22064000.0);
//   h := 2087546.84511715 + 2087546.84511715 * x * (0.4880153718655694 + x * (0.2079670746250689 + x * (-6.084122698421623 + x * (25.08887602293532 + x * (-48.38215180269516 + x * (45.66489164833212 + (-16.98555442961553 + 0.0006616936460057692 * x) * x))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p \"Inline after index reduction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := bpro.h;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p_der \"derivative function for the specific enthalpy along the phase boundary\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   input Real p_der \"derivative of pressure\";
//   output Real h_der \"time derivative of specific enthalpy along the phase boundary\";
// algorithm
//   if bpro.region3boundary then
//     h_der := ((bpro.d * bpro.pd - bpro.T * bpro.pt) * p_der + p_der * (bpro.T * bpro.pt ^ 2.0 + bpro.d ^ 2.0 * bpro.pd * bpro.cv) / bpro.dpT) / (bpro.d ^ 2.0 * bpro.pd);
//   else
//     h_der := (1.0 / bpro.d - bpro.T * bpro.vt) * p_der + p_der * bpro.cp / bpro.dpT;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p_der;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_dT \"return the current region (valid values: 1,2,3,4,5) in IF97, given density and temperature\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Integer phase = 0 \"phase: 2 for two-phase, 1 for one phase, 0 if not known\";
//   input Integer mode = 0 \"mode: 0 means check, otherwise assume region=mode\";
//   output Integer region \"(valid values: 1,2,3,4,5) in IF97\";
//   protected Boolean Tovercrit \"flag if overcritical temperature\";
//   protected Real p23(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure needed to know if region 2 or 3\";
// algorithm
//   Tovercrit := T > 647.096;
//   if mode <> 0 then
//     region := mode;
//   else
//     p23 := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT(T);
//     if T > 1073.15 then
//       if d < 20.5655874106483 then
//         region := 5;
//       else
//         assert( false, \"out of valid region for IF97, pressure above region 5!\");
//       end if;
//     elseif Tovercrit then
//       if d > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n(p23, T) and T > 623.15 then
//         region := 3;
//       elseif T < 623.15 then
//         region := 1;
//       else
//         region := 2;
//       end if;
//     elseif d > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_T(T) then
//       if T < 623.15 then
//         region := 1;
//       else
//         region := 3;
//       end if;
//     elseif d < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_T(T) then
//       if d > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n(p23, T) and T > 623.15 then
//         region := 3;
//       else
//         region := 2;
//       end if;
//     else
//       region := 4;
//     end if;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_dT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_pT \"return the current region (valid values: 1,2,3,5) in IF97, given pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Integer mode = 0 \"mode: 0 means check, otherwise assume region=mode\";
//   output Integer region \"region (valid values: 1,2,3,5) in IF97, region 4 is impossible!\";
// algorithm
//   if mode <> 0 then
//     region := mode;
//   else
//     if p < 16529200.0 then
//       if T > 1073.15 then
//         region := 5;
//       elseif T > Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p) then
//         region := 2;
//       else
//         region := 1;
//       end if;
//     else
//       if T < 623.15 then
//         region := 1;
//       elseif T < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp(p) then
//         region := 3;
//       else
//         region := 2;
//       end if;
//     end if;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_ph \"return the current region (valid values: 1,2,3,4,5) in IF97 for given pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Integer phase = 0 \"phase: 2 for two-phase, 1 for one phase, 0 if not known\";
//   input Integer mode = 0 \"mode: 0 means check, otherwise assume region=mode\";
//   output Integer region \"region (valid values: 1,2,3,4,5) in IF97\";
//   protected Boolean hsubcrit;
//   protected Real Ttest(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0);
//   protected Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"bubble enthalpy\";
//   protected Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"dew enthalpy\";
// algorithm
//   if mode <> 0 then
//     region := mode;
//   else
//     hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(p);
//     hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(p);
//     if phase == 2 then
//       region := 4;
//     else
//       if p < 611.657 or p > 100000000.0 or h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp1(p) or p < 10000000.0 and h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5(p) or p >= 10000000.0 and h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp2(p) then
//         region := -1;
//       else
//         hsubcrit := h < 2087546.84511715;
//         if p < 16529200.0 then
//           if hsubcrit then
//             if phase == 1 then
//               region := 1;
//             else
//               if h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT1(p, Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p)) then
//                 region := 1;
//               else
//                 region := 4;
//               end if;
//             end if;
//           else
//             if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp5(p) then
//               if p < 10000000.0 and h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5(p) then
//                 region := 5;
//               else
//                 region := -2;
//               end if;
//             else
//               if phase == 1 then
//                 region := 2;
//               else
//                 if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT2(p, Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p)) then
//                   region := 2;
//                 else
//                   region := 4;
//                 end if;
//               end if;
//             end if;
//           end if;
//         else
//           if hsubcrit then
//             if h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp1(p) then
//               region := 1;
//             else
//               if h < hl or p > 22064000.0 then
//                 region := 3;
//               else
//                 region := 4;
//               end if;
//             end if;
//           else
//             if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp2(p) then
//               region := 2;
//             else
//               if h > hv or p > 22064000.0 then
//                 region := 3;
//               else
//                 region := 4;
//               end if;
//             end if;
//           end if;
//         end if;
//       end if;
//     end if;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_T \"density of saturated water\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density of water at the boiling point\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
// algorithm
//   p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//   if T < 623.15 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n(p, T);
//   elseif T < 647.096 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(p);
//   else
//     d := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_T;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b \"explicit approximation of liquid density on the boundary between regions 4 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real dl(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"liquid density\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   if p < 22064000.0 then
//     x := acos(p / 22064000.0);
//     dl := 322.0 + 322.0 * x * (1.903224079094824 + x * (-2.5314861802401123 + x * (-8.191449323843552 + x * (94.34196116778385 + x * (-369.3676833623383 + x * (796.6627910598293 + x * (-994.5385383600702 + x * (673.2581177021598 + (-191.43077336405156 + 0.00052536560808895 * x) * x))))))));
//   else
//     dl := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_T \"density of saturated vapour\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density of steam at the condensation point\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
// algorithm
//   p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//   if T < 623.15 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n(p, T);
//   elseif T < 647.096 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(p);
//   else
//     d := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_T;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b \"explicit approximation of vapour density on the boundary between regions 4 and 2\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real dv(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"vapour density\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   if p < 22064000.0 then
//     x := acos(p / 22064000.0);
//     dv := 322.0 + 322.0 * x * (-1.8463850803362596 + x * (-1.1447872718878493 + x * (59.18702203076563 + x * (-403.5391431811611 + x * (1437.2007245332388 + x * (-3015.853540307519 + x * (3740.5790348670057 + x * (-2537.375817253895 + (725.8761975803782 + -0.0011151111658332337 * x) * x))))))));
//   else
//     dv := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Transport.visc_dTp \"dynamic viscosity eta(d,T,p), industrial formulation\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure (only needed for region of validity)\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"dynamic viscosity\";
//   protected constant Real n0 = 1.0 \"viscosity coefficient\";
//   protected constant Real n1 = 0.978197 \"viscosity coefficient\";
//   protected constant Real n2 = 0.579829 \"viscosity coefficient\";
//   protected constant Real n3 = -0.202354 \"viscosity coefficient\";
//   protected constant Real[42] nn = {0.5132047, 0.3205656, 0.0, 0.0, -0.7782567, 0.1885447, 0.2151778, 0.7317883, 1.241044, 1.476783, 0.0, 0.0, -0.2818107, -1.070786, -1.263184, 0.0, 0.0, 0.0, 0.1778064, 0.460504, 0.2340379, -0.4924179, 0.0, 0.0, -0.0417661, 0.0, 0.0, 0.1600435, 0.0, 0.0, 0.0, -0.01578386, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.003629481, 0.0, 0.0} \"viscosity coefficients\";
//   protected constant Real rhostar(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = 317.763 \"scaling density\";
//   protected constant Real etastar(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.000055071 \"scaling viscosity\";
//   protected constant Real tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 647.226 \"scaling temperature\";
//   protected Integer i \"auxiliary variable\";
//   protected Integer j \"auxiliary variable\";
//   protected Real delta \"dimensionless density\";
//   protected Real deltam1 \"dimensionless density\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real taum1 \"dimensionless temperature\";
//   protected Real Psi0 \"auxiliary variable\";
//   protected Real Psi1 \"auxiliary variable\";
//   protected Real tfun \"auxiliary variable\";
//   protected Real rhofun \"auxiliary variable\";
//   protected Real Tc = T + -273.15 \"Celsius temperature for region check\";
// algorithm
//   delta := d / 317.763;
//   assert( d > 0.004854575724778614, \"IF97 medium function visc_dTp for viscosity called with too low density
// d = \" + String(d, 0, true, 6) + \" <= \" + String(0.004854575724778614, 0, true, 6) + \" (triple point density)\");
//   assert( p <= 500000000.0 and Tc >= 0.0 and Tc <= 150.0 or p <= 350000000.0 and Tc > 150.0 and Tc <= 600.0 or p <= 300000000.0 and Tc > 600.0 and Tc <= 900.0, \"IF97 medium function visc_dTp: viscosity computed outside the range
// of validity of the IF97 formulation: p = \" + String(p, 0, true, 6) + \" Pa, Tc = \" + String(Tc, 0, true, 6) + \" K\");
//   deltam1 := delta + -1.0;
//   tau := 647.226 / T;
//   taum1 := tau + -1.0;
//   Psi0 := tau ^ -0.5 / (1.0 + (0.978197 + (0.579829 + -0.202354 * tau) * tau) * tau);
//   Psi1 := 0.0;
//   tfun := 1.0;
//   for i in 1:6 loop
//     if i <> 1 then
//       tfun := tfun * taum1;
//     end if;
//     rhofun := 1.0;
//     for j in 0:6 loop
//       if j <> 0 then
//         rhofun := rhofun * deltam1;
//       end if;
//       Psi1 := Psi1 + {0.5132047, 0.3205656, 0.0, 0.0, -0.7782567, 0.1885447, 0.2151778, 0.7317883, 1.241044, 1.476783, 0.0, 0.0, -0.2818107, -1.070786, -1.263184, 0.0, 0.0, 0.0, 0.1778064, 0.460504, 0.2340379, -0.4924179, 0.0, 0.0, -0.0417661, 0.0, 0.0, 0.1600435, 0.0, 0.0, 0.0, -0.01578386, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.003629481, 0.0, 0.0}[i + 6 * j] * tfun * rhofun;
//     end for;
//   end for;
//   eta := 0.000055071 * Psi0 * exp(delta * Psi1);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Transport.visc_dTp;
// 
// function Modelica.Media.Water.IF97_Utilities.T_ph \"temperature as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_props_ph(p, h, Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph(p, h, phase, region));
// end Modelica.Media.Water.IF97_Utilities.T_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.T_ph_der \"derivative function of T_ph\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real h_der \"derivative of specific enthalpy\";
//   output Real T_der \"derivative of temperature\";
// algorithm
//   if aux.region == 4 then
//     T_der := p_der / aux.dpT;
//   elseif aux.region == 3 then
//     T_der := p_der * ((-aux.rho) * aux.pd + aux.T * aux.pt) / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) + h_der * aux.rho ^ 2.0 * aux.pd / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0);
//   else
//     T_der := p_der * (-1.0 / aux.rho + aux.T * aux.vt) / aux.cp + h_der / aux.cp;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.T_ph_der;
// 
// function Modelica.Media.Water.IF97_Utilities.T_props_ph \"Inline after index reduction\" \"temperature as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase properties \"auxiliary record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
// algorithm
//   T := properties.T;
// end Modelica.Media.Water.IF97_Utilities.T_props_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.cp_dT \"specific heat capacity at constant pressure as function of density and temperature\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"specific heat capacity\";
// algorithm
//   cp := Modelica.Media.Water.IF97_Utilities.cp_props_dT(d, T, Modelica.Media.Water.IF97_Utilities.waterBaseProp_dT(d, T, phase, region));
// end Modelica.Media.Water.IF97_Utilities.cp_dT;
// 
// function Modelica.Media.Water.IF97_Utilities.cp_pT \"specific heat capacity at constant pressure as function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"specific heat capacity\";
// algorithm
//   cp := Modelica.Media.Water.IF97_Utilities.cp_props_pT(p, T, Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT(p, T, region));
// end Modelica.Media.Water.IF97_Utilities.cp_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.cp_ph \"specific heat capacity at constant pressure as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"specific heat capacity\";
// algorithm
//   cp := Modelica.Media.Water.IF97_Utilities.cp_props_ph(p, h, Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph(p, h, phase, region));
// end Modelica.Media.Water.IF97_Utilities.cp_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.cp_props_dT \"Inline after index reduction\" \"specific heat capacity at constant pressure as function of density and temperature\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"specific heat capacity\";
// algorithm
//   cp := aux.cp;
// end Modelica.Media.Water.IF97_Utilities.cp_props_dT;
// 
// function Modelica.Media.Water.IF97_Utilities.cp_props_pT \"Inline after index reduction\" \"specific heat capacity at constant pressure as function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"specific heat capacity\";
// algorithm
//   cp := if aux.region == 3 then (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) / (aux.rho ^ 2.0 * aux.pd) else aux.cp;
// end Modelica.Media.Water.IF97_Utilities.cp_props_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.cp_props_ph \"Inline after index reduction\" \"specific heat capacity at constant pressure as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"specific heat capacity\";
// algorithm
//   cp := aux.cp;
// end Modelica.Media.Water.IF97_Utilities.cp_props_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.dynamicViscosity \"compute eta(d,T) in the one-phase region\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure (only needed for region of validity)\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"dynamic viscosity\";
//   protected constant Real n0 = 1.0 \"viscosity coefficient\";
//   protected constant Real n1 = 0.978197 \"viscosity coefficient\";
//   protected constant Real n2 = 0.579829 \"viscosity coefficient\";
//   protected constant Real n3 = -0.202354 \"viscosity coefficient\";
//   protected constant Real[42] nn = {0.5132047, 0.3205656, 0.0, 0.0, -0.7782567, 0.1885447, 0.2151778, 0.7317883, 1.241044, 1.476783, 0.0, 0.0, -0.2818107, -1.070786, -1.263184, 0.0, 0.0, 0.0, 0.1778064, 0.460504, 0.2340379, -0.4924179, 0.0, 0.0, -0.0417661, 0.0, 0.0, 0.1600435, 0.0, 0.0, 0.0, -0.01578386, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.003629481, 0.0, 0.0} \"viscosity coefficients\";
//   protected constant Real rhostar(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = 317.763 \"scaling density\";
//   protected constant Real etastar(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.000055071 \"scaling viscosity\";
//   protected constant Real tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 647.226 \"scaling temperature\";
//   protected Integer i \"auxiliary variable\";
//   protected Integer j \"auxiliary variable\";
//   protected Real delta \"dimensionless density\";
//   protected Real deltam1 \"dimensionless density\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real taum1 \"dimensionless temperature\";
//   protected Real Psi0 \"auxiliary variable\";
//   protected Real Psi1 \"auxiliary variable\";
//   protected Real tfun \"auxiliary variable\";
//   protected Real rhofun \"auxiliary variable\";
//   protected Real Tc = T + -273.15 \"Celsius temperature for region check\";
// algorithm
//   delta := d / 317.763;
//   assert( d > 0.004854575724778614, \"IF97 medium function visc_dTp for viscosity called with too low density
// d = \" + String(d, 0, true, 6) + \" <= \" + String(0.004854575724778614, 0, true, 6) + \" (triple point density)\");
//   assert( p <= 500000000.0 and Tc >= 0.0 and Tc <= 150.0 or p <= 350000000.0 and Tc > 150.0 and Tc <= 600.0 or p <= 300000000.0 and Tc > 600.0 and Tc <= 900.0, \"IF97 medium function visc_dTp: viscosity computed outside the range
// of validity of the IF97 formulation: p = \" + String(p, 0, true, 6) + \" Pa, Tc = \" + String(Tc, 0, true, 6) + \" K\");
//   deltam1 := delta + -1.0;
//   tau := 647.226 / T;
//   taum1 := tau + -1.0;
//   Psi0 := tau ^ -0.5 / (1.0 + (0.978197 + (0.579829 + -0.202354 * tau) * tau) * tau);
//   Psi1 := 0.0;
//   tfun := 1.0;
//   for i in 1:6 loop
//     if i <> 1 then
//       tfun := tfun * taum1;
//     end if;
//     rhofun := 1.0;
//     for j in 0:6 loop
//       if j <> 0 then
//         rhofun := rhofun * deltam1;
//       end if;
//       Psi1 := Psi1 + {0.5132047, 0.3205656, 0.0, 0.0, -0.7782567, 0.1885447, 0.2151778, 0.7317883, 1.241044, 1.476783, 0.0, 0.0, -0.2818107, -1.070786, -1.263184, 0.0, 0.0, 0.0, 0.1778064, 0.460504, 0.2340379, -0.4924179, 0.0, 0.0, -0.0417661, 0.0, 0.0, 0.1600435, 0.0, 0.0, 0.0, -0.01578386, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.003629481, 0.0, 0.0}[i + 6 * j] * tfun * rhofun;
//     end for;
//   end for;
//   eta := 0.000055071 * Psi0 * exp(delta * Psi1);
// end Modelica.Media.Water.IF97_Utilities.dynamicViscosity;
// 
// function Modelica.Media.Water.IF97_Utilities.h_pT \"specific enthalpy as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Temperature\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_props_pT(p, T, Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT(p, T, region));
// end Modelica.Media.Water.IF97_Utilities.h_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.h_pT_der \"derivative function of h_pT\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real T_der \"derivative of temperature\";
//   output Real h_der \"derivative of specific enthalpy\";
// algorithm
//   if aux.region == 3 then
//     h_der := p_der * ((-aux.rho) * aux.pd + T * aux.pt) / (aux.rho ^ 2.0 * aux.pd) + T_der * (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) / (aux.rho ^ 2.0 * aux.pd);
//   else
//     h_der := (1.0 / aux.rho - aux.T * aux.vt) * p_der + aux.cp * T_der;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.h_pT_der;
// 
// function Modelica.Media.Water.IF97_Utilities.h_props_pT \"Inline after index reduction\" \"specific enthalpy as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := aux.h;
// end Modelica.Media.Water.IF97_Utilities.h_props_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.hl_p \"compute the saturated liquid specific h(p)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p, Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.hl_p;
// 
// function Modelica.Media.Water.IF97_Utilities.hv_p \"compute the saturated vapour specific h(p)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p, Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.hv_p;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_pT \"density as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
// algorithm
//   rho := Modelica.Media.Water.IF97_Utilities.rho_props_pT(p, T, Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT(p, T, region));
// end Modelica.Media.Water.IF97_Utilities.rho_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_pT_der \"derivative function of rho_pT\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real T_der \"derivative of temperature\";
//   output Real rho_der \"derivative of density\";
// algorithm
//   if aux.region == 3 then
//     rho_der := p_der / aux.pd + (-T_der) * aux.pt / aux.pd;
//   else
//     rho_der := (-aux.rho ^ 2.0) * (aux.vp * p_der + aux.vt * T_der);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rho_pT_der;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_ph \"density as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
// algorithm
//   rho := Modelica.Media.Water.IF97_Utilities.rho_props_ph(p, h, Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph(p, h, phase, region));
// end Modelica.Media.Water.IF97_Utilities.rho_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_ph_der \"derivative function of rho_ph\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real h_der \"derivative of specific enthalpy\";
//   output Real rho_der \"derivative of density\";
// algorithm
//   if aux.region == 4 then
//     rho_der := p_der * aux.rho * (1.0 + aux.rho * aux.cv / aux.dpT) / (aux.T * aux.dpT) + (-h_der) * aux.rho ^ 2.0 / (aux.T * aux.dpT);
//   elseif aux.region == 3 then
//     rho_der := p_der * aux.rho * (aux.cv * aux.rho + aux.pt) / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) + h_der * (-aux.rho ^ 2.0) * aux.pt / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0);
//   else
//     rho_der := p_der * (-aux.rho ^ 2.0) * (aux.vp * aux.cp + (-aux.vt) / aux.rho + aux.T * aux.vt ^ 2.0) / aux.cp + h_der * (-aux.rho ^ 2.0) * aux.vt / aux.cp;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rho_ph_der;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_props_pT \"Inline after index reduction\" \"density as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
// algorithm
//   rho := aux.rho;
// end Modelica.Media.Water.IF97_Utilities.rho_props_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_props_ph \"Inline after index reduction\" \"density as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase properties \"auxiliary record\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
// algorithm
//   rho := properties.rho;
// end Modelica.Media.Water.IF97_Utilities.rho_props_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.rhol_T \"compute the saturated liquid d(T)\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density of water at the boiling point\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
// algorithm
//   p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//   if T < 623.15 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n(p, T);
//   elseif T < 647.096 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(p);
//   else
//     d := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rhol_T;
// 
// function Modelica.Media.Water.IF97_Utilities.rhov_T \"compute the saturated vapour d(T)\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density of steam at the condensation point\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
// algorithm
//   p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//   if T < 623.15 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n(p, T);
//   elseif T < 647.096 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(p);
//   else
//     d := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rhov_T;
// 
// function Modelica.Media.Water.IF97_Utilities.thermalConductivity \"compute lambda(d,T,p) in the one-phase region\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature (K)\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Boolean industrialMethod = true \"if true, the industrial method is used, otherwise the scientific one\";
//   output Real lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") \"thermal conductivity\";
//   protected Integer region(min = 1, max = 5) \"IF97 region, valid values:1,2,3, and 5\";
//   protected constant Real n0 = 1.0 \"conductivity coefficient\";
//   protected constant Real n1 = 6.978267 \"conductivity coefficient\";
//   protected constant Real n2 = 2.599096 \"conductivity coefficient\";
//   protected constant Real n3 = -0.998254 \"conductivity coefficient\";
//   protected constant Real[30] nn = {1.3293046, 1.7018363, 5.2246158, 8.7127675, -1.8525999, -0.40452437, -2.2156845, -10.124111, -9.5000611, 0.9340469, 0.2440949, 1.6511057, 4.9874687, 4.3786606, 0.0, 0.018660751, -0.76736002, -0.27297694, -0.91783782, 0.0, -0.12961068, 0.37283344, -0.43083393, 0.0, 0.0, 0.044809953, -0.1120316, 0.13333849, 0.0, 0.0} \"conductivity coefficient\";
//   protected constant Real lamstar(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = 0.4945 \"scaling conductivity\";
//   protected constant Real rhostar(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = 317.763 \"scaling density\";
//   protected constant Real tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 647.226 \"scaling temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 22115000.0 \"scaling pressure\";
//   protected constant Real etastar(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.000055071 \"scaling viscosity\";
//   protected Integer i \"auxiliary variable\";
//   protected Integer j \"auxiliary variable\";
//   protected Real delta \"dimensionless density\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real deltam1 \"dimensionless density\";
//   protected Real taum1 \"dimensionless temperature\";
//   protected Real Lam0 \"part of thermal conductivity\";
//   protected Real Lam1 \"part of thermal conductivity\";
//   protected Real Lam2 \"part of thermal conductivity\";
//   protected Real tfun \"auxiliary variable\";
//   protected Real rhofun \"auxiliary variable\";
//   protected Real dpitau \"auxiliary variable\";
//   protected Real ddelpi \"auxiliary variable\";
//   protected Real d2 \"auxiliary variable\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Real Tc = T + -273.15 \"Celsius temperature for region check\";
//   protected Real Chi \"symmetrized compressibility\";
//   protected constant Real rhostar2(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = 317.7 \"Reference density\";
//   protected constant Real Tstar2(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = 647.25 \"Reference temperature\";
//   protected constant Real lambdastar(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = 1.0 \"Reference thermal conductivity\";
//   protected Real lambdaREL \"Relative thermal conductivity\";
//   protected Real deltaTREL \"Relative temperature increment\";
//   protected constant Real[6] C = {0.642857, -4.11717, -6.17937, 0.00308976, 0.0822994, 10.0932};
//   protected constant Real[4] dpar = {0.0701309, 0.011852, 0.00169937, -1.02};
//   protected constant Real[3] b = {-0.39707, 0.400302, 1.06};
//   protected constant Real[2] B = {-0.171587, 2.39219};
//   protected constant Real[4] a = {0.0102811, 0.0299621, 0.0156146, -0.00422464};
//   protected Real Q;
//   protected Real S;
//   protected Real lambdaREL2 \"function, part of the interpolating equation of the thermal conductivity\";
//   protected Real lambdaREL1 \"function, part of the interpolating equation of the thermal conductivity\";
//   protected Real lambdaREL0 \"function, part of the interpolating equation of the thermal conductivity\";
//   protected parameter Real rhoREL = d / 317.7 \"Relative density\";
//   protected parameter Real TREL = T / 647.25 \"Relative temperature\";
// algorithm
//   assert( d > 0.004854575724778614, \"IF97 medium function cond_dTp called with too low density
// d = \" + String(d, 0, true, 6) + \" <= \" + String(0.004854575724778614, 0, true, 6) + \" (triple point density)\");
//   assert( p <= 100000000.0 and Tc >= 0.0 and Tc <= 500.0 or p <= 70000000.0 and Tc > 500.0 and Tc <= 650.0 or p <= 40000000.0 and Tc > 650.0 and Tc <= 800.0, \"IF97 medium function cond_dTp: thermal conductivity computed outside the range
// of validity of the IF97 formulation: p = \" + String(p, 0, true, 6) + \" Pa, Tc = \" + String(Tc, 0, true, 6) + \" K\");
//   if industrialMethod == true then
//     deltaTREL := 0.00308976 + abs(TREL + -1.0);
//     Q := 2.0 + 0.0822994 / deltaTREL ^ 0.6;
//     if TREL >= 1.0 then
//       S := 1.0 / deltaTREL;
//     else
//       S := 10.0932 / deltaTREL ^ 0.6;
//     end if;
//     lambdaREL2 := (0.011852 + 0.0701309 / TREL ^ 10.0) * rhoREL ^ 1.8 * exp(0.642857 + -0.642857 * rhoREL ^ 2.8) + 0.00169937 * S * rhoREL ^ Q * exp((1.0 - rhoREL ^ (1.0 + Q)) * Q / (1.0 + Q)) + -1.02 * exp(-4.11717 * TREL ^ 1.5 + -6.17937 / rhoREL ^ 5.0);
//     lambdaREL1 := -0.39707 + 0.400302 * rhoREL + 1.06 * exp(-0.171587 * (2.39219 + rhoREL) ^ 2.0);
//     lambdaREL0 := TREL ^ 0.5 * (0.0102811 + 0.0299621 * TREL + 0.0156146 * TREL ^ 2.0 + -0.00422464 * TREL ^ 3.0);
//     lambdaREL := lambdaREL0 + lambdaREL1 + lambdaREL2;
//     lambda := lambdaREL;
//   else
//     if p < 16529200.0 then
//       if d > 322.0 then
//         region := 1;
//       else
//         region := 2;
//       end if;
//     else
//       assert( false, \"the scientific method works only for temperature up to 623.15 K\");
//     end if;
//     tau := 647.226 / T;
//     delta := d / 317.763;
//     deltam1 := delta + -1.0;
//     taum1 := tau + -1.0;
//     Lam0 := tau ^ -0.5 / (1.0 + (6.978267 + (2.599096 + -0.998254 * tau) * tau) * tau);
//     Lam1 := 0.0;
//     tfun := 1.0;
//     for i in 1:5 loop
//       if i <> 1 then
//         tfun := tfun * taum1;
//       end if;
//       rhofun := 1.0;
//       for j in 0:5 loop
//         if j <> 0 then
//           rhofun := rhofun * deltam1;
//         end if;
//         Lam1 := Lam1 + {1.3293046, 1.7018363, 5.2246158, 8.7127675, -1.8525999, -0.40452437, -2.2156845, -10.124111, -9.5000611, 0.9340469, 0.2440949, 1.6511057, 4.9874687, 4.3786606, 0.0, 0.018660751, -0.76736002, -0.27297694, -0.91783782, 0.0, -0.12961068, 0.37283344, -0.43083393, 0.0, 0.0, 0.044809953, -0.1120316, 0.13333849, 0.0, 0.0}[i + 5 * j] * tfun * rhofun;
//       end for;
//     end for;
//     if region == 1 then
//       g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p, T);
//       dpitau := -483.7732661089758 * (g.gpi + -1386.0 * g.gtaupi / T) / (g.gpipi * T);
//       ddelpi := -0.00000011755309867468366 * T * d ^ 2.0 * g.gpipi;
//       Chi := delta * ddelpi;
//     elseif region == 2 then
//       g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p, T);
//       dpitau := -29.266380284874522 * (g.gpi + -540.0 * g.gtaupi / T) / (g.gpipi * T);
//       ddelpi := -0.00003212031447965937 * T * d ^ 2.0 * g.gpipi;
//       Chi := delta * ddelpi;
//     else
//       assert( false, \"thermal conductivity can only be called in the one-phase regions below 623.15 K
// (p = \" + String(p, 0, true, 6) + \" Pa, T = \" + String(T, 0, true, 6) + \" K, region = \" + String(region, 0, true) + \")\");
//     end if;
//     taum1 := 1.0 / tau + -1.0;
//     d2 := deltam1 ^ 2.0;
//     Lam2 := 0.00000007626232080000001 * exp(-18.66 * taum1 ^ 2.0 - d2 ^ 2.0) * delta ^ 0.5 * max(Chi, 1e-60) ^ 0.4678 * dpitau ^ 2.0 / ((tau * delta) ^ 2.0 * Modelica.Media.Water.IF97_Utilities.BaseIF97.Transport.visc_dTp(d, T, p, 0));
//     lambda := 0.4945 * (Lam0 * exp(delta * Lam1) + Lam2);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.thermalConductivity;
// 
// function Modelica.Media.Water.IF97_Utilities.waterBaseProp_dT \"intermediate property record for water (d and T prefered states)\"
//   input Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Integer phase = 0 \"phase: 2 for two-phase, 1 for one phase, 0 if unknown\";
//   input Integer region = 0 \"if 0, do region computation, otherwise assume the region is this input\";
//   output Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   protected Real h_liq(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"liquid specific enthalpy\";
//   protected Real d_liq(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"liquid density\";
//   protected Real h_vap(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"vapour specific enthalpy\";
//   protected Real d_vap(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"vapour density\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz funcion and dervatives w.r.t. delta and tau\";
//   protected Modelica.Media.Common.PhaseBoundaryProperties liq \"phase boundary property record\";
//   protected Modelica.Media.Common.PhaseBoundaryProperties vap \"phase boundary property record\";
//   protected Modelica.Media.Common.GibbsDerivs gl \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.GibbsDerivs gv \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs fl \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs fv \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Integer error \"error flag for inverse iterations\";
// algorithm
//   aux.region := if region == 0 then if phase == 2 then 4 else Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_dT(rho, T, phase, 0) else region;
//   aux.phase := if aux.region == 4 then 2 else 1;
//   aux.R := 461.526;
//   aux.rho := rho;
//   aux.T := T;
//   if aux.region == 1 then
//     (aux.p, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.pofdt125(rho, T, 0.00000001, 1);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(aux.p, T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := aux.p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / aux.p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * T / aux.p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 0.0;
//   elseif aux.region == 2 then
//     (aux.p, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.pofdt125(rho, T, 0.00000001, 2);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(aux.p, T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := aux.p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / aux.p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * T / aux.p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 1.0;
//   elseif aux.region == 3 then
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(rho, T);
//     aux.p := aux.R * rho * T * f.delta * f.fdelta;
//     aux.h := aux.R * T * (f.tau * f.ftau + f.delta * f.fdelta);
//     aux.s := aux.R * (f.tau * f.ftau - f.f);
//     aux.pd := aux.R * T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//     aux.pt := aux.R * rho * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     aux.cp := (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) / (aux.rho ^ 2.0 * aux.pd);
//     aux.cv := aux.R * (-f.tau ^ 2.0) * f.ftautau;
//     aux.x := 0.0;
//   elseif aux.region == 4 then
//     aux.p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//     d_liq := Modelica.Media.Water.IF97_Utilities.rhol_T(T);
//     d_vap := Modelica.Media.Water.IF97_Utilities.rhov_T(T);
//     h_liq := Modelica.Media.Water.IF97_Utilities.hl_p(aux.p);
//     h_vap := Modelica.Media.Water.IF97_Utilities.hv_p(aux.p);
//     aux.x := if d_vap <> d_liq then (1.0 / rho + -1.0 / d_liq) / (1.0 / d_vap + -1.0 / d_liq) else 1.0;
//     aux.h := h_liq + aux.x * (h_vap - h_liq);
//     if T < 623.15 then
//       gl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(aux.p, T);
//       gv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(aux.p, T);
//       liq := Modelica.Media.Common.gibbsToBoundaryProps(gl);
//       vap := Modelica.Media.Common.gibbsToBoundaryProps(gv);
//     else
//       fl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d_liq, T);
//       fv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d_vap, T);
//       liq := Modelica.Media.Common.helmholtzToBoundaryProps(fl);
//       vap := Modelica.Media.Common.helmholtzToBoundaryProps(fv);
//     end if;
//     aux.dpT := if liq.d <> vap.d then (vap.s - liq.s) * liq.d * vap.d / (liq.d - vap.d) else Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(aux.T);
//     aux.s := liq.s + aux.x * (vap.s - liq.s);
//     aux.cv := Modelica.Media.Common.cv2Phase(liq, vap, aux.x, aux.T, aux.p);
//     aux.cp := liq.cp + aux.x * (vap.cp - liq.cp);
//     aux.pt := liq.pt + aux.x * (vap.pt - liq.pt);
//     aux.pd := liq.pd + aux.x * (vap.pd - liq.pd);
//   elseif aux.region == 5 then
//     (aux.p, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.pofdt125(rho, T, 0.00000001, 5);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(aux.p, T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := aux.p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / aux.p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * T / aux.p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//   else
//     assert( false, \"error in region computation of IF97 steam tables(rho = \" + String(rho, 0, true, 6) + \", T = \" + String(T, 0, true, 6) + \")\");
//   end if;
// end Modelica.Media.Water.IF97_Utilities.waterBaseProp_dT;
// 
// function Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT \"intermediate property record for water (p and T prefered states)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Integer region = 0 \"if 0, do region computation, otherwise assume the region is this input\";
//   output Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz funcion and dervatives w.r.t. delta and tau\";
//   protected Integer error \"error flag for inverse iterations\";
// algorithm
//   aux.phase := 1;
//   aux.region := if region == 0 then Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_pT(p, T, 0) else region;
//   aux.R := 461.526;
//   aux.p := p;
//   aux.T := T;
//   if aux.region == 1 then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p, T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * T / p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 0.0;
//   elseif aux.region == 2 then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p, T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * T / p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 1.0;
//   elseif aux.region == 3 then
//     (aux.rho, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofpt3(p, T, 0.0000001);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(aux.rho, T);
//     aux.h := aux.R * T * (f.tau * f.ftau + f.delta * f.fdelta);
//     aux.s := aux.R * (f.tau * f.ftau - f.f);
//     aux.pd := aux.R * T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//     aux.pt := aux.R * aux.rho * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     aux.cv := aux.R * (-f.tau ^ 2.0) * f.ftautau;
//     aux.x := 0.0;
//   elseif aux.region == 5 then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(p, T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * T / p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//   else
//     assert( false, \"error in region computation of IF97 steam tables(p = \" + String(p, 0, true, 6) + \", T = \" + String(T, 0, true, 6) + \")\");
//   end if;
// end Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph \"intermediate property record for water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"specific enthalpy\";
//   input Integer phase = 0 \"phase: 2 for two-phase, 1 for one phase, 0 if unknown\";
//   input Integer region = 0 \"if 0, do region computation, otherwise assume the region is this input\";
//   output Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz funcion and dervatives w.r.t. delta and tau\";
//   protected Integer error \"error flag for inverse iterations\";
//   protected Real h_liq(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"liquid specific enthalpy\";
//   protected Real d_liq(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"liquid density\";
//   protected Real h_vap(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"vapour specific enthalpy\";
//   protected Real d_vap(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) \"vapour density\";
//   protected Modelica.Media.Common.PhaseBoundaryProperties liq \"phase boundary property record\";
//   protected Modelica.Media.Common.PhaseBoundaryProperties vap \"phase boundary property record\";
//   protected Modelica.Media.Common.GibbsDerivs gl \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.GibbsDerivs gv \"dimensionless Gibbs funcion and dervatives w.r.t. pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs fl \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs fv \"dimensionless Helmholtz function and dervatives w.r.t. delta and tau\";
//   protected Real t1(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature at phase boundary, using inverse from region 1\";
//   protected Real t2(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"temperature at phase boundary, using inverse from region 2\";
// algorithm
//   aux.region := if region == 0 then if phase == 2 then 4 else Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_ph(p, h, phase, 0) else region;
//   aux.phase := if phase <> 0 then phase else if aux.region == 4 then 2 else 1;
//   aux.p := max(p, 611.657);
//   aux.h := max(h, 1000.0);
//   aux.R := 461.526;
//   if aux.region == 1 then
//     aux.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1(aux.p, aux.h);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p, aux.T);
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * aux.T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * aux.T / p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 0.0;
//     aux.dpT := (-aux.vt) / aux.vp;
//   elseif aux.region == 2 then
//     aux.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2(aux.p, aux.h);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p, aux.T);
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * aux.T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * aux.T / p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 1.0;
//     aux.dpT := (-aux.vt) / aux.vp;
//   elseif aux.region == 3 then
//     (aux.rho, aux.T, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dtofph3(aux.p, aux.h, 0.0000001, 0.000001);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(aux.rho, aux.T);
//     aux.h := aux.R * aux.T * (f.tau * f.ftau + f.delta * f.fdelta);
//     aux.s := aux.R * (f.tau * f.ftau - f.f);
//     aux.pd := aux.R * aux.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//     aux.pt := aux.R * aux.rho * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     aux.cv := abs(aux.R * (-f.tau ^ 2.0) * f.ftautau);
//     aux.cp := (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) / (aux.rho ^ 2.0 * aux.pd);
//     aux.x := 0.0;
//     aux.dpT := aux.pt;
//   elseif aux.region == 4 then
//     h_liq := Modelica.Media.Water.IF97_Utilities.hl_p(p);
//     h_vap := Modelica.Media.Water.IF97_Utilities.hv_p(p);
//     aux.x := if h_vap <> h_liq then (h - h_liq) / (h_vap - h_liq) else 1.0;
//     if p < 16529200.0 then
//       t1 := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1(aux.p, h_liq);
//       t2 := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2(aux.p, h_vap);
//       gl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(aux.p, t1);
//       gv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(aux.p, t2);
//       liq := Modelica.Media.Common.gibbsToBoundaryProps(gl);
//       vap := Modelica.Media.Common.gibbsToBoundaryProps(gv);
//       aux.T := t1 + aux.x * (t2 - t1);
//     else
//       aux.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(aux.p);
//       d_liq := Modelica.Media.Water.IF97_Utilities.rhol_T(aux.T);
//       d_vap := Modelica.Media.Water.IF97_Utilities.rhov_T(aux.T);
//       fl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d_liq, aux.T);
//       fv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d_vap, aux.T);
//       liq := Modelica.Media.Common.helmholtzToBoundaryProps(fl);
//       vap := Modelica.Media.Common.helmholtzToBoundaryProps(fv);
//     end if;
//     aux.dpT := if liq.d <> vap.d then (vap.s - liq.s) * liq.d * vap.d / (liq.d - vap.d) else Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(aux.T);
//     aux.s := liq.s + aux.x * (vap.s - liq.s);
//     aux.rho := liq.d * vap.d / (vap.d + aux.x * (liq.d - vap.d));
//     aux.cv := Modelica.Media.Common.cv2Phase(liq, vap, aux.x, aux.T, p);
//     aux.cp := liq.cp + aux.x * (vap.cp - liq.cp);
//     aux.pt := liq.pt + aux.x * (vap.pt - liq.pt);
//     aux.pd := liq.pd + aux.x * (vap.pd - liq.pd);
//   elseif aux.region == 5 then
//     (aux.T, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.tofph5(aux.p, aux.h, 0.0000001);
//     assert( error == 0, \"error in inverse iteration of steam tables\");
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(aux.p, aux.T);
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * aux.T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi) * aux.R / p;
//     aux.vp := g.gpipi * g.pi ^ 2.0 * aux.R * aux.T / p ^ 2.0;
//     aux.cp := (-aux.R) * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * ((-g.tau ^ 2.0) * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.dpT := (-aux.vt) / aux.vp;
//   else
//     assert( false, \"error in region computation of IF97 steam tables(p = \" + String(p, 0, true, 6) + \", h = \" + String(h, 0, true, 6) + \")\");
//   end if;
// end Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph;
// 
// function Modelica.SIunits.Conversions.from_degC \"Inline before index reduction\" \"Convert from degCelsius to Kelvin\"
//   input Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
//   output Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Kelvin value\";
// algorithm
//   Kelvin := Celsius + 273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// function Modelica.SIunits.Conversions.to_bar \"Inline before index reduction\" \"Convert from Pascal to bar\"
//   input Real Pa(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) \"Pascal value\";
//   output Real bar(quantity = \"Pressure\", unit = \"bar\") \"bar value\";
// algorithm
//   bar := Pa / 100000.0;
// end Modelica.SIunits.Conversions.to_bar;
// 
// function Modelica.SIunits.Conversions.to_degC \"Inline before index reduction\" \"Convert from Kelvin to degCelsius\"
//   input Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Kelvin value\";
//   output Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
// algorithm
//   Celsius := -273.15 + Kelvin;
// end Modelica.SIunits.Conversions.to_degC;
// 
// function Modelica.Utilities.Streams.error
//   input String string \"String to be printed to error message window\";
// 
//   external \"C\" ModelicaError(string);
// end Modelica.Utilities.Streams.error;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.SaturationProperties \"Automatically generated record constructor for SiemensPower.Boundaries.WaterSink.Medium.SaturationProperties\"
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") psat;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") Tsat;
//   output SaturationProperties res;
// end SiemensPower.Boundaries.WaterSink.Medium.SaturationProperties;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.ThermodynamicState \"Automatically generated record constructor for SiemensPower.Boundaries.WaterSink.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-10000000000.0, max=10000000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end SiemensPower.Boundaries.WaterSink.Medium.ThermodynamicState;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.bubbleEnthalpy \"boiling curve specific enthalpy of water\"
//   input SiemensPower.Boundaries.WaterSink.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"boiling curve specific enthalpy\";
// algorithm
//   hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(sat.psat);
// end SiemensPower.Boundaries.WaterSink.Medium.bubbleEnthalpy;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p, T, 0);
// end SiemensPower.Boundaries.WaterSink.Medium.density_pT;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p, h, phase, 0);
// end SiemensPower.Boundaries.WaterSink.Medium.density_ph;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.dewEnthalpy \"dew curve specific enthalpy of water\"
//   input SiemensPower.Boundaries.WaterSink.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"dew curve specific enthalpy\";
// algorithm
//   hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(sat.psat);
// end SiemensPower.Boundaries.WaterSink.Medium.dewEnthalpy;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.saturationTemperature \"saturation temperature of water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
// end SiemensPower.Boundaries.WaterSink.Medium.saturationTemperature;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output SiemensPower.Boundaries.WaterSink.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := SiemensPower.Boundaries.WaterSink.Medium.ThermodynamicState(1, SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy_pT(p, T, 0), SiemensPower.Boundaries.WaterSink.Medium.density_pT(p, T, 0), T, p);
// end SiemensPower.Boundaries.WaterSink.Medium.setState_pTX;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input SiemensPower.Boundaries.WaterSink.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p, T, 0);
// end SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy_pT;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy(SiemensPower.Boundaries.WaterSink.Medium.setState_pTX(p, T, X, phase));
// end SiemensPower.Boundaries.WaterSink.Medium.specificEnthalpy_pTX;
// 
// function SiemensPower.Boundaries.WaterSink.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p, h, phase, 0);
// end SiemensPower.Boundaries.WaterSink.Medium.temperature_ph;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.SaturationProperties \"Automatically generated record constructor for SiemensPower.Components.Pipes.Tube.Medium.SaturationProperties\"
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") psat;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") Tsat;
//   output SaturationProperties res;
// end SiemensPower.Components.Pipes.Tube.Medium.SaturationProperties;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState \"Automatically generated record constructor for SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-10000000000.0, max=10000000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy \"boiling curve specific enthalpy of water\"
//   input SiemensPower.Components.Pipes.Tube.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"boiling curve specific enthalpy\";
// algorithm
//   hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(sat.psat);
// end SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.density \"return density of ideal gas\"
//   input SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := state.d;
// end SiemensPower.Components.Pipes.Tube.Medium.density;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p, T, 0);
// end SiemensPower.Components.Pipes.Tube.Medium.density_pT;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p, h, phase, 0);
// end SiemensPower.Components.Pipes.Tube.Medium.density_ph;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.density_phX \"Return density from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
// algorithm
//   d := SiemensPower.Components.Pipes.Tube.Medium.density(SiemensPower.Components.Pipes.Tube.Medium.setState_phX(p, h, X, phase));
// end SiemensPower.Components.Pipes.Tube.Medium.density_phX;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy \"dew curve specific enthalpy of water\"
//   input SiemensPower.Components.Pipes.Tube.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) \"dew curve specific enthalpy\";
// algorithm
//   hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(sat.psat);
// end SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity \"Dynamic viscosity of water\"
//   input SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := Modelica.Media.Water.IF97_Utilities.dynamicViscosity(state.d, state.T, state.p, state.phase);
// end SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature \"saturation temperature of water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
// end SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState(1, SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy_pT(p, T, 0), SiemensPower.Components.Pipes.Tube.Medium.density_pT(p, T, 0), T, p);
// end SiemensPower.Components.Pipes.Tube.Medium.setState_pTX;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.setState_phX \"Return thermodynamic state of water as function of p and h\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState(0, h, SiemensPower.Components.Pipes.Tube.Medium.density_ph(p, h, 0), SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(p, h, 0), p);
// end SiemensPower.Components.Pipes.Tube.Medium.setState_phX;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p, T, 0);
// end SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy_pT;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy(SiemensPower.Components.Pipes.Tube.Medium.setState_pTX(p, T, X, phase));
// end SiemensPower.Components.Pipes.Tube.Medium.specificEnthalpy_pTX;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp \"specific heat capacity at constant pressure of water\"
//   input SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Specific heat capacity at constant pressure\";
// algorithm
//   cp := Modelica.Media.Water.IF97_Utilities.cp_ph(state.p, state.h, state.phase, 0);
// end SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.temperature \"return temperature of ideal gas\"
//   input SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end SiemensPower.Components.Pipes.Tube.Medium.temperature;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p, h, phase, 0);
// end SiemensPower.Components.Pipes.Tube.Medium.temperature_ph;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := SiemensPower.Components.Pipes.Tube.Medium.temperature(SiemensPower.Components.Pipes.Tube.Medium.setState_phX(p, h, X, phase));
// end SiemensPower.Components.Pipes.Tube.Medium.temperature_phX;
// 
// function SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity \"Thermal conductivity of water\"
//   input SiemensPower.Components.Pipes.Tube.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0) \"Thermal conductivity\";
// algorithm
//   lambda := Modelica.Media.Water.IF97_Utilities.thermalConductivity(state.d, state.T, state.p, state.phase, true);
// end SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity;
// 
// function linspace
//   input Real x1 \"start\";
//   input Real x2 \"end\";
//   input Integer n \"number\";
//   output Real[n] v;
// algorithm
//   assert( n >= 2, \"linspace requires n>=2 but got \" + String(n, 0, true));
//   v := array(x1 + (x2 - x1) * Real(i + -1) / Real(n + -1) for i in 1:n);
// end linspace;
// 
// class SiemensPower.Components.Pipes.Tests.tube_test
//   parameter Integer watersource_mh.nPorts = 1 \"Number of ports\";
//   input Real watersource_mh.medium.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0, StateSelect = StateSelect.default) \"Absolute pressure of medium\";
//   input Real watersource_mh.medium.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0, StateSelect = StateSelect.default) \"Specific enthalpy of medium\";
//   Real watersource_mh.medium.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real watersource_mh.medium.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real watersource_mh.medium.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real watersource_mh.medium.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real watersource_mh.medium.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real watersource_mh.medium.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer watersource_mh.medium.state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real watersource_mh.medium.state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real watersource_mh.medium.state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real watersource_mh.medium.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real watersource_mh.medium.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean watersource_mh.medium.preferredMediumStates = false \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean watersource_mh.medium.standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real watersource_mh.medium.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(watersource_mh.medium.T) \"Temperature of medium in [degC]\";
//   Real watersource_mh.medium.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(watersource_mh.medium.p) \"Absolute pressure of medium in [bar]\";
//   Real watersource_mh.medium.sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real watersource_mh.medium.sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer watersource_mh.medium.phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   protected parameter enumeration(Entering, Leaving, Bidirectional) watersource_mh.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional \"Allowed flow direction\";
//   parameter Boolean watersource_mh.use_m_flow_in = false \"Get the mass flow rate from the input connector\";
//   parameter Boolean watersource_mh.use_h_in = false \"Get the specific enthalpy from the input connector\";
//   parameter Boolean watersource_mh.use_X_in = false \"Get the composition from the input connector\";
//   parameter Boolean watersource_mh.use_C_in = false \"Get the trace substances from the input connector\";
//   parameter Real watersource_mh.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = 50.0 \"Fixed mass flow rate going out of the fluid port\";
//   parameter Real watersource_mh.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = 500000.0 \"Fixed value of specific enthalpy\";
//   parameter Real watersource_mh.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Fixed value of composition\";
//   protected input Real watersource_mh.m_flow_in_internal \"Needed to connect to conditional connector\";
//   protected input Real watersource_mh.h_in_internal \"Needed to connect to conditional connector\";
//   protected input Real watersource_mh.X_in_internal[1] \"Needed to connect to conditional connector\";
//   Real watersource_mh.ports[1].m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if watersource_mh.flowDirection == Modelica.Fluid.Types.PortFlowDirection.Entering then 0.0 else -1e+60, max = if watersource_mh.flowDirection == Modelica.Fluid.Types.PortFlowDirection.Leaving then 0.0 else 1e+60) \"Mass flow rate from the connection point into the component\";
//   Real watersource_mh.ports[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real watersource_mh.ports[1].h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   parameter Real watersink_ph.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 3000000.0 \"Pressure\";
//   parameter Real watersink_ph.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = 1000000.0 \"Specific enthalpy for reverse flow\";
//   Real watersink_ph.hPortActual(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real watersink_ph.water.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0, StateSelect = StateSelect.default) \"Absolute pressure of medium\";
//   input Real watersink_ph.water.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0, StateSelect = StateSelect.default) \"Specific enthalpy of medium\";
//   Real watersink_ph.water.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real watersink_ph.water.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real watersink_ph.water.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real watersink_ph.water.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real watersink_ph.water.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real watersink_ph.water.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer watersink_ph.water.state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real watersink_ph.water.state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real watersink_ph.water.state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real watersink_ph.water.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real watersink_ph.water.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean watersink_ph.water.preferredMediumStates = false \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean watersink_ph.water.standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real watersink_ph.water.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(watersink_ph.water.T) \"Temperature of medium in [degC]\";
//   Real watersink_ph.water.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(watersink_ph.water.p) \"Absolute pressure of medium in [bar]\";
//   Real watersink_ph.water.sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real watersink_ph.water.sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer watersink_ph.water.phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   Real watersink_ph.port.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real watersink_ph.port.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real watersink_ph.port.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   input Real watersink_ph.p_set;
//   input Real watersink_ph.h_set;
//   protected Real EVA.TWall[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[1], nominal = 300.0);
//   protected Real EVA.TWall[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[2], nominal = 300.0);
//   protected Real EVA.TWall[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[3], nominal = 300.0);
//   protected Real EVA.TWall[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[4], nominal = 300.0);
//   protected Real EVA.TWall[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[5], nominal = 300.0);
//   protected Real EVA.TWall[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[6], nominal = 300.0);
//   protected Real EVA.TWall[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[7], nominal = 300.0);
//   protected Real EVA.TWall[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[8], nominal = 300.0);
//   protected Real EVA.TWall[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[9], nominal = 300.0);
//   protected Real EVA.TWall[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[10], nominal = 300.0);
//   protected Real EVA.TWall[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[11], nominal = 300.0);
//   protected Real EVA.TWall[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[12], nominal = 300.0);
//   protected Real EVA.TWall[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[13], nominal = 300.0);
//   protected Real EVA.TWall[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[14], nominal = 300.0);
//   protected Real EVA.TWall[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[15], nominal = 300.0);
//   protected Real EVA.TWall[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[16], nominal = 300.0);
//   protected Real EVA.TWall[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[17], nominal = 300.0);
//   protected Real EVA.TWall[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[18], nominal = 300.0);
//   protected Real EVA.TWall[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[19], nominal = 300.0);
//   protected Real EVA.TWall[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TWall_start[20], nominal = 300.0);
//   parameter Real EVA.m_flow_start(quantity = \"MassFlowRate\", unit = \"kg/s\") = 50.0 \"Guess value for mass flow rate\";
//   parameter Real EVA.pIn_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 3100000.0 \"Start value of inlet pressure\";
//   parameter Real EVA.pOut_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 3000000.0 \"Start value of outlet pressure\";
//   parameter Boolean EVA.useTemperatureStartValue = false \"Use T_start if true, otherwise h_start\";
//   parameter Real EVA.hIn_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = 1000000.0 \"Start value of specific enthalpy\";
//   parameter Real EVA.hOut_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = 1000000.0 \"Start value of specific outlet enthalpy\";
//   parameter Real EVA.TIn_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if EVA.useTemperatureStartValue then 298.15 else SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pIn_start, EVA.hIn_start, {EVA.XIn_start[1]}, 0) \"Start value of temperature\";
//   parameter Real EVA.TOut_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if EVA.useTemperatureStartValue then 298.15 else SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pOut_start, EVA.hOut_start, {EVA.XOut_start[1]}, 0) \"Start value of  outlet temperature\";
//   parameter Real EVA.XIn_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   constant Real EVA.g = 9.80665;
//   parameter Integer EVA.numberOfNodes(min = 1) = 20 \"Number of nodes for thermal variables\";
//   parameter Integer EVA.geoPipe.Nt = 100 \"Number of parallel tubes\";
//   parameter Real EVA.geoPipe.L(quantity = \"Length\", unit = \"m\") = 40.0 \"Length of tube\";
//   parameter Real EVA.geoPipe.H(quantity = \"Length\", unit = \"m\") = 0.0 \"Height difference between outlet and inlet\";
//   parameter Real EVA.geoPipe.d_out(quantity = \"Length\", unit = \"m\") = 0.038 \"Outer diameter of the tube\";
//   parameter Real EVA.geoPipe.s(quantity = \"Length\", unit = \"m\") = 0.003 \"Thickness of the wall\";
//   parameter Real EVA.geoPipe.r(quantity = \"Length\", unit = \"m\") = 0.00003 \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.geoPipe.zeta_add = 0.0 \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.geoPipe.isCylindric = true \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.geoPipe.A(quantity = \"Area\", unit = \"m2\") = (if EVA.geoPipe.isCylindric then 0.7853981633974483 else 1.0) * (EVA.geoPipe.d_out + -2.0 * EVA.geoPipe.s) ^ 2.0 \"inner cross sectional area\";
//   parameter Boolean EVA.initializeInletPressure = true \"add steady state equation for pressure\";
//   parameter Boolean EVA.initializeSteadyStateEnthalpies = true \"lets initialize der(h)=0\";
//   parameter Boolean EVA.initializeSteadyStateInletEnthalpy = true \"steady state initial condition for input enthalpy\";
//   final parameter Real EVA.diameterInner(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out + -2.0 * EVA.geoPipe.s;
//   final parameter Real EVA.V(quantity = \"Volume\", unit = \"m3\") = EVA.geoPipe.A * EVA.geoPipe.L;
//   final parameter Real EVA.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A;
//   final parameter Real EVA.sinphi = EVA.geoPipe.H / EVA.geoPipe.L;
//   protected final parameter Real EVA.hydM = 0.4 \"Part of portIn for p\";
//   parameter Real EVA.alpha_start(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 10000.0 \"Heat transfer coefficient (not too small for valid wall temperature)\";
//   parameter Integer EVA.numberOfWallLayers(min = 1) = 3 \"Number of wall layers\";
//   parameter Real EVA.metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = 540.0 \"Specific heat capacity\";
//   parameter Real EVA.metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = 44.0 \"Thermal conductivity\";
//   parameter Real EVA.metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = 7850.0 \"Mass density\";
//   parameter Real EVA.metal.Rm = 600.0 \"Tension strength [MPa]\";
//   parameter Real EVA.metal.Rp02 = 440.0 \"Elastic limit [MPa]\";
//   parameter Real EVA.diameterBranch(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out + -2.0 * EVA.geoPipe.s \"Average aperture of branch\";
//   parameter Real EVA.wallThicknessBranch(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Wall thickness of branch\";
//   protected Real EVA.m_flowsZero(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = EVA.pIn_start - EVA.pOut_start, nominal = 100000.0);
//   Real EVA.hIn(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = EVA.hIn_start, nominal = 1000000.0) \"actual state at portIn\";
//   Real EVA.hOut(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = EVA.hOut_start, nominal = 1000000.0) \"actual state at portOut\";
//   Integer EVA.state_from_a.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.state_from_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.state_from_a.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.state_from_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TIn_start, nominal = 300.0) \"temperature\";
//   Real EVA.state_from_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = EVA.pIn_start, nominal = 100000.0) \"pressure\";
//   Integer EVA.state_from_b.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.state_from_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.state_from_b.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.state_from_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.TOut_start, nominal = 300.0) \"temperature\";
//   Real EVA.state_from_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = EVA.pOut_start, nominal = 100000.0) \"pressure\";
//   parameter Real EVA.XOut_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = EVA.XIn_start[1] \"Start value of mass fractions m_i/m\";
//   Real EVA.portIn.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start) \"Mass flow rate from the connection point into the component\";
//   Real EVA.portIn.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = EVA.pIn_start, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real EVA.portIn.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = EVA.hIn_start, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real EVA.vol_av(quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   final parameter Real EVA.dz(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L / Real(EVA.numberOfNodes);
//   Real EVA.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[2](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[3](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[4](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[5](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[6](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[7](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[8](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[9](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[10](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[11](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[12](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[13](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[14](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[15](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[16](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[17](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[18](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[19](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   Real EVA.m_flows[20](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = EVA.m_flow_start / Real(EVA.geoPipe.Nt));
//   protected final parameter Real EVA.equalCellDistribution[1] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[1];
//   protected final parameter Real EVA.equalCellDistribution[2] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[2];
//   protected final parameter Real EVA.equalCellDistribution[3] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[3];
//   protected final parameter Real EVA.equalCellDistribution[4] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[4];
//   protected final parameter Real EVA.equalCellDistribution[5] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[5];
//   protected final parameter Real EVA.equalCellDistribution[6] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[6];
//   protected final parameter Real EVA.equalCellDistribution[7] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[7];
//   protected final parameter Real EVA.equalCellDistribution[8] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[8];
//   protected final parameter Real EVA.equalCellDistribution[9] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[9];
//   protected final parameter Real EVA.equalCellDistribution[10] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[10];
//   protected final parameter Real EVA.equalCellDistribution[11] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[11];
//   protected final parameter Real EVA.equalCellDistribution[12] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[12];
//   protected final parameter Real EVA.equalCellDistribution[13] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[13];
//   protected final parameter Real EVA.equalCellDistribution[14] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[14];
//   protected final parameter Real EVA.equalCellDistribution[15] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[15];
//   protected final parameter Real EVA.equalCellDistribution[16] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[16];
//   protected final parameter Real EVA.equalCellDistribution[17] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[17];
//   protected final parameter Real EVA.equalCellDistribution[18] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[18];
//   protected final parameter Real EVA.equalCellDistribution[19] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[19];
//   protected final parameter Real EVA.equalCellDistribution[20] = if EVA.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(EVA.numberOfNodes), 1.0, EVA.numberOfNodes)[20];
//   protected final parameter Real EVA.pressureDistribution_start[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[1];
//   protected final parameter Real EVA.pressureDistribution_start[2](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[2];
//   protected final parameter Real EVA.pressureDistribution_start[3](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[3];
//   protected final parameter Real EVA.pressureDistribution_start[4](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[4];
//   protected final parameter Real EVA.pressureDistribution_start[5](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[5];
//   protected final parameter Real EVA.pressureDistribution_start[6](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[6];
//   protected final parameter Real EVA.pressureDistribution_start[7](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[7];
//   protected final parameter Real EVA.pressureDistribution_start[8](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[8];
//   protected final parameter Real EVA.pressureDistribution_start[9](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[9];
//   protected final parameter Real EVA.pressureDistribution_start[10](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[10];
//   protected final parameter Real EVA.pressureDistribution_start[11](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[11];
//   protected final parameter Real EVA.pressureDistribution_start[12](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[12];
//   protected final parameter Real EVA.pressureDistribution_start[13](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[13];
//   protected final parameter Real EVA.pressureDistribution_start[14](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[14];
//   protected final parameter Real EVA.pressureDistribution_start[15](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[15];
//   protected final parameter Real EVA.pressureDistribution_start[16](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[16];
//   protected final parameter Real EVA.pressureDistribution_start[17](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[17];
//   protected final parameter Real EVA.pressureDistribution_start[18](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[18];
//   protected final parameter Real EVA.pressureDistribution_start[19](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[19];
//   protected final parameter Real EVA.pressureDistribution_start[20](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if EVA.numberOfNodes == 1 then EVA.pOut_start else linspace(EVA.pIn_start, EVA.pOut_start, EVA.numberOfNodes)[20];
//   protected Real EVA.vol[1](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[2](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[3](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[4](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[5](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[6](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[7](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[8](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[9](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[10](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[11](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[12](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[13](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[14](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[15](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[16](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[17](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[18](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[19](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.vol[20](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (EVA.pIn_start + EVA.pOut_start), 0.5 * (EVA.hIn_start + EVA.hOut_start), {EVA.XIn_start[1]}, 0));
//   protected Real EVA.cp[1](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[2](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[3](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[4](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[5](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[6](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[7](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[8](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[9](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[10](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[11](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[12](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[13](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[14](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[15](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[16](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[17](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[18](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[19](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.cp[20](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real EVA.eta[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[3](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[4](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[5](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[6](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[7](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[8](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[9](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[10](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[11](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[12](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[13](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[14](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[15](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[16](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[17](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[18](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[19](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.eta[20](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real EVA.lambda[1](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[2](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[3](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[4](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[5](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[6](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[7](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[8](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[9](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[10](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[11](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[12](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[13](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[14](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[15](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[16](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[17](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[18](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[19](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real EVA.lambda[20](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   parameter Integer EVA.heatport.numberOfNodes = EVA.numberOfNodes \"Number of nodes\";
//   Real EVA.heatport.port[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.port[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.heatport.port[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatport.Q_flow[1](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[2](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[3](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[4](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[5](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[6](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[7](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[8](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[9](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[10](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[11](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[12](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[13](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[14](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[15](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[16](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[17](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[18](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[19](quantity = \"Power\", unit = \"W\");
//   Real EVA.heatport.Q_flow[20](quantity = \"Power\", unit = \"W\");
//   Real EVA.alpha[1](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[2](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[3](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[4](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[5](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[6](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[7](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[8](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[9](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[10](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[11](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[12](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[13](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[14](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[15](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[16](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[17](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[18](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[19](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.alpha[20](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   parameter Real EVA.heatedArea(quantity = \"Area\", unit = \"m2\") = 3.141592653589793 * Real(EVA.geoPipe.Nt) * EVA.geoPipe.L * EVA.diameterInner \"Total Area for heat transfer\";
//   final parameter Real EVA.VTotal(quantity = \"Volume\", unit = \"m3\") = Real(EVA.geoPipe.Nt) * EVA.V;
//   final parameter Real EVA.VCell(quantity = \"Volume\", unit = \"m3\") = EVA.V / Real(EVA.numberOfNodes);
//   protected final parameter Real EVA.hydP = 1.0 - EVA.hydM \"Part of portIn for m_flow\";
//   Real EVA.portOut.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = -EVA.m_flow_start) \"Mass flow rate from the connection point into the component\";
//   Real EVA.portOut.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = EVA.pOut_start, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real EVA.portOut.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = EVA.hOut_start, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected final parameter Real EVA.q_start(quantity = \"HeatFlux\", unit = \"W/m2\") = EVA.m_flow_start * (EVA.hOut_start - EVA.hIn_start) / EVA.heatedArea;
//   Real EVA.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = EVA.hydP * EVA.pIn_start + (1.0 - EVA.hydP) * EVA.pOut_start, nominal = 100000.0) \"pressure\";
//   protected Real EVA.qHeating[1](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[2](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[3](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[4](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[5](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[6](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[7](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[8](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[9](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[10](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[11](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[12](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[13](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[14](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[15](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[16](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[17](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[18](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[19](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qHeating[20](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start) = 0.0;
//   protected Real EVA.qMetalFluid[1](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[2](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[3](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[4](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[5](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[6](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[7](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[8](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[9](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[10](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[11](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[12](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[13](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[14](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[15](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[16](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[17](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[18](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[19](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   protected Real EVA.qMetalFluid[20](quantity = \"HeatFlux\", unit = \"W/m2\", start = EVA.q_start);
//   parameter Real EVA.h_start[1](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[1] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[2](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[2] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[3](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[3] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[4](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[4] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[5](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[5] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[6](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[6] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[7](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[7] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[8](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[8] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[9](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[9] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[10](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[10] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[11](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[11] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[12](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[12] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[13](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[13] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[14](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[14] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[15](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[15] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[16](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[16] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[17](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[17] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[18](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[18] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[19](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[19] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.h_start[20](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = EVA.hIn_start + EVA.equalCellDistribution[20] * (EVA.hOut_start - EVA.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real EVA.Q_flow_start[1](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[2](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[3](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[4](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[5](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[6](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[7](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[8](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[9](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[10](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[11](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[12](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[13](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[14](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[15](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[16](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[17](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[18](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[19](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real EVA.Q_flow_start[20](quantity = \"Power\", unit = \"W\") = (EVA.hOut_start - EVA.hIn_start) * EVA.m_flow_start / Real(EVA.geoPipe.Nt * EVA.numberOfNodes) \"Detailed start values for heat flow\";
//   input Real EVA.fluid[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[1], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[1], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[1].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[1].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[1].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[1].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[1].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[1].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[1].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[1].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[1].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[1].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[1].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[1].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[1].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[1].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[1].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[1].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[1].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[1].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[2], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[2], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[2].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[2].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[2].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[2].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[2].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[2].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[2].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[2].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[2].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[2].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[2].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[2].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[2].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[2].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[2].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[2].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[2].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[2].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[3].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[3], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[3].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[3], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[3].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[3].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[3].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[3].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[3].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[3].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[3].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[3].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[3].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[3].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[3].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[3].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[3].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[3].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[3].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[3].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[3].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[3].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[3].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[4].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[4], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[4].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[4], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[4].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[4].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[4].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[4].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[4].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[4].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[4].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[4].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[4].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[4].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[4].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[4].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[4].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[4].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[4].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[4].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[4].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[4].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[4].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[5].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[5], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[5].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[5], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[5].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[5].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[5].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[5].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[5].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[5].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[5].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[5].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[5].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[5].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[5].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[5].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[5].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[5].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[5].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[5].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[5].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[5].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[5].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[6].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[6], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[6].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[6], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[6].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[6].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[6].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[6].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[6].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[6].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[6].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[6].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[6].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[6].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[6].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[6].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[6].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[6].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[6].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[6].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[6].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[6].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[6].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[7].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[7], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[7].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[7], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[7].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[7].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[7].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[7].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[7].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[7].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[7].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[7].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[7].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[7].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[7].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[7].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[7].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[7].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[7].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[7].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[7].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[7].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[7].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[8].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[8], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[8].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[8], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[8].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[8].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[8].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[8].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[8].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[8].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[8].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[8].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[8].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[8].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[8].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[8].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[8].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[8].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[8].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[8].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[8].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[8].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[8].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[9].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[9], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[9].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[9], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[9].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[9].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[9].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[9].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[9].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[9].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[9].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[9].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[9].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[9].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[9].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[9].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[9].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[9].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[9].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[9].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[9].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[9].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[9].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[10].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[10], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[10].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[10], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[10].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[10].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[10].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[10].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[10].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[10].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[10].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[10].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[10].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[10].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[10].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[10].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[10].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[10].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[10].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[10].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[10].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[10].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[10].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[11].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[11], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[11].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[11], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[11].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[11].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[11].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[11].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[11].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[11].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[11].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[11].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[11].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[11].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[11].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[11].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[11].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[11].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[11].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[11].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[11].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[11].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[11].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[12].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[12], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[12].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[12], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[12].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[12].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[12].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[12].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[12].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[12].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[12].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[12].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[12].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[12].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[12].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[12].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[12].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[12].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[12].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[12].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[12].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[12].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[12].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[13].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[13], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[13].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[13], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[13].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[13].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[13].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[13].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[13].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[13].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[13].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[13].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[13].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[13].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[13].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[13].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[13].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[13].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[13].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[13].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[13].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[13].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[13].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[14].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[14], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[14].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[14], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[14].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[14].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[14].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[14].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[14].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[14].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[14].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[14].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[14].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[14].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[14].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[14].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[14].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[14].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[14].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[14].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[14].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[14].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[14].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[15].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[15], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[15].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[15], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[15].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[15].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[15].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[15].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[15].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[15].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[15].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[15].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[15].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[15].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[15].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[15].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[15].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[15].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[15].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[15].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[15].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[15].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[15].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[16].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[16], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[16].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[16], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[16].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[16].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[16].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[16].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[16].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[16].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[16].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[16].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[16].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[16].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[16].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[16].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[16].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[16].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[16].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[16].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[16].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[16].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[16].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[17].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[17], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[17].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[17], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[17].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[17].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[17].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[17].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[17].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[17].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[17].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[17].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[17].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[17].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[17].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[17].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[17].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[17].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[17].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[17].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[17].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[17].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[17].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[18].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[18], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[18].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[18], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[18].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[18].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[18].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[18].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[18].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[18].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[18].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[18].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[18].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[18].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[18].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[18].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[18].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[18].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[18].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[18].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[18].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[18].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[18].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[19].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[19], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[19].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[19], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[19].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[19].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[19].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[19].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[19].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[19].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[19].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[19].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[19].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[19].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[19].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[19].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[19].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[19].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[19].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[19].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[19].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[19].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[19].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real EVA.fluid[20].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = EVA.pressureDistribution_start[20], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real EVA.fluid[20].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = EVA.h_start[20], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real EVA.fluid[20].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real EVA.fluid[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real EVA.fluid[20].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real EVA.fluid[20].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real EVA.fluid[20].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real EVA.fluid[20].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer EVA.fluid[20].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real EVA.fluid[20].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real EVA.fluid[20].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real EVA.fluid[20].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real EVA.fluid[20].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean EVA.fluid[20].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean EVA.fluid[20].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real EVA.fluid[20].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(EVA.fluid[20].T) \"Temperature of medium in [degC]\";
//   Real EVA.fluid[20].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(EVA.fluid[20].p) \"Absolute pressure of medium in [bar]\";
//   Real EVA.fluid[20].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real EVA.fluid[20].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer EVA.fluid[20].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   Real EVA.d_av(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = (EVA.d_start[1] + EVA.d_start[2] + EVA.d_start[3] + EVA.d_start[4] + EVA.d_start[5] + EVA.d_start[6] + EVA.d_start[7] + EVA.d_start[8] + EVA.d_start[9] + EVA.d_start[10] + EVA.d_start[11] + EVA.d_start[12] + EVA.d_start[13] + EVA.d_start[14] + EVA.d_start[15] + EVA.d_start[16] + EVA.d_start[17] + EVA.d_start[18] + EVA.d_start[19] + EVA.d_start[20]) / Real(EVA.numberOfNodes), nominal = 1.0);
//   Real EVA.dpfric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = EVA.dpFric_start, nominal = 100000.0);
//   Real EVA.dphyd(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = EVA.dpHyd_start, nominal = 100000.0);
//   protected final parameter Real EVA.dpHyd_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 9.80665 * EVA.geoPipe.H * (EVA.d_start[1] + EVA.d_start[2] + EVA.d_start[3] + EVA.d_start[4] + EVA.d_start[5] + EVA.d_start[6] + EVA.d_start[7] + EVA.d_start[8] + EVA.d_start[9] + EVA.d_start[10] + EVA.d_start[11] + EVA.d_start[12] + EVA.d_start[13] + EVA.d_start[14] + EVA.d_start[15] + EVA.d_start[16] + EVA.d_start[17] + EVA.d_start[18] + EVA.d_start[19] + EVA.d_start[20]) / Real(EVA.numberOfNodes);
//   protected final parameter Real EVA.dpFric_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = max(0.0, EVA.pIn_start + (-EVA.pOut_start) - EVA.dpHyd_start);
//   protected final parameter Real EVA.T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[1], EVA.h_start[1], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[2], EVA.h_start[2], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[3], EVA.h_start[3], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[4], EVA.h_start[4], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[5], EVA.h_start[5], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[6], EVA.h_start[6], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[7], EVA.h_start[7], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[8], EVA.h_start[8], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[9], EVA.h_start[9], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[10], EVA.h_start[10], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[11], EVA.h_start[11], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[12], EVA.h_start[12], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[13], EVA.h_start[13], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[14], EVA.h_start[14], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[15], EVA.h_start[15], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[16], EVA.h_start[16], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[17], EVA.h_start[17], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[18], EVA.h_start[18], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[19], EVA.h_start[19], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.T_start[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(EVA.pressureDistribution_start[20], EVA.h_start[20], {EVA.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real EVA.d_start[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[1], EVA.h_start[1], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[2], EVA.h_start[2], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[3](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[3], EVA.h_start[3], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[4](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[4], EVA.h_start[4], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[5](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[5], EVA.h_start[5], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[6](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[6], EVA.h_start[6], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[7](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[7], EVA.h_start[7], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[8](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[8], EVA.h_start[8], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[9](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[9], EVA.h_start[9], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[10](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[10], EVA.h_start[10], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[11](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[11], EVA.h_start[11], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[12](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[12], EVA.h_start[12], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[13](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[13], EVA.h_start[13], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[14](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[14], EVA.h_start[14], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[15](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[15], EVA.h_start[15], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[16](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[16], EVA.h_start[16], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[17](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[17], EVA.h_start[17], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[18](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[18], EVA.h_start[18], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[19](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[19], EVA.h_start[19], {EVA.XIn_start[1]}, 0);
//   protected final parameter Real EVA.d_start[20](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(EVA.pressureDistribution_start[20], EVA.h_start[20], {EVA.XIn_start[1]}, 0);
//   protected Real EVA.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[1], nominal = 300.0);
//   protected Real EVA.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[2], nominal = 300.0);
//   protected Real EVA.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[3], nominal = 300.0);
//   protected Real EVA.T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[4], nominal = 300.0);
//   protected Real EVA.T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[5], nominal = 300.0);
//   protected Real EVA.T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[6], nominal = 300.0);
//   protected Real EVA.T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[7], nominal = 300.0);
//   protected Real EVA.T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[8], nominal = 300.0);
//   protected Real EVA.T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[9], nominal = 300.0);
//   protected Real EVA.T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[10], nominal = 300.0);
//   protected Real EVA.T[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[11], nominal = 300.0);
//   protected Real EVA.T[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[12], nominal = 300.0);
//   protected Real EVA.T[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[13], nominal = 300.0);
//   protected Real EVA.T[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[14], nominal = 300.0);
//   protected Real EVA.T[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[15], nominal = 300.0);
//   protected Real EVA.T[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[16], nominal = 300.0);
//   protected Real EVA.T[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[17], nominal = 300.0);
//   protected Real EVA.T[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[18], nominal = 300.0);
//   protected Real EVA.T[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[19], nominal = 300.0);
//   protected Real EVA.T[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = EVA.T_start[20], nominal = 300.0);
//   protected Real EVA.d[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[1], nominal = 1.0);
//   protected Real EVA.d[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[2], nominal = 1.0);
//   protected Real EVA.d[3](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[3], nominal = 1.0);
//   protected Real EVA.d[4](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[4], nominal = 1.0);
//   protected Real EVA.d[5](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[5], nominal = 1.0);
//   protected Real EVA.d[6](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[6], nominal = 1.0);
//   protected Real EVA.d[7](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[7], nominal = 1.0);
//   protected Real EVA.d[8](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[8], nominal = 1.0);
//   protected Real EVA.d[9](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[9], nominal = 1.0);
//   protected Real EVA.d[10](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[10], nominal = 1.0);
//   protected Real EVA.d[11](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[11], nominal = 1.0);
//   protected Real EVA.d[12](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[12], nominal = 1.0);
//   protected Real EVA.d[13](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[13], nominal = 1.0);
//   protected Real EVA.d[14](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[14], nominal = 1.0);
//   protected Real EVA.d[15](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[15], nominal = 1.0);
//   protected Real EVA.d[16](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[16], nominal = 1.0);
//   protected Real EVA.d[17](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[17], nominal = 1.0);
//   protected Real EVA.d[18](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[18], nominal = 1.0);
//   protected Real EVA.d[19](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[19], nominal = 1.0);
//   protected Real EVA.d[20](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = EVA.d_start[20], nominal = 1.0);
//   protected Real EVA.E_flows[1](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[1]);
//   protected Real EVA.E_flows[2](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[2]);
//   protected Real EVA.E_flows[3](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[3]);
//   protected Real EVA.E_flows[4](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[4]);
//   protected Real EVA.E_flows[5](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[5]);
//   protected Real EVA.E_flows[6](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[6]);
//   protected Real EVA.E_flows[7](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[7]);
//   protected Real EVA.E_flows[8](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[8]);
//   protected Real EVA.E_flows[9](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[9]);
//   protected Real EVA.E_flows[10](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[10]);
//   protected Real EVA.E_flows[11](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[11]);
//   protected Real EVA.E_flows[12](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[12]);
//   protected Real EVA.E_flows[13](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[13]);
//   protected Real EVA.E_flows[14](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[14]);
//   protected Real EVA.E_flows[15](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[15]);
//   protected Real EVA.E_flows[16](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[16]);
//   protected Real EVA.E_flows[17](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[17]);
//   protected Real EVA.E_flows[18](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[18]);
//   protected Real EVA.E_flows[19](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[19]);
//   protected Real EVA.E_flows[20](quantity = \"Power\", unit = \"W\", start = -EVA.Q_flow_start[20]);
//   parameter Integer EVA.friction.geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.friction.geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.friction.geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.friction.geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.friction.geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.friction.geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.friction.geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.friction.geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.friction.geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   parameter Real EVA.friction.dz(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"length of tube section for which friction pressure loss is wanted\";
//   parameter Real EVA.friction.lambda = 0.02 \"constant friction factor (used for valve friction model only)\";
//   input Real EVA.friction.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.p \"pressure\";
//   input Real EVA.friction.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[1].h \"specific enthalpy\";
//   input Real EVA.friction.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d_av \"mass density\";
//   input Real EVA.friction.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[1] \"dynamic viscosoty\";
//   input Real EVA.friction.steamQuality = 1.5 \"Steam quality\";
//   input Real EVA.friction.xdo = 0.9 \"Critical steam quality, at which the boiling crisis (e.g. dryout) occurs\";
//   input Real EVA.friction.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[1] \"mass flow rate\";
//   Real EVA.friction.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0);
//   final parameter Real EVA.friction.diameterInner(quantity = \"Length\", unit = \"m\") = EVA.friction.geoPipe.d_out + -2.0 * EVA.friction.geoPipe.s;
//   Real EVA.friction.DPMFLOW_ADD_IN_var.zeta_TOT(quantity = \"Pressure loss coefficient | zeta_tot = zeta_loc + zeta_fri\", unit = \"1\", min = 0.0, max = 1111.0) = max(0.000000000001, EVA.friction.geoPipe.zeta_add) \"Pressure loss coefficient\";
//   Real EVA.friction.DPMFLOW_ADD_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.friction.rho \"Density of fluid\";
//   Real EVA.friction.DPMFLOW_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.friction.eta \"Dynamic viscosity of fluid\";
//   Real EVA.friction.DPMFLOW_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.friction.rho \"Density of fluid\";
//   final parameter Real EVA.friction.A(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * EVA.friction.diameterInner ^ 2.0;
//   enumeration(Neglected, Considered) EVA.friction.DPMFLOW_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Neglected \"Choice of considering surface roughness\";
//   Real EVA.friction.DPMFLOW_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.friction.diameterInner \"Hydraulic diameter\";
//   Real EVA.friction.DPMFLOW_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.friction.dz \"Length\";
//   Real EVA.friction.DPMFLOW_IN_con.K(quantity = \"Length\", unit = \"m\") = EVA.friction.geoPipe.r \"Roughness (average height of surface asperities)\";
//   Real EVA.friction.DPMFLOW_ADD_IN_con.A_cross(quantity = \"Area\", unit = \"m2\") = EVA.friction.A \"Cross sectional area\";
//   Real EVA.friction.DPMFLOW_ADD_IN_con.dp_smooth(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 1.0 \"Start linearisation for decreasing pressure loss\";
//   parameter Real EVA.TWall_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[1] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[2] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[3] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[4] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[5] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[6] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[7] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[8] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[9] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[10] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[11] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[12] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[13] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[14] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[15] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[16] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[17] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[18] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[19] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   parameter Real EVA.TWall_start[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = EVA.T_start[20] + EVA.q_start / EVA.alpha_start \"start values for wall temperatures\";
//   Real EVA.heatPort[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[1].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[1] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[2].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[2] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[3].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[3] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[4].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[4] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[5].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[5] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[6].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[6] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[7].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[7] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[8].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[8] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[9].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[9] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[10].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[10] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[11].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[11] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[12].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[12] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[13].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[13] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[14].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[14] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[15].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[15] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[16].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[16] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[17].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[17] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[18].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[18] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[19].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[19] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.heatPort[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.TWall_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.heatPort[20].Q_flow(quantity = \"Power\", unit = \"W\", start = EVA.Q_flow_start[20] * Real(EVA.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Integer EVA.wall.numberOfNodes(min = 1) = EVA.numberOfNodes \"Number of nodes\";
//   parameter Integer EVA.wall.numberOfWallLayers(min = 1) = EVA.numberOfWallLayers \"Number of wall layers\";
//   parameter Real EVA.wall.metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.metal.cp \"Specific heat capacity\";
//   parameter Real EVA.wall.metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.metal.lambda \"Thermal conductivity\";
//   parameter Real EVA.wall.metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.metal.rho \"Mass density\";
//   parameter Real EVA.wall.metal.Rm = EVA.metal.Rm \"Tension strength [MPa]\";
//   parameter Real EVA.wall.metal.Rp02 = EVA.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer EVA.wall.numberOfParallelTubes(min = 1) = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.wall.length(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Tube length\";
//   parameter Real EVA.wall.diameterInner(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out + -2.0 * EVA.geoPipe.s \"Internal diameter (single tube)\";
//   parameter Real EVA.wall.wallThickness(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Wall thickness\";
//   Real EVA.wall.port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_ext[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_ext[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.port_int[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.port_int[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real EVA.wall.T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[1] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[2] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[3] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[4] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[5] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[6] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[7] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[8] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[9] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[10] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[11] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[12] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[13] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[14] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[15] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[16] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[17] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[18] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[19] \"Temperature start values for inner layer\";
//   parameter Real EVA.wall.T_start[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.TWall_start[20] \"Temperature start values for inner layer\";
//   constant Real EVA.wall.layer[1].pi = 3.141592653589793;
//   parameter Integer EVA.wall.layer[1].numberOfNodes(min = 1) = EVA.wall.numberOfNodes \"Number of nodes\";
//   parameter Boolean EVA.wall.layer[1].assumePlainHeatTransfer = false \"no logarithmic correction\";
//   parameter Real EVA.wall.layer[1].metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.wall.metal.cp \"Specific heat capacity\";
//   parameter Real EVA.wall.layer[1].metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.wall.metal.lambda \"Thermal conductivity\";
//   parameter Real EVA.wall.layer[1].metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.wall.metal.rho \"Mass density\";
//   parameter Real EVA.wall.layer[1].metal.Rm = EVA.wall.metal.Rm \"Tension strength [MPa]\";
//   parameter Real EVA.wall.layer[1].metal.Rp02 = EVA.wall.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer EVA.wall.layer[1].numberOfParallelTubes(min = 1) = EVA.wall.numberOfParallelTubes \"Number of parallel tubes\";
//   parameter Real EVA.wall.layer[1].length(quantity = \"Length\", unit = \"m\") = EVA.wall.length \"Tube length\";
//   parameter Real EVA.wall.layer[1].diameterInner(quantity = \"Length\", unit = \"m\") = if EVA.wall.numberOfWallLayers == 1 then EVA.wall.diameterInner else linspace(EVA.wall.diameterInner, EVA.wall.diameterInner + 2.0 * EVA.wall.wallThickness + -2.0 * EVA.wall.wallThickness / Real(EVA.wall.numberOfWallLayers), EVA.wall.numberOfWallLayers)[1] \"Internal diameter (single tube)\";
//   parameter Real EVA.wall.layer[1].wallThickness(quantity = \"Length\", unit = \"m\") = EVA.wall.wallThickness / Real(EVA.wall.numberOfWallLayers) \"Wall thickness\";
//   parameter Boolean EVA.wall.layer[1].useDynamicEquations = true \"switch off for steady-state simulations\";
//   parameter Boolean EVA.wall.layer[1].considerConductivity = true \"Wall conduction resistance accounted for\";
//   parameter Boolean EVA.wall.layer[1].considerAxialHeatTransfer = false \"With heat transfer in the wall parallel to the flow direction\";
//   parameter String EVA.wall.layer[1].initOpt = \"steadyState\" \"Initialisation option\";
//   Real EVA.wall.layer[1].Am(quantity = \"Area\", unit = \"m2\") \"Area of the metal tube cross-section\";
//   Real EVA.wall.layer[1].rint(quantity = \"Length\", unit = \"m\");
//   Real EVA.wall.layer[1].rext(quantity = \"Length\", unit = \"m\");
//   Real EVA.wall.layer[1].Tube_mass(quantity = \"Mass\", unit = \"kg\", min = 0.0);
//   Real EVA.wall.layer[1].HeatCap(quantity = \"HeatCapacity\", unit = \"J/K\") \"HeatCapacity of a Tube part\";
//   parameter Real EVA.wall.layer[1].T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[1] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[2] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[3] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[4] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[5] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[6] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[7] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[8] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[9] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[10] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[11] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[12] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[13] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[14] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[15] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[16] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[17] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[18] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[19] \"Temperature start values\";
//   parameter Real EVA.wall.layer[1].T_start[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[20] \"Temperature start values\";
//   Real EVA.wall.layer[1].port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_ext[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_ext[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].port_int[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[1].port_int[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[1].T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[1], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[2], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[3], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[4], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[5], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[6], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[7], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[8], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[9], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[10], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[11], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[12], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[13], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[14], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[15], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[16], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[17], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[18], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[19], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[1].T[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[1].T_start[20], nominal = 300.0) \"Node temperatures\";
//   constant Real EVA.wall.layer[2].pi = 3.141592653589793;
//   parameter Integer EVA.wall.layer[2].numberOfNodes(min = 1) = EVA.wall.numberOfNodes \"Number of nodes\";
//   parameter Boolean EVA.wall.layer[2].assumePlainHeatTransfer = false \"no logarithmic correction\";
//   parameter Real EVA.wall.layer[2].metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.wall.metal.cp \"Specific heat capacity\";
//   parameter Real EVA.wall.layer[2].metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.wall.metal.lambda \"Thermal conductivity\";
//   parameter Real EVA.wall.layer[2].metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.wall.metal.rho \"Mass density\";
//   parameter Real EVA.wall.layer[2].metal.Rm = EVA.wall.metal.Rm \"Tension strength [MPa]\";
//   parameter Real EVA.wall.layer[2].metal.Rp02 = EVA.wall.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer EVA.wall.layer[2].numberOfParallelTubes(min = 1) = EVA.wall.numberOfParallelTubes \"Number of parallel tubes\";
//   parameter Real EVA.wall.layer[2].length(quantity = \"Length\", unit = \"m\") = EVA.wall.length \"Tube length\";
//   parameter Real EVA.wall.layer[2].diameterInner(quantity = \"Length\", unit = \"m\") = if EVA.wall.numberOfWallLayers == 1 then {EVA.wall.diameterInner}[2] else linspace(EVA.wall.diameterInner, EVA.wall.diameterInner + 2.0 * EVA.wall.wallThickness + -2.0 * EVA.wall.wallThickness / Real(EVA.wall.numberOfWallLayers), EVA.wall.numberOfWallLayers)[2] \"Internal diameter (single tube)\";
//   parameter Real EVA.wall.layer[2].wallThickness(quantity = \"Length\", unit = \"m\") = EVA.wall.wallThickness / Real(EVA.wall.numberOfWallLayers) \"Wall thickness\";
//   parameter Boolean EVA.wall.layer[2].useDynamicEquations = true \"switch off for steady-state simulations\";
//   parameter Boolean EVA.wall.layer[2].considerConductivity = true \"Wall conduction resistance accounted for\";
//   parameter Boolean EVA.wall.layer[2].considerAxialHeatTransfer = false \"With heat transfer in the wall parallel to the flow direction\";
//   parameter String EVA.wall.layer[2].initOpt = \"steadyState\" \"Initialisation option\";
//   Real EVA.wall.layer[2].Am(quantity = \"Area\", unit = \"m2\") \"Area of the metal tube cross-section\";
//   Real EVA.wall.layer[2].rint(quantity = \"Length\", unit = \"m\");
//   Real EVA.wall.layer[2].rext(quantity = \"Length\", unit = \"m\");
//   Real EVA.wall.layer[2].Tube_mass(quantity = \"Mass\", unit = \"kg\", min = 0.0);
//   Real EVA.wall.layer[2].HeatCap(quantity = \"HeatCapacity\", unit = \"J/K\") \"HeatCapacity of a Tube part\";
//   parameter Real EVA.wall.layer[2].T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[1] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[2] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[3] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[4] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[5] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[6] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[7] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[8] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[9] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[10] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[11] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[12] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[13] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[14] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[15] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[16] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[17] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[18] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[19] \"Temperature start values\";
//   parameter Real EVA.wall.layer[2].T_start[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[20] \"Temperature start values\";
//   Real EVA.wall.layer[2].port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_ext[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_ext[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].port_int[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[2].port_int[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[2].T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[1], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[2], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[3], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[4], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[5], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[6], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[7], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[8], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[9], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[10], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[11], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[12], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[13], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[14], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[15], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[16], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[17], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[18], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[19], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[2].T[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[2].T_start[20], nominal = 300.0) \"Node temperatures\";
//   constant Real EVA.wall.layer[3].pi = 3.141592653589793;
//   parameter Integer EVA.wall.layer[3].numberOfNodes(min = 1) = EVA.wall.numberOfNodes \"Number of nodes\";
//   parameter Boolean EVA.wall.layer[3].assumePlainHeatTransfer = false \"no logarithmic correction\";
//   parameter Real EVA.wall.layer[3].metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.wall.metal.cp \"Specific heat capacity\";
//   parameter Real EVA.wall.layer[3].metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.wall.metal.lambda \"Thermal conductivity\";
//   parameter Real EVA.wall.layer[3].metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.wall.metal.rho \"Mass density\";
//   parameter Real EVA.wall.layer[3].metal.Rm = EVA.wall.metal.Rm \"Tension strength [MPa]\";
//   parameter Real EVA.wall.layer[3].metal.Rp02 = EVA.wall.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer EVA.wall.layer[3].numberOfParallelTubes(min = 1) = EVA.wall.numberOfParallelTubes \"Number of parallel tubes\";
//   parameter Real EVA.wall.layer[3].length(quantity = \"Length\", unit = \"m\") = EVA.wall.length \"Tube length\";
//   parameter Real EVA.wall.layer[3].diameterInner(quantity = \"Length\", unit = \"m\") = if EVA.wall.numberOfWallLayers == 1 then {EVA.wall.diameterInner}[3] else linspace(EVA.wall.diameterInner, EVA.wall.diameterInner + 2.0 * EVA.wall.wallThickness + -2.0 * EVA.wall.wallThickness / Real(EVA.wall.numberOfWallLayers), EVA.wall.numberOfWallLayers)[3] \"Internal diameter (single tube)\";
//   parameter Real EVA.wall.layer[3].wallThickness(quantity = \"Length\", unit = \"m\") = EVA.wall.wallThickness / Real(EVA.wall.numberOfWallLayers) \"Wall thickness\";
//   parameter Boolean EVA.wall.layer[3].useDynamicEquations = true \"switch off for steady-state simulations\";
//   parameter Boolean EVA.wall.layer[3].considerConductivity = true \"Wall conduction resistance accounted for\";
//   parameter Boolean EVA.wall.layer[3].considerAxialHeatTransfer = false \"With heat transfer in the wall parallel to the flow direction\";
//   parameter String EVA.wall.layer[3].initOpt = \"steadyState\" \"Initialisation option\";
//   Real EVA.wall.layer[3].Am(quantity = \"Area\", unit = \"m2\") \"Area of the metal tube cross-section\";
//   Real EVA.wall.layer[3].rint(quantity = \"Length\", unit = \"m\");
//   Real EVA.wall.layer[3].rext(quantity = \"Length\", unit = \"m\");
//   Real EVA.wall.layer[3].Tube_mass(quantity = \"Mass\", unit = \"kg\", min = 0.0);
//   Real EVA.wall.layer[3].HeatCap(quantity = \"HeatCapacity\", unit = \"J/K\") \"HeatCapacity of a Tube part\";
//   parameter Real EVA.wall.layer[3].T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[1] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[2] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[3] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[4] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[5] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[6] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[7] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[8] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[9] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[10] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[11] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[12] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[13] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[14] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[15] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[16] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[17] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[18] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[19] \"Temperature start values\";
//   parameter Real EVA.wall.layer[3].T_start[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = EVA.wall.T_start[20] \"Temperature start values\";
//   Real EVA.wall.layer[3].port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_ext[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_ext[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[11], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[12], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[13], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[14], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[15], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[16], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[17], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[18], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[19], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].port_int[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[20], nominal = 300.0) \"Port temperature\";
//   Real EVA.wall.layer[3].port_int[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real EVA.wall.layer[3].T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[1], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[2], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[3], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[4], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[5], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[6], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[7], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[8], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[9], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[10], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[11](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[11], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[12](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[12], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[13](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[13], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[14](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[14], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[15](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[15], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[16](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[16], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[17](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[17], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[18](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[18], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[19](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[19], nominal = 300.0) \"Node temperatures\";
//   Real EVA.wall.layer[3].T[20](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = EVA.wall.layer[3].T_start[20], nominal = 300.0) \"Node temperatures\";
//   parameter Integer EVA.HT[1].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[1].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[1].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[1].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[1].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[1].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[1].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[1].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[1].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[1].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[1].geoPipe.d_out + -2.0 * EVA.HT[1].geoPipe.s;
//   input Real EVA.HT[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[1].p;
//   input Real EVA.HT[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[1].h;
//   input Real EVA.HT[1].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[1];
//   input Real EVA.HT[1].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[1];
//   input Real EVA.HT[1].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[1];
//   input Real EVA.HT[1].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[1];
//   input Real EVA.HT[1].steamQuality = 1.5;
//   input Real EVA.HT[1].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[1];
//   input Real EVA.HT[1].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[1] - EVA.fluid[1].T;
//   Real EVA.HT[1].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[1].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[1].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[1].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[1].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[1].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[1].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[1].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[1].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[1].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[1].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[1].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[1].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[1].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[1].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[1].rho \"Density of fluid\";
//   Real EVA.HT[1].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[1].m_flow;
//   parameter Integer EVA.HT[2].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[2].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[2].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[2].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[2].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[2].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[2].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[2].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[2].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[2].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[2].geoPipe.d_out + -2.0 * EVA.HT[2].geoPipe.s;
//   input Real EVA.HT[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[2].p;
//   input Real EVA.HT[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[2].h;
//   input Real EVA.HT[2].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[2];
//   input Real EVA.HT[2].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[2];
//   input Real EVA.HT[2].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[2];
//   input Real EVA.HT[2].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[2];
//   input Real EVA.HT[2].steamQuality = 1.5;
//   input Real EVA.HT[2].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[2];
//   input Real EVA.HT[2].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[2] - EVA.fluid[2].T;
//   Real EVA.HT[2].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[2].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[2].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[2].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[2].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[2].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[2].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[2].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[2].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[2].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[2].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[2].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[2].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[2].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[2].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[2].rho \"Density of fluid\";
//   Real EVA.HT[2].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[2].m_flow;
//   parameter Integer EVA.HT[3].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[3].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[3].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[3].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[3].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[3].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[3].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[3].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[3].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[3].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[3].geoPipe.d_out + -2.0 * EVA.HT[3].geoPipe.s;
//   input Real EVA.HT[3].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[3].p;
//   input Real EVA.HT[3].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[3].h;
//   input Real EVA.HT[3].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[3];
//   input Real EVA.HT[3].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[3];
//   input Real EVA.HT[3].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[3];
//   input Real EVA.HT[3].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[3];
//   input Real EVA.HT[3].steamQuality = 1.5;
//   input Real EVA.HT[3].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[3];
//   input Real EVA.HT[3].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[3] - EVA.fluid[3].T;
//   Real EVA.HT[3].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[3].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[3].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[3].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[3].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[3].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[3].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[3].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[3].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[3].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[3].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[3].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[3].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[3].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[3].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[3].rho \"Density of fluid\";
//   Real EVA.HT[3].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[3].m_flow;
//   parameter Integer EVA.HT[4].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[4].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[4].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[4].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[4].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[4].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[4].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[4].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[4].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[4].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[4].geoPipe.d_out + -2.0 * EVA.HT[4].geoPipe.s;
//   input Real EVA.HT[4].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[4].p;
//   input Real EVA.HT[4].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[4].h;
//   input Real EVA.HT[4].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[4];
//   input Real EVA.HT[4].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[4];
//   input Real EVA.HT[4].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[4];
//   input Real EVA.HT[4].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[4];
//   input Real EVA.HT[4].steamQuality = 1.5;
//   input Real EVA.HT[4].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[4];
//   input Real EVA.HT[4].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[4] - EVA.fluid[4].T;
//   Real EVA.HT[4].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[4].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[4].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[4].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[4].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[4].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[4].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[4].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[4].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[4].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[4].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[4].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[4].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[4].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[4].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[4].rho \"Density of fluid\";
//   Real EVA.HT[4].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[4].m_flow;
//   parameter Integer EVA.HT[5].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[5].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[5].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[5].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[5].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[5].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[5].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[5].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[5].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[5].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[5].geoPipe.d_out + -2.0 * EVA.HT[5].geoPipe.s;
//   input Real EVA.HT[5].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[5].p;
//   input Real EVA.HT[5].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[5].h;
//   input Real EVA.HT[5].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[5];
//   input Real EVA.HT[5].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[5];
//   input Real EVA.HT[5].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[5];
//   input Real EVA.HT[5].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[5];
//   input Real EVA.HT[5].steamQuality = 1.5;
//   input Real EVA.HT[5].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[5];
//   input Real EVA.HT[5].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[5] - EVA.fluid[5].T;
//   Real EVA.HT[5].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[5].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[5].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[5].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[5].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[5].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[5].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[5].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[5].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[5].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[5].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[5].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[5].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[5].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[5].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[5].rho \"Density of fluid\";
//   Real EVA.HT[5].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[5].m_flow;
//   parameter Integer EVA.HT[6].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[6].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[6].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[6].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[6].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[6].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[6].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[6].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[6].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[6].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[6].geoPipe.d_out + -2.0 * EVA.HT[6].geoPipe.s;
//   input Real EVA.HT[6].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[6].p;
//   input Real EVA.HT[6].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[6].h;
//   input Real EVA.HT[6].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[6];
//   input Real EVA.HT[6].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[6];
//   input Real EVA.HT[6].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[6];
//   input Real EVA.HT[6].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[6];
//   input Real EVA.HT[6].steamQuality = 1.5;
//   input Real EVA.HT[6].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[6];
//   input Real EVA.HT[6].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[6] - EVA.fluid[6].T;
//   Real EVA.HT[6].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[6].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[6].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[6].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[6].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[6].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[6].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[6].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[6].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[6].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[6].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[6].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[6].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[6].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[6].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[6].rho \"Density of fluid\";
//   Real EVA.HT[6].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[6].m_flow;
//   parameter Integer EVA.HT[7].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[7].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[7].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[7].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[7].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[7].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[7].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[7].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[7].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[7].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[7].geoPipe.d_out + -2.0 * EVA.HT[7].geoPipe.s;
//   input Real EVA.HT[7].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[7].p;
//   input Real EVA.HT[7].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[7].h;
//   input Real EVA.HT[7].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[7];
//   input Real EVA.HT[7].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[7];
//   input Real EVA.HT[7].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[7];
//   input Real EVA.HT[7].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[7];
//   input Real EVA.HT[7].steamQuality = 1.5;
//   input Real EVA.HT[7].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[7];
//   input Real EVA.HT[7].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[7] - EVA.fluid[7].T;
//   Real EVA.HT[7].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[7].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[7].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[7].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[7].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[7].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[7].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[7].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[7].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[7].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[7].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[7].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[7].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[7].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[7].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[7].rho \"Density of fluid\";
//   Real EVA.HT[7].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[7].m_flow;
//   parameter Integer EVA.HT[8].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[8].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[8].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[8].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[8].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[8].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[8].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[8].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[8].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[8].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[8].geoPipe.d_out + -2.0 * EVA.HT[8].geoPipe.s;
//   input Real EVA.HT[8].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[8].p;
//   input Real EVA.HT[8].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[8].h;
//   input Real EVA.HT[8].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[8];
//   input Real EVA.HT[8].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[8];
//   input Real EVA.HT[8].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[8];
//   input Real EVA.HT[8].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[8];
//   input Real EVA.HT[8].steamQuality = 1.5;
//   input Real EVA.HT[8].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[8];
//   input Real EVA.HT[8].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[8] - EVA.fluid[8].T;
//   Real EVA.HT[8].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[8].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[8].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[8].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[8].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[8].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[8].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[8].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[8].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[8].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[8].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[8].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[8].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[8].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[8].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[8].rho \"Density of fluid\";
//   Real EVA.HT[8].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[8].m_flow;
//   parameter Integer EVA.HT[9].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[9].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[9].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[9].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[9].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[9].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[9].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[9].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[9].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[9].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[9].geoPipe.d_out + -2.0 * EVA.HT[9].geoPipe.s;
//   input Real EVA.HT[9].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[9].p;
//   input Real EVA.HT[9].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[9].h;
//   input Real EVA.HT[9].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[9];
//   input Real EVA.HT[9].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[9];
//   input Real EVA.HT[9].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[9];
//   input Real EVA.HT[9].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[9];
//   input Real EVA.HT[9].steamQuality = 1.5;
//   input Real EVA.HT[9].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[9];
//   input Real EVA.HT[9].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[9] - EVA.fluid[9].T;
//   Real EVA.HT[9].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[9].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[9].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[9].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[9].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[9].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[9].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[9].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[9].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[9].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[9].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[9].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[9].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[9].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[9].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[9].rho \"Density of fluid\";
//   Real EVA.HT[9].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[9].m_flow;
//   parameter Integer EVA.HT[10].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[10].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[10].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[10].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[10].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[10].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[10].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[10].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[10].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[10].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[10].geoPipe.d_out + -2.0 * EVA.HT[10].geoPipe.s;
//   input Real EVA.HT[10].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[10].p;
//   input Real EVA.HT[10].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[10].h;
//   input Real EVA.HT[10].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[10];
//   input Real EVA.HT[10].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[10];
//   input Real EVA.HT[10].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[10];
//   input Real EVA.HT[10].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[10];
//   input Real EVA.HT[10].steamQuality = 1.5;
//   input Real EVA.HT[10].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[10];
//   input Real EVA.HT[10].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[10] - EVA.fluid[10].T;
//   Real EVA.HT[10].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[10].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[10].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[10].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[10].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[10].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[10].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[10].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[10].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[10].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[10].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[10].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[10].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[10].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[10].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[10].rho \"Density of fluid\";
//   Real EVA.HT[10].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[10].m_flow;
//   parameter Integer EVA.HT[11].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[11].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[11].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[11].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[11].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[11].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[11].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[11].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[11].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[11].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[11].geoPipe.d_out + -2.0 * EVA.HT[11].geoPipe.s;
//   input Real EVA.HT[11].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[11].p;
//   input Real EVA.HT[11].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[11].h;
//   input Real EVA.HT[11].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[11];
//   input Real EVA.HT[11].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[11];
//   input Real EVA.HT[11].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[11];
//   input Real EVA.HT[11].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[11];
//   input Real EVA.HT[11].steamQuality = 1.5;
//   input Real EVA.HT[11].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[11];
//   input Real EVA.HT[11].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[11] - EVA.fluid[11].T;
//   Real EVA.HT[11].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[11].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[11].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[11].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[11].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[11].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[11].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[11].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[11].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[11].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[11].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[11].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[11].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[11].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[11].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[11].rho \"Density of fluid\";
//   Real EVA.HT[11].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[11].m_flow;
//   parameter Integer EVA.HT[12].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[12].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[12].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[12].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[12].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[12].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[12].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[12].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[12].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[12].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[12].geoPipe.d_out + -2.0 * EVA.HT[12].geoPipe.s;
//   input Real EVA.HT[12].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[12].p;
//   input Real EVA.HT[12].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[12].h;
//   input Real EVA.HT[12].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[12];
//   input Real EVA.HT[12].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[12];
//   input Real EVA.HT[12].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[12];
//   input Real EVA.HT[12].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[12];
//   input Real EVA.HT[12].steamQuality = 1.5;
//   input Real EVA.HT[12].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[12];
//   input Real EVA.HT[12].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[12] - EVA.fluid[12].T;
//   Real EVA.HT[12].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[12].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[12].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[12].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[12].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[12].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[12].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[12].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[12].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[12].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[12].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[12].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[12].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[12].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[12].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[12].rho \"Density of fluid\";
//   Real EVA.HT[12].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[12].m_flow;
//   parameter Integer EVA.HT[13].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[13].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[13].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[13].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[13].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[13].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[13].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[13].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[13].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[13].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[13].geoPipe.d_out + -2.0 * EVA.HT[13].geoPipe.s;
//   input Real EVA.HT[13].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[13].p;
//   input Real EVA.HT[13].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[13].h;
//   input Real EVA.HT[13].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[13];
//   input Real EVA.HT[13].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[13];
//   input Real EVA.HT[13].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[13];
//   input Real EVA.HT[13].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[13];
//   input Real EVA.HT[13].steamQuality = 1.5;
//   input Real EVA.HT[13].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[13];
//   input Real EVA.HT[13].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[13] - EVA.fluid[13].T;
//   Real EVA.HT[13].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[13].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[13].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[13].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[13].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[13].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[13].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[13].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[13].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[13].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[13].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[13].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[13].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[13].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[13].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[13].rho \"Density of fluid\";
//   Real EVA.HT[13].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[13].m_flow;
//   parameter Integer EVA.HT[14].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[14].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[14].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[14].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[14].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[14].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[14].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[14].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[14].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[14].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[14].geoPipe.d_out + -2.0 * EVA.HT[14].geoPipe.s;
//   input Real EVA.HT[14].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[14].p;
//   input Real EVA.HT[14].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[14].h;
//   input Real EVA.HT[14].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[14];
//   input Real EVA.HT[14].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[14];
//   input Real EVA.HT[14].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[14];
//   input Real EVA.HT[14].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[14];
//   input Real EVA.HT[14].steamQuality = 1.5;
//   input Real EVA.HT[14].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[14];
//   input Real EVA.HT[14].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[14] - EVA.fluid[14].T;
//   Real EVA.HT[14].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[14].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[14].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[14].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[14].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[14].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[14].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[14].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[14].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[14].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[14].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[14].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[14].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[14].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[14].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[14].rho \"Density of fluid\";
//   Real EVA.HT[14].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[14].m_flow;
//   parameter Integer EVA.HT[15].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[15].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[15].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[15].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[15].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[15].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[15].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[15].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[15].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[15].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[15].geoPipe.d_out + -2.0 * EVA.HT[15].geoPipe.s;
//   input Real EVA.HT[15].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[15].p;
//   input Real EVA.HT[15].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[15].h;
//   input Real EVA.HT[15].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[15];
//   input Real EVA.HT[15].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[15];
//   input Real EVA.HT[15].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[15];
//   input Real EVA.HT[15].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[15];
//   input Real EVA.HT[15].steamQuality = 1.5;
//   input Real EVA.HT[15].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[15];
//   input Real EVA.HT[15].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[15] - EVA.fluid[15].T;
//   Real EVA.HT[15].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[15].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[15].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[15].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[15].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[15].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[15].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[15].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[15].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[15].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[15].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[15].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[15].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[15].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[15].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[15].rho \"Density of fluid\";
//   Real EVA.HT[15].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[15].m_flow;
//   parameter Integer EVA.HT[16].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[16].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[16].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[16].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[16].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[16].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[16].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[16].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[16].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[16].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[16].geoPipe.d_out + -2.0 * EVA.HT[16].geoPipe.s;
//   input Real EVA.HT[16].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[16].p;
//   input Real EVA.HT[16].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[16].h;
//   input Real EVA.HT[16].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[16];
//   input Real EVA.HT[16].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[16];
//   input Real EVA.HT[16].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[16];
//   input Real EVA.HT[16].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[16];
//   input Real EVA.HT[16].steamQuality = 1.5;
//   input Real EVA.HT[16].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[16];
//   input Real EVA.HT[16].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[16] - EVA.fluid[16].T;
//   Real EVA.HT[16].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[16].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[16].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[16].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[16].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[16].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[16].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[16].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[16].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[16].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[16].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[16].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[16].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[16].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[16].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[16].rho \"Density of fluid\";
//   Real EVA.HT[16].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[16].m_flow;
//   parameter Integer EVA.HT[17].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[17].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[17].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[17].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[17].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[17].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[17].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[17].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[17].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[17].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[17].geoPipe.d_out + -2.0 * EVA.HT[17].geoPipe.s;
//   input Real EVA.HT[17].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[17].p;
//   input Real EVA.HT[17].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[17].h;
//   input Real EVA.HT[17].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[17];
//   input Real EVA.HT[17].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[17];
//   input Real EVA.HT[17].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[17];
//   input Real EVA.HT[17].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[17];
//   input Real EVA.HT[17].steamQuality = 1.5;
//   input Real EVA.HT[17].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[17];
//   input Real EVA.HT[17].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[17] - EVA.fluid[17].T;
//   Real EVA.HT[17].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[17].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[17].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[17].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[17].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[17].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[17].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[17].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[17].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[17].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[17].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[17].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[17].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[17].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[17].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[17].rho \"Density of fluid\";
//   Real EVA.HT[17].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[17].m_flow;
//   parameter Integer EVA.HT[18].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[18].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[18].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[18].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[18].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[18].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[18].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[18].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[18].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[18].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[18].geoPipe.d_out + -2.0 * EVA.HT[18].geoPipe.s;
//   input Real EVA.HT[18].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[18].p;
//   input Real EVA.HT[18].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[18].h;
//   input Real EVA.HT[18].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[18];
//   input Real EVA.HT[18].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[18];
//   input Real EVA.HT[18].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[18];
//   input Real EVA.HT[18].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[18];
//   input Real EVA.HT[18].steamQuality = 1.5;
//   input Real EVA.HT[18].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[18];
//   input Real EVA.HT[18].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[18] - EVA.fluid[18].T;
//   Real EVA.HT[18].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[18].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[18].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[18].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[18].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[18].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[18].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[18].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[18].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[18].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[18].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[18].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[18].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[18].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[18].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[18].rho \"Density of fluid\";
//   Real EVA.HT[18].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[18].m_flow;
//   parameter Integer EVA.HT[19].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[19].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[19].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[19].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[19].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[19].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[19].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[19].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[19].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[19].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[19].geoPipe.d_out + -2.0 * EVA.HT[19].geoPipe.s;
//   input Real EVA.HT[19].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[19].p;
//   input Real EVA.HT[19].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[19].h;
//   input Real EVA.HT[19].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[19];
//   input Real EVA.HT[19].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[19];
//   input Real EVA.HT[19].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[19];
//   input Real EVA.HT[19].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[19];
//   input Real EVA.HT[19].steamQuality = 1.5;
//   input Real EVA.HT[19].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[19];
//   input Real EVA.HT[19].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[19] - EVA.fluid[19].T;
//   Real EVA.HT[19].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[19].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[19].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[19].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[19].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[19].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[19].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[19].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[19].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[19].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[19].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[19].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[19].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[19].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[19].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[19].rho \"Density of fluid\";
//   Real EVA.HT[19].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[19].m_flow;
//   parameter Integer EVA.HT[20].geoPipe.Nt = EVA.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real EVA.HT[20].geoPipe.L(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.L \"Length of tube\";
//   parameter Real EVA.HT[20].geoPipe.H(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real EVA.HT[20].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real EVA.HT[20].geoPipe.s(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.s \"Thickness of the wall\";
//   parameter Real EVA.HT[20].geoPipe.r(quantity = \"Length\", unit = \"m\") = EVA.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real EVA.HT[20].geoPipe.zeta_add = EVA.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean EVA.HT[20].geoPipe.isCylindric = EVA.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real EVA.HT[20].geoPipe.A(quantity = \"Area\", unit = \"m2\") = EVA.geoPipe.A \"inner cross sectional area\";
//   final parameter Real EVA.HT[20].diameterInner(quantity = \"Length\", unit = \"m\") = EVA.HT[20].geoPipe.d_out + -2.0 * EVA.HT[20].geoPipe.s;
//   input Real EVA.HT[20].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = EVA.fluid[20].p;
//   input Real EVA.HT[20].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = EVA.fluid[20].h;
//   input Real EVA.HT[20].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.d[20];
//   input Real EVA.HT[20].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.eta[20];
//   input Real EVA.HT[20].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.cp[20];
//   input Real EVA.HT[20].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.lambda[20];
//   input Real EVA.HT[20].steamQuality = 1.5;
//   input Real EVA.HT[20].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.m_flows[20];
//   input Real EVA.HT[20].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = EVA.TWall[20] - EVA.fluid[20].T;
//   Real EVA.HT[20].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real EVA.HT[20].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = EVA.HT[20].diameterInner \"Hydraulic diameter\";
//   Real EVA.HT[20].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = EVA.HT[20].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) EVA.HT[20].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real EVA.HT[20].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) EVA.HT[20].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real EVA.HT[20].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = EVA.HT[20].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real EVA.HT[20].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = EVA.HT[20].eta \"Dynamic viscosity of fluid\";
//   Real EVA.HT[20].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = EVA.HT[20].lambda \"Thermal conductivity of fluid\";
//   Real EVA.HT[20].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = EVA.HT[20].rho \"Density of fluid\";
//   Real EVA.HT[20].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = EVA.HT[20].m_flow;
//   protected Real ECO.TWall[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[1], nominal = 300.0);
//   protected Real ECO.TWall[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[2], nominal = 300.0);
//   protected Real ECO.TWall[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[3], nominal = 300.0);
//   protected Real ECO.TWall[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[4], nominal = 300.0);
//   protected Real ECO.TWall[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[5], nominal = 300.0);
//   protected Real ECO.TWall[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[6], nominal = 300.0);
//   protected Real ECO.TWall[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[7], nominal = 300.0);
//   protected Real ECO.TWall[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[8], nominal = 300.0);
//   protected Real ECO.TWall[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[9], nominal = 300.0);
//   protected Real ECO.TWall[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TWall_start[10], nominal = 300.0);
//   parameter Real ECO.m_flow_start(quantity = \"MassFlowRate\", unit = \"kg/s\") = 50.0 \"Guess value for mass flow rate\";
//   parameter Real ECO.pIn_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 3100000.0 \"Start value of inlet pressure\";
//   parameter Real ECO.pOut_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 3000000.0 \"Start value of outlet pressure\";
//   parameter Boolean ECO.useTemperatureStartValue = false \"Use T_start if true, otherwise h_start\";
//   parameter Real ECO.hIn_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = 1000000.0 \"Start value of specific enthalpy\";
//   parameter Real ECO.hOut_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = 1000000.0 \"Start value of specific outlet enthalpy\";
//   parameter Real ECO.TIn_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if ECO.useTemperatureStartValue then 298.15 else SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pIn_start, ECO.hIn_start, {ECO.XIn_start[1]}, 0) \"Start value of temperature\";
//   parameter Real ECO.TOut_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if ECO.useTemperatureStartValue then 298.15 else SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pOut_start, ECO.hOut_start, {ECO.XOut_start[1]}, 0) \"Start value of  outlet temperature\";
//   parameter Real ECO.XIn_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   constant Real ECO.g = 9.80665;
//   parameter Integer ECO.numberOfNodes(min = 1) = 10 \"Number of nodes for thermal variables\";
//   parameter Integer ECO.geoPipe.Nt = 100 \"Number of parallel tubes\";
//   parameter Real ECO.geoPipe.L(quantity = \"Length\", unit = \"m\") = 10.0 \"Length of tube\";
//   parameter Real ECO.geoPipe.H(quantity = \"Length\", unit = \"m\") = 0.0 \"Height difference between outlet and inlet\";
//   parameter Real ECO.geoPipe.d_out(quantity = \"Length\", unit = \"m\") = 0.038 \"Outer diameter of the tube\";
//   parameter Real ECO.geoPipe.s(quantity = \"Length\", unit = \"m\") = 0.003 \"Thickness of the wall\";
//   parameter Real ECO.geoPipe.r(quantity = \"Length\", unit = \"m\") = 0.00003 \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.geoPipe.zeta_add = 0.0 \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.geoPipe.isCylindric = true \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.geoPipe.A(quantity = \"Area\", unit = \"m2\") = (if ECO.geoPipe.isCylindric then 0.7853981633974483 else 1.0) * (ECO.geoPipe.d_out + -2.0 * ECO.geoPipe.s) ^ 2.0 \"inner cross sectional area\";
//   parameter Boolean ECO.initializeInletPressure = true \"add steady state equation for pressure\";
//   parameter Boolean ECO.initializeSteadyStateEnthalpies = true \"lets initialize der(h)=0\";
//   parameter Boolean ECO.initializeSteadyStateInletEnthalpy = true \"steady state initial condition for input enthalpy\";
//   final parameter Real ECO.diameterInner(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out + -2.0 * ECO.geoPipe.s;
//   final parameter Real ECO.V(quantity = \"Volume\", unit = \"m3\") = ECO.geoPipe.A * ECO.geoPipe.L;
//   final parameter Real ECO.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A;
//   final parameter Real ECO.sinphi = ECO.geoPipe.H / ECO.geoPipe.L;
//   protected final parameter Real ECO.hydM = 0.4 \"Part of portIn for p\";
//   parameter Real ECO.alpha_start(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 10000.0 \"Heat transfer coefficient (not too small for valid wall temperature)\";
//   parameter Integer ECO.numberOfWallLayers(min = 1) = 3 \"Number of wall layers\";
//   parameter Real ECO.metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = 540.0 \"Specific heat capacity\";
//   parameter Real ECO.metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = 44.0 \"Thermal conductivity\";
//   parameter Real ECO.metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = 7850.0 \"Mass density\";
//   parameter Real ECO.metal.Rm = 600.0 \"Tension strength [MPa]\";
//   parameter Real ECO.metal.Rp02 = 440.0 \"Elastic limit [MPa]\";
//   parameter Real ECO.diameterBranch(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out + -2.0 * ECO.geoPipe.s \"Average aperture of branch\";
//   parameter Real ECO.wallThicknessBranch(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Wall thickness of branch\";
//   protected Real ECO.m_flowsZero(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = ECO.pIn_start - ECO.pOut_start, nominal = 100000.0);
//   Real ECO.hIn(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = ECO.hIn_start, nominal = 1000000.0) \"actual state at portIn\";
//   Real ECO.hOut(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = ECO.hOut_start, nominal = 1000000.0) \"actual state at portOut\";
//   Integer ECO.state_from_a.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.state_from_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.state_from_a.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.state_from_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TIn_start, nominal = 300.0) \"temperature\";
//   Real ECO.state_from_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = ECO.pIn_start, nominal = 100000.0) \"pressure\";
//   Integer ECO.state_from_b.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.state_from_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.state_from_b.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.state_from_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.TOut_start, nominal = 300.0) \"temperature\";
//   Real ECO.state_from_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = ECO.pOut_start, nominal = 100000.0) \"pressure\";
//   parameter Real ECO.XOut_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = ECO.XIn_start[1] \"Start value of mass fractions m_i/m\";
//   Real ECO.portIn.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start) \"Mass flow rate from the connection point into the component\";
//   Real ECO.portIn.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = ECO.pIn_start, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real ECO.portIn.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = ECO.hIn_start, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real ECO.vol_av(quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   final parameter Real ECO.dz(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L / Real(ECO.numberOfNodes);
//   Real ECO.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[2](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[3](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[4](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[5](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[6](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[7](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[8](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[9](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   Real ECO.m_flows[10](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = ECO.m_flow_start / Real(ECO.geoPipe.Nt));
//   protected final parameter Real ECO.equalCellDistribution[1] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[1];
//   protected final parameter Real ECO.equalCellDistribution[2] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[2];
//   protected final parameter Real ECO.equalCellDistribution[3] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[3];
//   protected final parameter Real ECO.equalCellDistribution[4] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[4];
//   protected final parameter Real ECO.equalCellDistribution[5] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[5];
//   protected final parameter Real ECO.equalCellDistribution[6] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[6];
//   protected final parameter Real ECO.equalCellDistribution[7] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[7];
//   protected final parameter Real ECO.equalCellDistribution[8] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[8];
//   protected final parameter Real ECO.equalCellDistribution[9] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[9];
//   protected final parameter Real ECO.equalCellDistribution[10] = if ECO.numberOfNodes == 1 then 1.0 else linspace(1.0 / Real(ECO.numberOfNodes), 1.0, ECO.numberOfNodes)[10];
//   protected final parameter Real ECO.pressureDistribution_start[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[1];
//   protected final parameter Real ECO.pressureDistribution_start[2](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[2];
//   protected final parameter Real ECO.pressureDistribution_start[3](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[3];
//   protected final parameter Real ECO.pressureDistribution_start[4](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[4];
//   protected final parameter Real ECO.pressureDistribution_start[5](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[5];
//   protected final parameter Real ECO.pressureDistribution_start[6](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[6];
//   protected final parameter Real ECO.pressureDistribution_start[7](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[7];
//   protected final parameter Real ECO.pressureDistribution_start[8](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[8];
//   protected final parameter Real ECO.pressureDistribution_start[9](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[9];
//   protected final parameter Real ECO.pressureDistribution_start[10](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = if ECO.numberOfNodes == 1 then ECO.pOut_start else linspace(ECO.pIn_start, ECO.pOut_start, ECO.numberOfNodes)[10];
//   protected Real ECO.vol[1](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[2](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[3](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[4](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[5](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[6](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[7](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[8](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[9](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.vol[10](quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.00003, max = 1000000.0, start = 1.0 / SiemensPower.Components.Pipes.Tube.Medium.density_phX(0.5 * (ECO.pIn_start + ECO.pOut_start), 0.5 * (ECO.hIn_start + ECO.hOut_start), {ECO.XIn_start[1]}, 0));
//   protected Real ECO.cp[1](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[2](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[3](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[4](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[5](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[6](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[7](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[8](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[9](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.cp[10](quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0);
//   protected Real ECO.eta[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[3](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[4](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[5](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[6](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[7](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[8](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[9](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.eta[10](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   protected Real ECO.lambda[1](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[2](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[3](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[4](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[5](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[6](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[7](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[8](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[9](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   protected Real ECO.lambda[10](quantity = \"ThermalConductivity\", unit = \"W/(m.K)\", min = 0.0, max = 500.0, start = 1.0, nominal = 1.0);
//   parameter Integer ECO.heatport.numberOfNodes = ECO.numberOfNodes \"Number of nodes\";
//   Real ECO.heatport.port[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.port[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.heatport.port[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatport.Q_flow[1](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[2](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[3](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[4](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[5](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[6](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[7](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[8](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[9](quantity = \"Power\", unit = \"W\");
//   Real ECO.heatport.Q_flow[10](quantity = \"Power\", unit = \"W\");
//   Real ECO.alpha[1](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[2](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[3](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[4](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[5](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[6](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[7](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[8](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[9](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.alpha[10](quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   parameter Real ECO.heatedArea(quantity = \"Area\", unit = \"m2\") = 3.141592653589793 * Real(ECO.geoPipe.Nt) * ECO.geoPipe.L * ECO.diameterInner \"Total Area for heat transfer\";
//   final parameter Real ECO.VTotal(quantity = \"Volume\", unit = \"m3\") = Real(ECO.geoPipe.Nt) * ECO.V;
//   final parameter Real ECO.VCell(quantity = \"Volume\", unit = \"m3\") = ECO.V / Real(ECO.numberOfNodes);
//   protected final parameter Real ECO.hydP = 1.0 - ECO.hydM \"Part of portIn for m_flow\";
//   Real ECO.portOut.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0, start = -ECO.m_flow_start) \"Mass flow rate from the connection point into the component\";
//   Real ECO.portOut.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = ECO.pOut_start, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real ECO.portOut.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, start = ECO.hOut_start, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected final parameter Real ECO.q_start(quantity = \"HeatFlux\", unit = \"W/m2\") = ECO.m_flow_start * (ECO.hOut_start - ECO.hIn_start) / ECO.heatedArea;
//   Real ECO.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = ECO.hydP * ECO.pIn_start + (1.0 - ECO.hydP) * ECO.pOut_start, nominal = 100000.0) \"pressure\";
//   protected Real ECO.qHeating[1](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[2](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[3](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[4](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[5](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[6](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[7](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[8](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[9](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qHeating[10](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start) = 0.0;
//   protected Real ECO.qMetalFluid[1](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[2](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[3](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[4](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[5](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[6](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[7](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[8](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[9](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   protected Real ECO.qMetalFluid[10](quantity = \"HeatFlux\", unit = \"W/m2\", start = ECO.q_start);
//   parameter Real ECO.h_start[1](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[1] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[2](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[2] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[3](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[3] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[4](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[4] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[5](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[5] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[6](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[6] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[7](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[7] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[8](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[8] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[9](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[9] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.h_start[10](quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = ECO.hIn_start + ECO.equalCellDistribution[10] * (ECO.hOut_start - ECO.hIn_start) \"guess values for initial enthalpy vector\";
//   parameter Real ECO.Q_flow_start[1](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[2](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[3](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[4](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[5](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[6](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[7](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[8](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[9](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   parameter Real ECO.Q_flow_start[10](quantity = \"Power\", unit = \"W\") = (ECO.hOut_start - ECO.hIn_start) * ECO.m_flow_start / Real(ECO.geoPipe.Nt * ECO.numberOfNodes) \"Detailed start values for heat flow\";
//   input Real ECO.fluid[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[1], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[1], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[1].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[1].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[1].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[1].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[1].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[1].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[1].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[1].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[1].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[1].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[1].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[1].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[1].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[1].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[1].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[1].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[1].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[1].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[2], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[2], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[2].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[2].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[2].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[2].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[2].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[2].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[2].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[2].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[2].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[2].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[2].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[2].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[2].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[2].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[2].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[2].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[2].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[2].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[3].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[3], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[3].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[3], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[3].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[3].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[3].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[3].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[3].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[3].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[3].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[3].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[3].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[3].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[3].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[3].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[3].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[3].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[3].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[3].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[3].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[3].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[3].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[4].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[4], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[4].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[4], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[4].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[4].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[4].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[4].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[4].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[4].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[4].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[4].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[4].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[4].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[4].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[4].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[4].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[4].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[4].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[4].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[4].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[4].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[4].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[5].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[5], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[5].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[5], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[5].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[5].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[5].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[5].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[5].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[5].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[5].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[5].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[5].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[5].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[5].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[5].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[5].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[5].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[5].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[5].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[5].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[5].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[5].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[6].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[6], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[6].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[6], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[6].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[6].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[6].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[6].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[6].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[6].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[6].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[6].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[6].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[6].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[6].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[6].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[6].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[6].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[6].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[6].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[6].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[6].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[6].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[7].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[7], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[7].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[7], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[7].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[7].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[7].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[7].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[7].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[7].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[7].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[7].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[7].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[7].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[7].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[7].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[7].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[7].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[7].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[7].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[7].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[7].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[7].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[8].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[8], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[8].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[8], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[8].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[8].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[8].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[8].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[8].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[8].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[8].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[8].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[8].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[8].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[8].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[8].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[8].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[8].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[8].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[8].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[8].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[8].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[8].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[9].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[9], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[9].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[9], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[9].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[9].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[9].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[9].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[9].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[9].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[9].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[9].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[9].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[9].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[9].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[9].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[9].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[9].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[9].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[9].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[9].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[9].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[9].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real ECO.fluid[10].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 2000.0, max = 1000000000.0, start = ECO.pressureDistribution_start[10], nominal = 100000.0, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real ECO.fluid[10].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = ECO.h_start[10], nominal = 1000000.0, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real ECO.fluid[10].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real ECO.fluid[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real ECO.fluid[10].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real ECO.fluid[10].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real ECO.fluid[10].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real ECO.fluid[10].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer ECO.fluid[10].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use\";
//   Real ECO.fluid[10].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real ECO.fluid[10].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real ECO.fluid[10].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real ECO.fluid[10].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean ECO.fluid[10].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean ECO.fluid[10].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real ECO.fluid[10].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(ECO.fluid[10].T) \"Temperature of medium in [degC]\";
//   Real ECO.fluid[10].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(ECO.fluid[10].p) \"Absolute pressure of medium in [bar]\";
//   Real ECO.fluid[10].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real ECO.fluid[10].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer ECO.fluid[10].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   Real ECO.d_av(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = (ECO.d_start[1] + ECO.d_start[2] + ECO.d_start[3] + ECO.d_start[4] + ECO.d_start[5] + ECO.d_start[6] + ECO.d_start[7] + ECO.d_start[8] + ECO.d_start[9] + ECO.d_start[10]) / Real(ECO.numberOfNodes), nominal = 1.0);
//   Real ECO.dpfric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = ECO.dpFric_start, nominal = 100000.0);
//   Real ECO.dphyd(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = ECO.dpHyd_start, nominal = 100000.0);
//   protected final parameter Real ECO.dpHyd_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 9.80665 * ECO.geoPipe.H * (ECO.d_start[1] + ECO.d_start[2] + ECO.d_start[3] + ECO.d_start[4] + ECO.d_start[5] + ECO.d_start[6] + ECO.d_start[7] + ECO.d_start[8] + ECO.d_start[9] + ECO.d_start[10]) / Real(ECO.numberOfNodes);
//   protected final parameter Real ECO.dpFric_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = max(0.0, ECO.pIn_start + (-ECO.pOut_start) - ECO.dpHyd_start);
//   protected final parameter Real ECO.T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[1], ECO.h_start[1], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[2], ECO.h_start[2], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[3], ECO.h_start[3], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[4], ECO.h_start[4], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[5], ECO.h_start[5], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[6], ECO.h_start[6], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[7], ECO.h_start[7], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[8], ECO.h_start[8], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[9], ECO.h_start[9], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = SiemensPower.Components.Pipes.Tube.Medium.temperature_phX(ECO.pressureDistribution_start[10], ECO.h_start[10], {ECO.XIn_start[1]}, 0) \"start values for fluid temperatures\";
//   protected final parameter Real ECO.d_start[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[1], ECO.h_start[1], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[2], ECO.h_start[2], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[3](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[3], ECO.h_start[3], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[4](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[4], ECO.h_start[4], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[5](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[5], ECO.h_start[5], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[6](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[6], ECO.h_start[6], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[7](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[7], ECO.h_start[7], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[8](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[8], ECO.h_start[8], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[9](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[9], ECO.h_start[9], {ECO.XIn_start[1]}, 0);
//   protected final parameter Real ECO.d_start[10](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = SiemensPower.Components.Pipes.Tube.Medium.density_phX(ECO.pressureDistribution_start[10], ECO.h_start[10], {ECO.XIn_start[1]}, 0);
//   protected Real ECO.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[1], nominal = 300.0);
//   protected Real ECO.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[2], nominal = 300.0);
//   protected Real ECO.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[3], nominal = 300.0);
//   protected Real ECO.T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[4], nominal = 300.0);
//   protected Real ECO.T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[5], nominal = 300.0);
//   protected Real ECO.T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[6], nominal = 300.0);
//   protected Real ECO.T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[7], nominal = 300.0);
//   protected Real ECO.T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[8], nominal = 300.0);
//   protected Real ECO.T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[9], nominal = 300.0);
//   protected Real ECO.T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = ECO.T_start[10], nominal = 300.0);
//   protected Real ECO.d[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[1], nominal = 1.0);
//   protected Real ECO.d[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[2], nominal = 1.0);
//   protected Real ECO.d[3](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[3], nominal = 1.0);
//   protected Real ECO.d[4](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[4], nominal = 1.0);
//   protected Real ECO.d[5](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[5], nominal = 1.0);
//   protected Real ECO.d[6](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[6], nominal = 1.0);
//   protected Real ECO.d[7](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[7], nominal = 1.0);
//   protected Real ECO.d[8](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[8], nominal = 1.0);
//   protected Real ECO.d[9](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[9], nominal = 1.0);
//   protected Real ECO.d[10](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = ECO.d_start[10], nominal = 1.0);
//   protected Real ECO.E_flows[1](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[1]);
//   protected Real ECO.E_flows[2](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[2]);
//   protected Real ECO.E_flows[3](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[3]);
//   protected Real ECO.E_flows[4](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[4]);
//   protected Real ECO.E_flows[5](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[5]);
//   protected Real ECO.E_flows[6](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[6]);
//   protected Real ECO.E_flows[7](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[7]);
//   protected Real ECO.E_flows[8](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[8]);
//   protected Real ECO.E_flows[9](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[9]);
//   protected Real ECO.E_flows[10](quantity = \"Power\", unit = \"W\", start = -ECO.Q_flow_start[10]);
//   parameter Integer ECO.friction.geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.friction.geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.friction.geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.friction.geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.friction.geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.friction.geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.friction.geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.friction.geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.friction.geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   parameter Real ECO.friction.dz(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"length of tube section for which friction pressure loss is wanted\";
//   parameter Real ECO.friction.lambda = 0.02 \"constant friction factor (used for valve friction model only)\";
//   input Real ECO.friction.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.p \"pressure\";
//   input Real ECO.friction.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[1].h \"specific enthalpy\";
//   input Real ECO.friction.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d_av \"mass density\";
//   input Real ECO.friction.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[1] \"dynamic viscosoty\";
//   input Real ECO.friction.steamQuality = 1.5 \"Steam quality\";
//   input Real ECO.friction.xdo = 0.9 \"Critical steam quality, at which the boiling crisis (e.g. dryout) occurs\";
//   input Real ECO.friction.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[1] \"mass flow rate\";
//   Real ECO.friction.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0);
//   final parameter Real ECO.friction.diameterInner(quantity = \"Length\", unit = \"m\") = ECO.friction.geoPipe.d_out + -2.0 * ECO.friction.geoPipe.s;
//   Real ECO.friction.DPMFLOW_ADD_IN_var.zeta_TOT(quantity = \"Pressure loss coefficient | zeta_tot = zeta_loc + zeta_fri\", unit = \"1\", min = 0.0, max = 1111.0) = max(0.000000000001, ECO.friction.geoPipe.zeta_add) \"Pressure loss coefficient\";
//   Real ECO.friction.DPMFLOW_ADD_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.friction.rho \"Density of fluid\";
//   Real ECO.friction.DPMFLOW_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.friction.eta \"Dynamic viscosity of fluid\";
//   Real ECO.friction.DPMFLOW_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.friction.rho \"Density of fluid\";
//   final parameter Real ECO.friction.A(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * ECO.friction.diameterInner ^ 2.0;
//   enumeration(Neglected, Considered) ECO.friction.DPMFLOW_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Neglected \"Choice of considering surface roughness\";
//   Real ECO.friction.DPMFLOW_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.friction.diameterInner \"Hydraulic diameter\";
//   Real ECO.friction.DPMFLOW_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.friction.dz \"Length\";
//   Real ECO.friction.DPMFLOW_IN_con.K(quantity = \"Length\", unit = \"m\") = ECO.friction.geoPipe.r \"Roughness (average height of surface asperities)\";
//   Real ECO.friction.DPMFLOW_ADD_IN_con.A_cross(quantity = \"Area\", unit = \"m2\") = ECO.friction.A \"Cross sectional area\";
//   Real ECO.friction.DPMFLOW_ADD_IN_con.dp_smooth(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = 1.0 \"Start linearisation for decreasing pressure loss\";
//   parameter Real ECO.TWall_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[1] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[2] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[3] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[4] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[5] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[6] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[7] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[8] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[9] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   parameter Real ECO.TWall_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = ECO.T_start[10] + ECO.q_start / ECO.alpha_start \"start values for wall temperatures\";
//   Real ECO.heatPort[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[1].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[1] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[2].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[2] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[3].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[3] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[4].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[4] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[5].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[5] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[6].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[6] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[7].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[7] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[8].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[8] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[9].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[9] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.heatPort[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.TWall_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.heatPort[10].Q_flow(quantity = \"Power\", unit = \"W\", start = ECO.Q_flow_start[10] * Real(ECO.geoPipe.Nt)) \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Integer ECO.wall.numberOfNodes(min = 1) = ECO.numberOfNodes \"Number of nodes\";
//   parameter Integer ECO.wall.numberOfWallLayers(min = 1) = ECO.numberOfWallLayers \"Number of wall layers\";
//   parameter Real ECO.wall.metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.metal.cp \"Specific heat capacity\";
//   parameter Real ECO.wall.metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.metal.lambda \"Thermal conductivity\";
//   parameter Real ECO.wall.metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.metal.rho \"Mass density\";
//   parameter Real ECO.wall.metal.Rm = ECO.metal.Rm \"Tension strength [MPa]\";
//   parameter Real ECO.wall.metal.Rp02 = ECO.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer ECO.wall.numberOfParallelTubes(min = 1) = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.wall.length(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Tube length\";
//   parameter Real ECO.wall.diameterInner(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out + -2.0 * ECO.geoPipe.s \"Internal diameter (single tube)\";
//   parameter Real ECO.wall.wallThickness(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Wall thickness\";
//   Real ECO.wall.port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real ECO.wall.T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[1] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[2] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[3] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[4] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[5] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[6] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[7] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[8] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[9] \"Temperature start values for inner layer\";
//   parameter Real ECO.wall.T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.TWall_start[10] \"Temperature start values for inner layer\";
//   constant Real ECO.wall.layer[1].pi = 3.141592653589793;
//   parameter Integer ECO.wall.layer[1].numberOfNodes(min = 1) = ECO.wall.numberOfNodes \"Number of nodes\";
//   parameter Boolean ECO.wall.layer[1].assumePlainHeatTransfer = false \"no logarithmic correction\";
//   parameter Real ECO.wall.layer[1].metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.wall.metal.cp \"Specific heat capacity\";
//   parameter Real ECO.wall.layer[1].metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.wall.metal.lambda \"Thermal conductivity\";
//   parameter Real ECO.wall.layer[1].metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.wall.metal.rho \"Mass density\";
//   parameter Real ECO.wall.layer[1].metal.Rm = ECO.wall.metal.Rm \"Tension strength [MPa]\";
//   parameter Real ECO.wall.layer[1].metal.Rp02 = ECO.wall.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer ECO.wall.layer[1].numberOfParallelTubes(min = 1) = ECO.wall.numberOfParallelTubes \"Number of parallel tubes\";
//   parameter Real ECO.wall.layer[1].length(quantity = \"Length\", unit = \"m\") = ECO.wall.length \"Tube length\";
//   parameter Real ECO.wall.layer[1].diameterInner(quantity = \"Length\", unit = \"m\") = if ECO.wall.numberOfWallLayers == 1 then ECO.wall.diameterInner else linspace(ECO.wall.diameterInner, ECO.wall.diameterInner + 2.0 * ECO.wall.wallThickness + -2.0 * ECO.wall.wallThickness / Real(ECO.wall.numberOfWallLayers), ECO.wall.numberOfWallLayers)[1] \"Internal diameter (single tube)\";
//   parameter Real ECO.wall.layer[1].wallThickness(quantity = \"Length\", unit = \"m\") = ECO.wall.wallThickness / Real(ECO.wall.numberOfWallLayers) \"Wall thickness\";
//   parameter Boolean ECO.wall.layer[1].useDynamicEquations = true \"switch off for steady-state simulations\";
//   parameter Boolean ECO.wall.layer[1].considerConductivity = true \"Wall conduction resistance accounted for\";
//   parameter Boolean ECO.wall.layer[1].considerAxialHeatTransfer = false \"With heat transfer in the wall parallel to the flow direction\";
//   parameter String ECO.wall.layer[1].initOpt = \"steadyState\" \"Initialisation option\";
//   Real ECO.wall.layer[1].Am(quantity = \"Area\", unit = \"m2\") \"Area of the metal tube cross-section\";
//   Real ECO.wall.layer[1].rint(quantity = \"Length\", unit = \"m\");
//   Real ECO.wall.layer[1].rext(quantity = \"Length\", unit = \"m\");
//   Real ECO.wall.layer[1].Tube_mass(quantity = \"Mass\", unit = \"kg\", min = 0.0);
//   Real ECO.wall.layer[1].HeatCap(quantity = \"HeatCapacity\", unit = \"J/K\") \"HeatCapacity of a Tube part\";
//   parameter Real ECO.wall.layer[1].T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[1] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[2] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[3] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[4] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[5] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[6] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[7] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[8] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[9] \"Temperature start values\";
//   parameter Real ECO.wall.layer[1].T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[10] \"Temperature start values\";
//   Real ECO.wall.layer[1].port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[1].port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[1].T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[1], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[2], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[3], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[4], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[5], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[6], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[7], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[8], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[9], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[1].T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[1].T_start[10], nominal = 300.0) \"Node temperatures\";
//   constant Real ECO.wall.layer[2].pi = 3.141592653589793;
//   parameter Integer ECO.wall.layer[2].numberOfNodes(min = 1) = ECO.wall.numberOfNodes \"Number of nodes\";
//   parameter Boolean ECO.wall.layer[2].assumePlainHeatTransfer = false \"no logarithmic correction\";
//   parameter Real ECO.wall.layer[2].metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.wall.metal.cp \"Specific heat capacity\";
//   parameter Real ECO.wall.layer[2].metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.wall.metal.lambda \"Thermal conductivity\";
//   parameter Real ECO.wall.layer[2].metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.wall.metal.rho \"Mass density\";
//   parameter Real ECO.wall.layer[2].metal.Rm = ECO.wall.metal.Rm \"Tension strength [MPa]\";
//   parameter Real ECO.wall.layer[2].metal.Rp02 = ECO.wall.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer ECO.wall.layer[2].numberOfParallelTubes(min = 1) = ECO.wall.numberOfParallelTubes \"Number of parallel tubes\";
//   parameter Real ECO.wall.layer[2].length(quantity = \"Length\", unit = \"m\") = ECO.wall.length \"Tube length\";
//   parameter Real ECO.wall.layer[2].diameterInner(quantity = \"Length\", unit = \"m\") = if ECO.wall.numberOfWallLayers == 1 then {ECO.wall.diameterInner}[2] else linspace(ECO.wall.diameterInner, ECO.wall.diameterInner + 2.0 * ECO.wall.wallThickness + -2.0 * ECO.wall.wallThickness / Real(ECO.wall.numberOfWallLayers), ECO.wall.numberOfWallLayers)[2] \"Internal diameter (single tube)\";
//   parameter Real ECO.wall.layer[2].wallThickness(quantity = \"Length\", unit = \"m\") = ECO.wall.wallThickness / Real(ECO.wall.numberOfWallLayers) \"Wall thickness\";
//   parameter Boolean ECO.wall.layer[2].useDynamicEquations = true \"switch off for steady-state simulations\";
//   parameter Boolean ECO.wall.layer[2].considerConductivity = true \"Wall conduction resistance accounted for\";
//   parameter Boolean ECO.wall.layer[2].considerAxialHeatTransfer = false \"With heat transfer in the wall parallel to the flow direction\";
//   parameter String ECO.wall.layer[2].initOpt = \"steadyState\" \"Initialisation option\";
//   Real ECO.wall.layer[2].Am(quantity = \"Area\", unit = \"m2\") \"Area of the metal tube cross-section\";
//   Real ECO.wall.layer[2].rint(quantity = \"Length\", unit = \"m\");
//   Real ECO.wall.layer[2].rext(quantity = \"Length\", unit = \"m\");
//   Real ECO.wall.layer[2].Tube_mass(quantity = \"Mass\", unit = \"kg\", min = 0.0);
//   Real ECO.wall.layer[2].HeatCap(quantity = \"HeatCapacity\", unit = \"J/K\") \"HeatCapacity of a Tube part\";
//   parameter Real ECO.wall.layer[2].T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[1] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[2] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[3] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[4] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[5] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[6] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[7] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[8] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[9] \"Temperature start values\";
//   parameter Real ECO.wall.layer[2].T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[10] \"Temperature start values\";
//   Real ECO.wall.layer[2].port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[2].port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[2].T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[1], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[2], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[3], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[4], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[5], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[6], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[7], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[8], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[9], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[2].T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[2].T_start[10], nominal = 300.0) \"Node temperatures\";
//   constant Real ECO.wall.layer[3].pi = 3.141592653589793;
//   parameter Integer ECO.wall.layer[3].numberOfNodes(min = 1) = ECO.wall.numberOfNodes \"Number of nodes\";
//   parameter Boolean ECO.wall.layer[3].assumePlainHeatTransfer = false \"no logarithmic correction\";
//   parameter Real ECO.wall.layer[3].metal.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.wall.metal.cp \"Specific heat capacity\";
//   parameter Real ECO.wall.layer[3].metal.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.wall.metal.lambda \"Thermal conductivity\";
//   parameter Real ECO.wall.layer[3].metal.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.wall.metal.rho \"Mass density\";
//   parameter Real ECO.wall.layer[3].metal.Rm = ECO.wall.metal.Rm \"Tension strength [MPa]\";
//   parameter Real ECO.wall.layer[3].metal.Rp02 = ECO.wall.metal.Rp02 \"Elastic limit [MPa]\";
//   parameter Integer ECO.wall.layer[3].numberOfParallelTubes(min = 1) = ECO.wall.numberOfParallelTubes \"Number of parallel tubes\";
//   parameter Real ECO.wall.layer[3].length(quantity = \"Length\", unit = \"m\") = ECO.wall.length \"Tube length\";
//   parameter Real ECO.wall.layer[3].diameterInner(quantity = \"Length\", unit = \"m\") = if ECO.wall.numberOfWallLayers == 1 then {ECO.wall.diameterInner}[3] else linspace(ECO.wall.diameterInner, ECO.wall.diameterInner + 2.0 * ECO.wall.wallThickness + -2.0 * ECO.wall.wallThickness / Real(ECO.wall.numberOfWallLayers), ECO.wall.numberOfWallLayers)[3] \"Internal diameter (single tube)\";
//   parameter Real ECO.wall.layer[3].wallThickness(quantity = \"Length\", unit = \"m\") = ECO.wall.wallThickness / Real(ECO.wall.numberOfWallLayers) \"Wall thickness\";
//   parameter Boolean ECO.wall.layer[3].useDynamicEquations = true \"switch off for steady-state simulations\";
//   parameter Boolean ECO.wall.layer[3].considerConductivity = true \"Wall conduction resistance accounted for\";
//   parameter Boolean ECO.wall.layer[3].considerAxialHeatTransfer = false \"With heat transfer in the wall parallel to the flow direction\";
//   parameter String ECO.wall.layer[3].initOpt = \"steadyState\" \"Initialisation option\";
//   Real ECO.wall.layer[3].Am(quantity = \"Area\", unit = \"m2\") \"Area of the metal tube cross-section\";
//   Real ECO.wall.layer[3].rint(quantity = \"Length\", unit = \"m\");
//   Real ECO.wall.layer[3].rext(quantity = \"Length\", unit = \"m\");
//   Real ECO.wall.layer[3].Tube_mass(quantity = \"Mass\", unit = \"kg\", min = 0.0);
//   Real ECO.wall.layer[3].HeatCap(quantity = \"HeatCapacity\", unit = \"J/K\") \"HeatCapacity of a Tube part\";
//   parameter Real ECO.wall.layer[3].T_start[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[1] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[2] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[3] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[4] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[5] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[6] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[7] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[8] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[9] \"Temperature start values\";
//   parameter Real ECO.wall.layer[3].T_start[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) = ECO.wall.T_start[10] \"Temperature start values\";
//   Real ECO.wall.layer[3].port_ext[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_ext[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_ext[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[1], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[2], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[3], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[4], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[5], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[6], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[7], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[8], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[9], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].port_int[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[10], nominal = 300.0) \"Port temperature\";
//   Real ECO.wall.layer[3].port_int[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real ECO.wall.layer[3].T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[1], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[2], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[3], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[4](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[4], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[5](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[5], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[6](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[6], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[7](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[7], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[8](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[8], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[9](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[9], nominal = 300.0) \"Node temperatures\";
//   Real ECO.wall.layer[3].T[10](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = ECO.wall.layer[3].T_start[10], nominal = 300.0) \"Node temperatures\";
//   parameter Integer ECO.HT[1].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[1].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[1].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[1].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[1].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[1].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[1].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[1].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[1].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[1].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[1].geoPipe.d_out + -2.0 * ECO.HT[1].geoPipe.s;
//   input Real ECO.HT[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[1].p;
//   input Real ECO.HT[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[1].h;
//   input Real ECO.HT[1].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[1];
//   input Real ECO.HT[1].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[1];
//   input Real ECO.HT[1].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[1];
//   input Real ECO.HT[1].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[1];
//   input Real ECO.HT[1].steamQuality = 1.5;
//   input Real ECO.HT[1].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[1];
//   input Real ECO.HT[1].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[1] - ECO.fluid[1].T;
//   Real ECO.HT[1].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[1].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[1].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[1].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[1].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[1].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[1].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[1].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[1].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[1].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[1].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[1].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[1].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[1].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[1].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[1].rho \"Density of fluid\";
//   Real ECO.HT[1].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[1].m_flow;
//   parameter Integer ECO.HT[2].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[2].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[2].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[2].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[2].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[2].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[2].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[2].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[2].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[2].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[2].geoPipe.d_out + -2.0 * ECO.HT[2].geoPipe.s;
//   input Real ECO.HT[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[2].p;
//   input Real ECO.HT[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[2].h;
//   input Real ECO.HT[2].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[2];
//   input Real ECO.HT[2].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[2];
//   input Real ECO.HT[2].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[2];
//   input Real ECO.HT[2].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[2];
//   input Real ECO.HT[2].steamQuality = 1.5;
//   input Real ECO.HT[2].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[2];
//   input Real ECO.HT[2].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[2] - ECO.fluid[2].T;
//   Real ECO.HT[2].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[2].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[2].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[2].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[2].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[2].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[2].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[2].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[2].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[2].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[2].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[2].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[2].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[2].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[2].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[2].rho \"Density of fluid\";
//   Real ECO.HT[2].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[2].m_flow;
//   parameter Integer ECO.HT[3].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[3].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[3].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[3].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[3].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[3].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[3].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[3].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[3].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[3].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[3].geoPipe.d_out + -2.0 * ECO.HT[3].geoPipe.s;
//   input Real ECO.HT[3].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[3].p;
//   input Real ECO.HT[3].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[3].h;
//   input Real ECO.HT[3].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[3];
//   input Real ECO.HT[3].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[3];
//   input Real ECO.HT[3].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[3];
//   input Real ECO.HT[3].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[3];
//   input Real ECO.HT[3].steamQuality = 1.5;
//   input Real ECO.HT[3].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[3];
//   input Real ECO.HT[3].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[3] - ECO.fluid[3].T;
//   Real ECO.HT[3].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[3].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[3].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[3].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[3].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[3].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[3].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[3].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[3].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[3].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[3].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[3].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[3].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[3].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[3].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[3].rho \"Density of fluid\";
//   Real ECO.HT[3].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[3].m_flow;
//   parameter Integer ECO.HT[4].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[4].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[4].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[4].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[4].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[4].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[4].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[4].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[4].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[4].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[4].geoPipe.d_out + -2.0 * ECO.HT[4].geoPipe.s;
//   input Real ECO.HT[4].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[4].p;
//   input Real ECO.HT[4].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[4].h;
//   input Real ECO.HT[4].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[4];
//   input Real ECO.HT[4].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[4];
//   input Real ECO.HT[4].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[4];
//   input Real ECO.HT[4].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[4];
//   input Real ECO.HT[4].steamQuality = 1.5;
//   input Real ECO.HT[4].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[4];
//   input Real ECO.HT[4].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[4] - ECO.fluid[4].T;
//   Real ECO.HT[4].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[4].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[4].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[4].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[4].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[4].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[4].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[4].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[4].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[4].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[4].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[4].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[4].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[4].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[4].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[4].rho \"Density of fluid\";
//   Real ECO.HT[4].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[4].m_flow;
//   parameter Integer ECO.HT[5].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[5].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[5].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[5].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[5].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[5].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[5].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[5].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[5].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[5].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[5].geoPipe.d_out + -2.0 * ECO.HT[5].geoPipe.s;
//   input Real ECO.HT[5].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[5].p;
//   input Real ECO.HT[5].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[5].h;
//   input Real ECO.HT[5].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[5];
//   input Real ECO.HT[5].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[5];
//   input Real ECO.HT[5].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[5];
//   input Real ECO.HT[5].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[5];
//   input Real ECO.HT[5].steamQuality = 1.5;
//   input Real ECO.HT[5].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[5];
//   input Real ECO.HT[5].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[5] - ECO.fluid[5].T;
//   Real ECO.HT[5].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[5].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[5].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[5].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[5].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[5].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[5].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[5].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[5].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[5].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[5].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[5].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[5].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[5].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[5].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[5].rho \"Density of fluid\";
//   Real ECO.HT[5].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[5].m_flow;
//   parameter Integer ECO.HT[6].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[6].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[6].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[6].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[6].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[6].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[6].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[6].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[6].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[6].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[6].geoPipe.d_out + -2.0 * ECO.HT[6].geoPipe.s;
//   input Real ECO.HT[6].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[6].p;
//   input Real ECO.HT[6].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[6].h;
//   input Real ECO.HT[6].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[6];
//   input Real ECO.HT[6].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[6];
//   input Real ECO.HT[6].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[6];
//   input Real ECO.HT[6].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[6];
//   input Real ECO.HT[6].steamQuality = 1.5;
//   input Real ECO.HT[6].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[6];
//   input Real ECO.HT[6].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[6] - ECO.fluid[6].T;
//   Real ECO.HT[6].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[6].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[6].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[6].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[6].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[6].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[6].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[6].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[6].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[6].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[6].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[6].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[6].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[6].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[6].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[6].rho \"Density of fluid\";
//   Real ECO.HT[6].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[6].m_flow;
//   parameter Integer ECO.HT[7].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[7].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[7].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[7].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[7].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[7].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[7].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[7].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[7].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[7].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[7].geoPipe.d_out + -2.0 * ECO.HT[7].geoPipe.s;
//   input Real ECO.HT[7].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[7].p;
//   input Real ECO.HT[7].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[7].h;
//   input Real ECO.HT[7].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[7];
//   input Real ECO.HT[7].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[7];
//   input Real ECO.HT[7].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[7];
//   input Real ECO.HT[7].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[7];
//   input Real ECO.HT[7].steamQuality = 1.5;
//   input Real ECO.HT[7].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[7];
//   input Real ECO.HT[7].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[7] - ECO.fluid[7].T;
//   Real ECO.HT[7].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[7].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[7].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[7].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[7].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[7].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[7].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[7].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[7].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[7].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[7].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[7].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[7].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[7].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[7].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[7].rho \"Density of fluid\";
//   Real ECO.HT[7].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[7].m_flow;
//   parameter Integer ECO.HT[8].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[8].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[8].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[8].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[8].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[8].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[8].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[8].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[8].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[8].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[8].geoPipe.d_out + -2.0 * ECO.HT[8].geoPipe.s;
//   input Real ECO.HT[8].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[8].p;
//   input Real ECO.HT[8].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[8].h;
//   input Real ECO.HT[8].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[8];
//   input Real ECO.HT[8].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[8];
//   input Real ECO.HT[8].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[8];
//   input Real ECO.HT[8].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[8];
//   input Real ECO.HT[8].steamQuality = 1.5;
//   input Real ECO.HT[8].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[8];
//   input Real ECO.HT[8].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[8] - ECO.fluid[8].T;
//   Real ECO.HT[8].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[8].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[8].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[8].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[8].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[8].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[8].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[8].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[8].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[8].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[8].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[8].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[8].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[8].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[8].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[8].rho \"Density of fluid\";
//   Real ECO.HT[8].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[8].m_flow;
//   parameter Integer ECO.HT[9].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[9].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[9].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[9].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[9].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[9].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[9].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[9].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[9].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[9].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[9].geoPipe.d_out + -2.0 * ECO.HT[9].geoPipe.s;
//   input Real ECO.HT[9].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[9].p;
//   input Real ECO.HT[9].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[9].h;
//   input Real ECO.HT[9].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[9];
//   input Real ECO.HT[9].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[9];
//   input Real ECO.HT[9].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[9];
//   input Real ECO.HT[9].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[9];
//   input Real ECO.HT[9].steamQuality = 1.5;
//   input Real ECO.HT[9].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[9];
//   input Real ECO.HT[9].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[9] - ECO.fluid[9].T;
//   Real ECO.HT[9].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[9].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[9].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[9].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[9].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[9].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[9].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[9].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[9].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[9].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[9].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[9].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[9].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[9].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[9].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[9].rho \"Density of fluid\";
//   Real ECO.HT[9].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[9].m_flow;
//   parameter Integer ECO.HT[10].geoPipe.Nt = ECO.geoPipe.Nt \"Number of parallel tubes\";
//   parameter Real ECO.HT[10].geoPipe.L(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.L \"Length of tube\";
//   parameter Real ECO.HT[10].geoPipe.H(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.H \"Height difference between outlet and inlet\";
//   parameter Real ECO.HT[10].geoPipe.d_out(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.d_out \"Outer diameter of the tube\";
//   parameter Real ECO.HT[10].geoPipe.s(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.s \"Thickness of the wall\";
//   parameter Real ECO.HT[10].geoPipe.r(quantity = \"Length\", unit = \"m\") = ECO.geoPipe.r \"Inner roughness (friction coefficient) of the wall\";
//   parameter Real ECO.HT[10].geoPipe.zeta_add = ECO.geoPipe.zeta_add \"Additive friction loss coefficient (for bendings)\";
//   parameter Boolean ECO.HT[10].geoPipe.isCylindric = ECO.geoPipe.isCylindric \"assume circular (NOT quadratic) inner cross sectional area\";
//   final parameter Real ECO.HT[10].geoPipe.A(quantity = \"Area\", unit = \"m2\") = ECO.geoPipe.A \"inner cross sectional area\";
//   final parameter Real ECO.HT[10].diameterInner(quantity = \"Length\", unit = \"m\") = ECO.HT[10].geoPipe.d_out + -2.0 * ECO.HT[10].geoPipe.s;
//   input Real ECO.HT[10].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = -1000000000.0, max = 1000000000.0, start = 100000.0, nominal = 100000.0) = ECO.fluid[10].p;
//   input Real ECO.HT[10].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", nominal = 1000000.0) = ECO.fluid[10].h;
//   input Real ECO.HT[10].rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.d[10];
//   input Real ECO.HT[10].eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.eta[10];
//   input Real ECO.HT[10].cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.cp[10];
//   input Real ECO.HT[10].lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.lambda[10];
//   input Real ECO.HT[10].steamQuality = 1.5;
//   input Real ECO.HT[10].m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.m_flows[10];
//   input Real ECO.HT[10].dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"K\", min = -2000.0, max = 2000.0, start = 1.0, nominal = 1.0) = ECO.TWall[10] - ECO.fluid[10].T;
//   Real ECO.HT[10].alpha(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\");
//   Real ECO.HT[10].KC_IN_con.d_hyd(quantity = \"Length\", unit = \"m\", min = 0.0) = ECO.HT[10].diameterInner \"Hydraulic diameter\";
//   Real ECO.HT[10].KC_IN_con.L(quantity = \"Length\", unit = \"m\") = ECO.HT[10].geoPipe.L \"Length\";
//   enumeration(Neglected, Considered) ECO.HT[10].KC_IN_con.roughness = Modelica.Fluid.Dissipation.Utilities.Types.Roughness.Considered \"Choice of considering surface roughness\";
//   Real ECO.HT[10].KC_IN_con.K(quantity = \"Length\", unit = \"m\") = 0.0 \"Roughness (average height of surface asperities)\";
//   enumeration(UWTuDFF, UHFuDFF, UWTuUFF, UHFuUFF) ECO.HT[10].KC_IN_con.target = Modelica.Fluid.Dissipation.Utilities.Types.HeatTransferBoundary.UHFuUFF \"Choice of heat transfer boundary condition\";
//   Real ECO.HT[10].KC_IN_var.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ECO.HT[10].cp \"Specific heat capacity of fluid at constant pressure\";
//   Real ECO.HT[10].KC_IN_var.eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = ECO.HT[10].eta \"Dynamic viscosity of fluid\";
//   Real ECO.HT[10].KC_IN_var.lambda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ECO.HT[10].lambda \"Thermal conductivity of fluid\";
//   Real ECO.HT[10].KC_IN_var.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.000001, max = 30000.0) = ECO.HT[10].rho \"Density of fluid\";
//   Real ECO.HT[10].KC_IN_var.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = ECO.HT[10].m_flow;
//   output Real timeTable1.y \"Connector of Real output signal\";
//   parameter Real timeTable1.table[1,1] = 0.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[1,2] = 3000000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[2,1] = 1100.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[2,2] = 3000000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[3,1] = 1400.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[3,2] = 3100000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[4,1] = 2000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.table[4,2] = 3100000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable1.timeDelay(quantity = \"Time\", unit = \"s\") = 0.01 \"Delay time\";
//   output Real timeTable1.yOriginal \"original time table function\";
//   output Real timeTable1.originalTable.y \"Connector of Real output signal\";
//   parameter Real timeTable1.originalTable.table[1,1] = timeTable1.table[1,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[1,2] = timeTable1.table[1,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[2,1] = timeTable1.table[2,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[2,2] = timeTable1.table[2,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[3,1] = timeTable1.table[3,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[3,2] = timeTable1.table[3,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[4,1] = timeTable1.table[4,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.table[4,2] = timeTable1.table[4,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable1.originalTable.offset = 0.0 \"Offset of output signal\";
//   parameter Real timeTable1.originalTable.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Output = offset for time < startTime\";
//   protected Real timeTable1.originalTable.a \"Interpolation coefficients a of actual interval (y=a*x+b)\";
//   protected Real timeTable1.originalTable.b \"Interpolation coefficients b of actual interval (y=a*x+b)\";
//   protected Integer timeTable1.originalTable.last(start = 1) \"Last used lower grid index\";
//   protected Real timeTable1.originalTable.nextEvent(quantity = \"Time\", unit = \"s\", start = 0.0, fixed = true) \"Next event instant\";
//   input Real timeTable1.C1signal.u;
//   output Real timeTable1.C1signal.y;
//   parameter Real timeTable1.C1signal.timeDelay(quantity = \"Time\", unit = \"s\") = timeTable1.timeDelay;
//   output Real realExpression.y = 25000000.0 \"Value of Real output\";
//   parameter Integer prescribedHeatFlow1.numberOfCells = 10 \"Number of cells\";
//   input Real prescribedHeatFlow1.Q_flow \"Overall heat input\";
//   Real prescribedHeatFlow1.portsOut[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow1.portsOut[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow1.portsOut[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Integer prescribedHeatFlow.numberOfCells = 20 \"Number of cells\";
//   input Real prescribedHeatFlow.Q_flow \"Overall heat input\";
//   Real prescribedHeatFlow.portsOut[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[4].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[4].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[5].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[5].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[6].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[6].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[7].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[7].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[8].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[8].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[9].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[9].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[10].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[10].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[11].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[11].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[12].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[12].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[13].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[13].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[14].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[14].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[15].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[15].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[16].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[16].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[17].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[17].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[18].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[18].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[19].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[19].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real prescribedHeatFlow.portsOut[20].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 6000.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real prescribedHeatFlow.portsOut[20].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   output Real timeTable.y \"Connector of Real output signal\";
//   parameter Real timeTable.table[1,1] = 0.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[1,2] = 0.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[2,1] = 101.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[2,2] = 0.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[3,1] = 1000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[3,2] = 100000000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[4,1] = 2000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.table[4,2] = 100000000.0 \"Table matrix (time = first column)\";
//   parameter Real timeTable.timeDelay(quantity = \"Time\", unit = \"s\") = 0.01 \"Delay time\";
//   output Real timeTable.yOriginal \"original time table function\";
//   output Real timeTable.originalTable.y \"Connector of Real output signal\";
//   parameter Real timeTable.originalTable.table[1,1] = timeTable.table[1,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[1,2] = timeTable.table[1,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[2,1] = timeTable.table[2,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[2,2] = timeTable.table[2,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[3,1] = timeTable.table[3,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[3,2] = timeTable.table[3,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[4,1] = timeTable.table[4,1] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.table[4,2] = timeTable.table[4,2] \"Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])\";
//   parameter Real timeTable.originalTable.offset = 0.0 \"Offset of output signal\";
//   parameter Real timeTable.originalTable.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Output = offset for time < startTime\";
//   protected Real timeTable.originalTable.a \"Interpolation coefficients a of actual interval (y=a*x+b)\";
//   protected Real timeTable.originalTable.b \"Interpolation coefficients b of actual interval (y=a*x+b)\";
//   protected Integer timeTable.originalTable.last(start = 1) \"Last used lower grid index\";
//   protected Real timeTable.originalTable.nextEvent(quantity = \"Time\", unit = \"s\", start = 0.0, fixed = true) \"Next event instant\";
//   input Real timeTable.C1signal.u;
//   output Real timeTable.C1signal.y;
//   parameter Real timeTable.C1signal.timeDelay(quantity = \"Time\", unit = \"s\") = timeTable.timeDelay;
// initial equation
//   der(EVA.wall.layer[1].T[1]) = 0.0;
//   der(EVA.wall.layer[1].T[2]) = 0.0;
//   der(EVA.wall.layer[1].T[3]) = 0.0;
//   der(EVA.wall.layer[1].T[4]) = 0.0;
//   der(EVA.wall.layer[1].T[5]) = 0.0;
//   der(EVA.wall.layer[1].T[6]) = 0.0;
//   der(EVA.wall.layer[1].T[7]) = 0.0;
//   der(EVA.wall.layer[1].T[8]) = 0.0;
//   der(EVA.wall.layer[1].T[9]) = 0.0;
//   der(EVA.wall.layer[1].T[10]) = 0.0;
//   der(EVA.wall.layer[1].T[11]) = 0.0;
//   der(EVA.wall.layer[1].T[12]) = 0.0;
//   der(EVA.wall.layer[1].T[13]) = 0.0;
//   der(EVA.wall.layer[1].T[14]) = 0.0;
//   der(EVA.wall.layer[1].T[15]) = 0.0;
//   der(EVA.wall.layer[1].T[16]) = 0.0;
//   der(EVA.wall.layer[1].T[17]) = 0.0;
//   der(EVA.wall.layer[1].T[18]) = 0.0;
//   der(EVA.wall.layer[1].T[19]) = 0.0;
//   der(EVA.wall.layer[1].T[20]) = 0.0;
//   der(EVA.wall.layer[2].T[1]) = 0.0;
//   der(EVA.wall.layer[2].T[2]) = 0.0;
//   der(EVA.wall.layer[2].T[3]) = 0.0;
//   der(EVA.wall.layer[2].T[4]) = 0.0;
//   der(EVA.wall.layer[2].T[5]) = 0.0;
//   der(EVA.wall.layer[2].T[6]) = 0.0;
//   der(EVA.wall.layer[2].T[7]) = 0.0;
//   der(EVA.wall.layer[2].T[8]) = 0.0;
//   der(EVA.wall.layer[2].T[9]) = 0.0;
//   der(EVA.wall.layer[2].T[10]) = 0.0;
//   der(EVA.wall.layer[2].T[11]) = 0.0;
//   der(EVA.wall.layer[2].T[12]) = 0.0;
//   der(EVA.wall.layer[2].T[13]) = 0.0;
//   der(EVA.wall.layer[2].T[14]) = 0.0;
//   der(EVA.wall.layer[2].T[15]) = 0.0;
//   der(EVA.wall.layer[2].T[16]) = 0.0;
//   der(EVA.wall.layer[2].T[17]) = 0.0;
//   der(EVA.wall.layer[2].T[18]) = 0.0;
//   der(EVA.wall.layer[2].T[19]) = 0.0;
//   der(EVA.wall.layer[2].T[20]) = 0.0;
//   der(EVA.wall.layer[3].T[1]) = 0.0;
//   der(EVA.wall.layer[3].T[2]) = 0.0;
//   der(EVA.wall.layer[3].T[3]) = 0.0;
//   der(EVA.wall.layer[3].T[4]) = 0.0;
//   der(EVA.wall.layer[3].T[5]) = 0.0;
//   der(EVA.wall.layer[3].T[6]) = 0.0;
//   der(EVA.wall.layer[3].T[7]) = 0.0;
//   der(EVA.wall.layer[3].T[8]) = 0.0;
//   der(EVA.wall.layer[3].T[9]) = 0.0;
//   der(EVA.wall.layer[3].T[10]) = 0.0;
//   der(EVA.wall.layer[3].T[11]) = 0.0;
//   der(EVA.wall.layer[3].T[12]) = 0.0;
//   der(EVA.wall.layer[3].T[13]) = 0.0;
//   der(EVA.wall.layer[3].T[14]) = 0.0;
//   der(EVA.wall.layer[3].T[15]) = 0.0;
//   der(EVA.wall.layer[3].T[16]) = 0.0;
//   der(EVA.wall.layer[3].T[17]) = 0.0;
//   der(EVA.wall.layer[3].T[18]) = 0.0;
//   der(EVA.wall.layer[3].T[19]) = 0.0;
//   der(EVA.wall.layer[3].T[20]) = 0.0;
//   der(EVA.m_flows[1]) = 0.0;
//   der(EVA.p) = 0.0;
//   der(EVA.fluid[1].h) = 0.0;
//   der(EVA.fluid[2].h) = 0.0;
//   der(EVA.fluid[3].h) = 0.0;
//   der(EVA.fluid[4].h) = 0.0;
//   der(EVA.fluid[5].h) = 0.0;
//   der(EVA.fluid[6].h) = 0.0;
//   der(EVA.fluid[7].h) = 0.0;
//   der(EVA.fluid[8].h) = 0.0;
//   der(EVA.fluid[9].h) = 0.0;
//   der(EVA.fluid[10].h) = 0.0;
//   der(EVA.fluid[11].h) = 0.0;
//   der(EVA.fluid[12].h) = 0.0;
//   der(EVA.fluid[13].h) = 0.0;
//   der(EVA.fluid[14].h) = 0.0;
//   der(EVA.fluid[15].h) = 0.0;
//   der(EVA.fluid[16].h) = 0.0;
//   der(EVA.fluid[17].h) = 0.0;
//   der(EVA.fluid[18].h) = 0.0;
//   der(EVA.fluid[19].h) = 0.0;
//   der(EVA.fluid[20].h) = 0.0;
//   der(ECO.wall.layer[1].T[1]) = 0.0;
//   der(ECO.wall.layer[1].T[2]) = 0.0;
//   der(ECO.wall.layer[1].T[3]) = 0.0;
//   der(ECO.wall.layer[1].T[4]) = 0.0;
//   der(ECO.wall.layer[1].T[5]) = 0.0;
//   der(ECO.wall.layer[1].T[6]) = 0.0;
//   der(ECO.wall.layer[1].T[7]) = 0.0;
//   der(ECO.wall.layer[1].T[8]) = 0.0;
//   der(ECO.wall.layer[1].T[9]) = 0.0;
//   der(ECO.wall.layer[1].T[10]) = 0.0;
//   der(ECO.wall.layer[2].T[1]) = 0.0;
//   der(ECO.wall.layer[2].T[2]) = 0.0;
//   der(ECO.wall.layer[2].T[3]) = 0.0;
//   der(ECO.wall.layer[2].T[4]) = 0.0;
//   der(ECO.wall.layer[2].T[5]) = 0.0;
//   der(ECO.wall.layer[2].T[6]) = 0.0;
//   der(ECO.wall.layer[2].T[7]) = 0.0;
//   der(ECO.wall.layer[2].T[8]) = 0.0;
//   der(ECO.wall.layer[2].T[9]) = 0.0;
//   der(ECO.wall.layer[2].T[10]) = 0.0;
//   der(ECO.wall.layer[3].T[1]) = 0.0;
//   der(ECO.wall.layer[3].T[2]) = 0.0;
//   der(ECO.wall.layer[3].T[3]) = 0.0;
//   der(ECO.wall.layer[3].T[4]) = 0.0;
//   der(ECO.wall.layer[3].T[5]) = 0.0;
//   der(ECO.wall.layer[3].T[6]) = 0.0;
//   der(ECO.wall.layer[3].T[7]) = 0.0;
//   der(ECO.wall.layer[3].T[8]) = 0.0;
//   der(ECO.wall.layer[3].T[9]) = 0.0;
//   der(ECO.wall.layer[3].T[10]) = 0.0;
//   der(ECO.m_flows[1]) = 0.0;
//   der(ECO.p) = 0.0;
//   der(ECO.fluid[1].h) = 0.0;
//   der(ECO.fluid[2].h) = 0.0;
//   der(ECO.fluid[3].h) = 0.0;
//   der(ECO.fluid[4].h) = 0.0;
//   der(ECO.fluid[5].h) = 0.0;
//   der(ECO.fluid[6].h) = 0.0;
//   der(ECO.fluid[7].h) = 0.0;
//   der(ECO.fluid[8].h) = 0.0;
//   der(ECO.fluid[9].h) = 0.0;
//   der(ECO.fluid[10].h) = 0.0;
//   timeTable1.C1signal.u = timeTable1.C1signal.y;
//   timeTable.C1signal.u = timeTable.C1signal.y;
// equation
//   watersource_mh.medium.MM = 0.018015268;
//   watersource_mh.medium.phase = if watersource_mh.medium.h < Modelica.Fluid.Sources.MassFlowSource_h.Medium.bubbleEnthalpy(watersource_mh.medium.sat) or watersource_mh.medium.h > Modelica.Fluid.Sources.MassFlowSource_h.Medium.dewEnthalpy(watersource_mh.medium.sat) or watersource_mh.medium.p > 22064000.0 then 1 else 2;
//   watersource_mh.medium.d = Modelica.Fluid.Sources.MassFlowSource_h.Medium.density_ph(watersource_mh.medium.p, watersource_mh.medium.h, watersource_mh.medium.phase);
//   watersource_mh.medium.T = Modelica.Fluid.Sources.MassFlowSource_h.Medium.temperature_ph(watersource_mh.medium.p, watersource_mh.medium.h, watersource_mh.medium.phase);
//   watersource_mh.medium.sat.Tsat = Modelica.Fluid.Sources.MassFlowSource_h.Medium.saturationTemperature(watersource_mh.medium.p);
//   watersource_mh.medium.sat.psat = watersource_mh.medium.p;
//   watersource_mh.medium.u = watersource_mh.medium.h + (-watersource_mh.medium.p) / watersource_mh.medium.d;
//   watersource_mh.medium.R = 461.5236365065454;
//   watersource_mh.medium.h = watersource_mh.medium.state.h;
//   watersource_mh.medium.p = watersource_mh.medium.state.p;
//   watersource_mh.medium.T = watersource_mh.medium.state.T;
//   watersource_mh.medium.d = watersource_mh.medium.state.d;
//   watersource_mh.medium.phase = watersource_mh.medium.state.phase;
//   watersource_mh.medium.X[1] = 1.0;
//   assert(watersource_mh.medium.X[1] >= -0.00001 and watersource_mh.medium.X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(watersource_mh.medium.X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(watersource_mh.medium.p >= 0.0,\"Pressure (= \" + String(watersource_mh.medium.p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(watersource_mh.medium.T, 0, true, 6) + \" K)\");
//   .Modelica.Fluid.Utilities.checkBoundary(\"WaterIF97\",{\"water\"},false,true,{watersource_mh.X_in_internal[1]},\"MassFlowSource_h\");
//   watersource_mh.m_flow_in_internal = watersource_mh.m_flow;
//   watersource_mh.h_in_internal = watersource_mh.h;
//   watersource_mh.X_in_internal[1] = watersource_mh.X[1];
//   watersource_mh.ports[1].m_flow = -watersource_mh.m_flow_in_internal;
//   watersource_mh.medium.h = watersource_mh.h_in_internal;
//   assert(cardinality({}[1]) <= 1,\"
// each ports[i] of boundary shall at most be connected to one component.
// If two or more connections are present, ideal mixing takes
// place with these connections, which is usually not the intention
// of the modeller. Increase nPorts to add an additional port.
// \");
//   watersource_mh.ports[1].p = watersource_mh.medium.p;
//   watersource_mh.ports[1].h_outflow = watersource_mh.medium.h;
//   watersink_ph.water.MM = 0.018015268;
//   watersink_ph.water.phase = if watersink_ph.water.h < SiemensPower.Boundaries.WaterSink.Medium.bubbleEnthalpy(watersink_ph.water.sat) or watersink_ph.water.h > SiemensPower.Boundaries.WaterSink.Medium.dewEnthalpy(watersink_ph.water.sat) or watersink_ph.water.p > 22064000.0 then 1 else 2;
//   watersink_ph.water.d = SiemensPower.Boundaries.WaterSink.Medium.density_ph(watersink_ph.water.p, watersink_ph.water.h, watersink_ph.water.phase);
//   watersink_ph.water.T = SiemensPower.Boundaries.WaterSink.Medium.temperature_ph(watersink_ph.water.p, watersink_ph.water.h, watersink_ph.water.phase);
//   watersink_ph.water.sat.Tsat = SiemensPower.Boundaries.WaterSink.Medium.saturationTemperature(watersink_ph.water.p);
//   watersink_ph.water.sat.psat = watersink_ph.water.p;
//   watersink_ph.water.u = watersink_ph.water.h + (-watersink_ph.water.p) / watersink_ph.water.d;
//   watersink_ph.water.R = 461.5236365065454;
//   watersink_ph.water.h = watersink_ph.water.state.h;
//   watersink_ph.water.p = watersink_ph.water.state.p;
//   watersink_ph.water.T = watersink_ph.water.state.T;
//   watersink_ph.water.d = watersink_ph.water.state.d;
//   watersink_ph.water.phase = watersink_ph.water.state.phase;
//   watersink_ph.water.X[1] = 1.0;
//   assert(watersink_ph.water.X[1] >= -0.00001 and watersink_ph.water.X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(watersink_ph.water.X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(watersink_ph.water.p >= 0.0,\"Pressure (= \" + String(watersink_ph.water.p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(watersink_ph.water.T, 0, true, 6) + \" K)\");
//   watersink_ph.h_set = watersink_ph.h_start;
//   watersink_ph.water.p = watersink_ph.p_set;
//   watersink_ph.water.h = watersink_ph.h_set;
//   watersink_ph.port.p = watersink_ph.water.p;
//   watersink_ph.port.h_outflow = watersink_ph.water.h;
//   watersink_ph.hPortActual = if watersink_ph.port.m_flow > 0.0 then EVA.portOut.h_outflow else watersink_ph.port.h_outflow;
//   EVA.heatport.TWall[1] = EVA.heatport.port[1].T;
//   EVA.heatport.TWall[2] = EVA.heatport.port[2].T;
//   EVA.heatport.TWall[3] = EVA.heatport.port[3].T;
//   EVA.heatport.TWall[4] = EVA.heatport.port[4].T;
//   EVA.heatport.TWall[5] = EVA.heatport.port[5].T;
//   EVA.heatport.TWall[6] = EVA.heatport.port[6].T;
//   EVA.heatport.TWall[7] = EVA.heatport.port[7].T;
//   EVA.heatport.TWall[8] = EVA.heatport.port[8].T;
//   EVA.heatport.TWall[9] = EVA.heatport.port[9].T;
//   EVA.heatport.TWall[10] = EVA.heatport.port[10].T;
//   EVA.heatport.TWall[11] = EVA.heatport.port[11].T;
//   EVA.heatport.TWall[12] = EVA.heatport.port[12].T;
//   EVA.heatport.TWall[13] = EVA.heatport.port[13].T;
//   EVA.heatport.TWall[14] = EVA.heatport.port[14].T;
//   EVA.heatport.TWall[15] = EVA.heatport.port[15].T;
//   EVA.heatport.TWall[16] = EVA.heatport.port[16].T;
//   EVA.heatport.TWall[17] = EVA.heatport.port[17].T;
//   EVA.heatport.TWall[18] = EVA.heatport.port[18].T;
//   EVA.heatport.TWall[19] = EVA.heatport.port[19].T;
//   EVA.heatport.TWall[20] = EVA.heatport.port[20].T;
//   EVA.heatport.Q_flow[1] = EVA.heatport.port[1].Q_flow;
//   EVA.heatport.Q_flow[2] = EVA.heatport.port[2].Q_flow;
//   EVA.heatport.Q_flow[3] = EVA.heatport.port[3].Q_flow;
//   EVA.heatport.Q_flow[4] = EVA.heatport.port[4].Q_flow;
//   EVA.heatport.Q_flow[5] = EVA.heatport.port[5].Q_flow;
//   EVA.heatport.Q_flow[6] = EVA.heatport.port[6].Q_flow;
//   EVA.heatport.Q_flow[7] = EVA.heatport.port[7].Q_flow;
//   EVA.heatport.Q_flow[8] = EVA.heatport.port[8].Q_flow;
//   EVA.heatport.Q_flow[9] = EVA.heatport.port[9].Q_flow;
//   EVA.heatport.Q_flow[10] = EVA.heatport.port[10].Q_flow;
//   EVA.heatport.Q_flow[11] = EVA.heatport.port[11].Q_flow;
//   EVA.heatport.Q_flow[12] = EVA.heatport.port[12].Q_flow;
//   EVA.heatport.Q_flow[13] = EVA.heatport.port[13].Q_flow;
//   EVA.heatport.Q_flow[14] = EVA.heatport.port[14].Q_flow;
//   EVA.heatport.Q_flow[15] = EVA.heatport.port[15].Q_flow;
//   EVA.heatport.Q_flow[16] = EVA.heatport.port[16].Q_flow;
//   EVA.heatport.Q_flow[17] = EVA.heatport.port[17].Q_flow;
//   EVA.heatport.Q_flow[18] = EVA.heatport.port[18].Q_flow;
//   EVA.heatport.Q_flow[19] = EVA.heatport.port[19].Q_flow;
//   EVA.heatport.Q_flow[20] = EVA.heatport.port[20].Q_flow;
//   EVA.fluid[1].MM = 0.018015268;
//   EVA.fluid[1].phase = if EVA.fluid[1].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[1].sat) or EVA.fluid[1].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[1].sat) or EVA.fluid[1].p > 22064000.0 then 1 else 2;
//   EVA.fluid[1].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[1].p, EVA.fluid[1].h, EVA.fluid[1].phase);
//   EVA.fluid[1].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[1].p, EVA.fluid[1].h, EVA.fluid[1].phase);
//   EVA.fluid[1].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[1].p);
//   EVA.fluid[1].sat.psat = EVA.fluid[1].p;
//   EVA.fluid[1].u = EVA.fluid[1].h + (-EVA.fluid[1].p) / EVA.fluid[1].d;
//   EVA.fluid[1].R = 461.5236365065454;
//   EVA.fluid[1].h = EVA.fluid[1].state.h;
//   EVA.fluid[1].p = EVA.fluid[1].state.p;
//   EVA.fluid[1].T = EVA.fluid[1].state.T;
//   EVA.fluid[1].d = EVA.fluid[1].state.d;
//   EVA.fluid[1].phase = EVA.fluid[1].state.phase;
//   EVA.fluid[1].X[1] = 1.0;
//   assert(EVA.fluid[1].X[1] >= -0.00001 and EVA.fluid[1].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[1].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[1].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[1].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[1].T, 0, true, 6) + \" K)\");
//   EVA.fluid[2].MM = 0.018015268;
//   EVA.fluid[2].phase = if EVA.fluid[2].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[2].sat) or EVA.fluid[2].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[2].sat) or EVA.fluid[2].p > 22064000.0 then 1 else 2;
//   EVA.fluid[2].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[2].p, EVA.fluid[2].h, EVA.fluid[2].phase);
//   EVA.fluid[2].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[2].p, EVA.fluid[2].h, EVA.fluid[2].phase);
//   EVA.fluid[2].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[2].p);
//   EVA.fluid[2].sat.psat = EVA.fluid[2].p;
//   EVA.fluid[2].u = EVA.fluid[2].h + (-EVA.fluid[2].p) / EVA.fluid[2].d;
//   EVA.fluid[2].R = 461.5236365065454;
//   EVA.fluid[2].h = EVA.fluid[2].state.h;
//   EVA.fluid[2].p = EVA.fluid[2].state.p;
//   EVA.fluid[2].T = EVA.fluid[2].state.T;
//   EVA.fluid[2].d = EVA.fluid[2].state.d;
//   EVA.fluid[2].phase = EVA.fluid[2].state.phase;
//   EVA.fluid[2].X[1] = 1.0;
//   assert(EVA.fluid[2].X[1] >= -0.00001 and EVA.fluid[2].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[2].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[2].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[2].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[2].T, 0, true, 6) + \" K)\");
//   EVA.fluid[3].MM = 0.018015268;
//   EVA.fluid[3].phase = if EVA.fluid[3].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[3].sat) or EVA.fluid[3].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[3].sat) or EVA.fluid[3].p > 22064000.0 then 1 else 2;
//   EVA.fluid[3].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[3].p, EVA.fluid[3].h, EVA.fluid[3].phase);
//   EVA.fluid[3].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[3].p, EVA.fluid[3].h, EVA.fluid[3].phase);
//   EVA.fluid[3].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[3].p);
//   EVA.fluid[3].sat.psat = EVA.fluid[3].p;
//   EVA.fluid[3].u = EVA.fluid[3].h + (-EVA.fluid[3].p) / EVA.fluid[3].d;
//   EVA.fluid[3].R = 461.5236365065454;
//   EVA.fluid[3].h = EVA.fluid[3].state.h;
//   EVA.fluid[3].p = EVA.fluid[3].state.p;
//   EVA.fluid[3].T = EVA.fluid[3].state.T;
//   EVA.fluid[3].d = EVA.fluid[3].state.d;
//   EVA.fluid[3].phase = EVA.fluid[3].state.phase;
//   EVA.fluid[3].X[1] = 1.0;
//   assert(EVA.fluid[3].X[1] >= -0.00001 and EVA.fluid[3].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[3].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[3].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[3].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[3].T, 0, true, 6) + \" K)\");
//   EVA.fluid[4].MM = 0.018015268;
//   EVA.fluid[4].phase = if EVA.fluid[4].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[4].sat) or EVA.fluid[4].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[4].sat) or EVA.fluid[4].p > 22064000.0 then 1 else 2;
//   EVA.fluid[4].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[4].p, EVA.fluid[4].h, EVA.fluid[4].phase);
//   EVA.fluid[4].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[4].p, EVA.fluid[4].h, EVA.fluid[4].phase);
//   EVA.fluid[4].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[4].p);
//   EVA.fluid[4].sat.psat = EVA.fluid[4].p;
//   EVA.fluid[4].u = EVA.fluid[4].h + (-EVA.fluid[4].p) / EVA.fluid[4].d;
//   EVA.fluid[4].R = 461.5236365065454;
//   EVA.fluid[4].h = EVA.fluid[4].state.h;
//   EVA.fluid[4].p = EVA.fluid[4].state.p;
//   EVA.fluid[4].T = EVA.fluid[4].state.T;
//   EVA.fluid[4].d = EVA.fluid[4].state.d;
//   EVA.fluid[4].phase = EVA.fluid[4].state.phase;
//   EVA.fluid[4].X[1] = 1.0;
//   assert(EVA.fluid[4].X[1] >= -0.00001 and EVA.fluid[4].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[4].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[4].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[4].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[4].T, 0, true, 6) + \" K)\");
//   EVA.fluid[5].MM = 0.018015268;
//   EVA.fluid[5].phase = if EVA.fluid[5].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[5].sat) or EVA.fluid[5].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[5].sat) or EVA.fluid[5].p > 22064000.0 then 1 else 2;
//   EVA.fluid[5].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[5].p, EVA.fluid[5].h, EVA.fluid[5].phase);
//   EVA.fluid[5].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[5].p, EVA.fluid[5].h, EVA.fluid[5].phase);
//   EVA.fluid[5].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[5].p);
//   EVA.fluid[5].sat.psat = EVA.fluid[5].p;
//   EVA.fluid[5].u = EVA.fluid[5].h + (-EVA.fluid[5].p) / EVA.fluid[5].d;
//   EVA.fluid[5].R = 461.5236365065454;
//   EVA.fluid[5].h = EVA.fluid[5].state.h;
//   EVA.fluid[5].p = EVA.fluid[5].state.p;
//   EVA.fluid[5].T = EVA.fluid[5].state.T;
//   EVA.fluid[5].d = EVA.fluid[5].state.d;
//   EVA.fluid[5].phase = EVA.fluid[5].state.phase;
//   EVA.fluid[5].X[1] = 1.0;
//   assert(EVA.fluid[5].X[1] >= -0.00001 and EVA.fluid[5].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[5].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[5].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[5].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[5].T, 0, true, 6) + \" K)\");
//   EVA.fluid[6].MM = 0.018015268;
//   EVA.fluid[6].phase = if EVA.fluid[6].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[6].sat) or EVA.fluid[6].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[6].sat) or EVA.fluid[6].p > 22064000.0 then 1 else 2;
//   EVA.fluid[6].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[6].p, EVA.fluid[6].h, EVA.fluid[6].phase);
//   EVA.fluid[6].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[6].p, EVA.fluid[6].h, EVA.fluid[6].phase);
//   EVA.fluid[6].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[6].p);
//   EVA.fluid[6].sat.psat = EVA.fluid[6].p;
//   EVA.fluid[6].u = EVA.fluid[6].h + (-EVA.fluid[6].p) / EVA.fluid[6].d;
//   EVA.fluid[6].R = 461.5236365065454;
//   EVA.fluid[6].h = EVA.fluid[6].state.h;
//   EVA.fluid[6].p = EVA.fluid[6].state.p;
//   EVA.fluid[6].T = EVA.fluid[6].state.T;
//   EVA.fluid[6].d = EVA.fluid[6].state.d;
//   EVA.fluid[6].phase = EVA.fluid[6].state.phase;
//   EVA.fluid[6].X[1] = 1.0;
//   assert(EVA.fluid[6].X[1] >= -0.00001 and EVA.fluid[6].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[6].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[6].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[6].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[6].T, 0, true, 6) + \" K)\");
//   EVA.fluid[7].MM = 0.018015268;
//   EVA.fluid[7].phase = if EVA.fluid[7].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[7].sat) or EVA.fluid[7].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[7].sat) or EVA.fluid[7].p > 22064000.0 then 1 else 2;
//   EVA.fluid[7].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[7].p, EVA.fluid[7].h, EVA.fluid[7].phase);
//   EVA.fluid[7].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[7].p, EVA.fluid[7].h, EVA.fluid[7].phase);
//   EVA.fluid[7].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[7].p);
//   EVA.fluid[7].sat.psat = EVA.fluid[7].p;
//   EVA.fluid[7].u = EVA.fluid[7].h + (-EVA.fluid[7].p) / EVA.fluid[7].d;
//   EVA.fluid[7].R = 461.5236365065454;
//   EVA.fluid[7].h = EVA.fluid[7].state.h;
//   EVA.fluid[7].p = EVA.fluid[7].state.p;
//   EVA.fluid[7].T = EVA.fluid[7].state.T;
//   EVA.fluid[7].d = EVA.fluid[7].state.d;
//   EVA.fluid[7].phase = EVA.fluid[7].state.phase;
//   EVA.fluid[7].X[1] = 1.0;
//   assert(EVA.fluid[7].X[1] >= -0.00001 and EVA.fluid[7].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[7].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[7].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[7].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[7].T, 0, true, 6) + \" K)\");
//   EVA.fluid[8].MM = 0.018015268;
//   EVA.fluid[8].phase = if EVA.fluid[8].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[8].sat) or EVA.fluid[8].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[8].sat) or EVA.fluid[8].p > 22064000.0 then 1 else 2;
//   EVA.fluid[8].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[8].p, EVA.fluid[8].h, EVA.fluid[8].phase);
//   EVA.fluid[8].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[8].p, EVA.fluid[8].h, EVA.fluid[8].phase);
//   EVA.fluid[8].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[8].p);
//   EVA.fluid[8].sat.psat = EVA.fluid[8].p;
//   EVA.fluid[8].u = EVA.fluid[8].h + (-EVA.fluid[8].p) / EVA.fluid[8].d;
//   EVA.fluid[8].R = 461.5236365065454;
//   EVA.fluid[8].h = EVA.fluid[8].state.h;
//   EVA.fluid[8].p = EVA.fluid[8].state.p;
//   EVA.fluid[8].T = EVA.fluid[8].state.T;
//   EVA.fluid[8].d = EVA.fluid[8].state.d;
//   EVA.fluid[8].phase = EVA.fluid[8].state.phase;
//   EVA.fluid[8].X[1] = 1.0;
//   assert(EVA.fluid[8].X[1] >= -0.00001 and EVA.fluid[8].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[8].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[8].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[8].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[8].T, 0, true, 6) + \" K)\");
//   EVA.fluid[9].MM = 0.018015268;
//   EVA.fluid[9].phase = if EVA.fluid[9].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[9].sat) or EVA.fluid[9].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[9].sat) or EVA.fluid[9].p > 22064000.0 then 1 else 2;
//   EVA.fluid[9].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[9].p, EVA.fluid[9].h, EVA.fluid[9].phase);
//   EVA.fluid[9].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[9].p, EVA.fluid[9].h, EVA.fluid[9].phase);
//   EVA.fluid[9].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[9].p);
//   EVA.fluid[9].sat.psat = EVA.fluid[9].p;
//   EVA.fluid[9].u = EVA.fluid[9].h + (-EVA.fluid[9].p) / EVA.fluid[9].d;
//   EVA.fluid[9].R = 461.5236365065454;
//   EVA.fluid[9].h = EVA.fluid[9].state.h;
//   EVA.fluid[9].p = EVA.fluid[9].state.p;
//   EVA.fluid[9].T = EVA.fluid[9].state.T;
//   EVA.fluid[9].d = EVA.fluid[9].state.d;
//   EVA.fluid[9].phase = EVA.fluid[9].state.phase;
//   EVA.fluid[9].X[1] = 1.0;
//   assert(EVA.fluid[9].X[1] >= -0.00001 and EVA.fluid[9].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[9].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[9].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[9].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[9].T, 0, true, 6) + \" K)\");
//   EVA.fluid[10].MM = 0.018015268;
//   EVA.fluid[10].phase = if EVA.fluid[10].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[10].sat) or EVA.fluid[10].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[10].sat) or EVA.fluid[10].p > 22064000.0 then 1 else 2;
//   EVA.fluid[10].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[10].p, EVA.fluid[10].h, EVA.fluid[10].phase);
//   EVA.fluid[10].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[10].p, EVA.fluid[10].h, EVA.fluid[10].phase);
//   EVA.fluid[10].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[10].p);
//   EVA.fluid[10].sat.psat = EVA.fluid[10].p;
//   EVA.fluid[10].u = EVA.fluid[10].h + (-EVA.fluid[10].p) / EVA.fluid[10].d;
//   EVA.fluid[10].R = 461.5236365065454;
//   EVA.fluid[10].h = EVA.fluid[10].state.h;
//   EVA.fluid[10].p = EVA.fluid[10].state.p;
//   EVA.fluid[10].T = EVA.fluid[10].state.T;
//   EVA.fluid[10].d = EVA.fluid[10].state.d;
//   EVA.fluid[10].phase = EVA.fluid[10].state.phase;
//   EVA.fluid[10].X[1] = 1.0;
//   assert(EVA.fluid[10].X[1] >= -0.00001 and EVA.fluid[10].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[10].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[10].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[10].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[10].T, 0, true, 6) + \" K)\");
//   EVA.fluid[11].MM = 0.018015268;
//   EVA.fluid[11].phase = if EVA.fluid[11].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[11].sat) or EVA.fluid[11].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[11].sat) or EVA.fluid[11].p > 22064000.0 then 1 else 2;
//   EVA.fluid[11].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[11].p, EVA.fluid[11].h, EVA.fluid[11].phase);
//   EVA.fluid[11].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[11].p, EVA.fluid[11].h, EVA.fluid[11].phase);
//   EVA.fluid[11].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[11].p);
//   EVA.fluid[11].sat.psat = EVA.fluid[11].p;
//   EVA.fluid[11].u = EVA.fluid[11].h + (-EVA.fluid[11].p) / EVA.fluid[11].d;
//   EVA.fluid[11].R = 461.5236365065454;
//   EVA.fluid[11].h = EVA.fluid[11].state.h;
//   EVA.fluid[11].p = EVA.fluid[11].state.p;
//   EVA.fluid[11].T = EVA.fluid[11].state.T;
//   EVA.fluid[11].d = EVA.fluid[11].state.d;
//   EVA.fluid[11].phase = EVA.fluid[11].state.phase;
//   EVA.fluid[11].X[1] = 1.0;
//   assert(EVA.fluid[11].X[1] >= -0.00001 and EVA.fluid[11].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[11].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[11].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[11].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[11].T, 0, true, 6) + \" K)\");
//   EVA.fluid[12].MM = 0.018015268;
//   EVA.fluid[12].phase = if EVA.fluid[12].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[12].sat) or EVA.fluid[12].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[12].sat) or EVA.fluid[12].p > 22064000.0 then 1 else 2;
//   EVA.fluid[12].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[12].p, EVA.fluid[12].h, EVA.fluid[12].phase);
//   EVA.fluid[12].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[12].p, EVA.fluid[12].h, EVA.fluid[12].phase);
//   EVA.fluid[12].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[12].p);
//   EVA.fluid[12].sat.psat = EVA.fluid[12].p;
//   EVA.fluid[12].u = EVA.fluid[12].h + (-EVA.fluid[12].p) / EVA.fluid[12].d;
//   EVA.fluid[12].R = 461.5236365065454;
//   EVA.fluid[12].h = EVA.fluid[12].state.h;
//   EVA.fluid[12].p = EVA.fluid[12].state.p;
//   EVA.fluid[12].T = EVA.fluid[12].state.T;
//   EVA.fluid[12].d = EVA.fluid[12].state.d;
//   EVA.fluid[12].phase = EVA.fluid[12].state.phase;
//   EVA.fluid[12].X[1] = 1.0;
//   assert(EVA.fluid[12].X[1] >= -0.00001 and EVA.fluid[12].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[12].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[12].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[12].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[12].T, 0, true, 6) + \" K)\");
//   EVA.fluid[13].MM = 0.018015268;
//   EVA.fluid[13].phase = if EVA.fluid[13].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[13].sat) or EVA.fluid[13].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[13].sat) or EVA.fluid[13].p > 22064000.0 then 1 else 2;
//   EVA.fluid[13].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[13].p, EVA.fluid[13].h, EVA.fluid[13].phase);
//   EVA.fluid[13].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[13].p, EVA.fluid[13].h, EVA.fluid[13].phase);
//   EVA.fluid[13].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[13].p);
//   EVA.fluid[13].sat.psat = EVA.fluid[13].p;
//   EVA.fluid[13].u = EVA.fluid[13].h + (-EVA.fluid[13].p) / EVA.fluid[13].d;
//   EVA.fluid[13].R = 461.5236365065454;
//   EVA.fluid[13].h = EVA.fluid[13].state.h;
//   EVA.fluid[13].p = EVA.fluid[13].state.p;
//   EVA.fluid[13].T = EVA.fluid[13].state.T;
//   EVA.fluid[13].d = EVA.fluid[13].state.d;
//   EVA.fluid[13].phase = EVA.fluid[13].state.phase;
//   EVA.fluid[13].X[1] = 1.0;
//   assert(EVA.fluid[13].X[1] >= -0.00001 and EVA.fluid[13].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[13].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[13].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[13].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[13].T, 0, true, 6) + \" K)\");
//   EVA.fluid[14].MM = 0.018015268;
//   EVA.fluid[14].phase = if EVA.fluid[14].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[14].sat) or EVA.fluid[14].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[14].sat) or EVA.fluid[14].p > 22064000.0 then 1 else 2;
//   EVA.fluid[14].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[14].p, EVA.fluid[14].h, EVA.fluid[14].phase);
//   EVA.fluid[14].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[14].p, EVA.fluid[14].h, EVA.fluid[14].phase);
//   EVA.fluid[14].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[14].p);
//   EVA.fluid[14].sat.psat = EVA.fluid[14].p;
//   EVA.fluid[14].u = EVA.fluid[14].h + (-EVA.fluid[14].p) / EVA.fluid[14].d;
//   EVA.fluid[14].R = 461.5236365065454;
//   EVA.fluid[14].h = EVA.fluid[14].state.h;
//   EVA.fluid[14].p = EVA.fluid[14].state.p;
//   EVA.fluid[14].T = EVA.fluid[14].state.T;
//   EVA.fluid[14].d = EVA.fluid[14].state.d;
//   EVA.fluid[14].phase = EVA.fluid[14].state.phase;
//   EVA.fluid[14].X[1] = 1.0;
//   assert(EVA.fluid[14].X[1] >= -0.00001 and EVA.fluid[14].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[14].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[14].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[14].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[14].T, 0, true, 6) + \" K)\");
//   EVA.fluid[15].MM = 0.018015268;
//   EVA.fluid[15].phase = if EVA.fluid[15].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[15].sat) or EVA.fluid[15].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[15].sat) or EVA.fluid[15].p > 22064000.0 then 1 else 2;
//   EVA.fluid[15].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[15].p, EVA.fluid[15].h, EVA.fluid[15].phase);
//   EVA.fluid[15].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[15].p, EVA.fluid[15].h, EVA.fluid[15].phase);
//   EVA.fluid[15].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[15].p);
//   EVA.fluid[15].sat.psat = EVA.fluid[15].p;
//   EVA.fluid[15].u = EVA.fluid[15].h + (-EVA.fluid[15].p) / EVA.fluid[15].d;
//   EVA.fluid[15].R = 461.5236365065454;
//   EVA.fluid[15].h = EVA.fluid[15].state.h;
//   EVA.fluid[15].p = EVA.fluid[15].state.p;
//   EVA.fluid[15].T = EVA.fluid[15].state.T;
//   EVA.fluid[15].d = EVA.fluid[15].state.d;
//   EVA.fluid[15].phase = EVA.fluid[15].state.phase;
//   EVA.fluid[15].X[1] = 1.0;
//   assert(EVA.fluid[15].X[1] >= -0.00001 and EVA.fluid[15].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[15].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[15].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[15].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[15].T, 0, true, 6) + \" K)\");
//   EVA.fluid[16].MM = 0.018015268;
//   EVA.fluid[16].phase = if EVA.fluid[16].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[16].sat) or EVA.fluid[16].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[16].sat) or EVA.fluid[16].p > 22064000.0 then 1 else 2;
//   EVA.fluid[16].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[16].p, EVA.fluid[16].h, EVA.fluid[16].phase);
//   EVA.fluid[16].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[16].p, EVA.fluid[16].h, EVA.fluid[16].phase);
//   EVA.fluid[16].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[16].p);
//   EVA.fluid[16].sat.psat = EVA.fluid[16].p;
//   EVA.fluid[16].u = EVA.fluid[16].h + (-EVA.fluid[16].p) / EVA.fluid[16].d;
//   EVA.fluid[16].R = 461.5236365065454;
//   EVA.fluid[16].h = EVA.fluid[16].state.h;
//   EVA.fluid[16].p = EVA.fluid[16].state.p;
//   EVA.fluid[16].T = EVA.fluid[16].state.T;
//   EVA.fluid[16].d = EVA.fluid[16].state.d;
//   EVA.fluid[16].phase = EVA.fluid[16].state.phase;
//   EVA.fluid[16].X[1] = 1.0;
//   assert(EVA.fluid[16].X[1] >= -0.00001 and EVA.fluid[16].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[16].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[16].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[16].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[16].T, 0, true, 6) + \" K)\");
//   EVA.fluid[17].MM = 0.018015268;
//   EVA.fluid[17].phase = if EVA.fluid[17].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[17].sat) or EVA.fluid[17].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[17].sat) or EVA.fluid[17].p > 22064000.0 then 1 else 2;
//   EVA.fluid[17].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[17].p, EVA.fluid[17].h, EVA.fluid[17].phase);
//   EVA.fluid[17].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[17].p, EVA.fluid[17].h, EVA.fluid[17].phase);
//   EVA.fluid[17].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[17].p);
//   EVA.fluid[17].sat.psat = EVA.fluid[17].p;
//   EVA.fluid[17].u = EVA.fluid[17].h + (-EVA.fluid[17].p) / EVA.fluid[17].d;
//   EVA.fluid[17].R = 461.5236365065454;
//   EVA.fluid[17].h = EVA.fluid[17].state.h;
//   EVA.fluid[17].p = EVA.fluid[17].state.p;
//   EVA.fluid[17].T = EVA.fluid[17].state.T;
//   EVA.fluid[17].d = EVA.fluid[17].state.d;
//   EVA.fluid[17].phase = EVA.fluid[17].state.phase;
//   EVA.fluid[17].X[1] = 1.0;
//   assert(EVA.fluid[17].X[1] >= -0.00001 and EVA.fluid[17].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[17].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[17].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[17].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[17].T, 0, true, 6) + \" K)\");
//   EVA.fluid[18].MM = 0.018015268;
//   EVA.fluid[18].phase = if EVA.fluid[18].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[18].sat) or EVA.fluid[18].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[18].sat) or EVA.fluid[18].p > 22064000.0 then 1 else 2;
//   EVA.fluid[18].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[18].p, EVA.fluid[18].h, EVA.fluid[18].phase);
//   EVA.fluid[18].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[18].p, EVA.fluid[18].h, EVA.fluid[18].phase);
//   EVA.fluid[18].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[18].p);
//   EVA.fluid[18].sat.psat = EVA.fluid[18].p;
//   EVA.fluid[18].u = EVA.fluid[18].h + (-EVA.fluid[18].p) / EVA.fluid[18].d;
//   EVA.fluid[18].R = 461.5236365065454;
//   EVA.fluid[18].h = EVA.fluid[18].state.h;
//   EVA.fluid[18].p = EVA.fluid[18].state.p;
//   EVA.fluid[18].T = EVA.fluid[18].state.T;
//   EVA.fluid[18].d = EVA.fluid[18].state.d;
//   EVA.fluid[18].phase = EVA.fluid[18].state.phase;
//   EVA.fluid[18].X[1] = 1.0;
//   assert(EVA.fluid[18].X[1] >= -0.00001 and EVA.fluid[18].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[18].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[18].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[18].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[18].T, 0, true, 6) + \" K)\");
//   EVA.fluid[19].MM = 0.018015268;
//   EVA.fluid[19].phase = if EVA.fluid[19].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[19].sat) or EVA.fluid[19].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[19].sat) or EVA.fluid[19].p > 22064000.0 then 1 else 2;
//   EVA.fluid[19].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[19].p, EVA.fluid[19].h, EVA.fluid[19].phase);
//   EVA.fluid[19].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[19].p, EVA.fluid[19].h, EVA.fluid[19].phase);
//   EVA.fluid[19].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[19].p);
//   EVA.fluid[19].sat.psat = EVA.fluid[19].p;
//   EVA.fluid[19].u = EVA.fluid[19].h + (-EVA.fluid[19].p) / EVA.fluid[19].d;
//   EVA.fluid[19].R = 461.5236365065454;
//   EVA.fluid[19].h = EVA.fluid[19].state.h;
//   EVA.fluid[19].p = EVA.fluid[19].state.p;
//   EVA.fluid[19].T = EVA.fluid[19].state.T;
//   EVA.fluid[19].d = EVA.fluid[19].state.d;
//   EVA.fluid[19].phase = EVA.fluid[19].state.phase;
//   EVA.fluid[19].X[1] = 1.0;
//   assert(EVA.fluid[19].X[1] >= -0.00001 and EVA.fluid[19].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[19].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[19].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[19].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[19].T, 0, true, 6) + \" K)\");
//   EVA.fluid[20].MM = 0.018015268;
//   EVA.fluid[20].phase = if EVA.fluid[20].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(EVA.fluid[20].sat) or EVA.fluid[20].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(EVA.fluid[20].sat) or EVA.fluid[20].p > 22064000.0 then 1 else 2;
//   EVA.fluid[20].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(EVA.fluid[20].p, EVA.fluid[20].h, EVA.fluid[20].phase);
//   EVA.fluid[20].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(EVA.fluid[20].p, EVA.fluid[20].h, EVA.fluid[20].phase);
//   EVA.fluid[20].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(EVA.fluid[20].p);
//   EVA.fluid[20].sat.psat = EVA.fluid[20].p;
//   EVA.fluid[20].u = EVA.fluid[20].h + (-EVA.fluid[20].p) / EVA.fluid[20].d;
//   EVA.fluid[20].R = 461.5236365065454;
//   EVA.fluid[20].h = EVA.fluid[20].state.h;
//   EVA.fluid[20].p = EVA.fluid[20].state.p;
//   EVA.fluid[20].T = EVA.fluid[20].state.T;
//   EVA.fluid[20].d = EVA.fluid[20].state.d;
//   EVA.fluid[20].phase = EVA.fluid[20].state.phase;
//   EVA.fluid[20].X[1] = 1.0;
//   assert(EVA.fluid[20].X[1] >= -0.00001 and EVA.fluid[20].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(EVA.fluid[20].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(EVA.fluid[20].p >= 0.0,\"Pressure (= \" + String(EVA.fluid[20].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(EVA.fluid[20].T, 0, true, 6) + \" K)\");
//   EVA.friction.dp / EVA.friction.dz = Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP(EVA.friction.DPMFLOW_ADD_IN_con, EVA.friction.DPMFLOW_ADD_IN_var, EVA.friction.m_flow) / EVA.friction.geoPipe.L + Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP(EVA.friction.DPMFLOW_IN_con, EVA.friction.DPMFLOW_IN_var, EVA.friction.m_flow) / EVA.friction.dz;
//   EVA.wall.layer[1].rint = 0.5 * EVA.wall.layer[1].diameterInner;
//   EVA.wall.layer[1].rext = 0.5 * EVA.wall.layer[1].diameterInner + EVA.wall.layer[1].wallThickness;
//   EVA.wall.layer[1].Tube_mass = Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.rho * EVA.wall.layer[1].Am * EVA.wall.layer[1].length / Real(EVA.wall.layer[1].numberOfNodes);
//   EVA.wall.layer[1].HeatCap = EVA.wall.layer[1].metal.cp * EVA.wall.layer[1].Tube_mass;
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[1]) = EVA.wall.layer[1].port_int[1].Q_flow + EVA.wall.layer[1].port_ext[1].Q_flow;
//   EVA.wall.layer[1].port_int[1].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[1].T - EVA.wall.layer[1].T[1]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[1].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[1].T - EVA.wall.layer[1].T[1]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[2]) = EVA.wall.layer[1].port_int[2].Q_flow + EVA.wall.layer[1].port_ext[2].Q_flow;
//   EVA.wall.layer[1].port_int[2].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[2].T - EVA.wall.layer[1].T[2]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[2].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[2].T - EVA.wall.layer[1].T[2]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[3]) = EVA.wall.layer[1].port_int[3].Q_flow + EVA.wall.layer[1].port_ext[3].Q_flow;
//   EVA.wall.layer[1].port_int[3].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[3].T - EVA.wall.layer[1].T[3]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[3].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[3].T - EVA.wall.layer[1].T[3]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[4]) = EVA.wall.layer[1].port_int[4].Q_flow + EVA.wall.layer[1].port_ext[4].Q_flow;
//   EVA.wall.layer[1].port_int[4].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[4].T - EVA.wall.layer[1].T[4]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[4].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[4].T - EVA.wall.layer[1].T[4]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[5]) = EVA.wall.layer[1].port_int[5].Q_flow + EVA.wall.layer[1].port_ext[5].Q_flow;
//   EVA.wall.layer[1].port_int[5].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[5].T - EVA.wall.layer[1].T[5]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[5].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[5].T - EVA.wall.layer[1].T[5]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[6]) = EVA.wall.layer[1].port_int[6].Q_flow + EVA.wall.layer[1].port_ext[6].Q_flow;
//   EVA.wall.layer[1].port_int[6].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[6].T - EVA.wall.layer[1].T[6]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[6].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[6].T - EVA.wall.layer[1].T[6]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[7]) = EVA.wall.layer[1].port_int[7].Q_flow + EVA.wall.layer[1].port_ext[7].Q_flow;
//   EVA.wall.layer[1].port_int[7].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[7].T - EVA.wall.layer[1].T[7]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[7].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[7].T - EVA.wall.layer[1].T[7]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[8]) = EVA.wall.layer[1].port_int[8].Q_flow + EVA.wall.layer[1].port_ext[8].Q_flow;
//   EVA.wall.layer[1].port_int[8].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[8].T - EVA.wall.layer[1].T[8]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[8].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[8].T - EVA.wall.layer[1].T[8]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[9]) = EVA.wall.layer[1].port_int[9].Q_flow + EVA.wall.layer[1].port_ext[9].Q_flow;
//   EVA.wall.layer[1].port_int[9].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[9].T - EVA.wall.layer[1].T[9]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[9].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[9].T - EVA.wall.layer[1].T[9]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[10]) = EVA.wall.layer[1].port_int[10].Q_flow + EVA.wall.layer[1].port_ext[10].Q_flow;
//   EVA.wall.layer[1].port_int[10].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[10].T - EVA.wall.layer[1].T[10]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[10].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[10].T - EVA.wall.layer[1].T[10]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[11]) = EVA.wall.layer[1].port_int[11].Q_flow + EVA.wall.layer[1].port_ext[11].Q_flow;
//   EVA.wall.layer[1].port_int[11].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[11].T - EVA.wall.layer[1].T[11]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[11].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[11].T - EVA.wall.layer[1].T[11]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[12]) = EVA.wall.layer[1].port_int[12].Q_flow + EVA.wall.layer[1].port_ext[12].Q_flow;
//   EVA.wall.layer[1].port_int[12].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[12].T - EVA.wall.layer[1].T[12]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[12].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[12].T - EVA.wall.layer[1].T[12]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[13]) = EVA.wall.layer[1].port_int[13].Q_flow + EVA.wall.layer[1].port_ext[13].Q_flow;
//   EVA.wall.layer[1].port_int[13].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[13].T - EVA.wall.layer[1].T[13]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[13].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[13].T - EVA.wall.layer[1].T[13]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[14]) = EVA.wall.layer[1].port_int[14].Q_flow + EVA.wall.layer[1].port_ext[14].Q_flow;
//   EVA.wall.layer[1].port_int[14].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[14].T - EVA.wall.layer[1].T[14]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[14].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[14].T - EVA.wall.layer[1].T[14]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[15]) = EVA.wall.layer[1].port_int[15].Q_flow + EVA.wall.layer[1].port_ext[15].Q_flow;
//   EVA.wall.layer[1].port_int[15].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[15].T - EVA.wall.layer[1].T[15]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[15].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[15].T - EVA.wall.layer[1].T[15]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[16]) = EVA.wall.layer[1].port_int[16].Q_flow + EVA.wall.layer[1].port_ext[16].Q_flow;
//   EVA.wall.layer[1].port_int[16].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[16].T - EVA.wall.layer[1].T[16]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[16].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[16].T - EVA.wall.layer[1].T[16]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[17]) = EVA.wall.layer[1].port_int[17].Q_flow + EVA.wall.layer[1].port_ext[17].Q_flow;
//   EVA.wall.layer[1].port_int[17].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[17].T - EVA.wall.layer[1].T[17]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[17].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[17].T - EVA.wall.layer[1].T[17]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[18]) = EVA.wall.layer[1].port_int[18].Q_flow + EVA.wall.layer[1].port_ext[18].Q_flow;
//   EVA.wall.layer[1].port_int[18].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[18].T - EVA.wall.layer[1].T[18]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[18].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[18].T - EVA.wall.layer[1].T[18]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[19]) = EVA.wall.layer[1].port_int[19].Q_flow + EVA.wall.layer[1].port_ext[19].Q_flow;
//   EVA.wall.layer[1].port_int[19].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[19].T - EVA.wall.layer[1].T[19]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[19].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[19].T - EVA.wall.layer[1].T[19]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].HeatCap * der(EVA.wall.layer[1].T[20]) = EVA.wall.layer[1].port_int[20].Q_flow + EVA.wall.layer[1].port_ext[20].Q_flow;
//   EVA.wall.layer[1].port_int[20].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_int[20].T - EVA.wall.layer[1].T[20]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((-1.0 + EVA.wall.layer[1].rext / EVA.wall.layer[1].rint) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].port_ext[20].Q_flow = 12.566370614359172 * (EVA.wall.layer[1].port_ext[20].T - EVA.wall.layer[1].T[20]) * Real(EVA.wall.layer[1].numberOfParallelTubes) * EVA.wall.layer[1].metal.lambda * EVA.wall.layer[1].length / ((1.0 + (-EVA.wall.layer[1].rint) / EVA.wall.layer[1].rext) * Real(EVA.wall.layer[1].numberOfNodes));
//   EVA.wall.layer[1].Am = 3.141592653589793 * (EVA.wall.layer[1].rext ^ 2.0 - EVA.wall.layer[1].rint ^ 2.0);
//   EVA.wall.layer[2].rint = 0.5 * EVA.wall.layer[2].diameterInner;
//   EVA.wall.layer[2].rext = 0.5 * EVA.wall.layer[2].diameterInner + EVA.wall.layer[2].wallThickness;
//   EVA.wall.layer[2].Tube_mass = Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.rho * EVA.wall.layer[2].Am * EVA.wall.layer[2].length / Real(EVA.wall.layer[2].numberOfNodes);
//   EVA.wall.layer[2].HeatCap = EVA.wall.layer[2].metal.cp * EVA.wall.layer[2].Tube_mass;
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[1]) = EVA.wall.layer[2].port_int[1].Q_flow + EVA.wall.layer[2].port_ext[1].Q_flow;
//   EVA.wall.layer[2].port_int[1].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[1].T - EVA.wall.layer[2].T[1]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[1].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[1].T - EVA.wall.layer[2].T[1]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[2]) = EVA.wall.layer[2].port_int[2].Q_flow + EVA.wall.layer[2].port_ext[2].Q_flow;
//   EVA.wall.layer[2].port_int[2].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[2].T - EVA.wall.layer[2].T[2]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[2].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[2].T - EVA.wall.layer[2].T[2]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[3]) = EVA.wall.layer[2].port_int[3].Q_flow + EVA.wall.layer[2].port_ext[3].Q_flow;
//   EVA.wall.layer[2].port_int[3].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[3].T - EVA.wall.layer[2].T[3]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[3].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[3].T - EVA.wall.layer[2].T[3]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[4]) = EVA.wall.layer[2].port_int[4].Q_flow + EVA.wall.layer[2].port_ext[4].Q_flow;
//   EVA.wall.layer[2].port_int[4].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[4].T - EVA.wall.layer[2].T[4]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[4].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[4].T - EVA.wall.layer[2].T[4]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[5]) = EVA.wall.layer[2].port_int[5].Q_flow + EVA.wall.layer[2].port_ext[5].Q_flow;
//   EVA.wall.layer[2].port_int[5].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[5].T - EVA.wall.layer[2].T[5]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[5].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[5].T - EVA.wall.layer[2].T[5]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[6]) = EVA.wall.layer[2].port_int[6].Q_flow + EVA.wall.layer[2].port_ext[6].Q_flow;
//   EVA.wall.layer[2].port_int[6].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[6].T - EVA.wall.layer[2].T[6]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[6].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[6].T - EVA.wall.layer[2].T[6]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[7]) = EVA.wall.layer[2].port_int[7].Q_flow + EVA.wall.layer[2].port_ext[7].Q_flow;
//   EVA.wall.layer[2].port_int[7].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[7].T - EVA.wall.layer[2].T[7]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[7].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[7].T - EVA.wall.layer[2].T[7]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[8]) = EVA.wall.layer[2].port_int[8].Q_flow + EVA.wall.layer[2].port_ext[8].Q_flow;
//   EVA.wall.layer[2].port_int[8].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[8].T - EVA.wall.layer[2].T[8]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[8].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[8].T - EVA.wall.layer[2].T[8]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[9]) = EVA.wall.layer[2].port_int[9].Q_flow + EVA.wall.layer[2].port_ext[9].Q_flow;
//   EVA.wall.layer[2].port_int[9].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[9].T - EVA.wall.layer[2].T[9]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[9].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[9].T - EVA.wall.layer[2].T[9]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[10]) = EVA.wall.layer[2].port_int[10].Q_flow + EVA.wall.layer[2].port_ext[10].Q_flow;
//   EVA.wall.layer[2].port_int[10].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[10].T - EVA.wall.layer[2].T[10]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[10].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[10].T - EVA.wall.layer[2].T[10]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[11]) = EVA.wall.layer[2].port_int[11].Q_flow + EVA.wall.layer[2].port_ext[11].Q_flow;
//   EVA.wall.layer[2].port_int[11].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[11].T - EVA.wall.layer[2].T[11]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[11].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[11].T - EVA.wall.layer[2].T[11]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[12]) = EVA.wall.layer[2].port_int[12].Q_flow + EVA.wall.layer[2].port_ext[12].Q_flow;
//   EVA.wall.layer[2].port_int[12].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[12].T - EVA.wall.layer[2].T[12]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[12].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[12].T - EVA.wall.layer[2].T[12]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[13]) = EVA.wall.layer[2].port_int[13].Q_flow + EVA.wall.layer[2].port_ext[13].Q_flow;
//   EVA.wall.layer[2].port_int[13].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[13].T - EVA.wall.layer[2].T[13]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[13].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[13].T - EVA.wall.layer[2].T[13]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[14]) = EVA.wall.layer[2].port_int[14].Q_flow + EVA.wall.layer[2].port_ext[14].Q_flow;
//   EVA.wall.layer[2].port_int[14].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[14].T - EVA.wall.layer[2].T[14]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[14].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[14].T - EVA.wall.layer[2].T[14]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[15]) = EVA.wall.layer[2].port_int[15].Q_flow + EVA.wall.layer[2].port_ext[15].Q_flow;
//   EVA.wall.layer[2].port_int[15].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[15].T - EVA.wall.layer[2].T[15]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[15].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[15].T - EVA.wall.layer[2].T[15]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[16]) = EVA.wall.layer[2].port_int[16].Q_flow + EVA.wall.layer[2].port_ext[16].Q_flow;
//   EVA.wall.layer[2].port_int[16].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[16].T - EVA.wall.layer[2].T[16]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[16].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[16].T - EVA.wall.layer[2].T[16]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[17]) = EVA.wall.layer[2].port_int[17].Q_flow + EVA.wall.layer[2].port_ext[17].Q_flow;
//   EVA.wall.layer[2].port_int[17].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[17].T - EVA.wall.layer[2].T[17]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[17].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[17].T - EVA.wall.layer[2].T[17]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[18]) = EVA.wall.layer[2].port_int[18].Q_flow + EVA.wall.layer[2].port_ext[18].Q_flow;
//   EVA.wall.layer[2].port_int[18].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[18].T - EVA.wall.layer[2].T[18]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[18].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[18].T - EVA.wall.layer[2].T[18]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[19]) = EVA.wall.layer[2].port_int[19].Q_flow + EVA.wall.layer[2].port_ext[19].Q_flow;
//   EVA.wall.layer[2].port_int[19].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[19].T - EVA.wall.layer[2].T[19]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[19].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[19].T - EVA.wall.layer[2].T[19]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].HeatCap * der(EVA.wall.layer[2].T[20]) = EVA.wall.layer[2].port_int[20].Q_flow + EVA.wall.layer[2].port_ext[20].Q_flow;
//   EVA.wall.layer[2].port_int[20].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_int[20].T - EVA.wall.layer[2].T[20]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((-1.0 + EVA.wall.layer[2].rext / EVA.wall.layer[2].rint) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].port_ext[20].Q_flow = 12.566370614359172 * (EVA.wall.layer[2].port_ext[20].T - EVA.wall.layer[2].T[20]) * Real(EVA.wall.layer[2].numberOfParallelTubes) * EVA.wall.layer[2].metal.lambda * EVA.wall.layer[2].length / ((1.0 + (-EVA.wall.layer[2].rint) / EVA.wall.layer[2].rext) * Real(EVA.wall.layer[2].numberOfNodes));
//   EVA.wall.layer[2].Am = 3.141592653589793 * (EVA.wall.layer[2].rext ^ 2.0 - EVA.wall.layer[2].rint ^ 2.0);
//   EVA.wall.layer[3].rint = 0.5 * EVA.wall.layer[3].diameterInner;
//   EVA.wall.layer[3].rext = 0.5 * EVA.wall.layer[3].diameterInner + EVA.wall.layer[3].wallThickness;
//   EVA.wall.layer[3].Tube_mass = Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.rho * EVA.wall.layer[3].Am * EVA.wall.layer[3].length / Real(EVA.wall.layer[3].numberOfNodes);
//   EVA.wall.layer[3].HeatCap = EVA.wall.layer[3].metal.cp * EVA.wall.layer[3].Tube_mass;
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[1]) = EVA.wall.layer[3].port_int[1].Q_flow + EVA.wall.layer[3].port_ext[1].Q_flow;
//   EVA.wall.layer[3].port_int[1].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[1].T - EVA.wall.layer[3].T[1]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[1].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[1].T - EVA.wall.layer[3].T[1]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[2]) = EVA.wall.layer[3].port_int[2].Q_flow + EVA.wall.layer[3].port_ext[2].Q_flow;
//   EVA.wall.layer[3].port_int[2].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[2].T - EVA.wall.layer[3].T[2]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[2].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[2].T - EVA.wall.layer[3].T[2]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[3]) = EVA.wall.layer[3].port_int[3].Q_flow + EVA.wall.layer[3].port_ext[3].Q_flow;
//   EVA.wall.layer[3].port_int[3].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[3].T - EVA.wall.layer[3].T[3]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[3].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[3].T - EVA.wall.layer[3].T[3]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[4]) = EVA.wall.layer[3].port_int[4].Q_flow + EVA.wall.layer[3].port_ext[4].Q_flow;
//   EVA.wall.layer[3].port_int[4].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[4].T - EVA.wall.layer[3].T[4]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[4].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[4].T - EVA.wall.layer[3].T[4]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[5]) = EVA.wall.layer[3].port_int[5].Q_flow + EVA.wall.layer[3].port_ext[5].Q_flow;
//   EVA.wall.layer[3].port_int[5].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[5].T - EVA.wall.layer[3].T[5]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[5].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[5].T - EVA.wall.layer[3].T[5]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[6]) = EVA.wall.layer[3].port_int[6].Q_flow + EVA.wall.layer[3].port_ext[6].Q_flow;
//   EVA.wall.layer[3].port_int[6].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[6].T - EVA.wall.layer[3].T[6]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[6].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[6].T - EVA.wall.layer[3].T[6]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[7]) = EVA.wall.layer[3].port_int[7].Q_flow + EVA.wall.layer[3].port_ext[7].Q_flow;
//   EVA.wall.layer[3].port_int[7].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[7].T - EVA.wall.layer[3].T[7]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[7].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[7].T - EVA.wall.layer[3].T[7]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[8]) = EVA.wall.layer[3].port_int[8].Q_flow + EVA.wall.layer[3].port_ext[8].Q_flow;
//   EVA.wall.layer[3].port_int[8].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[8].T - EVA.wall.layer[3].T[8]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[8].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[8].T - EVA.wall.layer[3].T[8]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[9]) = EVA.wall.layer[3].port_int[9].Q_flow + EVA.wall.layer[3].port_ext[9].Q_flow;
//   EVA.wall.layer[3].port_int[9].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[9].T - EVA.wall.layer[3].T[9]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[9].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[9].T - EVA.wall.layer[3].T[9]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[10]) = EVA.wall.layer[3].port_int[10].Q_flow + EVA.wall.layer[3].port_ext[10].Q_flow;
//   EVA.wall.layer[3].port_int[10].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[10].T - EVA.wall.layer[3].T[10]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[10].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[10].T - EVA.wall.layer[3].T[10]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[11]) = EVA.wall.layer[3].port_int[11].Q_flow + EVA.wall.layer[3].port_ext[11].Q_flow;
//   EVA.wall.layer[3].port_int[11].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[11].T - EVA.wall.layer[3].T[11]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[11].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[11].T - EVA.wall.layer[3].T[11]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[12]) = EVA.wall.layer[3].port_int[12].Q_flow + EVA.wall.layer[3].port_ext[12].Q_flow;
//   EVA.wall.layer[3].port_int[12].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[12].T - EVA.wall.layer[3].T[12]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[12].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[12].T - EVA.wall.layer[3].T[12]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[13]) = EVA.wall.layer[3].port_int[13].Q_flow + EVA.wall.layer[3].port_ext[13].Q_flow;
//   EVA.wall.layer[3].port_int[13].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[13].T - EVA.wall.layer[3].T[13]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[13].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[13].T - EVA.wall.layer[3].T[13]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[14]) = EVA.wall.layer[3].port_int[14].Q_flow + EVA.wall.layer[3].port_ext[14].Q_flow;
//   EVA.wall.layer[3].port_int[14].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[14].T - EVA.wall.layer[3].T[14]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[14].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[14].T - EVA.wall.layer[3].T[14]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[15]) = EVA.wall.layer[3].port_int[15].Q_flow + EVA.wall.layer[3].port_ext[15].Q_flow;
//   EVA.wall.layer[3].port_int[15].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[15].T - EVA.wall.layer[3].T[15]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[15].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[15].T - EVA.wall.layer[3].T[15]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[16]) = EVA.wall.layer[3].port_int[16].Q_flow + EVA.wall.layer[3].port_ext[16].Q_flow;
//   EVA.wall.layer[3].port_int[16].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[16].T - EVA.wall.layer[3].T[16]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[16].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[16].T - EVA.wall.layer[3].T[16]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[17]) = EVA.wall.layer[3].port_int[17].Q_flow + EVA.wall.layer[3].port_ext[17].Q_flow;
//   EVA.wall.layer[3].port_int[17].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[17].T - EVA.wall.layer[3].T[17]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[17].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[17].T - EVA.wall.layer[3].T[17]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[18]) = EVA.wall.layer[3].port_int[18].Q_flow + EVA.wall.layer[3].port_ext[18].Q_flow;
//   EVA.wall.layer[3].port_int[18].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[18].T - EVA.wall.layer[3].T[18]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[18].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[18].T - EVA.wall.layer[3].T[18]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[19]) = EVA.wall.layer[3].port_int[19].Q_flow + EVA.wall.layer[3].port_ext[19].Q_flow;
//   EVA.wall.layer[3].port_int[19].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[19].T - EVA.wall.layer[3].T[19]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[19].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[19].T - EVA.wall.layer[3].T[19]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].HeatCap * der(EVA.wall.layer[3].T[20]) = EVA.wall.layer[3].port_int[20].Q_flow + EVA.wall.layer[3].port_ext[20].Q_flow;
//   EVA.wall.layer[3].port_int[20].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_int[20].T - EVA.wall.layer[3].T[20]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((-1.0 + EVA.wall.layer[3].rext / EVA.wall.layer[3].rint) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].port_ext[20].Q_flow = 12.566370614359172 * (EVA.wall.layer[3].port_ext[20].T - EVA.wall.layer[3].T[20]) * Real(EVA.wall.layer[3].numberOfParallelTubes) * EVA.wall.layer[3].metal.lambda * EVA.wall.layer[3].length / ((1.0 + (-EVA.wall.layer[3].rint) / EVA.wall.layer[3].rext) * Real(EVA.wall.layer[3].numberOfNodes));
//   EVA.wall.layer[3].Am = 3.141592653589793 * (EVA.wall.layer[3].rext ^ 2.0 - EVA.wall.layer[3].rint ^ 2.0);
//   EVA.HT[1].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[1].KC_IN_con, EVA.HT[1].KC_IN_var);
//   EVA.HT[2].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[2].KC_IN_con, EVA.HT[2].KC_IN_var);
//   EVA.HT[3].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[3].KC_IN_con, EVA.HT[3].KC_IN_var);
//   EVA.HT[4].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[4].KC_IN_con, EVA.HT[4].KC_IN_var);
//   EVA.HT[5].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[5].KC_IN_con, EVA.HT[5].KC_IN_var);
//   EVA.HT[6].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[6].KC_IN_con, EVA.HT[6].KC_IN_var);
//   EVA.HT[7].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[7].KC_IN_con, EVA.HT[7].KC_IN_var);
//   EVA.HT[8].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[8].KC_IN_con, EVA.HT[8].KC_IN_var);
//   EVA.HT[9].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[9].KC_IN_con, EVA.HT[9].KC_IN_var);
//   EVA.HT[10].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[10].KC_IN_con, EVA.HT[10].KC_IN_var);
//   EVA.HT[11].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[11].KC_IN_con, EVA.HT[11].KC_IN_var);
//   EVA.HT[12].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[12].KC_IN_con, EVA.HT[12].KC_IN_var);
//   EVA.HT[13].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[13].KC_IN_con, EVA.HT[13].KC_IN_var);
//   EVA.HT[14].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[14].KC_IN_con, EVA.HT[14].KC_IN_var);
//   EVA.HT[15].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[15].KC_IN_con, EVA.HT[15].KC_IN_var);
//   EVA.HT[16].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[16].KC_IN_con, EVA.HT[16].KC_IN_var);
//   EVA.HT[17].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[17].KC_IN_con, EVA.HT[17].KC_IN_var);
//   EVA.HT[18].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[18].KC_IN_con, EVA.HT[18].KC_IN_var);
//   EVA.HT[19].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[19].KC_IN_con, EVA.HT[19].KC_IN_var);
//   EVA.HT[20].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(EVA.HT[20].KC_IN_con, EVA.HT[20].KC_IN_var);
//   EVA.alpha[1] = EVA.HT[1].alpha;
//   EVA.qMetalFluid[1] = EVA.alpha[1] * (EVA.TWall[1] - EVA.fluid[1].T);
//   EVA.alpha[2] = EVA.HT[2].alpha;
//   EVA.qMetalFluid[2] = EVA.alpha[2] * (EVA.TWall[2] - EVA.fluid[2].T);
//   EVA.alpha[3] = EVA.HT[3].alpha;
//   EVA.qMetalFluid[3] = EVA.alpha[3] * (EVA.TWall[3] - EVA.fluid[3].T);
//   EVA.alpha[4] = EVA.HT[4].alpha;
//   EVA.qMetalFluid[4] = EVA.alpha[4] * (EVA.TWall[4] - EVA.fluid[4].T);
//   EVA.alpha[5] = EVA.HT[5].alpha;
//   EVA.qMetalFluid[5] = EVA.alpha[5] * (EVA.TWall[5] - EVA.fluid[5].T);
//   EVA.alpha[6] = EVA.HT[6].alpha;
//   EVA.qMetalFluid[6] = EVA.alpha[6] * (EVA.TWall[6] - EVA.fluid[6].T);
//   EVA.alpha[7] = EVA.HT[7].alpha;
//   EVA.qMetalFluid[7] = EVA.alpha[7] * (EVA.TWall[7] - EVA.fluid[7].T);
//   EVA.alpha[8] = EVA.HT[8].alpha;
//   EVA.qMetalFluid[8] = EVA.alpha[8] * (EVA.TWall[8] - EVA.fluid[8].T);
//   EVA.alpha[9] = EVA.HT[9].alpha;
//   EVA.qMetalFluid[9] = EVA.alpha[9] * (EVA.TWall[9] - EVA.fluid[9].T);
//   EVA.alpha[10] = EVA.HT[10].alpha;
//   EVA.qMetalFluid[10] = EVA.alpha[10] * (EVA.TWall[10] - EVA.fluid[10].T);
//   EVA.alpha[11] = EVA.HT[11].alpha;
//   EVA.qMetalFluid[11] = EVA.alpha[11] * (EVA.TWall[11] - EVA.fluid[11].T);
//   EVA.alpha[12] = EVA.HT[12].alpha;
//   EVA.qMetalFluid[12] = EVA.alpha[12] * (EVA.TWall[12] - EVA.fluid[12].T);
//   EVA.alpha[13] = EVA.HT[13].alpha;
//   EVA.qMetalFluid[13] = EVA.alpha[13] * (EVA.TWall[13] - EVA.fluid[13].T);
//   EVA.alpha[14] = EVA.HT[14].alpha;
//   EVA.qMetalFluid[14] = EVA.alpha[14] * (EVA.TWall[14] - EVA.fluid[14].T);
//   EVA.alpha[15] = EVA.HT[15].alpha;
//   EVA.qMetalFluid[15] = EVA.alpha[15] * (EVA.TWall[15] - EVA.fluid[15].T);
//   EVA.alpha[16] = EVA.HT[16].alpha;
//   EVA.qMetalFluid[16] = EVA.alpha[16] * (EVA.TWall[16] - EVA.fluid[16].T);
//   EVA.alpha[17] = EVA.HT[17].alpha;
//   EVA.qMetalFluid[17] = EVA.alpha[17] * (EVA.TWall[17] - EVA.fluid[17].T);
//   EVA.alpha[18] = EVA.HT[18].alpha;
//   EVA.qMetalFluid[18] = EVA.alpha[18] * (EVA.TWall[18] - EVA.fluid[18].T);
//   EVA.alpha[19] = EVA.HT[19].alpha;
//   EVA.qMetalFluid[19] = EVA.alpha[19] * (EVA.TWall[19] - EVA.fluid[19].T);
//   EVA.alpha[20] = EVA.HT[20].alpha;
//   EVA.qMetalFluid[20] = EVA.alpha[20] * (EVA.TWall[20] - EVA.fluid[20].T);
//   EVA.heatport.Q_flow[1] = EVA.qMetalFluid[1] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[2] = EVA.qMetalFluid[2] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[3] = EVA.qMetalFluid[3] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[4] = EVA.qMetalFluid[4] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[5] = EVA.qMetalFluid[5] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[6] = EVA.qMetalFluid[6] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[7] = EVA.qMetalFluid[7] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[8] = EVA.qMetalFluid[8] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[9] = EVA.qMetalFluid[9] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[10] = EVA.qMetalFluid[10] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[11] = EVA.qMetalFluid[11] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[12] = EVA.qMetalFluid[12] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[13] = EVA.qMetalFluid[13] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[14] = EVA.qMetalFluid[14] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[15] = EVA.qMetalFluid[15] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[16] = EVA.qMetalFluid[16] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[17] = EVA.qMetalFluid[17] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[18] = EVA.qMetalFluid[18] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[19] = EVA.qMetalFluid[19] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.heatport.Q_flow[20] = EVA.qMetalFluid[20] * EVA.heatedArea / Real(EVA.numberOfNodes);
//   EVA.p = EVA.hydP * EVA.portIn.p + (1.0 - EVA.hydP) * EVA.portOut.p;
//   EVA.m_flowsZero = (EVA.hydM * EVA.portIn.m_flow - (1.0 - EVA.hydM) * EVA.portOut.m_flow) / Real(EVA.geoPipe.Nt);
//   EVA.m_flows[1] = EVA.m_flowsZero;
//   EVA.m_flows[2] = EVA.m_flowsZero;
//   EVA.m_flows[3] = EVA.m_flowsZero;
//   EVA.m_flows[4] = EVA.m_flowsZero;
//   EVA.m_flows[5] = EVA.m_flowsZero;
//   EVA.m_flows[6] = EVA.m_flowsZero;
//   EVA.m_flows[7] = EVA.m_flowsZero;
//   EVA.m_flows[8] = EVA.m_flowsZero;
//   EVA.m_flows[9] = EVA.m_flowsZero;
//   EVA.m_flows[10] = EVA.m_flowsZero;
//   EVA.m_flows[11] = EVA.m_flowsZero;
//   EVA.m_flows[12] = EVA.m_flowsZero;
//   EVA.m_flows[13] = EVA.m_flowsZero;
//   EVA.m_flows[14] = EVA.m_flowsZero;
//   EVA.m_flows[15] = EVA.m_flowsZero;
//   EVA.m_flows[16] = EVA.m_flowsZero;
//   EVA.m_flows[17] = EVA.m_flowsZero;
//   EVA.m_flows[18] = EVA.m_flowsZero;
//   EVA.m_flows[19] = EVA.m_flowsZero;
//   EVA.m_flows[20] = EVA.m_flowsZero;
//   EVA.dpfric = EVA.friction.dp;
//   EVA.dphyd = 9.80665 * EVA.geoPipe.H * EVA.d_av;
//   EVA.VTotal * der(EVA.d_av) = EVA.portIn.m_flow + EVA.portOut.m_flow;
//   der(EVA.m_flows[1]) * EVA.geoPipe.L / EVA.A = EVA.portIn.p + (-EVA.dpfric) - EVA.dphyd - EVA.portOut.p;
//   EVA.fluid[1].p = EVA.p;
//   EVA.fluid[2].p = EVA.p;
//   EVA.fluid[3].p = EVA.p;
//   EVA.fluid[4].p = EVA.p;
//   EVA.fluid[5].p = EVA.p;
//   EVA.fluid[6].p = EVA.p;
//   EVA.fluid[7].p = EVA.p;
//   EVA.fluid[8].p = EVA.p;
//   EVA.fluid[9].p = EVA.p;
//   EVA.fluid[10].p = EVA.p;
//   EVA.fluid[11].p = EVA.p;
//   EVA.fluid[12].p = EVA.p;
//   EVA.fluid[13].p = EVA.p;
//   EVA.fluid[14].p = EVA.p;
//   EVA.fluid[15].p = EVA.p;
//   EVA.fluid[16].p = EVA.p;
//   EVA.fluid[17].p = EVA.p;
//   EVA.fluid[18].p = EVA.p;
//   EVA.fluid[19].p = EVA.p;
//   EVA.fluid[20].p = EVA.p;
//   EVA.fluid[1].d = EVA.d[1];
//   EVA.fluid[2].d = EVA.d[2];
//   EVA.fluid[3].d = EVA.d[3];
//   EVA.fluid[4].d = EVA.d[4];
//   EVA.fluid[5].d = EVA.d[5];
//   EVA.fluid[6].d = EVA.d[6];
//   EVA.fluid[7].d = EVA.d[7];
//   EVA.fluid[8].d = EVA.d[8];
//   EVA.fluid[9].d = EVA.d[9];
//   EVA.fluid[10].d = EVA.d[10];
//   EVA.fluid[11].d = EVA.d[11];
//   EVA.fluid[12].d = EVA.d[12];
//   EVA.fluid[13].d = EVA.d[13];
//   EVA.fluid[14].d = EVA.d[14];
//   EVA.fluid[15].d = EVA.d[15];
//   EVA.fluid[16].d = EVA.d[16];
//   EVA.fluid[17].d = EVA.d[17];
//   EVA.fluid[18].d = EVA.d[18];
//   EVA.fluid[19].d = EVA.d[19];
//   EVA.fluid[20].d = EVA.d[20];
//   EVA.fluid[1].T = EVA.T[1];
//   EVA.fluid[2].T = EVA.T[2];
//   EVA.fluid[3].T = EVA.T[3];
//   EVA.fluid[4].T = EVA.T[4];
//   EVA.fluid[5].T = EVA.T[5];
//   EVA.fluid[6].T = EVA.T[6];
//   EVA.fluid[7].T = EVA.T[7];
//   EVA.fluid[8].T = EVA.T[8];
//   EVA.fluid[9].T = EVA.T[9];
//   EVA.fluid[10].T = EVA.T[10];
//   EVA.fluid[11].T = EVA.T[11];
//   EVA.fluid[12].T = EVA.T[12];
//   EVA.fluid[13].T = EVA.T[13];
//   EVA.fluid[14].T = EVA.T[14];
//   EVA.fluid[15].T = EVA.T[15];
//   EVA.fluid[16].T = EVA.T[16];
//   EVA.fluid[17].T = EVA.T[17];
//   EVA.fluid[18].T = EVA.T[18];
//   EVA.fluid[19].T = EVA.T[19];
//   EVA.fluid[20].T = EVA.T[20];
//   EVA.vol[1] = 1.0 / EVA.fluid[1].d;
//   EVA.vol[2] = 1.0 / EVA.fluid[2].d;
//   EVA.vol[3] = 1.0 / EVA.fluid[3].d;
//   EVA.vol[4] = 1.0 / EVA.fluid[4].d;
//   EVA.vol[5] = 1.0 / EVA.fluid[5].d;
//   EVA.vol[6] = 1.0 / EVA.fluid[6].d;
//   EVA.vol[7] = 1.0 / EVA.fluid[7].d;
//   EVA.vol[8] = 1.0 / EVA.fluid[8].d;
//   EVA.vol[9] = 1.0 / EVA.fluid[9].d;
//   EVA.vol[10] = 1.0 / EVA.fluid[10].d;
//   EVA.vol[11] = 1.0 / EVA.fluid[11].d;
//   EVA.vol[12] = 1.0 / EVA.fluid[12].d;
//   EVA.vol[13] = 1.0 / EVA.fluid[13].d;
//   EVA.vol[14] = 1.0 / EVA.fluid[14].d;
//   EVA.vol[15] = 1.0 / EVA.fluid[15].d;
//   EVA.vol[16] = 1.0 / EVA.fluid[16].d;
//   EVA.vol[17] = 1.0 / EVA.fluid[17].d;
//   EVA.vol[18] = 1.0 / EVA.fluid[18].d;
//   EVA.vol[19] = 1.0 / EVA.fluid[19].d;
//   EVA.vol[20] = 1.0 / EVA.fluid[20].d;
//   EVA.d_av = (EVA.d[1] + EVA.d[2] + EVA.d[3] + EVA.d[4] + EVA.d[5] + EVA.d[6] + EVA.d[7] + EVA.d[8] + EVA.d[9] + EVA.d[10] + EVA.d[11] + EVA.d[12] + EVA.d[13] + EVA.d[14] + EVA.d[15] + EVA.d[16] + EVA.d[17] + EVA.d[18] + EVA.d[19] + EVA.d[20]) / Real(EVA.numberOfNodes);
//   EVA.vol_av = (EVA.vol[1] + EVA.vol[2] + EVA.vol[3] + EVA.vol[4] + EVA.vol[5] + EVA.vol[6] + EVA.vol[7] + EVA.vol[8] + EVA.vol[9] + EVA.vol[10] + EVA.vol[11] + EVA.vol[12] + EVA.vol[13] + EVA.vol[14] + EVA.vol[15] + EVA.vol[16] + EVA.vol[17] + EVA.vol[18] + EVA.vol[19] + EVA.vol[20]) / Real(EVA.numberOfNodes);
//   EVA.eta[1] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[1].state);
//   EVA.eta[2] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[2].state);
//   EVA.eta[3] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[3].state);
//   EVA.eta[4] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[4].state);
//   EVA.eta[5] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[5].state);
//   EVA.eta[6] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[6].state);
//   EVA.eta[7] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[7].state);
//   EVA.eta[8] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[8].state);
//   EVA.eta[9] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[9].state);
//   EVA.eta[10] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[10].state);
//   EVA.eta[11] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[11].state);
//   EVA.eta[12] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[12].state);
//   EVA.eta[13] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[13].state);
//   EVA.eta[14] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[14].state);
//   EVA.eta[15] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[15].state);
//   EVA.eta[16] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[16].state);
//   EVA.eta[17] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[17].state);
//   EVA.eta[18] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[18].state);
//   EVA.eta[19] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[19].state);
//   EVA.eta[20] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(EVA.fluid[20].state);
//   EVA.cp[1] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[1].state);
//   EVA.cp[2] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[2].state);
//   EVA.cp[3] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[3].state);
//   EVA.cp[4] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[4].state);
//   EVA.cp[5] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[5].state);
//   EVA.cp[6] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[6].state);
//   EVA.cp[7] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[7].state);
//   EVA.cp[8] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[8].state);
//   EVA.cp[9] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[9].state);
//   EVA.cp[10] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[10].state);
//   EVA.cp[11] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[11].state);
//   EVA.cp[12] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[12].state);
//   EVA.cp[13] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[13].state);
//   EVA.cp[14] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[14].state);
//   EVA.cp[15] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[15].state);
//   EVA.cp[16] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[16].state);
//   EVA.cp[17] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[17].state);
//   EVA.cp[18] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[18].state);
//   EVA.cp[19] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[19].state);
//   EVA.cp[20] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(EVA.fluid[20].state);
//   EVA.lambda[1] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[1].state);
//   EVA.lambda[2] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[2].state);
//   EVA.lambda[3] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[3].state);
//   EVA.lambda[4] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[4].state);
//   EVA.lambda[5] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[5].state);
//   EVA.lambda[6] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[6].state);
//   EVA.lambda[7] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[7].state);
//   EVA.lambda[8] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[8].state);
//   EVA.lambda[9] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[9].state);
//   EVA.lambda[10] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[10].state);
//   EVA.lambda[11] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[11].state);
//   EVA.lambda[12] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[12].state);
//   EVA.lambda[13] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[13].state);
//   EVA.lambda[14] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[14].state);
//   EVA.lambda[15] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[15].state);
//   EVA.lambda[16] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[16].state);
//   EVA.lambda[17] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[17].state);
//   EVA.lambda[18] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[18].state);
//   EVA.lambda[19] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[19].state);
//   EVA.lambda[20] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(EVA.fluid[20].state);
//   EVA.E_flows[1] = max(0.0, EVA.m_flowsZero) * (ECO.portOut.h_outflow - EVA.fluid[1].h) + max(0.0, -EVA.m_flows[1]) * (EVA.fluid[2].h - EVA.fluid[1].h);
//   EVA.E_flows[2] = max(0.0, EVA.m_flows[1]) * (EVA.fluid[1].h - EVA.fluid[2].h) + max(0.0, -EVA.m_flows[2]) * (EVA.fluid[3].h - EVA.fluid[2].h);
//   EVA.E_flows[3] = max(0.0, EVA.m_flows[2]) * (EVA.fluid[2].h - EVA.fluid[3].h) + max(0.0, -EVA.m_flows[3]) * (EVA.fluid[4].h - EVA.fluid[3].h);
//   EVA.E_flows[4] = max(0.0, EVA.m_flows[3]) * (EVA.fluid[3].h - EVA.fluid[4].h) + max(0.0, -EVA.m_flows[4]) * (EVA.fluid[5].h - EVA.fluid[4].h);
//   EVA.E_flows[5] = max(0.0, EVA.m_flows[4]) * (EVA.fluid[4].h - EVA.fluid[5].h) + max(0.0, -EVA.m_flows[5]) * (EVA.fluid[6].h - EVA.fluid[5].h);
//   EVA.E_flows[6] = max(0.0, EVA.m_flows[5]) * (EVA.fluid[5].h - EVA.fluid[6].h) + max(0.0, -EVA.m_flows[6]) * (EVA.fluid[7].h - EVA.fluid[6].h);
//   EVA.E_flows[7] = max(0.0, EVA.m_flows[6]) * (EVA.fluid[6].h - EVA.fluid[7].h) + max(0.0, -EVA.m_flows[7]) * (EVA.fluid[8].h - EVA.fluid[7].h);
//   EVA.E_flows[8] = max(0.0, EVA.m_flows[7]) * (EVA.fluid[7].h - EVA.fluid[8].h) + max(0.0, -EVA.m_flows[8]) * (EVA.fluid[9].h - EVA.fluid[8].h);
//   EVA.E_flows[9] = max(0.0, EVA.m_flows[8]) * (EVA.fluid[8].h - EVA.fluid[9].h) + max(0.0, -EVA.m_flows[9]) * (EVA.fluid[10].h - EVA.fluid[9].h);
//   EVA.E_flows[10] = max(0.0, EVA.m_flows[9]) * (EVA.fluid[9].h - EVA.fluid[10].h) + max(0.0, -EVA.m_flows[10]) * (EVA.fluid[11].h - EVA.fluid[10].h);
//   EVA.E_flows[11] = max(0.0, EVA.m_flows[10]) * (EVA.fluid[10].h - EVA.fluid[11].h) + max(0.0, -EVA.m_flows[11]) * (EVA.fluid[12].h - EVA.fluid[11].h);
//   EVA.E_flows[12] = max(0.0, EVA.m_flows[11]) * (EVA.fluid[11].h - EVA.fluid[12].h) + max(0.0, -EVA.m_flows[12]) * (EVA.fluid[13].h - EVA.fluid[12].h);
//   EVA.E_flows[13] = max(0.0, EVA.m_flows[12]) * (EVA.fluid[12].h - EVA.fluid[13].h) + max(0.0, -EVA.m_flows[13]) * (EVA.fluid[14].h - EVA.fluid[13].h);
//   EVA.E_flows[14] = max(0.0, EVA.m_flows[13]) * (EVA.fluid[13].h - EVA.fluid[14].h) + max(0.0, -EVA.m_flows[14]) * (EVA.fluid[15].h - EVA.fluid[14].h);
//   EVA.E_flows[15] = max(0.0, EVA.m_flows[14]) * (EVA.fluid[14].h - EVA.fluid[15].h) + max(0.0, -EVA.m_flows[15]) * (EVA.fluid[16].h - EVA.fluid[15].h);
//   EVA.E_flows[16] = max(0.0, EVA.m_flows[15]) * (EVA.fluid[15].h - EVA.fluid[16].h) + max(0.0, -EVA.m_flows[16]) * (EVA.fluid[17].h - EVA.fluid[16].h);
//   EVA.E_flows[17] = max(0.0, EVA.m_flows[16]) * (EVA.fluid[16].h - EVA.fluid[17].h) + max(0.0, -EVA.m_flows[17]) * (EVA.fluid[18].h - EVA.fluid[17].h);
//   EVA.E_flows[18] = max(0.0, EVA.m_flows[17]) * (EVA.fluid[17].h - EVA.fluid[18].h) + max(0.0, -EVA.m_flows[18]) * (EVA.fluid[19].h - EVA.fluid[18].h);
//   EVA.E_flows[19] = max(0.0, EVA.m_flows[18]) * (EVA.fluid[18].h - EVA.fluid[19].h) + max(0.0, -EVA.m_flows[19]) * (EVA.fluid[20].h - EVA.fluid[19].h);
//   EVA.E_flows[20] = max(0.0, EVA.m_flows[19]) * (EVA.fluid[19].h - EVA.fluid[20].h) + max(0.0, -EVA.m_flows[20]) * (watersink_ph.port.h_outflow - EVA.fluid[20].h);
//   EVA.portIn.h_outflow = EVA.fluid[1].h;
//   EVA.portOut.h_outflow = EVA.fluid[20].h;
//   EVA.VCell * EVA.fluid[1].d * der(EVA.fluid[1].h) = EVA.E_flows[1] + EVA.heatedArea * EVA.qHeating[1] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[2].d * der(EVA.fluid[2].h) = EVA.E_flows[2] + EVA.heatedArea * EVA.qHeating[2] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[3].d * der(EVA.fluid[3].h) = EVA.E_flows[3] + EVA.heatedArea * EVA.qHeating[3] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[4].d * der(EVA.fluid[4].h) = EVA.E_flows[4] + EVA.heatedArea * EVA.qHeating[4] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[5].d * der(EVA.fluid[5].h) = EVA.E_flows[5] + EVA.heatedArea * EVA.qHeating[5] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[6].d * der(EVA.fluid[6].h) = EVA.E_flows[6] + EVA.heatedArea * EVA.qHeating[6] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[7].d * der(EVA.fluid[7].h) = EVA.E_flows[7] + EVA.heatedArea * EVA.qHeating[7] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[8].d * der(EVA.fluid[8].h) = EVA.E_flows[8] + EVA.heatedArea * EVA.qHeating[8] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[9].d * der(EVA.fluid[9].h) = EVA.E_flows[9] + EVA.heatedArea * EVA.qHeating[9] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[10].d * der(EVA.fluid[10].h) = EVA.E_flows[10] + EVA.heatedArea * EVA.qHeating[10] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[11].d * der(EVA.fluid[11].h) = EVA.E_flows[11] + EVA.heatedArea * EVA.qHeating[11] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[12].d * der(EVA.fluid[12].h) = EVA.E_flows[12] + EVA.heatedArea * EVA.qHeating[12] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[13].d * der(EVA.fluid[13].h) = EVA.E_flows[13] + EVA.heatedArea * EVA.qHeating[13] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[14].d * der(EVA.fluid[14].h) = EVA.E_flows[14] + EVA.heatedArea * EVA.qHeating[14] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[15].d * der(EVA.fluid[15].h) = EVA.E_flows[15] + EVA.heatedArea * EVA.qHeating[15] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[16].d * der(EVA.fluid[16].h) = EVA.E_flows[16] + EVA.heatedArea * EVA.qHeating[16] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[17].d * der(EVA.fluid[17].h) = EVA.E_flows[17] + EVA.heatedArea * EVA.qHeating[17] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[18].d * der(EVA.fluid[18].h) = EVA.E_flows[18] + EVA.heatedArea * EVA.qHeating[18] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[19].d * der(EVA.fluid[19].h) = EVA.E_flows[19] + EVA.heatedArea * EVA.qHeating[19] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.VCell * EVA.fluid[20].d * der(EVA.fluid[20].h) = EVA.E_flows[20] + EVA.heatedArea * EVA.qHeating[20] / Real(EVA.numberOfNodes * EVA.geoPipe.Nt);
//   EVA.state_from_a = SiemensPower.Components.Pipes.Tube.Medium.setState_phX(EVA.portIn.p, ECO.portOut.h_outflow, {}, 0);
//   EVA.state_from_b = SiemensPower.Components.Pipes.Tube.Medium.setState_phX(EVA.portOut.p, watersink_ph.port.h_outflow, {}, 0);
//   if noEvent(EVA.portIn.m_flow >= 0.0) then
//   EVA.hIn = ECO.portOut.h_outflow;
//   else
//   EVA.hIn = EVA.portIn.h_outflow;
//   end if;
//   if noEvent(EVA.portOut.m_flow >= 0.0) then
//   EVA.hOut = watersink_ph.port.h_outflow;
//   else
//   EVA.hOut = EVA.portOut.h_outflow;
//   end if;
//   EVA.dp = EVA.portIn.p - EVA.portOut.p;
//   ECO.heatport.TWall[1] = ECO.heatport.port[1].T;
//   ECO.heatport.TWall[2] = ECO.heatport.port[2].T;
//   ECO.heatport.TWall[3] = ECO.heatport.port[3].T;
//   ECO.heatport.TWall[4] = ECO.heatport.port[4].T;
//   ECO.heatport.TWall[5] = ECO.heatport.port[5].T;
//   ECO.heatport.TWall[6] = ECO.heatport.port[6].T;
//   ECO.heatport.TWall[7] = ECO.heatport.port[7].T;
//   ECO.heatport.TWall[8] = ECO.heatport.port[8].T;
//   ECO.heatport.TWall[9] = ECO.heatport.port[9].T;
//   ECO.heatport.TWall[10] = ECO.heatport.port[10].T;
//   ECO.heatport.Q_flow[1] = ECO.heatport.port[1].Q_flow;
//   ECO.heatport.Q_flow[2] = ECO.heatport.port[2].Q_flow;
//   ECO.heatport.Q_flow[3] = ECO.heatport.port[3].Q_flow;
//   ECO.heatport.Q_flow[4] = ECO.heatport.port[4].Q_flow;
//   ECO.heatport.Q_flow[5] = ECO.heatport.port[5].Q_flow;
//   ECO.heatport.Q_flow[6] = ECO.heatport.port[6].Q_flow;
//   ECO.heatport.Q_flow[7] = ECO.heatport.port[7].Q_flow;
//   ECO.heatport.Q_flow[8] = ECO.heatport.port[8].Q_flow;
//   ECO.heatport.Q_flow[9] = ECO.heatport.port[9].Q_flow;
//   ECO.heatport.Q_flow[10] = ECO.heatport.port[10].Q_flow;
//   ECO.fluid[1].MM = 0.018015268;
//   ECO.fluid[1].phase = if ECO.fluid[1].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[1].sat) or ECO.fluid[1].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[1].sat) or ECO.fluid[1].p > 22064000.0 then 1 else 2;
//   ECO.fluid[1].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[1].p, ECO.fluid[1].h, ECO.fluid[1].phase);
//   ECO.fluid[1].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[1].p, ECO.fluid[1].h, ECO.fluid[1].phase);
//   ECO.fluid[1].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[1].p);
//   ECO.fluid[1].sat.psat = ECO.fluid[1].p;
//   ECO.fluid[1].u = ECO.fluid[1].h + (-ECO.fluid[1].p) / ECO.fluid[1].d;
//   ECO.fluid[1].R = 461.5236365065454;
//   ECO.fluid[1].h = ECO.fluid[1].state.h;
//   ECO.fluid[1].p = ECO.fluid[1].state.p;
//   ECO.fluid[1].T = ECO.fluid[1].state.T;
//   ECO.fluid[1].d = ECO.fluid[1].state.d;
//   ECO.fluid[1].phase = ECO.fluid[1].state.phase;
//   ECO.fluid[1].X[1] = 1.0;
//   assert(ECO.fluid[1].X[1] >= -0.00001 and ECO.fluid[1].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[1].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[1].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[1].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[1].T, 0, true, 6) + \" K)\");
//   ECO.fluid[2].MM = 0.018015268;
//   ECO.fluid[2].phase = if ECO.fluid[2].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[2].sat) or ECO.fluid[2].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[2].sat) or ECO.fluid[2].p > 22064000.0 then 1 else 2;
//   ECO.fluid[2].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[2].p, ECO.fluid[2].h, ECO.fluid[2].phase);
//   ECO.fluid[2].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[2].p, ECO.fluid[2].h, ECO.fluid[2].phase);
//   ECO.fluid[2].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[2].p);
//   ECO.fluid[2].sat.psat = ECO.fluid[2].p;
//   ECO.fluid[2].u = ECO.fluid[2].h + (-ECO.fluid[2].p) / ECO.fluid[2].d;
//   ECO.fluid[2].R = 461.5236365065454;
//   ECO.fluid[2].h = ECO.fluid[2].state.h;
//   ECO.fluid[2].p = ECO.fluid[2].state.p;
//   ECO.fluid[2].T = ECO.fluid[2].state.T;
//   ECO.fluid[2].d = ECO.fluid[2].state.d;
//   ECO.fluid[2].phase = ECO.fluid[2].state.phase;
//   ECO.fluid[2].X[1] = 1.0;
//   assert(ECO.fluid[2].X[1] >= -0.00001 and ECO.fluid[2].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[2].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[2].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[2].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[2].T, 0, true, 6) + \" K)\");
//   ECO.fluid[3].MM = 0.018015268;
//   ECO.fluid[3].phase = if ECO.fluid[3].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[3].sat) or ECO.fluid[3].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[3].sat) or ECO.fluid[3].p > 22064000.0 then 1 else 2;
//   ECO.fluid[3].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[3].p, ECO.fluid[3].h, ECO.fluid[3].phase);
//   ECO.fluid[3].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[3].p, ECO.fluid[3].h, ECO.fluid[3].phase);
//   ECO.fluid[3].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[3].p);
//   ECO.fluid[3].sat.psat = ECO.fluid[3].p;
//   ECO.fluid[3].u = ECO.fluid[3].h + (-ECO.fluid[3].p) / ECO.fluid[3].d;
//   ECO.fluid[3].R = 461.5236365065454;
//   ECO.fluid[3].h = ECO.fluid[3].state.h;
//   ECO.fluid[3].p = ECO.fluid[3].state.p;
//   ECO.fluid[3].T = ECO.fluid[3].state.T;
//   ECO.fluid[3].d = ECO.fluid[3].state.d;
//   ECO.fluid[3].phase = ECO.fluid[3].state.phase;
//   ECO.fluid[3].X[1] = 1.0;
//   assert(ECO.fluid[3].X[1] >= -0.00001 and ECO.fluid[3].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[3].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[3].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[3].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[3].T, 0, true, 6) + \" K)\");
//   ECO.fluid[4].MM = 0.018015268;
//   ECO.fluid[4].phase = if ECO.fluid[4].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[4].sat) or ECO.fluid[4].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[4].sat) or ECO.fluid[4].p > 22064000.0 then 1 else 2;
//   ECO.fluid[4].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[4].p, ECO.fluid[4].h, ECO.fluid[4].phase);
//   ECO.fluid[4].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[4].p, ECO.fluid[4].h, ECO.fluid[4].phase);
//   ECO.fluid[4].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[4].p);
//   ECO.fluid[4].sat.psat = ECO.fluid[4].p;
//   ECO.fluid[4].u = ECO.fluid[4].h + (-ECO.fluid[4].p) / ECO.fluid[4].d;
//   ECO.fluid[4].R = 461.5236365065454;
//   ECO.fluid[4].h = ECO.fluid[4].state.h;
//   ECO.fluid[4].p = ECO.fluid[4].state.p;
//   ECO.fluid[4].T = ECO.fluid[4].state.T;
//   ECO.fluid[4].d = ECO.fluid[4].state.d;
//   ECO.fluid[4].phase = ECO.fluid[4].state.phase;
//   ECO.fluid[4].X[1] = 1.0;
//   assert(ECO.fluid[4].X[1] >= -0.00001 and ECO.fluid[4].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[4].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[4].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[4].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[4].T, 0, true, 6) + \" K)\");
//   ECO.fluid[5].MM = 0.018015268;
//   ECO.fluid[5].phase = if ECO.fluid[5].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[5].sat) or ECO.fluid[5].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[5].sat) or ECO.fluid[5].p > 22064000.0 then 1 else 2;
//   ECO.fluid[5].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[5].p, ECO.fluid[5].h, ECO.fluid[5].phase);
//   ECO.fluid[5].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[5].p, ECO.fluid[5].h, ECO.fluid[5].phase);
//   ECO.fluid[5].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[5].p);
//   ECO.fluid[5].sat.psat = ECO.fluid[5].p;
//   ECO.fluid[5].u = ECO.fluid[5].h + (-ECO.fluid[5].p) / ECO.fluid[5].d;
//   ECO.fluid[5].R = 461.5236365065454;
//   ECO.fluid[5].h = ECO.fluid[5].state.h;
//   ECO.fluid[5].p = ECO.fluid[5].state.p;
//   ECO.fluid[5].T = ECO.fluid[5].state.T;
//   ECO.fluid[5].d = ECO.fluid[5].state.d;
//   ECO.fluid[5].phase = ECO.fluid[5].state.phase;
//   ECO.fluid[5].X[1] = 1.0;
//   assert(ECO.fluid[5].X[1] >= -0.00001 and ECO.fluid[5].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[5].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[5].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[5].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[5].T, 0, true, 6) + \" K)\");
//   ECO.fluid[6].MM = 0.018015268;
//   ECO.fluid[6].phase = if ECO.fluid[6].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[6].sat) or ECO.fluid[6].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[6].sat) or ECO.fluid[6].p > 22064000.0 then 1 else 2;
//   ECO.fluid[6].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[6].p, ECO.fluid[6].h, ECO.fluid[6].phase);
//   ECO.fluid[6].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[6].p, ECO.fluid[6].h, ECO.fluid[6].phase);
//   ECO.fluid[6].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[6].p);
//   ECO.fluid[6].sat.psat = ECO.fluid[6].p;
//   ECO.fluid[6].u = ECO.fluid[6].h + (-ECO.fluid[6].p) / ECO.fluid[6].d;
//   ECO.fluid[6].R = 461.5236365065454;
//   ECO.fluid[6].h = ECO.fluid[6].state.h;
//   ECO.fluid[6].p = ECO.fluid[6].state.p;
//   ECO.fluid[6].T = ECO.fluid[6].state.T;
//   ECO.fluid[6].d = ECO.fluid[6].state.d;
//   ECO.fluid[6].phase = ECO.fluid[6].state.phase;
//   ECO.fluid[6].X[1] = 1.0;
//   assert(ECO.fluid[6].X[1] >= -0.00001 and ECO.fluid[6].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[6].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[6].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[6].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[6].T, 0, true, 6) + \" K)\");
//   ECO.fluid[7].MM = 0.018015268;
//   ECO.fluid[7].phase = if ECO.fluid[7].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[7].sat) or ECO.fluid[7].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[7].sat) or ECO.fluid[7].p > 22064000.0 then 1 else 2;
//   ECO.fluid[7].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[7].p, ECO.fluid[7].h, ECO.fluid[7].phase);
//   ECO.fluid[7].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[7].p, ECO.fluid[7].h, ECO.fluid[7].phase);
//   ECO.fluid[7].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[7].p);
//   ECO.fluid[7].sat.psat = ECO.fluid[7].p;
//   ECO.fluid[7].u = ECO.fluid[7].h + (-ECO.fluid[7].p) / ECO.fluid[7].d;
//   ECO.fluid[7].R = 461.5236365065454;
//   ECO.fluid[7].h = ECO.fluid[7].state.h;
//   ECO.fluid[7].p = ECO.fluid[7].state.p;
//   ECO.fluid[7].T = ECO.fluid[7].state.T;
//   ECO.fluid[7].d = ECO.fluid[7].state.d;
//   ECO.fluid[7].phase = ECO.fluid[7].state.phase;
//   ECO.fluid[7].X[1] = 1.0;
//   assert(ECO.fluid[7].X[1] >= -0.00001 and ECO.fluid[7].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[7].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[7].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[7].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[7].T, 0, true, 6) + \" K)\");
//   ECO.fluid[8].MM = 0.018015268;
//   ECO.fluid[8].phase = if ECO.fluid[8].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[8].sat) or ECO.fluid[8].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[8].sat) or ECO.fluid[8].p > 22064000.0 then 1 else 2;
//   ECO.fluid[8].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[8].p, ECO.fluid[8].h, ECO.fluid[8].phase);
//   ECO.fluid[8].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[8].p, ECO.fluid[8].h, ECO.fluid[8].phase);
//   ECO.fluid[8].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[8].p);
//   ECO.fluid[8].sat.psat = ECO.fluid[8].p;
//   ECO.fluid[8].u = ECO.fluid[8].h + (-ECO.fluid[8].p) / ECO.fluid[8].d;
//   ECO.fluid[8].R = 461.5236365065454;
//   ECO.fluid[8].h = ECO.fluid[8].state.h;
//   ECO.fluid[8].p = ECO.fluid[8].state.p;
//   ECO.fluid[8].T = ECO.fluid[8].state.T;
//   ECO.fluid[8].d = ECO.fluid[8].state.d;
//   ECO.fluid[8].phase = ECO.fluid[8].state.phase;
//   ECO.fluid[8].X[1] = 1.0;
//   assert(ECO.fluid[8].X[1] >= -0.00001 and ECO.fluid[8].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[8].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[8].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[8].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[8].T, 0, true, 6) + \" K)\");
//   ECO.fluid[9].MM = 0.018015268;
//   ECO.fluid[9].phase = if ECO.fluid[9].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[9].sat) or ECO.fluid[9].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[9].sat) or ECO.fluid[9].p > 22064000.0 then 1 else 2;
//   ECO.fluid[9].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[9].p, ECO.fluid[9].h, ECO.fluid[9].phase);
//   ECO.fluid[9].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[9].p, ECO.fluid[9].h, ECO.fluid[9].phase);
//   ECO.fluid[9].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[9].p);
//   ECO.fluid[9].sat.psat = ECO.fluid[9].p;
//   ECO.fluid[9].u = ECO.fluid[9].h + (-ECO.fluid[9].p) / ECO.fluid[9].d;
//   ECO.fluid[9].R = 461.5236365065454;
//   ECO.fluid[9].h = ECO.fluid[9].state.h;
//   ECO.fluid[9].p = ECO.fluid[9].state.p;
//   ECO.fluid[9].T = ECO.fluid[9].state.T;
//   ECO.fluid[9].d = ECO.fluid[9].state.d;
//   ECO.fluid[9].phase = ECO.fluid[9].state.phase;
//   ECO.fluid[9].X[1] = 1.0;
//   assert(ECO.fluid[9].X[1] >= -0.00001 and ECO.fluid[9].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[9].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[9].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[9].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[9].T, 0, true, 6) + \" K)\");
//   ECO.fluid[10].MM = 0.018015268;
//   ECO.fluid[10].phase = if ECO.fluid[10].h < SiemensPower.Components.Pipes.Tube.Medium.bubbleEnthalpy(ECO.fluid[10].sat) or ECO.fluid[10].h > SiemensPower.Components.Pipes.Tube.Medium.dewEnthalpy(ECO.fluid[10].sat) or ECO.fluid[10].p > 22064000.0 then 1 else 2;
//   ECO.fluid[10].d = SiemensPower.Components.Pipes.Tube.Medium.density_ph(ECO.fluid[10].p, ECO.fluid[10].h, ECO.fluid[10].phase);
//   ECO.fluid[10].T = SiemensPower.Components.Pipes.Tube.Medium.temperature_ph(ECO.fluid[10].p, ECO.fluid[10].h, ECO.fluid[10].phase);
//   ECO.fluid[10].sat.Tsat = SiemensPower.Components.Pipes.Tube.Medium.saturationTemperature(ECO.fluid[10].p);
//   ECO.fluid[10].sat.psat = ECO.fluid[10].p;
//   ECO.fluid[10].u = ECO.fluid[10].h + (-ECO.fluid[10].p) / ECO.fluid[10].d;
//   ECO.fluid[10].R = 461.5236365065454;
//   ECO.fluid[10].h = ECO.fluid[10].state.h;
//   ECO.fluid[10].p = ECO.fluid[10].state.p;
//   ECO.fluid[10].T = ECO.fluid[10].state.T;
//   ECO.fluid[10].d = ECO.fluid[10].state.d;
//   ECO.fluid[10].phase = ECO.fluid[10].state.phase;
//   ECO.fluid[10].X[1] = 1.0;
//   assert(ECO.fluid[10].X[1] >= -0.00001 and ECO.fluid[10].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(ECO.fluid[10].X[1], 0, true, 6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(ECO.fluid[10].p >= 0.0,\"Pressure (= \" + String(ECO.fluid[10].p, 0, true, 6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(ECO.fluid[10].T, 0, true, 6) + \" K)\");
//   ECO.friction.dp / ECO.friction.dz = Modelica.Fluid.Dissipation.PressureLoss.General.dp_pressureLossCoefficient_DP(ECO.friction.DPMFLOW_ADD_IN_con, ECO.friction.DPMFLOW_ADD_IN_var, ECO.friction.m_flow) / ECO.friction.geoPipe.L + Modelica.Fluid.Dissipation.PressureLoss.StraightPipe.dp_overall_DP(ECO.friction.DPMFLOW_IN_con, ECO.friction.DPMFLOW_IN_var, ECO.friction.m_flow) / ECO.friction.dz;
//   ECO.wall.layer[1].rint = 0.5 * ECO.wall.layer[1].diameterInner;
//   ECO.wall.layer[1].rext = 0.5 * ECO.wall.layer[1].diameterInner + ECO.wall.layer[1].wallThickness;
//   ECO.wall.layer[1].Tube_mass = Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.rho * ECO.wall.layer[1].Am * ECO.wall.layer[1].length / Real(ECO.wall.layer[1].numberOfNodes);
//   ECO.wall.layer[1].HeatCap = ECO.wall.layer[1].metal.cp * ECO.wall.layer[1].Tube_mass;
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[1]) = ECO.wall.layer[1].port_int[1].Q_flow + ECO.wall.layer[1].port_ext[1].Q_flow;
//   ECO.wall.layer[1].port_int[1].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[1].T - ECO.wall.layer[1].T[1]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[1].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[1].T - ECO.wall.layer[1].T[1]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[2]) = ECO.wall.layer[1].port_int[2].Q_flow + ECO.wall.layer[1].port_ext[2].Q_flow;
//   ECO.wall.layer[1].port_int[2].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[2].T - ECO.wall.layer[1].T[2]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[2].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[2].T - ECO.wall.layer[1].T[2]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[3]) = ECO.wall.layer[1].port_int[3].Q_flow + ECO.wall.layer[1].port_ext[3].Q_flow;
//   ECO.wall.layer[1].port_int[3].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[3].T - ECO.wall.layer[1].T[3]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[3].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[3].T - ECO.wall.layer[1].T[3]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[4]) = ECO.wall.layer[1].port_int[4].Q_flow + ECO.wall.layer[1].port_ext[4].Q_flow;
//   ECO.wall.layer[1].port_int[4].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[4].T - ECO.wall.layer[1].T[4]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[4].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[4].T - ECO.wall.layer[1].T[4]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[5]) = ECO.wall.layer[1].port_int[5].Q_flow + ECO.wall.layer[1].port_ext[5].Q_flow;
//   ECO.wall.layer[1].port_int[5].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[5].T - ECO.wall.layer[1].T[5]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[5].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[5].T - ECO.wall.layer[1].T[5]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[6]) = ECO.wall.layer[1].port_int[6].Q_flow + ECO.wall.layer[1].port_ext[6].Q_flow;
//   ECO.wall.layer[1].port_int[6].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[6].T - ECO.wall.layer[1].T[6]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[6].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[6].T - ECO.wall.layer[1].T[6]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[7]) = ECO.wall.layer[1].port_int[7].Q_flow + ECO.wall.layer[1].port_ext[7].Q_flow;
//   ECO.wall.layer[1].port_int[7].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[7].T - ECO.wall.layer[1].T[7]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[7].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[7].T - ECO.wall.layer[1].T[7]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[8]) = ECO.wall.layer[1].port_int[8].Q_flow + ECO.wall.layer[1].port_ext[8].Q_flow;
//   ECO.wall.layer[1].port_int[8].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[8].T - ECO.wall.layer[1].T[8]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[8].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[8].T - ECO.wall.layer[1].T[8]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[9]) = ECO.wall.layer[1].port_int[9].Q_flow + ECO.wall.layer[1].port_ext[9].Q_flow;
//   ECO.wall.layer[1].port_int[9].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[9].T - ECO.wall.layer[1].T[9]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[9].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[9].T - ECO.wall.layer[1].T[9]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].HeatCap * der(ECO.wall.layer[1].T[10]) = ECO.wall.layer[1].port_int[10].Q_flow + ECO.wall.layer[1].port_ext[10].Q_flow;
//   ECO.wall.layer[1].port_int[10].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_int[10].T - ECO.wall.layer[1].T[10]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((-1.0 + ECO.wall.layer[1].rext / ECO.wall.layer[1].rint) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].port_ext[10].Q_flow = 12.566370614359172 * (ECO.wall.layer[1].port_ext[10].T - ECO.wall.layer[1].T[10]) * Real(ECO.wall.layer[1].numberOfParallelTubes) * ECO.wall.layer[1].metal.lambda * ECO.wall.layer[1].length / ((1.0 + (-ECO.wall.layer[1].rint) / ECO.wall.layer[1].rext) * Real(ECO.wall.layer[1].numberOfNodes));
//   ECO.wall.layer[1].Am = 3.141592653589793 * (ECO.wall.layer[1].rext ^ 2.0 - ECO.wall.layer[1].rint ^ 2.0);
//   ECO.wall.layer[2].rint = 0.5 * ECO.wall.layer[2].diameterInner;
//   ECO.wall.layer[2].rext = 0.5 * ECO.wall.layer[2].diameterInner + ECO.wall.layer[2].wallThickness;
//   ECO.wall.layer[2].Tube_mass = Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.rho * ECO.wall.layer[2].Am * ECO.wall.layer[2].length / Real(ECO.wall.layer[2].numberOfNodes);
//   ECO.wall.layer[2].HeatCap = ECO.wall.layer[2].metal.cp * ECO.wall.layer[2].Tube_mass;
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[1]) = ECO.wall.layer[2].port_int[1].Q_flow + ECO.wall.layer[2].port_ext[1].Q_flow;
//   ECO.wall.layer[2].port_int[1].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[1].T - ECO.wall.layer[2].T[1]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[1].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[1].T - ECO.wall.layer[2].T[1]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[2]) = ECO.wall.layer[2].port_int[2].Q_flow + ECO.wall.layer[2].port_ext[2].Q_flow;
//   ECO.wall.layer[2].port_int[2].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[2].T - ECO.wall.layer[2].T[2]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[2].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[2].T - ECO.wall.layer[2].T[2]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[3]) = ECO.wall.layer[2].port_int[3].Q_flow + ECO.wall.layer[2].port_ext[3].Q_flow;
//   ECO.wall.layer[2].port_int[3].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[3].T - ECO.wall.layer[2].T[3]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[3].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[3].T - ECO.wall.layer[2].T[3]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[4]) = ECO.wall.layer[2].port_int[4].Q_flow + ECO.wall.layer[2].port_ext[4].Q_flow;
//   ECO.wall.layer[2].port_int[4].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[4].T - ECO.wall.layer[2].T[4]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[4].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[4].T - ECO.wall.layer[2].T[4]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[5]) = ECO.wall.layer[2].port_int[5].Q_flow + ECO.wall.layer[2].port_ext[5].Q_flow;
//   ECO.wall.layer[2].port_int[5].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[5].T - ECO.wall.layer[2].T[5]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[5].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[5].T - ECO.wall.layer[2].T[5]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[6]) = ECO.wall.layer[2].port_int[6].Q_flow + ECO.wall.layer[2].port_ext[6].Q_flow;
//   ECO.wall.layer[2].port_int[6].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[6].T - ECO.wall.layer[2].T[6]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[6].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[6].T - ECO.wall.layer[2].T[6]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[7]) = ECO.wall.layer[2].port_int[7].Q_flow + ECO.wall.layer[2].port_ext[7].Q_flow;
//   ECO.wall.layer[2].port_int[7].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[7].T - ECO.wall.layer[2].T[7]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[7].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[7].T - ECO.wall.layer[2].T[7]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[8]) = ECO.wall.layer[2].port_int[8].Q_flow + ECO.wall.layer[2].port_ext[8].Q_flow;
//   ECO.wall.layer[2].port_int[8].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[8].T - ECO.wall.layer[2].T[8]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[8].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[8].T - ECO.wall.layer[2].T[8]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[9]) = ECO.wall.layer[2].port_int[9].Q_flow + ECO.wall.layer[2].port_ext[9].Q_flow;
//   ECO.wall.layer[2].port_int[9].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[9].T - ECO.wall.layer[2].T[9]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[9].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[9].T - ECO.wall.layer[2].T[9]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].HeatCap * der(ECO.wall.layer[2].T[10]) = ECO.wall.layer[2].port_int[10].Q_flow + ECO.wall.layer[2].port_ext[10].Q_flow;
//   ECO.wall.layer[2].port_int[10].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_int[10].T - ECO.wall.layer[2].T[10]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((-1.0 + ECO.wall.layer[2].rext / ECO.wall.layer[2].rint) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].port_ext[10].Q_flow = 12.566370614359172 * (ECO.wall.layer[2].port_ext[10].T - ECO.wall.layer[2].T[10]) * Real(ECO.wall.layer[2].numberOfParallelTubes) * ECO.wall.layer[2].metal.lambda * ECO.wall.layer[2].length / ((1.0 + (-ECO.wall.layer[2].rint) / ECO.wall.layer[2].rext) * Real(ECO.wall.layer[2].numberOfNodes));
//   ECO.wall.layer[2].Am = 3.141592653589793 * (ECO.wall.layer[2].rext ^ 2.0 - ECO.wall.layer[2].rint ^ 2.0);
//   ECO.wall.layer[3].rint = 0.5 * ECO.wall.layer[3].diameterInner;
//   ECO.wall.layer[3].rext = 0.5 * ECO.wall.layer[3].diameterInner + ECO.wall.layer[3].wallThickness;
//   ECO.wall.layer[3].Tube_mass = Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.rho * ECO.wall.layer[3].Am * ECO.wall.layer[3].length / Real(ECO.wall.layer[3].numberOfNodes);
//   ECO.wall.layer[3].HeatCap = ECO.wall.layer[3].metal.cp * ECO.wall.layer[3].Tube_mass;
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[1]) = ECO.wall.layer[3].port_int[1].Q_flow + ECO.wall.layer[3].port_ext[1].Q_flow;
//   ECO.wall.layer[3].port_int[1].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[1].T - ECO.wall.layer[3].T[1]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[1].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[1].T - ECO.wall.layer[3].T[1]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[2]) = ECO.wall.layer[3].port_int[2].Q_flow + ECO.wall.layer[3].port_ext[2].Q_flow;
//   ECO.wall.layer[3].port_int[2].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[2].T - ECO.wall.layer[3].T[2]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[2].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[2].T - ECO.wall.layer[3].T[2]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[3]) = ECO.wall.layer[3].port_int[3].Q_flow + ECO.wall.layer[3].port_ext[3].Q_flow;
//   ECO.wall.layer[3].port_int[3].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[3].T - ECO.wall.layer[3].T[3]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[3].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[3].T - ECO.wall.layer[3].T[3]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[4]) = ECO.wall.layer[3].port_int[4].Q_flow + ECO.wall.layer[3].port_ext[4].Q_flow;
//   ECO.wall.layer[3].port_int[4].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[4].T - ECO.wall.layer[3].T[4]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[4].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[4].T - ECO.wall.layer[3].T[4]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[5]) = ECO.wall.layer[3].port_int[5].Q_flow + ECO.wall.layer[3].port_ext[5].Q_flow;
//   ECO.wall.layer[3].port_int[5].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[5].T - ECO.wall.layer[3].T[5]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[5].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[5].T - ECO.wall.layer[3].T[5]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[6]) = ECO.wall.layer[3].port_int[6].Q_flow + ECO.wall.layer[3].port_ext[6].Q_flow;
//   ECO.wall.layer[3].port_int[6].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[6].T - ECO.wall.layer[3].T[6]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[6].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[6].T - ECO.wall.layer[3].T[6]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[7]) = ECO.wall.layer[3].port_int[7].Q_flow + ECO.wall.layer[3].port_ext[7].Q_flow;
//   ECO.wall.layer[3].port_int[7].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[7].T - ECO.wall.layer[3].T[7]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[7].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[7].T - ECO.wall.layer[3].T[7]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[8]) = ECO.wall.layer[3].port_int[8].Q_flow + ECO.wall.layer[3].port_ext[8].Q_flow;
//   ECO.wall.layer[3].port_int[8].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[8].T - ECO.wall.layer[3].T[8]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[8].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[8].T - ECO.wall.layer[3].T[8]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[9]) = ECO.wall.layer[3].port_int[9].Q_flow + ECO.wall.layer[3].port_ext[9].Q_flow;
//   ECO.wall.layer[3].port_int[9].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[9].T - ECO.wall.layer[3].T[9]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[9].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[9].T - ECO.wall.layer[3].T[9]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].HeatCap * der(ECO.wall.layer[3].T[10]) = ECO.wall.layer[3].port_int[10].Q_flow + ECO.wall.layer[3].port_ext[10].Q_flow;
//   ECO.wall.layer[3].port_int[10].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_int[10].T - ECO.wall.layer[3].T[10]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((-1.0 + ECO.wall.layer[3].rext / ECO.wall.layer[3].rint) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].port_ext[10].Q_flow = 12.566370614359172 * (ECO.wall.layer[3].port_ext[10].T - ECO.wall.layer[3].T[10]) * Real(ECO.wall.layer[3].numberOfParallelTubes) * ECO.wall.layer[3].metal.lambda * ECO.wall.layer[3].length / ((1.0 + (-ECO.wall.layer[3].rint) / ECO.wall.layer[3].rext) * Real(ECO.wall.layer[3].numberOfNodes));
//   ECO.wall.layer[3].Am = 3.141592653589793 * (ECO.wall.layer[3].rext ^ 2.0 - ECO.wall.layer[3].rint ^ 2.0);
//   ECO.HT[1].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[1].KC_IN_con, ECO.HT[1].KC_IN_var);
//   ECO.HT[2].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[2].KC_IN_con, ECO.HT[2].KC_IN_var);
//   ECO.HT[3].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[3].KC_IN_con, ECO.HT[3].KC_IN_var);
//   ECO.HT[4].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[4].KC_IN_con, ECO.HT[4].KC_IN_var);
//   ECO.HT[5].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[5].KC_IN_con, ECO.HT[5].KC_IN_var);
//   ECO.HT[6].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[6].KC_IN_con, ECO.HT[6].KC_IN_var);
//   ECO.HT[7].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[7].KC_IN_con, ECO.HT[7].KC_IN_var);
//   ECO.HT[8].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[8].KC_IN_con, ECO.HT[8].KC_IN_var);
//   ECO.HT[9].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[9].KC_IN_con, ECO.HT[9].KC_IN_var);
//   ECO.HT[10].alpha = Modelica.Fluid.Dissipation.HeatTransfer.StraightPipe.kc_overall_KC(ECO.HT[10].KC_IN_con, ECO.HT[10].KC_IN_var);
//   ECO.alpha[1] = ECO.HT[1].alpha;
//   ECO.qMetalFluid[1] = ECO.alpha[1] * (ECO.TWall[1] - ECO.fluid[1].T);
//   ECO.alpha[2] = ECO.HT[2].alpha;
//   ECO.qMetalFluid[2] = ECO.alpha[2] * (ECO.TWall[2] - ECO.fluid[2].T);
//   ECO.alpha[3] = ECO.HT[3].alpha;
//   ECO.qMetalFluid[3] = ECO.alpha[3] * (ECO.TWall[3] - ECO.fluid[3].T);
//   ECO.alpha[4] = ECO.HT[4].alpha;
//   ECO.qMetalFluid[4] = ECO.alpha[4] * (ECO.TWall[4] - ECO.fluid[4].T);
//   ECO.alpha[5] = ECO.HT[5].alpha;
//   ECO.qMetalFluid[5] = ECO.alpha[5] * (ECO.TWall[5] - ECO.fluid[5].T);
//   ECO.alpha[6] = ECO.HT[6].alpha;
//   ECO.qMetalFluid[6] = ECO.alpha[6] * (ECO.TWall[6] - ECO.fluid[6].T);
//   ECO.alpha[7] = ECO.HT[7].alpha;
//   ECO.qMetalFluid[7] = ECO.alpha[7] * (ECO.TWall[7] - ECO.fluid[7].T);
//   ECO.alpha[8] = ECO.HT[8].alpha;
//   ECO.qMetalFluid[8] = ECO.alpha[8] * (ECO.TWall[8] - ECO.fluid[8].T);
//   ECO.alpha[9] = ECO.HT[9].alpha;
//   ECO.qMetalFluid[9] = ECO.alpha[9] * (ECO.TWall[9] - ECO.fluid[9].T);
//   ECO.alpha[10] = ECO.HT[10].alpha;
//   ECO.qMetalFluid[10] = ECO.alpha[10] * (ECO.TWall[10] - ECO.fluid[10].T);
//   ECO.heatport.Q_flow[1] = ECO.qMetalFluid[1] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[2] = ECO.qMetalFluid[2] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[3] = ECO.qMetalFluid[3] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[4] = ECO.qMetalFluid[4] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[5] = ECO.qMetalFluid[5] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[6] = ECO.qMetalFluid[6] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[7] = ECO.qMetalFluid[7] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[8] = ECO.qMetalFluid[8] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[9] = ECO.qMetalFluid[9] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.heatport.Q_flow[10] = ECO.qMetalFluid[10] * ECO.heatedArea / Real(ECO.numberOfNodes);
//   ECO.p = ECO.hydP * ECO.portIn.p + (1.0 - ECO.hydP) * ECO.portOut.p;
//   ECO.m_flowsZero = (ECO.hydM * ECO.portIn.m_flow - (1.0 - ECO.hydM) * ECO.portOut.m_flow) / Real(ECO.geoPipe.Nt);
//   ECO.m_flows[1] = ECO.m_flowsZero;
//   ECO.m_flows[2] = ECO.m_flowsZero;
//   ECO.m_flows[3] = ECO.m_flowsZero;
//   ECO.m_flows[4] = ECO.m_flowsZero;
//   ECO.m_flows[5] = ECO.m_flowsZero;
//   ECO.m_flows[6] = ECO.m_flowsZero;
//   ECO.m_flows[7] = ECO.m_flowsZero;
//   ECO.m_flows[8] = ECO.m_flowsZero;
//   ECO.m_flows[9] = ECO.m_flowsZero;
//   ECO.m_flows[10] = ECO.m_flowsZero;
//   ECO.dpfric = ECO.friction.dp;
//   ECO.dphyd = 9.80665 * ECO.geoPipe.H * ECO.d_av;
//   ECO.VTotal * der(ECO.d_av) = ECO.portIn.m_flow + ECO.portOut.m_flow;
//   der(ECO.m_flows[1]) * ECO.geoPipe.L / ECO.A = ECO.portIn.p + (-ECO.dpfric) - ECO.dphyd - ECO.portOut.p;
//   ECO.fluid[1].p = ECO.p;
//   ECO.fluid[2].p = ECO.p;
//   ECO.fluid[3].p = ECO.p;
//   ECO.fluid[4].p = ECO.p;
//   ECO.fluid[5].p = ECO.p;
//   ECO.fluid[6].p = ECO.p;
//   ECO.fluid[7].p = ECO.p;
//   ECO.fluid[8].p = ECO.p;
//   ECO.fluid[9].p = ECO.p;
//   ECO.fluid[10].p = ECO.p;
//   ECO.fluid[1].d = ECO.d[1];
//   ECO.fluid[2].d = ECO.d[2];
//   ECO.fluid[3].d = ECO.d[3];
//   ECO.fluid[4].d = ECO.d[4];
//   ECO.fluid[5].d = ECO.d[5];
//   ECO.fluid[6].d = ECO.d[6];
//   ECO.fluid[7].d = ECO.d[7];
//   ECO.fluid[8].d = ECO.d[8];
//   ECO.fluid[9].d = ECO.d[9];
//   ECO.fluid[10].d = ECO.d[10];
//   ECO.fluid[1].T = ECO.T[1];
//   ECO.fluid[2].T = ECO.T[2];
//   ECO.fluid[3].T = ECO.T[3];
//   ECO.fluid[4].T = ECO.T[4];
//   ECO.fluid[5].T = ECO.T[5];
//   ECO.fluid[6].T = ECO.T[6];
//   ECO.fluid[7].T = ECO.T[7];
//   ECO.fluid[8].T = ECO.T[8];
//   ECO.fluid[9].T = ECO.T[9];
//   ECO.fluid[10].T = ECO.T[10];
//   ECO.vol[1] = 1.0 / ECO.fluid[1].d;
//   ECO.vol[2] = 1.0 / ECO.fluid[2].d;
//   ECO.vol[3] = 1.0 / ECO.fluid[3].d;
//   ECO.vol[4] = 1.0 / ECO.fluid[4].d;
//   ECO.vol[5] = 1.0 / ECO.fluid[5].d;
//   ECO.vol[6] = 1.0 / ECO.fluid[6].d;
//   ECO.vol[7] = 1.0 / ECO.fluid[7].d;
//   ECO.vol[8] = 1.0 / ECO.fluid[8].d;
//   ECO.vol[9] = 1.0 / ECO.fluid[9].d;
//   ECO.vol[10] = 1.0 / ECO.fluid[10].d;
//   ECO.d_av = (ECO.d[1] + ECO.d[2] + ECO.d[3] + ECO.d[4] + ECO.d[5] + ECO.d[6] + ECO.d[7] + ECO.d[8] + ECO.d[9] + ECO.d[10]) / Real(ECO.numberOfNodes);
//   ECO.vol_av = (ECO.vol[1] + ECO.vol[2] + ECO.vol[3] + ECO.vol[4] + ECO.vol[5] + ECO.vol[6] + ECO.vol[7] + ECO.vol[8] + ECO.vol[9] + ECO.vol[10]) / Real(ECO.numberOfNodes);
//   ECO.eta[1] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[1].state);
//   ECO.eta[2] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[2].state);
//   ECO.eta[3] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[3].state);
//   ECO.eta[4] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[4].state);
//   ECO.eta[5] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[5].state);
//   ECO.eta[6] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[6].state);
//   ECO.eta[7] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[7].state);
//   ECO.eta[8] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[8].state);
//   ECO.eta[9] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[9].state);
//   ECO.eta[10] = SiemensPower.Components.Pipes.Tube.Medium.dynamicViscosity(ECO.fluid[10].state);
//   ECO.cp[1] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[1].state);
//   ECO.cp[2] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[2].state);
//   ECO.cp[3] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[3].state);
//   ECO.cp[4] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[4].state);
//   ECO.cp[5] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[5].state);
//   ECO.cp[6] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[6].state);
//   ECO.cp[7] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[7].state);
//   ECO.cp[8] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[8].state);
//   ECO.cp[9] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[9].state);
//   ECO.cp[10] = SiemensPower.Components.Pipes.Tube.Medium.specificHeatCapacityCp(ECO.fluid[10].state);
//   ECO.lambda[1] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[1].state);
//   ECO.lambda[2] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[2].state);
//   ECO.lambda[3] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[3].state);
//   ECO.lambda[4] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[4].state);
//   ECO.lambda[5] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[5].state);
//   ECO.lambda[6] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[6].state);
//   ECO.lambda[7] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[7].state);
//   ECO.lambda[8] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[8].state);
//   ECO.lambda[9] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[9].state);
//   ECO.lambda[10] = SiemensPower.Components.Pipes.Tube.Medium.thermalConductivity(ECO.fluid[10].state);
//   ECO.E_flows[1] = max(0.0, ECO.m_flowsZero) * (watersource_mh.ports[1].h_outflow - ECO.fluid[1].h) + max(0.0, -ECO.m_flows[1]) * (ECO.fluid[2].h - ECO.fluid[1].h);
//   ECO.E_flows[2] = max(0.0, ECO.m_flows[1]) * (ECO.fluid[1].h - ECO.fluid[2].h) + max(0.0, -ECO.m_flows[2]) * (ECO.fluid[3].h - ECO.fluid[2].h);
//   ECO.E_flows[3] = max(0.0, ECO.m_flows[2]) * (ECO.fluid[2].h - ECO.fluid[3].h) + max(0.0, -ECO.m_flows[3]) * (ECO.fluid[4].h - ECO.fluid[3].h);
//   ECO.E_flows[4] = max(0.0, ECO.m_flows[3]) * (ECO.fluid[3].h - ECO.fluid[4].h) + max(0.0, -ECO.m_flows[4]) * (ECO.fluid[5].h - ECO.fluid[4].h);
//   ECO.E_flows[5] = max(0.0, ECO.m_flows[4]) * (ECO.fluid[4].h - ECO.fluid[5].h) + max(0.0, -ECO.m_flows[5]) * (ECO.fluid[6].h - ECO.fluid[5].h);
//   ECO.E_flows[6] = max(0.0, ECO.m_flows[5]) * (ECO.fluid[5].h - ECO.fluid[6].h) + max(0.0, -ECO.m_flows[6]) * (ECO.fluid[7].h - ECO.fluid[6].h);
//   ECO.E_flows[7] = max(0.0, ECO.m_flows[6]) * (ECO.fluid[6].h - ECO.fluid[7].h) + max(0.0, -ECO.m_flows[7]) * (ECO.fluid[8].h - ECO.fluid[7].h);
//   ECO.E_flows[8] = max(0.0, ECO.m_flows[7]) * (ECO.fluid[7].h - ECO.fluid[8].h) + max(0.0, -ECO.m_flows[8]) * (ECO.fluid[9].h - ECO.fluid[8].h);
//   ECO.E_flows[9] = max(0.0, ECO.m_flows[8]) * (ECO.fluid[8].h - ECO.fluid[9].h) + max(0.0, -ECO.m_flows[9]) * (ECO.fluid[10].h - ECO.fluid[9].h);
//   ECO.E_flows[10] = max(0.0, ECO.m_flows[9]) * (ECO.fluid[9].h - ECO.fluid[10].h) + max(0.0, -ECO.m_flows[10]) * (EVA.portIn.h_outflow - ECO.fluid[10].h);
//   ECO.portIn.h_outflow = ECO.fluid[1].h;
//   ECO.portOut.h_outflow = ECO.fluid[10].h;
//   ECO.VCell * ECO.fluid[1].d * der(ECO.fluid[1].h) = ECO.E_flows[1] + ECO.heatedArea * ECO.qHeating[1] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[2].d * der(ECO.fluid[2].h) = ECO.E_flows[2] + ECO.heatedArea * ECO.qHeating[2] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[3].d * der(ECO.fluid[3].h) = ECO.E_flows[3] + ECO.heatedArea * ECO.qHeating[3] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[4].d * der(ECO.fluid[4].h) = ECO.E_flows[4] + ECO.heatedArea * ECO.qHeating[4] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[5].d * der(ECO.fluid[5].h) = ECO.E_flows[5] + ECO.heatedArea * ECO.qHeating[5] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[6].d * der(ECO.fluid[6].h) = ECO.E_flows[6] + ECO.heatedArea * ECO.qHeating[6] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[7].d * der(ECO.fluid[7].h) = ECO.E_flows[7] + ECO.heatedArea * ECO.qHeating[7] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[8].d * der(ECO.fluid[8].h) = ECO.E_flows[8] + ECO.heatedArea * ECO.qHeating[8] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[9].d * der(ECO.fluid[9].h) = ECO.E_flows[9] + ECO.heatedArea * ECO.qHeating[9] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.VCell * ECO.fluid[10].d * der(ECO.fluid[10].h) = ECO.E_flows[10] + ECO.heatedArea * ECO.qHeating[10] / Real(ECO.numberOfNodes * ECO.geoPipe.Nt);
//   ECO.state_from_a = SiemensPower.Components.Pipes.Tube.Medium.setState_phX(ECO.portIn.p, watersource_mh.ports[1].h_outflow, {}, 0);
//   ECO.state_from_b = SiemensPower.Components.Pipes.Tube.Medium.setState_phX(ECO.portOut.p, EVA.portIn.h_outflow, {}, 0);
//   if noEvent(ECO.portIn.m_flow >= 0.0) then
//   ECO.hIn = watersource_mh.ports[1].h_outflow;
//   else
//   ECO.hIn = ECO.portIn.h_outflow;
//   end if;
//   if noEvent(ECO.portOut.m_flow >= 0.0) then
//   ECO.hOut = EVA.portIn.h_outflow;
//   else
//   ECO.hOut = ECO.portOut.h_outflow;
//   end if;
//   ECO.dp = ECO.portIn.p - ECO.portOut.p;
//   timeTable1.originalTable.y = timeTable1.originalTable.a * time + timeTable1.originalTable.b;
//   der(timeTable1.C1signal.y) = (timeTable1.C1signal.u - timeTable1.C1signal.y) / timeTable1.C1signal.timeDelay;
//   prescribedHeatFlow1.portsOut[1].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[2].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[3].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[4].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[5].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[6].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[7].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[8].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[9].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow1.portsOut[10].Q_flow = (-prescribedHeatFlow1.Q_flow) / Real(prescribedHeatFlow1.numberOfCells);
//   prescribedHeatFlow.portsOut[1].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[2].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[3].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[4].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[5].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[6].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[7].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[8].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[9].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[10].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[11].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[12].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[13].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[14].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[15].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[16].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[17].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[18].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[19].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   prescribedHeatFlow.portsOut[20].Q_flow = (-prescribedHeatFlow.Q_flow) / Real(prescribedHeatFlow.numberOfCells);
//   timeTable.originalTable.y = timeTable.originalTable.a * time + timeTable.originalTable.b;
//   der(timeTable.C1signal.y) = (timeTable.C1signal.u - timeTable.C1signal.y) / timeTable.C1signal.timeDelay;
//   watersource_mh.ports[1].m_flow + ECO.portIn.m_flow = 0.0;
//   watersink_ph.port.m_flow + EVA.portOut.m_flow = 0.0;
//   EVA.portIn.m_flow + ECO.portOut.m_flow = 0.0;
//   EVA.heatport.port[1].Q_flow + EVA.wall.port_int[1].Q_flow = 0.0;
//   EVA.heatport.port[2].Q_flow + EVA.wall.port_int[2].Q_flow = 0.0;
//   EVA.heatport.port[3].Q_flow + EVA.wall.port_int[3].Q_flow = 0.0;
//   EVA.heatport.port[4].Q_flow + EVA.wall.port_int[4].Q_flow = 0.0;
//   EVA.heatport.port[5].Q_flow + EVA.wall.port_int[5].Q_flow = 0.0;
//   EVA.heatport.port[6].Q_flow + EVA.wall.port_int[6].Q_flow = 0.0;
//   EVA.heatport.port[7].Q_flow + EVA.wall.port_int[7].Q_flow = 0.0;
//   EVA.heatport.port[8].Q_flow + EVA.wall.port_int[8].Q_flow = 0.0;
//   EVA.heatport.port[9].Q_flow + EVA.wall.port_int[9].Q_flow = 0.0;
//   EVA.heatport.port[10].Q_flow + EVA.wall.port_int[10].Q_flow = 0.0;
//   EVA.heatport.port[11].Q_flow + EVA.wall.port_int[11].Q_flow = 0.0;
//   EVA.heatport.port[12].Q_flow + EVA.wall.port_int[12].Q_flow = 0.0;
//   EVA.heatport.port[13].Q_flow + EVA.wall.port_int[13].Q_flow = 0.0;
//   EVA.heatport.port[14].Q_flow + EVA.wall.port_int[14].Q_flow = 0.0;
//   EVA.heatport.port[15].Q_flow + EVA.wall.port_int[15].Q_flow = 0.0;
//   EVA.heatport.port[16].Q_flow + EVA.wall.port_int[16].Q_flow = 0.0;
//   EVA.heatport.port[17].Q_flow + EVA.wall.port_int[17].Q_flow = 0.0;
//   EVA.heatport.port[18].Q_flow + EVA.wall.port_int[18].Q_flow = 0.0;
//   EVA.heatport.port[19].Q_flow + EVA.wall.port_int[19].Q_flow = 0.0;
//   EVA.heatport.port[20].Q_flow + EVA.wall.port_int[20].Q_flow = 0.0;
//   EVA.heatPort[1].Q_flow + prescribedHeatFlow.portsOut[1].Q_flow = 0.0;
//   EVA.heatPort[2].Q_flow + prescribedHeatFlow.portsOut[2].Q_flow = 0.0;
//   EVA.heatPort[3].Q_flow + prescribedHeatFlow.portsOut[3].Q_flow = 0.0;
//   EVA.heatPort[4].Q_flow + prescribedHeatFlow.portsOut[4].Q_flow = 0.0;
//   EVA.heatPort[5].Q_flow + prescribedHeatFlow.portsOut[5].Q_flow = 0.0;
//   EVA.heatPort[6].Q_flow + prescribedHeatFlow.portsOut[6].Q_flow = 0.0;
//   EVA.heatPort[7].Q_flow + prescribedHeatFlow.portsOut[7].Q_flow = 0.0;
//   EVA.heatPort[8].Q_flow + prescribedHeatFlow.portsOut[8].Q_flow = 0.0;
//   EVA.heatPort[9].Q_flow + prescribedHeatFlow.portsOut[9].Q_flow = 0.0;
//   EVA.heatPort[10].Q_flow + prescribedHeatFlow.portsOut[10].Q_flow = 0.0;
//   EVA.heatPort[11].Q_flow + prescribedHeatFlow.portsOut[11].Q_flow = 0.0;
//   EVA.heatPort[12].Q_flow + prescribedHeatFlow.portsOut[12].Q_flow = 0.0;
//   EVA.heatPort[13].Q_flow + prescribedHeatFlow.portsOut[13].Q_flow = 0.0;
//   EVA.heatPort[14].Q_flow + prescribedHeatFlow.portsOut[14].Q_flow = 0.0;
//   EVA.heatPort[15].Q_flow + prescribedHeatFlow.portsOut[15].Q_flow = 0.0;
//   EVA.heatPort[16].Q_flow + prescribedHeatFlow.portsOut[16].Q_flow = 0.0;
//   EVA.heatPort[17].Q_flow + prescribedHeatFlow.portsOut[17].Q_flow = 0.0;
//   EVA.heatPort[18].Q_flow + prescribedHeatFlow.portsOut[18].Q_flow = 0.0;
//   EVA.heatPort[19].Q_flow + prescribedHeatFlow.portsOut[19].Q_flow = 0.0;
//   EVA.heatPort[20].Q_flow + prescribedHeatFlow.portsOut[20].Q_flow = 0.0;
//   (-EVA.heatPort[1].Q_flow) + EVA.wall.port_ext[1].Q_flow = 0.0;
//   (-EVA.heatPort[2].Q_flow) + EVA.wall.port_ext[2].Q_flow = 0.0;
//   (-EVA.heatPort[3].Q_flow) + EVA.wall.port_ext[3].Q_flow = 0.0;
//   (-EVA.heatPort[4].Q_flow) + EVA.wall.port_ext[4].Q_flow = 0.0;
//   (-EVA.heatPort[5].Q_flow) + EVA.wall.port_ext[5].Q_flow = 0.0;
//   (-EVA.heatPort[6].Q_flow) + EVA.wall.port_ext[6].Q_flow = 0.0;
//   (-EVA.heatPort[7].Q_flow) + EVA.wall.port_ext[7].Q_flow = 0.0;
//   (-EVA.heatPort[8].Q_flow) + EVA.wall.port_ext[8].Q_flow = 0.0;
//   (-EVA.heatPort[9].Q_flow) + EVA.wall.port_ext[9].Q_flow = 0.0;
//   (-EVA.heatPort[10].Q_flow) + EVA.wall.port_ext[10].Q_flow = 0.0;
//   (-EVA.heatPort[11].Q_flow) + EVA.wall.port_ext[11].Q_flow = 0.0;
//   (-EVA.heatPort[12].Q_flow) + EVA.wall.port_ext[12].Q_flow = 0.0;
//   (-EVA.heatPort[13].Q_flow) + EVA.wall.port_ext[13].Q_flow = 0.0;
//   (-EVA.heatPort[14].Q_flow) + EVA.wall.port_ext[14].Q_flow = 0.0;
//   (-EVA.heatPort[15].Q_flow) + EVA.wall.port_ext[15].Q_flow = 0.0;
//   (-EVA.heatPort[16].Q_flow) + EVA.wall.port_ext[16].Q_flow = 0.0;
//   (-EVA.heatPort[17].Q_flow) + EVA.wall.port_ext[17].Q_flow = 0.0;
//   (-EVA.heatPort[18].Q_flow) + EVA.wall.port_ext[18].Q_flow = 0.0;
//   (-EVA.heatPort[19].Q_flow) + EVA.wall.port_ext[19].Q_flow = 0.0;
//   (-EVA.heatPort[20].Q_flow) + EVA.wall.port_ext[20].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[1].Q_flow + EVA.wall.layer[2].port_int[1].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[2].Q_flow + EVA.wall.layer[2].port_int[2].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[3].Q_flow + EVA.wall.layer[2].port_int[3].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[4].Q_flow + EVA.wall.layer[2].port_int[4].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[5].Q_flow + EVA.wall.layer[2].port_int[5].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[6].Q_flow + EVA.wall.layer[2].port_int[6].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[7].Q_flow + EVA.wall.layer[2].port_int[7].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[8].Q_flow + EVA.wall.layer[2].port_int[8].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[9].Q_flow + EVA.wall.layer[2].port_int[9].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[10].Q_flow + EVA.wall.layer[2].port_int[10].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[11].Q_flow + EVA.wall.layer[2].port_int[11].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[12].Q_flow + EVA.wall.layer[2].port_int[12].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[13].Q_flow + EVA.wall.layer[2].port_int[13].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[14].Q_flow + EVA.wall.layer[2].port_int[14].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[15].Q_flow + EVA.wall.layer[2].port_int[15].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[16].Q_flow + EVA.wall.layer[2].port_int[16].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[17].Q_flow + EVA.wall.layer[2].port_int[17].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[18].Q_flow + EVA.wall.layer[2].port_int[18].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[19].Q_flow + EVA.wall.layer[2].port_int[19].Q_flow = 0.0;
//   EVA.wall.layer[1].port_ext[20].Q_flow + EVA.wall.layer[2].port_int[20].Q_flow = 0.0;
//   (-EVA.wall.port_int[1].Q_flow) + EVA.wall.layer[1].port_int[1].Q_flow = 0.0;
//   (-EVA.wall.port_int[2].Q_flow) + EVA.wall.layer[1].port_int[2].Q_flow = 0.0;
//   (-EVA.wall.port_int[3].Q_flow) + EVA.wall.layer[1].port_int[3].Q_flow = 0.0;
//   (-EVA.wall.port_int[4].Q_flow) + EVA.wall.layer[1].port_int[4].Q_flow = 0.0;
//   (-EVA.wall.port_int[5].Q_flow) + EVA.wall.layer[1].port_int[5].Q_flow = 0.0;
//   (-EVA.wall.port_int[6].Q_flow) + EVA.wall.layer[1].port_int[6].Q_flow = 0.0;
//   (-EVA.wall.port_int[7].Q_flow) + EVA.wall.layer[1].port_int[7].Q_flow = 0.0;
//   (-EVA.wall.port_int[8].Q_flow) + EVA.wall.layer[1].port_int[8].Q_flow = 0.0;
//   (-EVA.wall.port_int[9].Q_flow) + EVA.wall.layer[1].port_int[9].Q_flow = 0.0;
//   (-EVA.wall.port_int[10].Q_flow) + EVA.wall.layer[1].port_int[10].Q_flow = 0.0;
//   (-EVA.wall.port_int[11].Q_flow) + EVA.wall.layer[1].port_int[11].Q_flow = 0.0;
//   (-EVA.wall.port_int[12].Q_flow) + EVA.wall.layer[1].port_int[12].Q_flow = 0.0;
//   (-EVA.wall.port_int[13].Q_flow) + EVA.wall.layer[1].port_int[13].Q_flow = 0.0;
//   (-EVA.wall.port_int[14].Q_flow) + EVA.wall.layer[1].port_int[14].Q_flow = 0.0;
//   (-EVA.wall.port_int[15].Q_flow) + EVA.wall.layer[1].port_int[15].Q_flow = 0.0;
//   (-EVA.wall.port_int[16].Q_flow) + EVA.wall.layer[1].port_int[16].Q_flow = 0.0;
//   (-EVA.wall.port_int[17].Q_flow) + EVA.wall.layer[1].port_int[17].Q_flow = 0.0;
//   (-EVA.wall.port_int[18].Q_flow) + EVA.wall.layer[1].port_int[18].Q_flow = 0.0;
//   (-EVA.wall.port_int[19].Q_flow) + EVA.wall.layer[1].port_int[19].Q_flow = 0.0;
//   (-EVA.wall.port_int[20].Q_flow) + EVA.wall.layer[1].port_int[20].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[1].Q_flow + EVA.wall.layer[3].port_int[1].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[2].Q_flow + EVA.wall.layer[3].port_int[2].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[3].Q_flow + EVA.wall.layer[3].port_int[3].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[4].Q_flow + EVA.wall.layer[3].port_int[4].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[5].Q_flow + EVA.wall.layer[3].port_int[5].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[6].Q_flow + EVA.wall.layer[3].port_int[6].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[7].Q_flow + EVA.wall.layer[3].port_int[7].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[8].Q_flow + EVA.wall.layer[3].port_int[8].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[9].Q_flow + EVA.wall.layer[3].port_int[9].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[10].Q_flow + EVA.wall.layer[3].port_int[10].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[11].Q_flow + EVA.wall.layer[3].port_int[11].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[12].Q_flow + EVA.wall.layer[3].port_int[12].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[13].Q_flow + EVA.wall.layer[3].port_int[13].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[14].Q_flow + EVA.wall.layer[3].port_int[14].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[15].Q_flow + EVA.wall.layer[3].port_int[15].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[16].Q_flow + EVA.wall.layer[3].port_int[16].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[17].Q_flow + EVA.wall.layer[3].port_int[17].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[18].Q_flow + EVA.wall.layer[3].port_int[18].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[19].Q_flow + EVA.wall.layer[3].port_int[19].Q_flow = 0.0;
//   EVA.wall.layer[2].port_ext[20].Q_flow + EVA.wall.layer[3].port_int[20].Q_flow = 0.0;
//   (-EVA.wall.port_ext[1].Q_flow) + EVA.wall.layer[3].port_ext[1].Q_flow = 0.0;
//   (-EVA.wall.port_ext[2].Q_flow) + EVA.wall.layer[3].port_ext[2].Q_flow = 0.0;
//   (-EVA.wall.port_ext[3].Q_flow) + EVA.wall.layer[3].port_ext[3].Q_flow = 0.0;
//   (-EVA.wall.port_ext[4].Q_flow) + EVA.wall.layer[3].port_ext[4].Q_flow = 0.0;
//   (-EVA.wall.port_ext[5].Q_flow) + EVA.wall.layer[3].port_ext[5].Q_flow = 0.0;
//   (-EVA.wall.port_ext[6].Q_flow) + EVA.wall.layer[3].port_ext[6].Q_flow = 0.0;
//   (-EVA.wall.port_ext[7].Q_flow) + EVA.wall.layer[3].port_ext[7].Q_flow = 0.0;
//   (-EVA.wall.port_ext[8].Q_flow) + EVA.wall.layer[3].port_ext[8].Q_flow = 0.0;
//   (-EVA.wall.port_ext[9].Q_flow) + EVA.wall.layer[3].port_ext[9].Q_flow = 0.0;
//   (-EVA.wall.port_ext[10].Q_flow) + EVA.wall.layer[3].port_ext[10].Q_flow = 0.0;
//   (-EVA.wall.port_ext[11].Q_flow) + EVA.wall.layer[3].port_ext[11].Q_flow = 0.0;
//   (-EVA.wall.port_ext[12].Q_flow) + EVA.wall.layer[3].port_ext[12].Q_flow = 0.0;
//   (-EVA.wall.port_ext[13].Q_flow) + EVA.wall.layer[3].port_ext[13].Q_flow = 0.0;
//   (-EVA.wall.port_ext[14].Q_flow) + EVA.wall.layer[3].port_ext[14].Q_flow = 0.0;
//   (-EVA.wall.port_ext[15].Q_flow) + EVA.wall.layer[3].port_ext[15].Q_flow = 0.0;
//   (-EVA.wall.port_ext[16].Q_flow) + EVA.wall.layer[3].port_ext[16].Q_flow = 0.0;
//   (-EVA.wall.port_ext[17].Q_flow) + EVA.wall.layer[3].port_ext[17].Q_flow = 0.0;
//   (-EVA.wall.port_ext[18].Q_flow) + EVA.wall.layer[3].port_ext[18].Q_flow = 0.0;
//   (-EVA.wall.port_ext[19].Q_flow) + EVA.wall.layer[3].port_ext[19].Q_flow = 0.0;
//   (-EVA.wall.port_ext[20].Q_flow) + EVA.wall.layer[3].port_ext[20].Q_flow = 0.0;
//   EVA.wall.layer[1].port_int[1].T = EVA.wall.port_int[1].T;
//   EVA.wall.layer[1].port_int[2].T = EVA.wall.port_int[2].T;
//   EVA.wall.layer[1].port_int[3].T = EVA.wall.port_int[3].T;
//   EVA.wall.layer[1].port_int[4].T = EVA.wall.port_int[4].T;
//   EVA.wall.layer[1].port_int[5].T = EVA.wall.port_int[5].T;
//   EVA.wall.layer[1].port_int[6].T = EVA.wall.port_int[6].T;
//   EVA.wall.layer[1].port_int[7].T = EVA.wall.port_int[7].T;
//   EVA.wall.layer[1].port_int[8].T = EVA.wall.port_int[8].T;
//   EVA.wall.layer[1].port_int[9].T = EVA.wall.port_int[9].T;
//   EVA.wall.layer[1].port_int[10].T = EVA.wall.port_int[10].T;
//   EVA.wall.layer[1].port_int[11].T = EVA.wall.port_int[11].T;
//   EVA.wall.layer[1].port_int[12].T = EVA.wall.port_int[12].T;
//   EVA.wall.layer[1].port_int[13].T = EVA.wall.port_int[13].T;
//   EVA.wall.layer[1].port_int[14].T = EVA.wall.port_int[14].T;
//   EVA.wall.layer[1].port_int[15].T = EVA.wall.port_int[15].T;
//   EVA.wall.layer[1].port_int[16].T = EVA.wall.port_int[16].T;
//   EVA.wall.layer[1].port_int[17].T = EVA.wall.port_int[17].T;
//   EVA.wall.layer[1].port_int[18].T = EVA.wall.port_int[18].T;
//   EVA.wall.layer[1].port_int[19].T = EVA.wall.port_int[19].T;
//   EVA.wall.layer[1].port_int[20].T = EVA.wall.port_int[20].T;
//   EVA.wall.layer[1].port_ext[1].T = EVA.wall.layer[2].port_int[1].T;
//   EVA.wall.layer[1].port_ext[2].T = EVA.wall.layer[2].port_int[2].T;
//   EVA.wall.layer[1].port_ext[3].T = EVA.wall.layer[2].port_int[3].T;
//   EVA.wall.layer[1].port_ext[4].T = EVA.wall.layer[2].port_int[4].T;
//   EVA.wall.layer[1].port_ext[5].T = EVA.wall.layer[2].port_int[5].T;
//   EVA.wall.layer[1].port_ext[6].T = EVA.wall.layer[2].port_int[6].T;
//   EVA.wall.layer[1].port_ext[7].T = EVA.wall.layer[2].port_int[7].T;
//   EVA.wall.layer[1].port_ext[8].T = EVA.wall.layer[2].port_int[8].T;
//   EVA.wall.layer[1].port_ext[9].T = EVA.wall.layer[2].port_int[9].T;
//   EVA.wall.layer[1].port_ext[10].T = EVA.wall.layer[2].port_int[10].T;
//   EVA.wall.layer[1].port_ext[11].T = EVA.wall.layer[2].port_int[11].T;
//   EVA.wall.layer[1].port_ext[12].T = EVA.wall.layer[2].port_int[12].T;
//   EVA.wall.layer[1].port_ext[13].T = EVA.wall.layer[2].port_int[13].T;
//   EVA.wall.layer[1].port_ext[14].T = EVA.wall.layer[2].port_int[14].T;
//   EVA.wall.layer[1].port_ext[15].T = EVA.wall.layer[2].port_int[15].T;
//   EVA.wall.layer[1].port_ext[16].T = EVA.wall.layer[2].port_int[16].T;
//   EVA.wall.layer[1].port_ext[17].T = EVA.wall.layer[2].port_int[17].T;
//   EVA.wall.layer[1].port_ext[18].T = EVA.wall.layer[2].port_int[18].T;
//   EVA.wall.layer[1].port_ext[19].T = EVA.wall.layer[2].port_int[19].T;
//   EVA.wall.layer[1].port_ext[20].T = EVA.wall.layer[2].port_int[20].T;
//   EVA.wall.layer[2].port_ext[1].T = EVA.wall.layer[3].port_int[1].T;
//   EVA.wall.layer[2].port_ext[2].T = EVA.wall.layer[3].port_int[2].T;
//   EVA.wall.layer[2].port_ext[3].T = EVA.wall.layer[3].port_int[3].T;
//   EVA.wall.layer[2].port_ext[4].T = EVA.wall.layer[3].port_int[4].T;
//   EVA.wall.layer[2].port_ext[5].T = EVA.wall.layer[3].port_int[5].T;
//   EVA.wall.layer[2].port_ext[6].T = EVA.wall.layer[3].port_int[6].T;
//   EVA.wall.layer[2].port_ext[7].T = EVA.wall.layer[3].port_int[7].T;
//   EVA.wall.layer[2].port_ext[8].T = EVA.wall.layer[3].port_int[8].T;
//   EVA.wall.layer[2].port_ext[9].T = EVA.wall.layer[3].port_int[9].T;
//   EVA.wall.layer[2].port_ext[10].T = EVA.wall.layer[3].port_int[10].T;
//   EVA.wall.layer[2].port_ext[11].T = EVA.wall.layer[3].port_int[11].T;
//   EVA.wall.layer[2].port_ext[12].T = EVA.wall.layer[3].port_int[12].T;
//   EVA.wall.layer[2].port_ext[13].T = EVA.wall.layer[3].port_int[13].T;
//   EVA.wall.layer[2].port_ext[14].T = EVA.wall.layer[3].port_int[14].T;
//   EVA.wall.layer[2].port_ext[15].T = EVA.wall.layer[3].port_int[15].T;
//   EVA.wall.layer[2].port_ext[16].T = EVA.wall.layer[3].port_int[16].T;
//   EVA.wall.layer[2].port_ext[17].T = EVA.wall.layer[3].port_int[17].T;
//   EVA.wall.layer[2].port_ext[18].T = EVA.wall.layer[3].port_int[18].T;
//   EVA.wall.layer[2].port_ext[19].T = EVA.wall.layer[3].port_int[19].T;
//   EVA.wall.layer[2].port_ext[20].T = EVA.wall.layer[3].port_int[20].T;
//   EVA.wall.layer[3].port_ext[1].T = EVA.wall.port_ext[1].T;
//   EVA.wall.layer[3].port_ext[2].T = EVA.wall.port_ext[2].T;
//   EVA.wall.layer[3].port_ext[3].T = EVA.wall.port_ext[3].T;
//   EVA.wall.layer[3].port_ext[4].T = EVA.wall.port_ext[4].T;
//   EVA.wall.layer[3].port_ext[5].T = EVA.wall.port_ext[5].T;
//   EVA.wall.layer[3].port_ext[6].T = EVA.wall.port_ext[6].T;
//   EVA.wall.layer[3].port_ext[7].T = EVA.wall.port_ext[7].T;
//   EVA.wall.layer[3].port_ext[8].T = EVA.wall.port_ext[8].T;
//   EVA.wall.layer[3].port_ext[9].T = EVA.wall.port_ext[9].T;
//   EVA.wall.layer[3].port_ext[10].T = EVA.wall.port_ext[10].T;
//   EVA.wall.layer[3].port_ext[11].T = EVA.wall.port_ext[11].T;
//   EVA.wall.layer[3].port_ext[12].T = EVA.wall.port_ext[12].T;
//   EVA.wall.layer[3].port_ext[13].T = EVA.wall.port_ext[13].T;
//   EVA.wall.layer[3].port_ext[14].T = EVA.wall.port_ext[14].T;
//   EVA.wall.layer[3].port_ext[15].T = EVA.wall.port_ext[15].T;
//   EVA.wall.layer[3].port_ext[16].T = EVA.wall.port_ext[16].T;
//   EVA.wall.layer[3].port_ext[17].T = EVA.wall.port_ext[17].T;
//   EVA.wall.layer[3].port_ext[18].T = EVA.wall.port_ext[18].T;
//   EVA.wall.layer[3].port_ext[19].T = EVA.wall.port_ext[19].T;
//   EVA.wall.layer[3].port_ext[20].T = EVA.wall.port_ext[20].T;
//   EVA.heatPort[1].T = EVA.wall.port_ext[1].T;
//   EVA.heatPort[2].T = EVA.wall.port_ext[2].T;
//   EVA.heatPort[3].T = EVA.wall.port_ext[3].T;
//   EVA.heatPort[4].T = EVA.wall.port_ext[4].T;
//   EVA.heatPort[5].T = EVA.wall.port_ext[5].T;
//   EVA.heatPort[6].T = EVA.wall.port_ext[6].T;
//   EVA.heatPort[7].T = EVA.wall.port_ext[7].T;
//   EVA.heatPort[8].T = EVA.wall.port_ext[8].T;
//   EVA.heatPort[9].T = EVA.wall.port_ext[9].T;
//   EVA.heatPort[10].T = EVA.wall.port_ext[10].T;
//   EVA.heatPort[11].T = EVA.wall.port_ext[11].T;
//   EVA.heatPort[12].T = EVA.wall.port_ext[12].T;
//   EVA.heatPort[13].T = EVA.wall.port_ext[13].T;
//   EVA.heatPort[14].T = EVA.wall.port_ext[14].T;
//   EVA.heatPort[15].T = EVA.wall.port_ext[15].T;
//   EVA.heatPort[16].T = EVA.wall.port_ext[16].T;
//   EVA.heatPort[17].T = EVA.wall.port_ext[17].T;
//   EVA.heatPort[18].T = EVA.wall.port_ext[18].T;
//   EVA.heatPort[19].T = EVA.wall.port_ext[19].T;
//   EVA.heatPort[20].T = EVA.wall.port_ext[20].T;
//   EVA.heatport.port[1].T = EVA.wall.port_int[1].T;
//   EVA.heatport.port[2].T = EVA.wall.port_int[2].T;
//   EVA.heatport.port[3].T = EVA.wall.port_int[3].T;
//   EVA.heatport.port[4].T = EVA.wall.port_int[4].T;
//   EVA.heatport.port[5].T = EVA.wall.port_int[5].T;
//   EVA.heatport.port[6].T = EVA.wall.port_int[6].T;
//   EVA.heatport.port[7].T = EVA.wall.port_int[7].T;
//   EVA.heatport.port[8].T = EVA.wall.port_int[8].T;
//   EVA.heatport.port[9].T = EVA.wall.port_int[9].T;
//   EVA.heatport.port[10].T = EVA.wall.port_int[10].T;
//   EVA.heatport.port[11].T = EVA.wall.port_int[11].T;
//   EVA.heatport.port[12].T = EVA.wall.port_int[12].T;
//   EVA.heatport.port[13].T = EVA.wall.port_int[13].T;
//   EVA.heatport.port[14].T = EVA.wall.port_int[14].T;
//   EVA.heatport.port[15].T = EVA.wall.port_int[15].T;
//   EVA.heatport.port[16].T = EVA.wall.port_int[16].T;
//   EVA.heatport.port[17].T = EVA.wall.port_int[17].T;
//   EVA.heatport.port[18].T = EVA.wall.port_int[18].T;
//   EVA.heatport.port[19].T = EVA.wall.port_int[19].T;
//   EVA.heatport.port[20].T = EVA.wall.port_int[20].T;
//   ECO.heatport.port[1].Q_flow + ECO.wall.port_int[1].Q_flow = 0.0;
//   ECO.heatport.port[2].Q_flow + ECO.wall.port_int[2].Q_flow = 0.0;
//   ECO.heatport.port[3].Q_flow + ECO.wall.port_int[3].Q_flow = 0.0;
//   ECO.heatport.port[4].Q_flow + ECO.wall.port_int[4].Q_flow = 0.0;
//   ECO.heatport.port[5].Q_flow + ECO.wall.port_int[5].Q_flow = 0.0;
//   ECO.heatport.port[6].Q_flow + ECO.wall.port_int[6].Q_flow = 0.0;
//   ECO.heatport.port[7].Q_flow + ECO.wall.port_int[7].Q_flow = 0.0;
//   ECO.heatport.port[8].Q_flow + ECO.wall.port_int[8].Q_flow = 0.0;
//   ECO.heatport.port[9].Q_flow + ECO.wall.port_int[9].Q_flow = 0.0;
//   ECO.heatport.port[10].Q_flow + ECO.wall.port_int[10].Q_flow = 0.0;
//   ECO.heatPort[1].Q_flow + prescribedHeatFlow1.portsOut[1].Q_flow = 0.0;
//   ECO.heatPort[2].Q_flow + prescribedHeatFlow1.portsOut[2].Q_flow = 0.0;
//   ECO.heatPort[3].Q_flow + prescribedHeatFlow1.portsOut[3].Q_flow = 0.0;
//   ECO.heatPort[4].Q_flow + prescribedHeatFlow1.portsOut[4].Q_flow = 0.0;
//   ECO.heatPort[5].Q_flow + prescribedHeatFlow1.portsOut[5].Q_flow = 0.0;
//   ECO.heatPort[6].Q_flow + prescribedHeatFlow1.portsOut[6].Q_flow = 0.0;
//   ECO.heatPort[7].Q_flow + prescribedHeatFlow1.portsOut[7].Q_flow = 0.0;
//   ECO.heatPort[8].Q_flow + prescribedHeatFlow1.portsOut[8].Q_flow = 0.0;
//   ECO.heatPort[9].Q_flow + prescribedHeatFlow1.portsOut[9].Q_flow = 0.0;
//   ECO.heatPort[10].Q_flow + prescribedHeatFlow1.portsOut[10].Q_flow = 0.0;
//   (-ECO.heatPort[1].Q_flow) + ECO.wall.port_ext[1].Q_flow = 0.0;
//   (-ECO.heatPort[2].Q_flow) + ECO.wall.port_ext[2].Q_flow = 0.0;
//   (-ECO.heatPort[3].Q_flow) + ECO.wall.port_ext[3].Q_flow = 0.0;
//   (-ECO.heatPort[4].Q_flow) + ECO.wall.port_ext[4].Q_flow = 0.0;
//   (-ECO.heatPort[5].Q_flow) + ECO.wall.port_ext[5].Q_flow = 0.0;
//   (-ECO.heatPort[6].Q_flow) + ECO.wall.port_ext[6].Q_flow = 0.0;
//   (-ECO.heatPort[7].Q_flow) + ECO.wall.port_ext[7].Q_flow = 0.0;
//   (-ECO.heatPort[8].Q_flow) + ECO.wall.port_ext[8].Q_flow = 0.0;
//   (-ECO.heatPort[9].Q_flow) + ECO.wall.port_ext[9].Q_flow = 0.0;
//   (-ECO.heatPort[10].Q_flow) + ECO.wall.port_ext[10].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[1].Q_flow + ECO.wall.layer[2].port_int[1].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[2].Q_flow + ECO.wall.layer[2].port_int[2].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[3].Q_flow + ECO.wall.layer[2].port_int[3].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[4].Q_flow + ECO.wall.layer[2].port_int[4].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[5].Q_flow + ECO.wall.layer[2].port_int[5].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[6].Q_flow + ECO.wall.layer[2].port_int[6].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[7].Q_flow + ECO.wall.layer[2].port_int[7].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[8].Q_flow + ECO.wall.layer[2].port_int[8].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[9].Q_flow + ECO.wall.layer[2].port_int[9].Q_flow = 0.0;
//   ECO.wall.layer[1].port_ext[10].Q_flow + ECO.wall.layer[2].port_int[10].Q_flow = 0.0;
//   (-ECO.wall.port_int[1].Q_flow) + ECO.wall.layer[1].port_int[1].Q_flow = 0.0;
//   (-ECO.wall.port_int[2].Q_flow) + ECO.wall.layer[1].port_int[2].Q_flow = 0.0;
//   (-ECO.wall.port_int[3].Q_flow) + ECO.wall.layer[1].port_int[3].Q_flow = 0.0;
//   (-ECO.wall.port_int[4].Q_flow) + ECO.wall.layer[1].port_int[4].Q_flow = 0.0;
//   (-ECO.wall.port_int[5].Q_flow) + ECO.wall.layer[1].port_int[5].Q_flow = 0.0;
//   (-ECO.wall.port_int[6].Q_flow) + ECO.wall.layer[1].port_int[6].Q_flow = 0.0;
//   (-ECO.wall.port_int[7].Q_flow) + ECO.wall.layer[1].port_int[7].Q_flow = 0.0;
//   (-ECO.wall.port_int[8].Q_flow) + ECO.wall.layer[1].port_int[8].Q_flow = 0.0;
//   (-ECO.wall.port_int[9].Q_flow) + ECO.wall.layer[1].port_int[9].Q_flow = 0.0;
//   (-ECO.wall.port_int[10].Q_flow) + ECO.wall.layer[1].port_int[10].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[1].Q_flow + ECO.wall.layer[3].port_int[1].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[2].Q_flow + ECO.wall.layer[3].port_int[2].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[3].Q_flow + ECO.wall.layer[3].port_int[3].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[4].Q_flow + ECO.wall.layer[3].port_int[4].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[5].Q_flow + ECO.wall.layer[3].port_int[5].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[6].Q_flow + ECO.wall.layer[3].port_int[6].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[7].Q_flow + ECO.wall.layer[3].port_int[7].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[8].Q_flow + ECO.wall.layer[3].port_int[8].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[9].Q_flow + ECO.wall.layer[3].port_int[9].Q_flow = 0.0;
//   ECO.wall.layer[2].port_ext[10].Q_flow + ECO.wall.layer[3].port_int[10].Q_flow = 0.0;
//   (-ECO.wall.port_ext[1].Q_flow) + ECO.wall.layer[3].port_ext[1].Q_flow = 0.0;
//   (-ECO.wall.port_ext[2].Q_flow) + ECO.wall.layer[3].port_ext[2].Q_flow = 0.0;
//   (-ECO.wall.port_ext[3].Q_flow) + ECO.wall.layer[3].port_ext[3].Q_flow = 0.0;
//   (-ECO.wall.port_ext[4].Q_flow) + ECO.wall.layer[3].port_ext[4].Q_flow = 0.0;
//   (-ECO.wall.port_ext[5].Q_flow) + ECO.wall.layer[3].port_ext[5].Q_flow = 0.0;
//   (-ECO.wall.port_ext[6].Q_flow) + ECO.wall.layer[3].port_ext[6].Q_flow = 0.0;
//   (-ECO.wall.port_ext[7].Q_flow) + ECO.wall.layer[3].port_ext[7].Q_flow = 0.0;
//   (-ECO.wall.port_ext[8].Q_flow) + ECO.wall.layer[3].port_ext[8].Q_flow = 0.0;
//   (-ECO.wall.port_ext[9].Q_flow) + ECO.wall.layer[3].port_ext[9].Q_flow = 0.0;
//   (-ECO.wall.port_ext[10].Q_flow) + ECO.wall.layer[3].port_ext[10].Q_flow = 0.0;
//   ECO.wall.layer[1].port_int[1].T = ECO.wall.port_int[1].T;
//   ECO.wall.layer[1].port_int[2].T = ECO.wall.port_int[2].T;
//   ECO.wall.layer[1].port_int[3].T = ECO.wall.port_int[3].T;
//   ECO.wall.layer[1].port_int[4].T = ECO.wall.port_int[4].T;
//   ECO.wall.layer[1].port_int[5].T = ECO.wall.port_int[5].T;
//   ECO.wall.layer[1].port_int[6].T = ECO.wall.port_int[6].T;
//   ECO.wall.layer[1].port_int[7].T = ECO.wall.port_int[7].T;
//   ECO.wall.layer[1].port_int[8].T = ECO.wall.port_int[8].T;
//   ECO.wall.layer[1].port_int[9].T = ECO.wall.port_int[9].T;
//   ECO.wall.layer[1].port_int[10].T = ECO.wall.port_int[10].T;
//   ECO.wall.layer[1].port_ext[1].T = ECO.wall.layer[2].port_int[1].T;
//   ECO.wall.layer[1].port_ext[2].T = ECO.wall.layer[2].port_int[2].T;
//   ECO.wall.layer[1].port_ext[3].T = ECO.wall.layer[2].port_int[3].T;
//   ECO.wall.layer[1].port_ext[4].T = ECO.wall.layer[2].port_int[4].T;
//   ECO.wall.layer[1].port_ext[5].T = ECO.wall.layer[2].port_int[5].T;
//   ECO.wall.layer[1].port_ext[6].T = ECO.wall.layer[2].port_int[6].T;
//   ECO.wall.layer[1].port_ext[7].T = ECO.wall.layer[2].port_int[7].T;
//   ECO.wall.layer[1].port_ext[8].T = ECO.wall.layer[2].port_int[8].T;
//   ECO.wall.layer[1].port_ext[9].T = ECO.wall.layer[2].port_int[9].T;
//   ECO.wall.layer[1].port_ext[10].T = ECO.wall.layer[2].port_int[10].T;
//   ECO.wall.layer[2].port_ext[1].T = ECO.wall.layer[3].port_int[1].T;
//   ECO.wall.layer[2].port_ext[2].T = ECO.wall.layer[3].port_int[2].T;
//   ECO.wall.layer[2].port_ext[3].T = ECO.wall.layer[3].port_int[3].T;
//   ECO.wall.layer[2].port_ext[4].T = ECO.wall.layer[3].port_int[4].T;
//   ECO.wall.layer[2].port_ext[5].T = ECO.wall.layer[3].port_int[5].T;
//   ECO.wall.layer[2].port_ext[6].T = ECO.wall.layer[3].port_int[6].T;
//   ECO.wall.layer[2].port_ext[7].T = ECO.wall.layer[3].port_int[7].T;
//   ECO.wall.layer[2].port_ext[8].T = ECO.wall.layer[3].port_int[8].T;
//   ECO.wall.layer[2].port_ext[9].T = ECO.wall.layer[3].port_int[9].T;
//   ECO.wall.layer[2].port_ext[10].T = ECO.wall.layer[3].port_int[10].T;
//   ECO.wall.layer[3].port_ext[1].T = ECO.wall.port_ext[1].T;
//   ECO.wall.layer[3].port_ext[2].T = ECO.wall.port_ext[2].T;
//   ECO.wall.layer[3].port_ext[3].T = ECO.wall.port_ext[3].T;
//   ECO.wall.layer[3].port_ext[4].T = ECO.wall.port_ext[4].T;
//   ECO.wall.layer[3].port_ext[5].T = ECO.wall.port_ext[5].T;
//   ECO.wall.layer[3].port_ext[6].T = ECO.wall.port_ext[6].T;
//   ECO.wall.layer[3].port_ext[7].T = ECO.wall.port_ext[7].T;
//   ECO.wall.layer[3].port_ext[8].T = ECO.wall.port_ext[8].T;
//   ECO.wall.layer[3].port_ext[9].T = ECO.wall.port_ext[9].T;
//   ECO.wall.layer[3].port_ext[10].T = ECO.wall.port_ext[10].T;
//   ECO.heatPort[1].T = ECO.wall.port_ext[1].T;
//   ECO.heatPort[2].T = ECO.wall.port_ext[2].T;
//   ECO.heatPort[3].T = ECO.wall.port_ext[3].T;
//   ECO.heatPort[4].T = ECO.wall.port_ext[4].T;
//   ECO.heatPort[5].T = ECO.wall.port_ext[5].T;
//   ECO.heatPort[6].T = ECO.wall.port_ext[6].T;
//   ECO.heatPort[7].T = ECO.wall.port_ext[7].T;
//   ECO.heatPort[8].T = ECO.wall.port_ext[8].T;
//   ECO.heatPort[9].T = ECO.wall.port_ext[9].T;
//   ECO.heatPort[10].T = ECO.wall.port_ext[10].T;
//   ECO.heatport.port[1].T = ECO.wall.port_int[1].T;
//   ECO.heatport.port[2].T = ECO.wall.port_int[2].T;
//   ECO.heatport.port[3].T = ECO.wall.port_int[3].T;
//   ECO.heatport.port[4].T = ECO.wall.port_int[4].T;
//   ECO.heatport.port[5].T = ECO.wall.port_int[5].T;
//   ECO.heatport.port[6].T = ECO.wall.port_int[6].T;
//   ECO.heatport.port[7].T = ECO.wall.port_int[7].T;
//   ECO.heatport.port[8].T = ECO.wall.port_int[8].T;
//   ECO.heatport.port[9].T = ECO.wall.port_int[9].T;
//   ECO.heatport.port[10].T = ECO.wall.port_int[10].T;
//   timeTable1.C1signal.u = timeTable1.originalTable.y;
//   timeTable1.C1signal.u = timeTable1.yOriginal;
//   timeTable1.C1signal.y = timeTable1.y;
//   timeTable.C1signal.u = timeTable.originalTable.y;
//   timeTable.C1signal.u = timeTable.yOriginal;
//   timeTable.C1signal.y = timeTable.y;
//   ECO.portOut.p = EVA.portIn.p;
//   EVA.portOut.p = watersink_ph.port.p;
//   prescribedHeatFlow1.Q_flow = realExpression.y;
//   prescribedHeatFlow.Q_flow = timeTable.y;
//   timeTable1.y = watersink_ph.p_set;
//   ECO.heatPort[1].T = prescribedHeatFlow1.portsOut[1].T;
//   ECO.heatPort[2].T = prescribedHeatFlow1.portsOut[2].T;
//   ECO.heatPort[3].T = prescribedHeatFlow1.portsOut[3].T;
//   ECO.heatPort[4].T = prescribedHeatFlow1.portsOut[4].T;
//   ECO.heatPort[5].T = prescribedHeatFlow1.portsOut[5].T;
//   ECO.heatPort[6].T = prescribedHeatFlow1.portsOut[6].T;
//   ECO.heatPort[7].T = prescribedHeatFlow1.portsOut[7].T;
//   ECO.heatPort[8].T = prescribedHeatFlow1.portsOut[8].T;
//   ECO.heatPort[9].T = prescribedHeatFlow1.portsOut[9].T;
//   ECO.heatPort[10].T = prescribedHeatFlow1.portsOut[10].T;
//   EVA.heatPort[1].T = prescribedHeatFlow.portsOut[1].T;
//   EVA.heatPort[2].T = prescribedHeatFlow.portsOut[2].T;
//   EVA.heatPort[3].T = prescribedHeatFlow.portsOut[3].T;
//   EVA.heatPort[4].T = prescribedHeatFlow.portsOut[4].T;
//   EVA.heatPort[5].T = prescribedHeatFlow.portsOut[5].T;
//   EVA.heatPort[6].T = prescribedHeatFlow.portsOut[6].T;
//   EVA.heatPort[7].T = prescribedHeatFlow.portsOut[7].T;
//   EVA.heatPort[8].T = prescribedHeatFlow.portsOut[8].T;
//   EVA.heatPort[9].T = prescribedHeatFlow.portsOut[9].T;
//   EVA.heatPort[10].T = prescribedHeatFlow.portsOut[10].T;
//   EVA.heatPort[11].T = prescribedHeatFlow.portsOut[11].T;
//   EVA.heatPort[12].T = prescribedHeatFlow.portsOut[12].T;
//   EVA.heatPort[13].T = prescribedHeatFlow.portsOut[13].T;
//   EVA.heatPort[14].T = prescribedHeatFlow.portsOut[14].T;
//   EVA.heatPort[15].T = prescribedHeatFlow.portsOut[15].T;
//   EVA.heatPort[16].T = prescribedHeatFlow.portsOut[16].T;
//   EVA.heatPort[17].T = prescribedHeatFlow.portsOut[17].T;
//   EVA.heatPort[18].T = prescribedHeatFlow.portsOut[18].T;
//   EVA.heatPort[19].T = prescribedHeatFlow.portsOut[19].T;
//   EVA.heatPort[20].T = prescribedHeatFlow.portsOut[20].T;
//   ECO.portIn.p = watersource_mh.ports[1].p;
// algorithm
//   when {time >= pre(timeTable1.originalTable.nextEvent), initial()} then
//     (timeTable1.originalTable.a, timeTable1.originalTable.b, timeTable1.originalTable.nextEvent, timeTable1.originalTable.last) := Modelica.Blocks.Sources.TimeTable.getInterpolationCoefficients({{timeTable1.originalTable.table[1,1], timeTable1.originalTable.table[1,2]}, {timeTable1.originalTable.table[2,1], timeTable1.originalTable.table[2,2]}, {timeTable1.originalTable.table[3,1], timeTable1.originalTable.table[3,2]}, {timeTable1.originalTable.table[4,1], timeTable1.originalTable.table[4,2]}}, timeTable1.originalTable.offset, timeTable1.originalTable.startTime, time, timeTable1.originalTable.last, 0.0000000000001);
//   end when;
//   when {time >= pre(timeTable.originalTable.nextEvent), initial()} then
//     (timeTable.originalTable.a, timeTable.originalTable.b, timeTable.originalTable.nextEvent, timeTable.originalTable.last) := Modelica.Blocks.Sources.TimeTable.getInterpolationCoefficients({{timeTable.originalTable.table[1,1], timeTable.originalTable.table[1,2]}, {timeTable.originalTable.table[2,1], timeTable.originalTable.table[2,2]}, {timeTable.originalTable.table[3,1], timeTable.originalTable.table[3,2]}, {timeTable.originalTable.table[4,1], timeTable.originalTable.table[4,2]}}, timeTable.originalTable.offset, timeTable.originalTable.startTime, time, timeTable.originalTable.last, 0.0000000000001);
//   end when;
// end SiemensPower.Components.Pipes.Tests.tube_test;
// "
// "Warning: Parameter EVA.geoPipe has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter EVA.metal has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter EVA.geoPipe has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter ECO.geoPipe has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter ECO.metal has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter ECO.geoPipe has neither value nor start value, and is fixed during initialization (fixed=true)
// "
// "Check of SiemensPower.Components.Pipes.Tests.tube_test completed successfully.
// 
// 
// Class SiemensPower.Components.Pipes.Tests.tube_test has 2465 equation(s) and 2465 variable(s).
// 1598 of these are trivial equation(s).
// "
// ""
// endResult
