// name: SimCodeTest
// cflags: +g=MetaModelica
// status: correct
// setup_command: rm -f SimCodeC_abc.c SimCodeC_abc.h SimCodeC_abc.makefile

setCommandLineOptions({"+g=MetaModelica","+d=rml"});
setOption(envCache,false);

runScript("LoadCompilerSources.mos");
getErrorString();

path:=Absyn.QUALIFIED("SimCodeC",Absyn.IDENT("abc"));
func:=DAE.FUNCTION(path,{DAE.FUNCTION_DEF({})},(DAE.T_FUNCTION({},DAE.T_NORETCALL_DEFAULT,DAE.NO_INLINE()),SOME(path)),false,DAE.NO_INLINE(),DAE.emptyElementSource);
SimCode.translateFunctions("SimCodeC_abc", func, {}, {});
getErrorString();
readFile("SimCodeC_abc.h");
readFile("SimCodeC_abc.c");
// Do not read the makefile; it's different depending on the OS
// readFile("SimCodeC_abc.makefile");

// Result:
// true
// true
// Loaded all files without error
// "true
// "
// ""
// record Absyn.Path.QUALIFIED
//     name = "SimCodeC",
//     path = record Absyn.Path.IDENT
//     name = "abc"
// end Absyn.Path.IDENT;
// end Absyn.Path.QUALIFIED;
// record DAE.Function.FUNCTION
//     path = record Absyn.Path.QUALIFIED
//     name = "SimCodeC",
//     path = record Absyn.Path.IDENT
//     name = "abc"
// end Absyn.Path.IDENT;
// end Absyn.Path.QUALIFIED;,
//     functions = {record DAE.FunctionDefinition.FUNCTION_DEF
//     body = {}
// end DAE.FunctionDefinition.FUNCTION_DEF;},
//     type_ = (record DAE.TType.T_FUNCTION
//     funcArg = {},
//     funcResultType = (record DAE.TType.T_NORETCALL
// end DAE.TType.T_NORETCALL;,NONE()),
//     inline = record DAE.InlineType.NO_INLINE
// end DAE.InlineType.NO_INLINE;
// end DAE.TType.T_FUNCTION;,SOME(record Absyn.Path.QUALIFIED
//     name = "SimCodeC",
//     path = record Absyn.Path.IDENT
//     name = "abc"
// end Absyn.Path.IDENT;
// end Absyn.Path.QUALIFIED;)),
//     partialPrefix = false,
//     inlineType = record DAE.InlineType.NO_INLINE
// end DAE.InlineType.NO_INLINE;,
//     source = record DAE.ElementSource.SOURCE
//     info = record Absyn.Info.INFO
//     fileName = "",
//     isReadOnly = false,
//     lineNumberStart = 0,
//     columnNumberStart = 0,
//     lineNumberEnd = 0,
//     columnNumberEnd = 0,
//     buildTimes = record Absyn.TimeStamp.TIMESTAMP
//     lastBuildTime = 0.0,
//     lastEditTime = 0.0
// end Absyn.TimeStamp.TIMESTAMP;
// end Absyn.Info.INFO;,
//     partOfLst = {},
//     instanceOptLst = {},
//     connectEquationOptLst = {},
//     typeLst = {}
// end DAE.ElementSource.SOURCE;
// end DAE.Function.FUNCTION;
// 
// ""
// "#ifndef SimCodeC_abc__H
// #define SimCodeC_abc__H
// #include "modelica.h"
// #include <stdio.h>
// #include <stdlib.h>
// #include <errno.h>
// 
// #if defined(_MSC_VER)
//   #define DLLExport   __declspec( dllexport )
// #else
//   #define DLLExport /* nothing */
// #endif
// #ifdef __cplusplus
// extern "C" {
// #endif
// 
// 
// void _SimCodeC_abc();
// 
// #ifdef __cplusplus
// }
// #endif
// #endif"
// "#include "SimCodeC_abc.h"
// #include <algorithm>
// #define MODELICA_ASSERT(cond,msg) { if (!(cond)) fprintf(stderr,"Modelica Assert: %s!\n", msg); }
// #define MODELICA_TERMINATE(msg) { fprintf(stderr,"Modelica Terminate: %s!\n", msg); fflush(stderr); }
// 
// extern "C" {
// void _SimCodeC_abc()
// {
//   state tmp1;
//   tmp1 = get_memory_state();
// 
// 
//   
//   _return:
//   restore_memory_state(tmp1);
//   return ;
// }
// 
// int in_SimCodeC_abc(type_description * inArgs, type_description * outVar)
// {
//   _SimCodeC_abc();
//   write_noretcall(outVar);
//   return 0;
// }
// 
// }
// 
// "
// endResult
