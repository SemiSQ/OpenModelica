//name:        Dependency + check Modelica.Mechanics.MultiBody [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Mechanics.MultiBody using +d=usedep
//status:      correct
//
// instantiate/check model example
//

// load libraries
loadModel(Modelica,{"3.1"}); getErrorString();
loadModel(ModelicaServices,{"1.0"}); // Needed for PartialLineForce
getErrorString();

// check without dependency analysis
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Types.RotationSequence); 
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();

// activate dependency analysis +d=usedep
setDebugFlags("usedep"); getErrorString();

// check with dependency analysis
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Types.RotationSequence); 
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();

// Result:
// true
// ""
// true
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce completed successfully.
// 
// [Interfaces.mo:580:3-664:23:writable] Warning: Forcing full instantiation of partial class PartialLineForce during checkModel.
// Warning: No corresponding 'inner' declaration found for component world declared as 'outer '.
//   The existing 'inner' components are: 
//     There are no 'inner' components defined in the model in any of the parent scopes of 'outer' component's scope: Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce.
//   Check if you have not misspelled the 'outer' component name.
//   Please declare an 'inner' component with the same name in the top scope.
//   Continuing flattening by only considering the 'outer' component declaration.
// 
// Class Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce has 1112 equation(s) and 1119 variable(s).
// 642 of these are trivial equation(s).
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Types.RotationSequence completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Types.RotationSequence has 0 equation(s) and 0 variable(s).
// 0 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
//   parameter String shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real length(quantity = \"Length\", unit = \"m\") = 0.0 \"Length of visual object\";
//   input Real width(quantity = \"Length\", unit = \"m\") = 0.0 \"Width of visual object\";
//   input Real height(quantity = \"Length\", unit = \"m\") = 0.0 \"Height of visual object\";
//   input Real extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real color[1] = 255.0 \"Color of shape\";
//   input Real color[2] = 0.0 \"Color of shape\";
//   input Real color[3] = 0.0 \"Color of shape\";
//   input Real specularCoefficient = 0.7 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({lengthDirection[1],lengthDirection[2],lengthDirection[3]});
//   protected Real e_x[1](unit = \"1\") = if noEvent(abs_n_x < 0.0000000001) then 1.0 else lengthDirection[1] / abs_n_x;
//   protected Real e_x[2](unit = \"1\") = if noEvent(abs_n_x < 0.0000000001) then 0.0 else lengthDirection[2] / abs_n_x;
//   protected Real e_x[3](unit = \"1\") = if noEvent(abs_n_x < 0.0000000001) then 0.0 else lengthDirection[3] / abs_n_x;
//   protected Real n_z_aux[1](unit = \"1\") = e_x[2] * widthDirection[3] - e_x[3] * widthDirection[2];
//   protected Real n_z_aux[2](unit = \"1\") = e_x[3] * widthDirection[1] - e_x[1] * widthDirection[3];
//   protected Real n_z_aux[3](unit = \"1\") = e_x[1] * widthDirection[2] - e_x[2] * widthDirection[1];
//   protected Real e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 0.000001) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{e_x[1],e_x[2],e_x[3]})[1];
//   protected Real e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 0.000001) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{e_x[1],e_x[2],e_x[3]})[2];
//   protected Real e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 0.000001) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{e_x[1],e_x[2],e_x[3]})[3];
//   protected output Real Form;
//   output Real rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Material;
//   protected output Real Extra;
// equation
//   Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(shapeType);
//   rxvisobj[1] = R.T[1,1] * e_x[1] + R.T[2,1] * e_x[2] + R.T[3,1] * e_x[3];
//   rxvisobj[2] = R.T[1,2] * e_x[1] + R.T[2,2] * e_x[2] + R.T[3,2] * e_x[3];
//   rxvisobj[3] = R.T[1,3] * e_x[1] + R.T[2,3] * e_x[2] + R.T[3,3] * e_x[3];
//   ryvisobj[1] = R.T[1,1] * e_y[1] + R.T[2,1] * e_y[2] + R.T[3,1] * e_y[3];
//   ryvisobj[2] = R.T[1,2] * e_y[1] + R.T[2,2] * e_y[2] + R.T[3,2] * e_y[3];
//   ryvisobj[3] = R.T[1,3] * e_y[1] + R.T[2,3] * e_y[2] + R.T[3,3] * e_y[3];
//   rvisobj = r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{R.T[1,1],R.T[1,2],R.T[1,3]},{R.T[2,1],R.T[2,2],R.T[2,3]},{R.T[3,1],R.T[3,2],R.T[3,3]}},{r_shape[1],r_shape[2],r_shape[3]});
//   size[1] = length;
//   size[2] = width;
//   size[3] = height;
//   Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(color[1] / 255.0,color[2] / 255.0,color[3] / 255.0,specularCoefficient);
//   Extra = extra;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape has 37 equation(s) and 37 variable(s).
// 13 of these are trivial equation(s).
// "
// ""
// true
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "[Interfaces.mo:580:3-664:23:writable] Warning: Forcing full instantiation of partial class PartialLineForce during checkModel.
// [Interfaces.mo:34:3-71:14:writable] Warning: Connector Modelica.Mechanics.MultiBody.Interfaces.Frame_a is not balanced: The number of potential variables (15) is not equal to the number of flow variables (6).
// [Interfaces.mo:73:3-109:14:writable] Warning: Connector Modelica.Mechanics.MultiBody.Interfaces.Frame_b is not balanced: The number of potential variables (15) is not equal to the number of flow variables (6).
// Warning: No corresponding 'inner' declaration found for component world declared as 'outer '.
//   The existing 'inner' components are: 
//     There are no 'inner' components defined in the model in any of the parent scopes of 'outer' component's scope: Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce.
//   Check if you have not misspelled the 'outer' component name.
//   Please declare an 'inner' component with the same name in the top scope.
//   Continuing flattening by only considering the 'outer' component declaration.
// [Interfaces.mo:73:3-109:14:writable] Warning: Connector Modelica.Mechanics.MultiBody.Interfaces.Frame_b is not balanced: The number of potential variables (15) is not equal to the number of flow variables (6).
// [Interfaces.mo:613:5-613:68:writable] Error: Class Frames.resolve2 not found in scope Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce (looking for a function or record).
// [Interfaces.mo:580:3-664:23:writable] Error: Illegal to instantiate partial class PartialLineForce
// Error: Error occurred while flattening model Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce
// "
// ""
// "[package.mo:3:1-3:32:writable] Error: Base class Modelica.Icons.Library2 not found in scope Modelica.Mechanics
// [package.mo:2:1-5197:13:writable] Error: Class Mechanics.MultiBody.Types.RotationSequence not found in scope Modelica.
// Error: Class Modelica.Mechanics.MultiBody.Types.RotationSequence not found in scope .
// Error: Error occurred while flattening model Modelica.Mechanics.MultiBody.Types.RotationSequence
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
//   parameter String shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real length(quantity = \"Length\", unit = \"m\") = 0.0 \"Length of visual object\";
//   input Real width(quantity = \"Length\", unit = \"m\") = 0.0 \"Width of visual object\";
//   input Real height(quantity = \"Length\", unit = \"m\") = 0.0 \"Height of visual object\";
//   input Real extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real color[1] = 255.0 \"Color of shape\";
//   input Real color[2] = 0.0 \"Color of shape\";
//   input Real color[3] = 0.0 \"Color of shape\";
//   input Real specularCoefficient = 0.7 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({lengthDirection[1],lengthDirection[2],lengthDirection[3]});
//   protected Real e_x[1](unit = \"1\") = if noEvent(abs_n_x < 0.0000000001) then 1.0 else lengthDirection[1] / abs_n_x;
//   protected Real e_x[2](unit = \"1\") = if noEvent(abs_n_x < 0.0000000001) then 0.0 else lengthDirection[2] / abs_n_x;
//   protected Real e_x[3](unit = \"1\") = if noEvent(abs_n_x < 0.0000000001) then 0.0 else lengthDirection[3] / abs_n_x;
//   protected Real n_z_aux[1](unit = \"1\") = e_x[2] * widthDirection[3] - e_x[3] * widthDirection[2];
//   protected Real n_z_aux[2](unit = \"1\") = e_x[3] * widthDirection[1] - e_x[1] * widthDirection[3];
//   protected Real n_z_aux[3](unit = \"1\") = e_x[1] * widthDirection[2] - e_x[2] * widthDirection[1];
//   protected Real e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 0.000001) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{e_x[1],e_x[2],e_x[3]})[1];
//   protected Real e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 0.000001) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{e_x[1],e_x[2],e_x[3]})[2];
//   protected Real e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 0.000001) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{e_x[1],e_x[2],e_x[3]})[3];
//   protected output Real Form;
//   output Real rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Material;
//   protected output Real Extra;
// equation
//   Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(shapeType);
//   rxvisobj[1] = R.T[1,1] * e_x[1] + R.T[2,1] * e_x[2] + R.T[3,1] * e_x[3];
//   rxvisobj[2] = R.T[1,2] * e_x[1] + R.T[2,2] * e_x[2] + R.T[3,2] * e_x[3];
//   rxvisobj[3] = R.T[1,3] * e_x[1] + R.T[2,3] * e_x[2] + R.T[3,3] * e_x[3];
//   ryvisobj[1] = R.T[1,1] * e_y[1] + R.T[2,1] * e_y[2] + R.T[3,1] * e_y[3];
//   ryvisobj[2] = R.T[1,2] * e_y[1] + R.T[2,2] * e_y[2] + R.T[3,2] * e_y[3];
//   ryvisobj[3] = R.T[1,3] * e_y[1] + R.T[2,3] * e_y[2] + R.T[3,3] * e_y[3];
//   rvisobj = r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{R.T[1,1],R.T[1,2],R.T[1,3]},{R.T[2,1],R.T[2,2],R.T[2,3]},{R.T[3,1],R.T[3,2],R.T[3,3]}},{r_shape[1],r_shape[2],r_shape[3]});
//   size[1] = length;
//   size[2] = width;
//   size[3] = height;
//   Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(color[1] / 255.0,color[2] / 255.0,color[3] / 255.0,specularCoefficient);
//   Extra = extra;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape has 37 equation(s) and 37 variable(s).
// 13 of these are trivial equation(s).
// "
// ""
// endResult
