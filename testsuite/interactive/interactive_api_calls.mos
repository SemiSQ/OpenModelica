// name: API-Interactive Calls
// keywords: Graphical API, component attributes
// status: correct
// 
//  Subset of the Graphical API for setting component attributes
//

setCommandLineOptions({"+d=showStatement"});

createModel(A);              getErrorString();
addComponent(x,Real,A);      getErrorString();
isModel(A);                  getErrorString();
isRecord(A);                 getErrorString();
isBlock(A);                  getErrorString();
isType(A);                   getErrorString();
isFunction(A);               getErrorString();
isPackage(A);                getErrorString();
isClass(A);                  getErrorString();

loadFile("interactive_api_calls.mo"); getErrorString();
isType(vector3D);            getErrorString();
isShortDefinition(vector3D); getErrorString();
isShortDefinition(C); getErrorString();
isEnumeration(C); getErrorString();
getEnumerationLiterals(C); getErrorString();
isEnumeration(size); getErrorString();
getEnumerationLiterals(size); getErrorString();
isReplaceable(ReplaceableClass, "M1"); getErrorString();
isReplaceable(RealSignal, "SignalType"); getErrorString();
getClassInformation(vector3D); getErrorString();
getInheritanceCount(vector3D); getErrorString();
getNthInheritedClass(vector3D, 1); getErrorString();
getNthComponentCondition(M, 1); getErrorString();
getNthComponentCondition(M, 2); getErrorString();
getNthComponentCondition(M, 3); getErrorString();
getExtendsModifierNames(vector3D, Real); getErrorString();
getExtendsModifierValue(vector3D, Real, start); getErrorString();
getExtendsModifierValue(vector3D, Real, nominal); getErrorString();
getClassComment(M); getErrorString();
getComponentComment(M, r); getErrorString();

loadModel(Modelica); getErrorString();
getAnnotationCount(Modelica.Electrical.Analog.Basic.Resistor); getErrorString();
getNthAnnotationString(Modelica.Electrical.Analog.Basic.Resistor, 1); getErrorString();
getImportCount(Modelica.Mechanics.Rotational); getErrorString();
getNthImport(Modelica.Mechanics.Rotational, 1); getErrorString();
getInitialAlgorithmCount(Modelica.Blocks.Sources.BooleanTable); getErrorString();
getNthInitialAlgorithm(Modelica.Blocks.Sources.BooleanTable, 1); getErrorString();
getAlgorithmCount(Modelica.Blocks.Sources.BooleanTable); getErrorString();
getNthAlgorithm(Modelica.Blocks.Sources.BooleanTable, 1); getErrorString();
getInitialEquationCount(Modelica.Mechanics.MultiBody.Parts.Body); getErrorString();
getNthInitialEquation(Modelica.Mechanics.MultiBody.Parts.Body, 1); getErrorString();
getEquationCount(Modelica.Mechanics.MultiBody.Parts.Body); getErrorString();
getNthEquation(Modelica.Mechanics.MultiBody.Parts.Body, 1); getErrorString();

getShortDefinitionBaseClassInformation(RealInput); getErrorString();
getShortDefinitionBaseClassInformation(RealInput3); getErrorString();
getShortDefinitionBaseClassInformation(RealConnect); getErrorString();

getExternalFunctionSpecification(TestPack.Ext); getErrorString();
getExternalFunctionSpecification(TestPack.NoExt); getErrorString();

// Result:
// {true}
// Evaluating: createModel(A)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: addComponent(x, Real, A)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: isModel(A)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: isRecord(A)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: isBlock(A)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: isType(A)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: isFunction(A)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: isPackage(A)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: isClass(A)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: loadFile("interactive_api_calls.mo")
// true
// Evaluating: getErrorString()
// ""
// Evaluating: isType(vector3D)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: isShortDefinition(vector3D)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: isShortDefinition(C)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: isEnumeration(C)
// false
// Evaluating: getErrorString()
// ""
// Evaluating: getEnumerationLiterals(C)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: isEnumeration(size)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: getEnumerationLiterals(size)
// {"Small","Medium","Large"}
// Evaluating: getErrorString()
// ""
// Evaluating: isReplaceable(ReplaceableClass, "M1")
// true
// Evaluating: getErrorString()
// ""
// Evaluating: isReplaceable(RealSignal, "SignalType")
// true
// Evaluating: getErrorString()
// ""
// Evaluating: getClassInformation(vector3D)
// {"type","","interactive_api_calls.mo",{false,false,false},{"writable",4,1,4,67},{3}}
// Evaluating: getErrorString()
// ""
// Evaluating: getInheritanceCount(vector3D)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthInheritedClass(vector3D, 1)
// Real
// Evaluating: getErrorString()
// ""
// Evaluating: getNthComponentCondition(M, 1)
// ""
// Evaluating: getErrorString()
// ""
// Evaluating: getNthComponentCondition(M, 2)
// "if i > 0"
// Evaluating: getErrorString()
// ""
// Evaluating: getNthComponentCondition(M, 3)
// Error
// Evaluating: getErrorString()
// ""
// Evaluating: getExtendsModifierNames(vector3D, Real)
// {start, nominal}
// Evaluating: getErrorString()
// ""
// Evaluating: getExtendsModifierValue(vector3D, Real, start)
//  = 5
// Evaluating: getErrorString()
// ""
// Evaluating: getExtendsModifierValue(vector3D, Real, nominal)
//  = {1,2,3,4,5}
// Evaluating: getErrorString()
// ""
// Evaluating: getClassComment(M)
// "A class comment"
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentComment(M, r)
// "A component comment"
// Evaluating: getErrorString()
// ""
// Evaluating: loadModel(Modelica)
// true
// Evaluating: getErrorString()
// ""
// Evaluating: getAnnotationCount(Modelica.Electrical.Analog.Basic.Resistor)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthAnnotationString(Modelica.Electrical.Analog.Basic.Resistor, 1)
// "annotation(Documentation(info = \"<HTML>
// <P>
// The linear resistor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i*R = v</i>.
// The Resistance <i>R</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// \", revisions = \"<html>
// <ul>
// <li><i> August 07, 2009   </i>
//        by Anton Haumer<br> temperature dependency of resistance added<br>
//        </li>
// <li><i> March 11, 2009   </i>
//        by Christoph Clauss<br> conditional heat port added<br>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>\"), Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}, grid = {2,2}), graphics = {Rectangle(extent = {{-70,30},{70,-30}}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid),Line(points = {{-90,0},{-70,0}}, color = {0,0,255}),Line(points = {{70,0},{90,0}}, color = {0,0,255}),Text(extent = {{-144,-40},{142,-72}}, lineColor = {0,0,0}, textString = \"R=%R\"),Line(visible = useHeatPort, points = {{0,-100},{0,-30}}, color = {127,0,0}, smooth = Smooth.None, pattern = LinePattern.Dot),Text(extent = {{-152,87},{148,47}}, textString = \"%name\", lineColor = {0,0,255})}), Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}, grid = {2,2}), graphics = {Rectangle(extent = {{-70,30},{70,-30}}, lineColor = {0,0,255}),Line(points = {{-96,0},{-70,0}}, color = {0,0,255}),Line(points = {{70,0},{96,0}}, color = {0,0,255})}));"
// Evaluating: getErrorString()
// ""
// Evaluating: getImportCount(Modelica.Mechanics.Rotational)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthImport(Modelica.Mechanics.Rotational, 1)
// {"Modelica.SIunits","SI","named"}
// Evaluating: getErrorString()
// ""
// Evaluating: getInitialAlgorithmCount(Modelica.Blocks.Sources.BooleanTable)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthInitialAlgorithm(Modelica.Blocks.Sources.BooleanTable, 1)
// "(index,nextTime,y):=getFirstIndex(table, time, startValue);
// "
// Evaluating: getErrorString()
// ""
// Evaluating: getAlgorithmCount(Modelica.Blocks.Sources.BooleanTable)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthAlgorithm(Modelica.Blocks.Sources.BooleanTable, 1)
// "when time >= pre(nextTime) and n > 0 then
//   if index < n then 
//     index:=index + 1;
//   nextTime:=table[index];
//   y:=not y;
//   elseif index == n then
//     index:=index + 1;
//     y:=not y;
// 
// 
//   else 
//   end if;
// 
// end when;
//  annotation(Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics = {Rectangle(extent = {{-18,70},{32,-50}}, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{-18,-50},{-18,70},{32,70},{32,-50},{-18,-50},{-18,-20},{32,-20},{32,10},{-18,10},{-18,40},{32,40},{32,70},{32,70},{32,-51}}, color = {0,0,0})}), Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics = {Rectangle(extent = {{-34,66},{16,-54}}, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{-34,-54},{-34,66},{16,66},{16,-54},{-34,-54},{-34,-24},{16,-24},{16,6},{-34,6},{-34,36},{16,36},{16,66},{16,66},{16,-55}}, color = {0,0,0}),Text(extent = {{-29,59},{10,44}}, lineColor = {0,0,0}, textString = \"time\")}), Documentation(info = \"<html>
// <p>
// The Boolean output y is a signal defined by parameter vector <b>table</b>.
// In the vector time points are stored. At every time point, the output y
// changes its value to the negated value of the previous one.
// </p>
// 
// <p>
// <img src=\\\"../Images/Blocks/Sources/BooleanTable.png\\\">
// </p>
// </html>\"));
// "
// Evaluating: getErrorString()
// ""
// Evaluating: getInitialEquationCount(Modelica.Mechanics.MultiBody.Parts.Body)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthInitialEquation(Modelica.Mechanics.MultiBody.Parts.Body, 1)
// "if angles_fixed then
//   if not Connections.isRoot(frame_a.R) then
//     zeros(3) = Frames.Orientation.equalityConstraint(frame_a.R, R_start);
//   elseif useQuaternions then
//     zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
//   else
//     phi = phi_start;
//   end if;
// end if;
// "
// Evaluating: getErrorString()
// ""
// Evaluating: getEquationCount(Modelica.Mechanics.MultiBody.Parts.Body)
// 1
// Evaluating: getErrorString()
// ""
// Evaluating: getNthEquation(Modelica.Mechanics.MultiBody.Parts.Body, 1)
// "if enforceStates then
//   Connections.root(frame_a.R);
// else
//   Connections.potentialRoot(frame_a.R);
// end if;
// r_0 = frame_a.r_0;
// if not Connections.isRoot(frame_a.R) then
//   Q = {0,0,0,1};
//   phi = zeros(3);
//   phi_d = zeros(3);
//   phi_dd = zeros(3);
// elseif useQuaternions then
//   frame_a.R = Frames.from_Q(Q, Frames.Quaternions.angularVelocity2(Q, der(Q)));
//   {0} = Frames.Quaternions.orientationConstraint(Q);
//   phi = zeros(3);
//   phi_d = zeros(3);
//   phi_dd = zeros(3);
// else
//   phi_d = der(phi);
//   phi_dd = der(phi_d);
//   frame_a.R = Frames.axesRotations(sequence_angleStates, phi, phi_d);
//   Q = {0,0,0,1};
// end if;
// g_0 = world.gravityAcceleration(frame_a.r_0 + Frames.resolve1(frame_a.R, r_CM));
// v_0 = der(frame_a.r_0);
// a_0 = der(v_0);
// w_a = Frames.angularVelocity2(frame_a.R);
// z_a = der(w_a);
// frame_a.f = m * (Frames.resolve2(frame_a.R, a_0 - g_0) + cross(z_a, r_CM) + cross(w_a, cross(w_a, r_CM)));
// frame_a.t = I * z_a + cross(w_a, I * w_a) + cross(r_CM, frame_a.f);
//  annotation(Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}, grid = {1,1}), graphics = {Rectangle(extent = {{-100,30},{-3,-31}}, lineColor = {0,0,0}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {0,127,255}),Text(extent = {{131,-123},{-129,-73}}, lineColor = {0,0,0}, textString = \"m=%m\"),Text(extent = {{-128,132},{132,72}}, textString = \"%name\", lineColor = {0,0,255}),Ellipse(extent = {{-20,60},{100,-60}}, lineColor = {0,0,0}, fillPattern = FillPattern.Sphere, fillColor = {0,127,255})}), Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}, grid = {1,1}), graphics), Documentation(info = \"<HTML>
// <p>
// <b>Rigid body</b> with mass and inertia tensor.
// All parameter vectors have to be resolved in frame_a.
// The <b>inertia tensor</b> has to be defined with respect to a
// coordinate system that is parallel to frame_a with the
// origin at the center of mass of the body.
// </p>
// <p>
// By default, this component is visualized by a <b>cylinder</b> located
// between frame_a and the center of mass and by a <b>sphere</b> that has
// its center at the center of mass. If the cylinder length is smaller as
// the radius of the sphere, e.g., since frame_a is located at the
// center of mass, the cylinder is not displayed. Note, that
// the animation may be switched off via parameter animation = <b>false</b>.
// </p>
// <IMG SRC=\\\"../Images/MultiBody/Body.png\\\" ALT=\\\"Parts.Body\\\">
// <p>
// <b>States of Body Components</b>
// </p>
// <p>
// Every body has potential states. If possible a tool will select
// the states of joints and not the states of bodies because this is
// usually the most efficient choice. In this case the position, orientation,
// velocity and angular velocity of frame_a of the body will be computed
// by the component that is connected to frame_a. However, if a body is moving
// freely in space, variables of the body have to be used as states. The potential
// states of the body are:
// </p>
// <ul>
// <li> The <b>position vector</b> frame_a.r_0 from the origin of the
//      world frame to the origin of frame_a of the body, resolved in
//      the world frame and the <b>absolute velocity</b> v_0 of the origin of
//      frame_a, resolved in the world frame (= der(frame_a.r_0)).</li>
// </li>
// <li> If parameter <b>useQuaternions</b> in the \\\"Advanced\\\" menu
//      is <b>true</b> (this is the default), then <b>4 quaternions</b>
//      are potential states. Additionally, the coordinates of the
//      absolute angular velocity vector of the
//      body are 3 potential states.<br>
//      If <b>useQuaternions</b> in the \\\"Advanced\\\" menu
//      is <b>false</b>, then <b>3 angles</b> and the derivatives of
//      these angles are potential states. The orientation of frame_a
//      is computed by rotating the world frame along the axes defined
//      in parameter vector \\\"sequence_angleStates\\\" (default = {1,2,3}, i.e.,
//      the Cardan angle sequence) around the angles used as potential states.
//      For example, the default is to rotate the x-axis of the world frame
//      around angles[1], the new y-axis around angles[2] and the new z-axis
//      around angles[3], arriving at frame_a.
//  </li>
// </ul>
// <p>
// The quaternions have the slight disadvantage that there is a
// non-linear constraint equation between the 4 quaternions.
// Therefore, at least one non-linear equation has to be solved
// during simulation. A tool might, however, analytically solve this
// simple constraint equation. Using the 3 angles as states has the
// disadvantage that there is a singular configuration in which a
// division by zero will occur. If it is possible to determine in advance
// for an application class that this singular configuration is outside
// of the operating region, the 3 angles might be used as potential
// states by setting <b>useQuaternions</b> = <b>false</b>.
// </p>
// <p>
// In text books about 3-dimensional mechanics often 3 angles and the
// angular velocity are used as states. This is not the case here, since
// 3 angles and their derivatives are used as potential states
// (if useQuaternions = false). The reason
// is that for real-time simulation the discretization formula of the
// integrator might be \\\"inlined\\\" and solved together with the body equations.
// By appropriate symbolic transformation the performance is
// drastically increased if angles and their
// derivatives are used as states, instead of angles and the angular
// velocity.
// </p>
// <p>
// Whether or not variables of the body are used as states is usually
// automatically selected by the Modelica translator. If parameter
// <b>enforceStates</b> is set to <b>true</b> in the \\\"Advanced\\\" menu,
// then body variables are forced to be used as states according
// to the setting of parameters \\\"useQuaternions\\\" and
// \\\"sequence_angleStates\\\".
// </p>
// </HTML>\"));
// "
// Evaluating: getErrorString()
// ""
// Evaluating: getShortDefinitionBaseClassInformation(RealInput)
// {Real,"","","unspecified","input",{}}
// Evaluating: getErrorString()
// ""
// Evaluating: getShortDefinitionBaseClassInformation(RealInput3)
// {Real,"flow","","constant","input",{3}}
// Evaluating: getErrorString()
// ""
// Evaluating: getShortDefinitionBaseClassInformation(RealConnect)
// {Real,"","stream","unspecified","unspecified",{}}
// Evaluating: getErrorString()
// ""
// Evaluating: getExternalFunctionSpecification(TestPack.Ext)
// "C","u","externFunc","x, y, z","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getExternalFunctionSpecification(TestPack.NoExt)
// {}
// Evaluating: getErrorString()
// ""
// endResult
