//name:         ControlledTanks
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.StateGraph.Examples.ControlledTanks);
getErrorString();
// Result:
// true
// "function Modelica.Blocks.Sources.BooleanTable.getFirstIndex
//   input Real[:] table "Vector of time instants";
//   input Real simulationStartTime(quantity = "Time", unit = "s") "Simulation start time";
//   input Boolean startValue "Value of y for y < table[1]";
//   output Integer index "First index to be used";
//   output Real nextTime(quantity = "Time", unit = "s") "Time instant of first event";
//   output Boolean y "Value of y at simulationStartTime";
//   protected Real t_last(quantity = "Time", unit = "s");
//   protected Integer j;
//   protected Integer n = size(table,1) "Number of table points";
// algorithm
//   if size(table,1) == 0 then
//     index := 0;
//     nextTime := -1e+60;
//     y := startValue;
//   elseif size(table,1) == 1 then
//     index := 1;
//     if table[1] > simulationStartTime then
//       nextTime := table[1];
//       y := startValue;
//     else
//       nextTime := simulationStartTime;
//       y := startValue;
//     end if;
//   else
//     t_last := table[1];
//     for i in 2:n loop
//       assert( table<asub>[i] > t_last, "Time values of table not strict monotonically increasing: table[" + String(i - 1,0,true,6) + "] = " + String(table<asub>[i - 1],0,true,6) + "table[" + String(i,0,true,6) + "] = " + String(table<asub>[i],0,true,6));
//     end for;
//     j := 1;
//     y := startValue;
//     while j < n AND table<asub>[j] <= simulationStartTime loop
//       y :=  NOT y;
//       j := 1 + j;
//     end while;
//     if j == 1 then
//       nextTime := table[1];
//       y := startValue;
//     elseif j == n AND table<asub>[n] <= simulationStartTime then
//       nextTime := simulationStartTime - 1.0;
//       y :=  NOT y;
//     else
//       nextTime := table<asub>[j];
//     end if;
//     index := j;
//   end if;
// end Modelica.Blocks.Sources.BooleanTable.getFirstIndex;
// 
// function Modelica.StateGraph.Temporary.anyTrue
//   input Boolean[:] b;
//   output Boolean result;
// algorithm
//   result := false;
//   for i in 1:size(b,1) loop
//     result := result OR b<asub>[i];
//   end for;
// end Modelica.StateGraph.Temporary.anyTrue;
// 
// fclass Modelica.StateGraph.Examples.ControlledTanks
//   output Boolean stateGraphRoot.suspend = false;
//   output Boolean stateGraphRoot.resume = false;
//   output Boolean stateGraphRoot.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   output Boolean stateGraphRoot.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   input Real stateGraphRoot.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   output Integer stateGraphRoot.activeSteps "Number of active steps within the stategraph";
//   parameter Real tankController.limit = 0.98 "Limit level of tank 1";
//   parameter Real tankController.waitTime = 3.0 "Wait time";
//   parameter Integer tankController.s1.nIn(min = 0) = 2 "Number of input connections";
//   parameter Integer tankController.s1.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.s1.localActive = tankController.s1.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.s1.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.s1.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.s1.inPort[2].occupied "true, if step is active";
//   input Boolean tankController.s1.inPort[2].set "true, if transition fires and step is activated";
//   output Boolean tankController.s1.outPort[1].available "true, if step is active";
//   input Boolean tankController.s1.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.s1.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.s1.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.s1.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.s1.newActive "Value of active in the next iteration";
//   protected Boolean tankController.s1.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.s1.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.makeProduct.stateGraphRoot.suspend = Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.suspend[1].reset}) OR tankController.makeProduct.outerState.subgraphStatePort.suspend;
//   output Boolean tankController.makeProduct.stateGraphRoot.resume = Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.resume[1].set}) OR tankController.makeProduct.outerState.subgraphStatePort.resume;
//   output Boolean tankController.makeProduct.stateGraphRoot.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   output Boolean tankController.makeProduct.stateGraphRoot.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   input Real tankController.makeProduct.stateGraphRoot.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   parameter Integer tankController.makeProduct.nSuspend = 1 "Number of suspend ports";
//   parameter Integer tankController.makeProduct.nResume = 1 "Number of resume ports";
//   output Boolean tankController.makeProduct.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.makeProduct.outerState.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.makeProduct.outerState.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.makeProduct.outerState.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   output Boolean tankController.makeProduct.inPort.occupied "true, if step is active";
//   input Boolean tankController.makeProduct.inPort.set "true, if transition fires and step is activated";
//   output Boolean tankController.makeProduct.outPort.available "true, if step is active";
//   input Boolean tankController.makeProduct.outPort.reset "true, if transition fires and step is deactivated";
//   output Boolean tankController.makeProduct.suspend[1].available "true, if step is active";
//   input Boolean tankController.makeProduct.suspend[1].reset "true, if transition fires and step is deactived";
//   output Boolean tankController.makeProduct.resume[1].occupied "true, if step is active";
//   input Boolean tankController.makeProduct.resume[1].set "true, if transition fires and step is activated";
//   protected Boolean tankController.makeProduct.newActive "Value of active in the next iteration";
//   protected Integer tankController.makeProduct.activeSteps "Number of active steps within the CompositeStep";
//   parameter Real tankController.makeProduct.limit = tankController.limit "Limit level of tank 1";
//   parameter Real tankController.makeProduct.waitTime = tankController.waitTime "Wait time";
//   input Real tankController.makeProduct.level1;
//   parameter Integer tankController.makeProduct.fillTank1.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.makeProduct.fillTank1.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.makeProduct.fillTank1.localActive = tankController.makeProduct.fillTank1.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.makeProduct.fillTank1.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.makeProduct.fillTank1.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.makeProduct.fillTank1.outPort[1].available "true, if step is active";
//   input Boolean tankController.makeProduct.fillTank1.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.makeProduct.fillTank1.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.makeProduct.fillTank1.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.makeProduct.fillTank1.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.makeProduct.fillTank1.newActive "Value of active in the next iteration";
//   protected Boolean tankController.makeProduct.fillTank1.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.makeProduct.fillTank1.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.makeProduct.T1.localCondition = tankController.makeProduct.T1.condition "= true, if transition may fire";
//   parameter Boolean tankController.makeProduct.T1.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.makeProduct.T1.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.makeProduct.T1.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.makeProduct.T1.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.makeProduct.T1.fire "= true, if transition fires";
//   input Boolean tankController.makeProduct.T1.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.makeProduct.T1.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.makeProduct.T1.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.makeProduct.T1.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.makeProduct.T1.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.makeProduct.T1.t_dummy;
//   input Boolean tankController.makeProduct.T1.condition = tankController.makeProduct.level1 > tankController.makeProduct.limit "= true, if transition may fire (time varying expression)";
//   parameter Integer tankController.makeProduct.fillTank2.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.makeProduct.fillTank2.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.makeProduct.fillTank2.localActive = tankController.makeProduct.fillTank2.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.makeProduct.fillTank2.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.makeProduct.fillTank2.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.makeProduct.fillTank2.outPort[1].available "true, if step is active";
//   input Boolean tankController.makeProduct.fillTank2.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.makeProduct.fillTank2.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.makeProduct.fillTank2.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.makeProduct.fillTank2.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.makeProduct.fillTank2.newActive "Value of active in the next iteration";
//   protected Boolean tankController.makeProduct.fillTank2.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.makeProduct.fillTank2.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.makeProduct.T3.localCondition = tankController.makeProduct.T3.condition "= true, if transition may fire";
//   parameter Boolean tankController.makeProduct.T3.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.makeProduct.T3.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.makeProduct.T3.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.makeProduct.T3.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.makeProduct.T3.fire "= true, if transition fires";
//   input Boolean tankController.makeProduct.T3.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.makeProduct.T3.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.makeProduct.T3.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.makeProduct.T3.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.makeProduct.T3.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.makeProduct.T3.t_dummy;
//   input Boolean tankController.makeProduct.T3.condition = tankController.makeProduct.level1 < 0.001 "= true, if transition may fire (time varying expression)";
//   parameter Integer tankController.makeProduct.emptyTank2.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.makeProduct.emptyTank2.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.makeProduct.emptyTank2.localActive = tankController.makeProduct.emptyTank2.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.makeProduct.emptyTank2.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.makeProduct.emptyTank2.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.makeProduct.emptyTank2.outPort[1].available "true, if step is active";
//   input Boolean tankController.makeProduct.emptyTank2.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.makeProduct.emptyTank2.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.makeProduct.emptyTank2.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.makeProduct.emptyTank2.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.makeProduct.emptyTank2.newActive "Value of active in the next iteration";
//   protected Boolean tankController.makeProduct.emptyTank2.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.makeProduct.emptyTank2.active "= true if step is active, otherwise the step is not active";
//   parameter Integer tankController.makeProduct.wait1.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.makeProduct.wait1.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.makeProduct.wait1.localActive = tankController.makeProduct.wait1.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.makeProduct.wait1.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.makeProduct.wait1.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.makeProduct.wait1.outPort[1].available "true, if step is active";
//   input Boolean tankController.makeProduct.wait1.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.makeProduct.wait1.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.makeProduct.wait1.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.makeProduct.wait1.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.makeProduct.wait1.newActive "Value of active in the next iteration";
//   protected Boolean tankController.makeProduct.wait1.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.makeProduct.wait1.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.makeProduct.T2.localCondition = tankController.makeProduct.T2.condition "= true, if transition may fire";
//   parameter Boolean tankController.makeProduct.T2.enableTimer = true "= true, if timer is enabled";
//   parameter Real tankController.makeProduct.T2.waitTime(quantity = "Time", unit = "s", min = 0.0) = tankController.makeProduct.waitTime "Wait time before transition fires";
//   output Real tankController.makeProduct.T2.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.makeProduct.T2.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.makeProduct.T2.fire "= true, if transition fires";
//   input Boolean tankController.makeProduct.T2.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.makeProduct.T2.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.makeProduct.T2.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.makeProduct.T2.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.makeProduct.T2.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.makeProduct.T2.t_dummy;
//   input Boolean tankController.makeProduct.T2.condition = true "= true, if transition may fire (time varying expression)";
//   parameter Integer tankController.makeProduct.wait2.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.makeProduct.wait2.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.makeProduct.wait2.localActive = tankController.makeProduct.wait2.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.makeProduct.wait2.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.makeProduct.wait2.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.makeProduct.wait2.outPort[1].available "true, if step is active";
//   input Boolean tankController.makeProduct.wait2.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.makeProduct.wait2.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.makeProduct.wait2.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.makeProduct.wait2.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.makeProduct.wait2.newActive "Value of active in the next iteration";
//   protected Boolean tankController.makeProduct.wait2.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.makeProduct.wait2.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.makeProduct.T4.localCondition = tankController.makeProduct.T4.condition "= true, if transition may fire";
//   parameter Boolean tankController.makeProduct.T4.enableTimer = true "= true, if timer is enabled";
//   parameter Real tankController.makeProduct.T4.waitTime(quantity = "Time", unit = "s", min = 0.0) = tankController.makeProduct.waitTime "Wait time before transition fires";
//   output Real tankController.makeProduct.T4.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.makeProduct.T4.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.makeProduct.T4.fire "= true, if transition fires";
//   input Boolean tankController.makeProduct.T4.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.makeProduct.T4.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.makeProduct.T4.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.makeProduct.T4.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.makeProduct.T4.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.makeProduct.T4.t_dummy;
//   input Boolean tankController.makeProduct.T4.condition = true "= true, if transition may fire (time varying expression)";
//   input Boolean tankController.T1.localCondition = tankController.T1.condition "= true, if transition may fire";
//   parameter Boolean tankController.T1.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.T1.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.T1.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.T1.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.T1.fire "= true, if transition fires";
//   input Boolean tankController.T1.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.T1.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.T1.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.T1.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.T1.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.T1.t_dummy;
//   input Boolean tankController.T1.condition = tankController.start "= true, if transition may fire (time varying expression)";
//   input Boolean tankController.T2.localCondition = tankController.T2.condition "= true, if transition may fire";
//   parameter Boolean tankController.T2.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.T2.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.T2.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.T2.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.T2.fire "= true, if transition fires";
//   input Boolean tankController.T2.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.T2.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.T2.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.T2.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.T2.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.T2.t_dummy;
//   input Boolean tankController.T2.condition = tankController.level2 < 0.001 "= true, if transition may fire (time varying expression)";
//   input Boolean tankController.T3.localCondition = tankController.T3.condition "= true, if transition may fire";
//   parameter Boolean tankController.T3.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.T3.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.T3.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.T3.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.T3.fire "= true, if transition fires";
//   input Boolean tankController.T3.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.T3.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.T3.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.T3.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.T3.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.T3.t_dummy;
//   input Boolean tankController.T3.condition = tankController.stop "= true, if transition may fire (time varying expression)";
//   parameter Integer tankController.s2.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.s2.nOut(min = 0) = 2 "Number of output connections";
//   output Boolean tankController.s2.localActive = tankController.s2.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.s2.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.s2.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.s2.outPort[1].available "true, if step is active";
//   input Boolean tankController.s2.outPort[1].reset "true, if transition fires and step is deactivated";
//   output Boolean tankController.s2.outPort[2].available "true, if step is active";
//   input Boolean tankController.s2.outPort[2].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.s2.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.s2.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.s2.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.s2.newActive "Value of active in the next iteration";
//   protected Boolean tankController.s2.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.s2.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.T4.localCondition = tankController.T4.condition "= true, if transition may fire";
//   parameter Boolean tankController.T4.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.T4.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.T4.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.T4.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.T4.fire "= true, if transition fires";
//   input Boolean tankController.T4.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.T4.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.T4.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.T4.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.T4.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.T4.t_dummy;
//   input Boolean tankController.T4.condition = tankController.start "= true, if transition may fire (time varying expression)";
//   input Boolean tankController.T5.localCondition = tankController.T5.condition "= true, if transition may fire";
//   parameter Boolean tankController.T5.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.T5.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.T5.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.T5.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.T5.fire "= true, if transition fires";
//   input Boolean tankController.T5.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.T5.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.T5.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.T5.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.T5.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.T5.t_dummy;
//   input Boolean tankController.T5.condition = tankController.shut "= true, if transition may fire (time varying expression)";
//   parameter Integer tankController.emptyTanks.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer tankController.emptyTanks.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean tankController.emptyTanks.localActive = tankController.emptyTanks.active "= true if step is active, otherwise the step is not active";
//   output Boolean tankController.emptyTanks.inPort[1].occupied "true, if step is active";
//   input Boolean tankController.emptyTanks.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean tankController.emptyTanks.outPort[1].available "true, if step is active";
//   input Boolean tankController.emptyTanks.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean tankController.emptyTanks.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean tankController.emptyTanks.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real tankController.emptyTanks.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean tankController.emptyTanks.newActive "Value of active in the next iteration";
//   protected Boolean tankController.emptyTanks.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean tankController.emptyTanks.active "= true if step is active, otherwise the step is not active";
//   input Boolean tankController.T6.localCondition = tankController.T6.condition "= true, if transition may fire";
//   parameter Boolean tankController.T6.enableTimer = false "= true, if timer is enabled";
//   parameter Real tankController.T6.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real tankController.T6.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean tankController.T6.enableFire "= true, if all firing conditions are true";
//   output Boolean tankController.T6.fire "= true, if transition fires";
//   input Boolean tankController.T6.inPort.available "true, if step connected to the transition input is active";
//   output Boolean tankController.T6.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean tankController.T6.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean tankController.T6.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real tankController.T6.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real tankController.T6.t_dummy;
//   input Boolean tankController.T6.condition = tankController.level1 + tankController.level2 < 0.001 "= true, if transition may fire (time varying expression)";
//   input Boolean tankController.start;
//   input Boolean tankController.stop;
//   input Boolean tankController.shut;
//   input Real tankController.level1;
//   input Real tankController.level2;
//   output Boolean tankController.valve1;
//   output Boolean tankController.valve2;
//   output Boolean tankController.valve3;
//   output Boolean tankController.setValve1.y = tankController.makeProduct.fillTank1.active "Value of Boolean output";
//   output Boolean tankController.setValve2.y = tankController.makeProduct.fillTank2.active OR tankController.emptyTanks.active "Value of Boolean output";
//   output Boolean tankController.setValve3.y = tankController.makeProduct.emptyTank2.active OR tankController.emptyTanks.active "Value of Boolean output";
//   parameter Real start.buttonTimeTable[1](quantity = "Time", unit = "s") = 1.0 "Time instants where button is pressend and released";
//   parameter Real start.buttonTimeTable[2](quantity = "Time", unit = "s") = 13.0 "Time instants where button is pressend and released";
//   parameter Real start.buttonTimeTable[3](quantity = "Time", unit = "s") = 15.0 "Time instants where button is pressend and released";
//   parameter Real start.buttonTimeTable[4](quantity = "Time", unit = "s") = 19.0 "Time instants where button is pressend and released";
//   input Boolean start.reset[1] = stop.on "Reset button to false, if an element of reset becomes true";
//   input Boolean start.reset[2] = shut.on "Reset button to false, if an element of reset becomes true";
//   output Boolean start.on;
//   output Boolean start.table.y "Connector of Boolean output signal";
//   parameter Boolean start.table.startValue = false "Start value of y. At time = table[1], y changes to 'not startValue'";
//   parameter Real start.table.table[1](quantity = "Time", unit = "s") = start.buttonTimeTable[1] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real start.table.table[2](quantity = "Time", unit = "s") = start.buttonTimeTable[2] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real start.table.table[3](quantity = "Time", unit = "s") = start.buttonTimeTable[3] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real start.table.table[4](quantity = "Time", unit = "s") = start.buttonTimeTable[4] "Vector of time points. At every time point, the output y gets its opposite value";
//   protected parameter Integer start.table.n = 4 "Number of table points";
//   protected Real start.table.nextTime(quantity = "Time", unit = "s");
//   protected Integer start.table.index "Index of actual table entry";
//   parameter Real stop.buttonTimeTable[1](quantity = "Time", unit = "s") = 13.0 "Time instants where button is pressend and released";
//   parameter Real stop.buttonTimeTable[2](quantity = "Time", unit = "s") = 15.0 "Time instants where button is pressend and released";
//   parameter Real stop.buttonTimeTable[3](quantity = "Time", unit = "s") = 19.0 "Time instants where button is pressend and released";
//   parameter Real stop.buttonTimeTable[4](quantity = "Time", unit = "s") = 21.0 "Time instants where button is pressend and released";
//   input Boolean stop.reset[1] = start.on "Reset button to false, if an element of reset becomes true";
//   input Boolean stop.reset[2] = shut.on "Reset button to false, if an element of reset becomes true";
//   output Boolean stop.on;
//   output Boolean stop.table.y "Connector of Boolean output signal";
//   parameter Boolean stop.table.startValue = false "Start value of y. At time = table[1], y changes to 'not startValue'";
//   parameter Real stop.table.table[1](quantity = "Time", unit = "s") = stop.buttonTimeTable[1] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real stop.table.table[2](quantity = "Time", unit = "s") = stop.buttonTimeTable[2] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real stop.table.table[3](quantity = "Time", unit = "s") = stop.buttonTimeTable[3] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real stop.table.table[4](quantity = "Time", unit = "s") = stop.buttonTimeTable[4] "Vector of time points. At every time point, the output y gets its opposite value";
//   protected parameter Integer stop.table.n = 4 "Number of table points";
//   protected Real stop.table.nextTime(quantity = "Time", unit = "s");
//   protected Integer stop.table.index "Index of actual table entry";
//   parameter Real shut.buttonTimeTable[1](quantity = "Time", unit = "s") = 21.0 "Time instants where button is pressend and released";
//   parameter Real shut.buttonTimeTable[2](quantity = "Time", unit = "s") = 100.0 "Time instants where button is pressend and released";
//   input Boolean shut.reset[1] = start.on "Reset button to false, if an element of reset becomes true";
//   input Boolean shut.reset[2] = stop.on "Reset button to false, if an element of reset becomes true";
//   output Boolean shut.on;
//   output Boolean shut.table.y "Connector of Boolean output signal";
//   parameter Boolean shut.table.startValue = false "Start value of y. At time = table[1], y changes to 'not startValue'";
//   parameter Real shut.table.table[1](quantity = "Time", unit = "s") = shut.buttonTimeTable[1] "Vector of time points. At every time point, the output y gets its opposite value";
//   parameter Real shut.table.table[2](quantity = "Time", unit = "s") = shut.buttonTimeTable[2] "Vector of time points. At every time point, the output y gets its opposite value";
//   protected parameter Integer shut.table.n = 2 "Number of table points";
//   protected Real shut.table.nextTime(quantity = "Time", unit = "s");
//   protected Integer shut.table.index "Index of actual table entry";
//   output Real tank1.levelSensor;
//   Real tank1.inflow1.Fi(quantity = "VolumeFlowRate", unit = "m3/s") "inflow";
//   Real tank1.outflow1.Fo(quantity = "VolumeFlowRate", unit = "m3/s") "outflow";
//   Boolean tank1.outflow1.open "valve open";
//   Real tank1.level "Tank level in % of max height";
//   parameter Real tank1.A = 1.0 "ground area of tank in m²";
//   parameter Real tank1.a = 0.2 "area of drain hole in m²";
//   parameter Real tank1.hmax = 1.0 "max height of tank in m";
//   constant Real tank1.g = 9.80665;
//   output Real tank2.levelSensor;
//   Real tank2.inflow1.Fi(quantity = "VolumeFlowRate", unit = "m3/s") "inflow";
//   Real tank2.outflow1.Fo(quantity = "VolumeFlowRate", unit = "m3/s") "outflow";
//   Boolean tank2.outflow1.open "valve open";
//   Real tank2.level "Tank level in % of max height";
//   parameter Real tank2.A = 1.0 "ground area of tank in m²";
//   parameter Real tank2.a = 0.2 "area of drain hole in m²";
//   parameter Real tank2.hmax = 1.0 "max height of tank in m";
//   constant Real tank2.g = 9.80665;
//   input Boolean valve1.valveControl;
//   Real valve1.inflow1.Fi(quantity = "VolumeFlowRate", unit = "m3/s") "inflow";
//   Real valve1.outflow1.Fo(quantity = "VolumeFlowRate", unit = "m3/s") "outflow";
//   Boolean valve1.outflow1.open "valve open";
//   Real source.outflow1.Fo(quantity = "VolumeFlowRate", unit = "m3/s") "outflow";
//   Boolean source.outflow1.open "valve open";
//   parameter Real source.maxflow = 1.0 "maximal flow out of source";
//   input Boolean valve2.valveControl;
//   Real valve2.inflow1.Fi(quantity = "VolumeFlowRate", unit = "m3/s") "inflow";
//   Real valve2.outflow1.Fo(quantity = "VolumeFlowRate", unit = "m3/s") "outflow";
//   Boolean valve2.outflow1.open "valve open";
//   input Boolean valve3.valveControl;
//   Real valve3.inflow1.Fi(quantity = "VolumeFlowRate", unit = "m3/s") "inflow";
//   Real valve3.outflow1.Fo(quantity = "VolumeFlowRate", unit = "m3/s") "outflow";
//   Boolean valve3.outflow1.open "valve open";
// initial equation
//   tankController.s1.active = true;
//   pre(tankController.s1.newActive) = pre(tankController.s1.localActive);
//   pre(tankController.s1.oldActive) = pre(tankController.s1.localActive);
//   tankController.makeProduct.fillTank1.active = false;
//   pre(tankController.makeProduct.fillTank1.newActive) = pre(tankController.makeProduct.fillTank1.localActive);
//   pre(tankController.makeProduct.fillTank1.oldActive) = pre(tankController.makeProduct.fillTank1.localActive);
//   pre(tankController.makeProduct.T1.enableFire) = false;
//   tankController.makeProduct.fillTank2.active = false;
//   pre(tankController.makeProduct.fillTank2.newActive) = pre(tankController.makeProduct.fillTank2.localActive);
//   pre(tankController.makeProduct.fillTank2.oldActive) = pre(tankController.makeProduct.fillTank2.localActive);
//   pre(tankController.makeProduct.T3.enableFire) = false;
//   tankController.makeProduct.emptyTank2.active = false;
//   pre(tankController.makeProduct.emptyTank2.newActive) = pre(tankController.makeProduct.emptyTank2.localActive);
//   pre(tankController.makeProduct.emptyTank2.oldActive) = pre(tankController.makeProduct.emptyTank2.localActive);
//   tankController.makeProduct.wait1.active = false;
//   pre(tankController.makeProduct.wait1.newActive) = pre(tankController.makeProduct.wait1.localActive);
//   pre(tankController.makeProduct.wait1.oldActive) = pre(tankController.makeProduct.wait1.localActive);
//   pre(tankController.makeProduct.T2.enableFire) = false;
//   tankController.makeProduct.wait2.active = false;
//   pre(tankController.makeProduct.wait2.newActive) = pre(tankController.makeProduct.wait2.localActive);
//   pre(tankController.makeProduct.wait2.oldActive) = pre(tankController.makeProduct.wait2.localActive);
//   pre(tankController.makeProduct.T4.enableFire) = false;
//   pre(tankController.makeProduct.newActive) = pre(tankController.makeProduct.active);
//   pre(tankController.T1.enableFire) = false;
//   pre(tankController.T2.enableFire) = false;
//   pre(tankController.T3.enableFire) = false;
//   tankController.s2.active = false;
//   pre(tankController.s2.newActive) = pre(tankController.s2.localActive);
//   pre(tankController.s2.oldActive) = pre(tankController.s2.localActive);
//   pre(tankController.T4.enableFire) = false;
//   pre(tankController.T5.enableFire) = false;
//   tankController.emptyTanks.active = false;
//   pre(tankController.emptyTanks.newActive) = pre(tankController.emptyTanks.localActive);
//   pre(tankController.emptyTanks.oldActive) = pre(tankController.emptyTanks.localActive);
//   pre(tankController.T6.enableFire) = false;
// initial algorithm
//   (start.table.index, start.table.nextTime, start.table.y) := Modelica.Blocks.Sources.BooleanTable.getFirstIndex({start.table.table[1],start.table.table[2],start.table.table[3],start.table.table[4]},time,start.table.startValue);
//   (stop.table.index, stop.table.nextTime, stop.table.y) := Modelica.Blocks.Sources.BooleanTable.getFirstIndex({stop.table.table[1],stop.table.table[2],stop.table.table[3],stop.table.table[4]},time,stop.table.startValue);
//   (shut.table.index, shut.table.nextTime, shut.table.y) := Modelica.Blocks.Sources.BooleanTable.getFirstIndex({shut.table.table[1],shut.table.table[2]},time,shut.table.startValue);
// equation
//   stateGraphRoot.activeSteps = -integer(stateGraphRoot.subgraphStatePort.activeSteps);
//   stateGraphRoot.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   stateGraphRoot.resume = stateGraphRoot.subgraphStatePort.resume;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector inPort[2] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.s1.localActive = pre(tankController.s1.newActive);
//   tankController.s1.newActive = if tankController.s1.subgraphStatePort.resume then tankController.s1.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.s1.inPort[1].set,tankController.s1.inPort[2].set}) OR tankController.s1.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.s1.outPort[1].reset})) AND  NOT tankController.s1.subgraphStatePort.suspend;
//   when tankController.s1.subgraphStatePort.suspend then
//   tankController.s1.oldActive = tankController.s1.localActive;
//   end when;
//   tankController.s1.subgraphStatePort.activeSteps = if tankController.s1.localActive then 1.0 else 0.0;
//   tankController.s1.inPort[1].occupied = tankController.s1.localActive;
//   tankController.s1.inPort[2].occupied = tankController.s1.inPort[1].occupied OR tankController.s1.inPort[1].set;
//   tankController.s1.outPort[1].available = tankController.s1.localActive;
//   tankController.makeProduct.stateGraphRoot.suspend = tankController.makeProduct.stateGraphRoot.subgraphStatePort.suspend;
//   tankController.makeProduct.stateGraphRoot.resume = tankController.makeProduct.stateGraphRoot.subgraphStatePort.resume;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.makeProduct.fillTank1.localActive = pre(tankController.makeProduct.fillTank1.newActive);
//   tankController.makeProduct.fillTank1.newActive = if tankController.makeProduct.fillTank1.subgraphStatePort.resume then tankController.makeProduct.fillTank1.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.fillTank1.inPort[1].set}) OR tankController.makeProduct.fillTank1.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.fillTank1.outPort[1].reset})) AND  NOT tankController.makeProduct.fillTank1.subgraphStatePort.suspend;
//   when tankController.makeProduct.fillTank1.subgraphStatePort.suspend then
//   tankController.makeProduct.fillTank1.oldActive = tankController.makeProduct.fillTank1.localActive;
//   end when;
//   tankController.makeProduct.fillTank1.subgraphStatePort.activeSteps = if tankController.makeProduct.fillTank1.localActive then 1.0 else 0.0;
//   tankController.makeProduct.fillTank1.inPort[1].occupied = tankController.makeProduct.fillTank1.localActive;
//   tankController.makeProduct.fillTank1.outPort[1].available = tankController.makeProduct.fillTank1.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.makeProduct.T1.t_start = 0.0;
//   tankController.makeProduct.T1.t_dummy = 0.0;
//   tankController.makeProduct.T1.t = 0.0;
//   tankController.makeProduct.T1.fire = tankController.makeProduct.T1.enableFire;
//   tankController.makeProduct.T1.enableFire = tankController.makeProduct.T1.localCondition AND tankController.makeProduct.T1.inPort.available AND  NOT tankController.makeProduct.T1.outPort.occupied;
//   tankController.makeProduct.T1.inPort.reset = tankController.makeProduct.T1.fire;
//   tankController.makeProduct.T1.outPort.set = tankController.makeProduct.T1.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.makeProduct.fillTank2.localActive = pre(tankController.makeProduct.fillTank2.newActive);
//   tankController.makeProduct.fillTank2.newActive = if tankController.makeProduct.fillTank2.subgraphStatePort.resume then tankController.makeProduct.fillTank2.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.fillTank2.inPort[1].set}) OR tankController.makeProduct.fillTank2.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.fillTank2.outPort[1].reset})) AND  NOT tankController.makeProduct.fillTank2.subgraphStatePort.suspend;
//   when tankController.makeProduct.fillTank2.subgraphStatePort.suspend then
//   tankController.makeProduct.fillTank2.oldActive = tankController.makeProduct.fillTank2.localActive;
//   end when;
//   tankController.makeProduct.fillTank2.subgraphStatePort.activeSteps = if tankController.makeProduct.fillTank2.localActive then 1.0 else 0.0;
//   tankController.makeProduct.fillTank2.inPort[1].occupied = tankController.makeProduct.fillTank2.localActive;
//   tankController.makeProduct.fillTank2.outPort[1].available = tankController.makeProduct.fillTank2.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.makeProduct.T3.t_start = 0.0;
//   tankController.makeProduct.T3.t_dummy = 0.0;
//   tankController.makeProduct.T3.t = 0.0;
//   tankController.makeProduct.T3.fire = tankController.makeProduct.T3.enableFire;
//   tankController.makeProduct.T3.enableFire = tankController.makeProduct.T3.localCondition AND tankController.makeProduct.T3.inPort.available AND  NOT tankController.makeProduct.T3.outPort.occupied;
//   tankController.makeProduct.T3.inPort.reset = tankController.makeProduct.T3.fire;
//   tankController.makeProduct.T3.outPort.set = tankController.makeProduct.T3.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.makeProduct.emptyTank2.localActive = pre(tankController.makeProduct.emptyTank2.newActive);
//   tankController.makeProduct.emptyTank2.newActive = if tankController.makeProduct.emptyTank2.subgraphStatePort.resume then tankController.makeProduct.emptyTank2.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.emptyTank2.inPort[1].set}) OR tankController.makeProduct.emptyTank2.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.emptyTank2.outPort[1].reset})) AND  NOT tankController.makeProduct.emptyTank2.subgraphStatePort.suspend;
//   when tankController.makeProduct.emptyTank2.subgraphStatePort.suspend then
//   tankController.makeProduct.emptyTank2.oldActive = tankController.makeProduct.emptyTank2.localActive;
//   end when;
//   tankController.makeProduct.emptyTank2.subgraphStatePort.activeSteps = if tankController.makeProduct.emptyTank2.localActive then 1.0 else 0.0;
//   tankController.makeProduct.emptyTank2.inPort[1].occupied = tankController.makeProduct.emptyTank2.localActive;
//   tankController.makeProduct.emptyTank2.outPort[1].available = tankController.makeProduct.emptyTank2.localActive;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.makeProduct.wait1.localActive = pre(tankController.makeProduct.wait1.newActive);
//   tankController.makeProduct.wait1.newActive = if tankController.makeProduct.wait1.subgraphStatePort.resume then tankController.makeProduct.wait1.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.wait1.inPort[1].set}) OR tankController.makeProduct.wait1.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.wait1.outPort[1].reset})) AND  NOT tankController.makeProduct.wait1.subgraphStatePort.suspend;
//   when tankController.makeProduct.wait1.subgraphStatePort.suspend then
//   tankController.makeProduct.wait1.oldActive = tankController.makeProduct.wait1.localActive;
//   end when;
//   tankController.makeProduct.wait1.subgraphStatePort.activeSteps = if tankController.makeProduct.wait1.localActive then 1.0 else 0.0;
//   tankController.makeProduct.wait1.inPort[1].occupied = tankController.makeProduct.wait1.localActive;
//   tankController.makeProduct.wait1.outPort[1].available = tankController.makeProduct.wait1.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when tankController.makeProduct.T2.enableFire then
//   tankController.makeProduct.T2.t_start = time;
//   end when;
//   tankController.makeProduct.T2.t_dummy = time - tankController.makeProduct.T2.t_start;
//   tankController.makeProduct.T2.t = if tankController.makeProduct.T2.enableFire then tankController.makeProduct.T2.t_dummy else 0.0;
//   tankController.makeProduct.T2.fire = tankController.makeProduct.T2.enableFire AND time >= tankController.makeProduct.T2.t_start + tankController.makeProduct.T2.waitTime;
//   tankController.makeProduct.T2.enableFire = tankController.makeProduct.T2.localCondition AND tankController.makeProduct.T2.inPort.available AND  NOT tankController.makeProduct.T2.outPort.occupied;
//   tankController.makeProduct.T2.inPort.reset = tankController.makeProduct.T2.fire;
//   tankController.makeProduct.T2.outPort.set = tankController.makeProduct.T2.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.makeProduct.wait2.localActive = pre(tankController.makeProduct.wait2.newActive);
//   tankController.makeProduct.wait2.newActive = if tankController.makeProduct.wait2.subgraphStatePort.resume then tankController.makeProduct.wait2.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.wait2.inPort[1].set}) OR tankController.makeProduct.wait2.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.wait2.outPort[1].reset})) AND  NOT tankController.makeProduct.wait2.subgraphStatePort.suspend;
//   when tankController.makeProduct.wait2.subgraphStatePort.suspend then
//   tankController.makeProduct.wait2.oldActive = tankController.makeProduct.wait2.localActive;
//   end when;
//   tankController.makeProduct.wait2.subgraphStatePort.activeSteps = if tankController.makeProduct.wait2.localActive then 1.0 else 0.0;
//   tankController.makeProduct.wait2.inPort[1].occupied = tankController.makeProduct.wait2.localActive;
//   tankController.makeProduct.wait2.outPort[1].available = tankController.makeProduct.wait2.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when tankController.makeProduct.T4.enableFire then
//   tankController.makeProduct.T4.t_start = time;
//   end when;
//   tankController.makeProduct.T4.t_dummy = time - tankController.makeProduct.T4.t_start;
//   tankController.makeProduct.T4.t = if tankController.makeProduct.T4.enableFire then tankController.makeProduct.T4.t_dummy else 0.0;
//   tankController.makeProduct.T4.fire = tankController.makeProduct.T4.enableFire AND time >= tankController.makeProduct.T4.t_start + tankController.makeProduct.T4.waitTime;
//   tankController.makeProduct.T4.enableFire = tankController.makeProduct.T4.localCondition AND tankController.makeProduct.T4.inPort.available AND  NOT tankController.makeProduct.T4.outPort.occupied;
//   tankController.makeProduct.T4.inPort.reset = tankController.makeProduct.T4.fire;
//   tankController.makeProduct.T4.outPort.set = tankController.makeProduct.T4.fire;
//   tankController.makeProduct.outerState.subgraphStatePort.activeSteps = if tankController.makeProduct.active then 1.0 else 0.0;
//   tankController.makeProduct.activeSteps = -integer(tankController.makeProduct.stateGraphRoot.subgraphStatePort.activeSteps);
//   tankController.makeProduct.active = pre(tankController.makeProduct.newActive);
//   tankController.makeProduct.newActive = tankController.makeProduct.activeSteps > 0 AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.suspend[1].reset}) AND  NOT tankController.makeProduct.outerState.subgraphStatePort.suspend OR Modelica.StateGraph.Temporary.anyTrue({tankController.makeProduct.resume[1].set}) OR tankController.makeProduct.outerState.subgraphStatePort.resume;
//   tankController.makeProduct.resume[1].occupied = tankController.makeProduct.active;
//   tankController.makeProduct.suspend[1].available = tankController.makeProduct.active;
//   assert(true,"Connector suspend[1] of the CompositeStep is connected to more than one transition");
//   assert(true,"Connector resume[1] of the CompositeStep is connected to more than one transition");
//   assert(true,"Connector inPort of the CompositeStep has more than 2 connections. It should have only one connection from the outside to the inPort and one connection to a step inside the CompositeStep.");
//   assert(true,"Connector outPort of the CompositeStep has more than 2 connections. It should have only one connection from the outPort to the outside to the CompositeStep and one connection from a step inside the CompositeStep to the outPort connector.");
//   tankController.makeProduct.T4.outPort.set = tankController.makeProduct.emptyTank2.inPort[1].set;
//   tankController.makeProduct.T4.outPort.occupied = tankController.makeProduct.emptyTank2.inPort[1].occupied;
//   tankController.makeProduct.T3.outPort.set = tankController.makeProduct.wait2.inPort[1].set;
//   tankController.makeProduct.T3.outPort.occupied = tankController.makeProduct.wait2.inPort[1].occupied;
//   tankController.makeProduct.wait2.outPort[1].reset = tankController.makeProduct.T4.inPort.reset;
//   tankController.makeProduct.wait2.outPort[1].available = tankController.makeProduct.T4.inPort.available;
//   tankController.makeProduct.T1.outPort.set = tankController.makeProduct.wait1.inPort[1].set;
//   tankController.makeProduct.T1.outPort.occupied = tankController.makeProduct.wait1.inPort[1].occupied;
//   tankController.makeProduct.T2.outPort.set = tankController.makeProduct.fillTank2.inPort[1].set;
//   tankController.makeProduct.T2.outPort.occupied = tankController.makeProduct.fillTank2.inPort[1].occupied;
//   tankController.makeProduct.wait1.outPort[1].reset = tankController.makeProduct.T2.inPort.reset;
//   tankController.makeProduct.wait1.outPort[1].available = tankController.makeProduct.T2.inPort.available;
//   tankController.makeProduct.emptyTank2.outPort[1].reset = tankController.makeProduct.outPort.reset;
//   tankController.makeProduct.emptyTank2.outPort[1].available = tankController.makeProduct.outPort.available;
//   tankController.makeProduct.fillTank2.outPort[1].reset = tankController.makeProduct.T3.inPort.reset;
//   tankController.makeProduct.fillTank2.outPort[1].available = tankController.makeProduct.T3.inPort.available;
//   tankController.makeProduct.fillTank1.outPort[1].reset = tankController.makeProduct.T1.inPort.reset;
//   tankController.makeProduct.fillTank1.outPort[1].available = tankController.makeProduct.T1.inPort.available;
//   tankController.makeProduct.fillTank1.inPort[1].set = tankController.makeProduct.inPort.set;
//   tankController.makeProduct.fillTank1.inPort[1].occupied = tankController.makeProduct.inPort.occupied;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.T1.t_start = 0.0;
//   tankController.T1.t_dummy = 0.0;
//   tankController.T1.t = 0.0;
//   tankController.T1.fire = tankController.T1.enableFire;
//   tankController.T1.enableFire = tankController.T1.localCondition AND tankController.T1.inPort.available AND  NOT tankController.T1.outPort.occupied;
//   tankController.T1.inPort.reset = tankController.T1.fire;
//   tankController.T1.outPort.set = tankController.T1.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.T2.t_start = 0.0;
//   tankController.T2.t_dummy = 0.0;
//   tankController.T2.t = 0.0;
//   tankController.T2.fire = tankController.T2.enableFire;
//   tankController.T2.enableFire = tankController.T2.localCondition AND tankController.T2.inPort.available AND  NOT tankController.T2.outPort.occupied;
//   tankController.T2.inPort.reset = tankController.T2.fire;
//   tankController.T2.outPort.set = tankController.T2.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.T3.t_start = 0.0;
//   tankController.T3.t_dummy = 0.0;
//   tankController.T3.t = 0.0;
//   tankController.T3.fire = tankController.T3.enableFire;
//   tankController.T3.enableFire = tankController.T3.localCondition AND tankController.T3.inPort.available AND  NOT tankController.T3.outPort.occupied;
//   tankController.T3.inPort.reset = tankController.T3.fire;
//   tankController.T3.outPort.set = tankController.T3.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[2] of the step is connected to more than one transition");
//   tankController.s2.localActive = pre(tankController.s2.newActive);
//   tankController.s2.newActive = if tankController.s2.subgraphStatePort.resume then tankController.s2.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.s2.inPort[1].set}) OR tankController.s2.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.s2.outPort[1].reset,tankController.s2.outPort[2].reset})) AND  NOT tankController.s2.subgraphStatePort.suspend;
//   when tankController.s2.subgraphStatePort.suspend then
//   tankController.s2.oldActive = tankController.s2.localActive;
//   end when;
//   tankController.s2.subgraphStatePort.activeSteps = if tankController.s2.localActive then 1.0 else 0.0;
//   tankController.s2.inPort[1].occupied = tankController.s2.localActive;
//   tankController.s2.outPort[1].available = tankController.s2.localActive;
//   tankController.s2.outPort[2].available = tankController.s2.outPort[1].available AND  NOT tankController.s2.outPort[1].reset;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.T4.t_start = 0.0;
//   tankController.T4.t_dummy = 0.0;
//   tankController.T4.t = 0.0;
//   tankController.T4.fire = tankController.T4.enableFire;
//   tankController.T4.enableFire = tankController.T4.localCondition AND tankController.T4.inPort.available AND  NOT tankController.T4.outPort.occupied;
//   tankController.T4.inPort.reset = tankController.T4.fire;
//   tankController.T4.outPort.set = tankController.T4.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.T5.t_start = 0.0;
//   tankController.T5.t_dummy = 0.0;
//   tankController.T5.t = 0.0;
//   tankController.T5.fire = tankController.T5.enableFire;
//   tankController.T5.enableFire = tankController.T5.localCondition AND tankController.T5.inPort.available AND  NOT tankController.T5.outPort.occupied;
//   tankController.T5.inPort.reset = tankController.T5.fire;
//   tankController.T5.outPort.set = tankController.T5.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   tankController.emptyTanks.localActive = pre(tankController.emptyTanks.newActive);
//   tankController.emptyTanks.newActive = if tankController.emptyTanks.subgraphStatePort.resume then tankController.emptyTanks.oldActive else (Modelica.StateGraph.Temporary.anyTrue({tankController.emptyTanks.inPort[1].set}) OR tankController.emptyTanks.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({tankController.emptyTanks.outPort[1].reset})) AND  NOT tankController.emptyTanks.subgraphStatePort.suspend;
//   when tankController.emptyTanks.subgraphStatePort.suspend then
//   tankController.emptyTanks.oldActive = tankController.emptyTanks.localActive;
//   end when;
//   tankController.emptyTanks.subgraphStatePort.activeSteps = if tankController.emptyTanks.localActive then 1.0 else 0.0;
//   tankController.emptyTanks.inPort[1].occupied = tankController.emptyTanks.localActive;
//   tankController.emptyTanks.outPort[1].available = tankController.emptyTanks.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   tankController.T6.t_start = 0.0;
//   tankController.T6.t_dummy = 0.0;
//   tankController.T6.t = 0.0;
//   tankController.T6.fire = tankController.T6.enableFire;
//   tankController.T6.enableFire = tankController.T6.localCondition AND tankController.T6.inPort.available AND  NOT tankController.T6.outPort.occupied;
//   tankController.T6.inPort.reset = tankController.T6.fire;
//   tankController.T6.outPort.set = tankController.T6.fire;
//   tankController.s1.outPort[1].reset = tankController.T1.inPort.reset;
//   tankController.s1.outPort[1].available = tankController.T1.inPort.available;
//   tankController.T1.outPort.set = tankController.makeProduct.inPort.set;
//   tankController.T1.outPort.occupied = tankController.makeProduct.inPort.occupied;
//   tankController.makeProduct.outPort.reset = tankController.T2.inPort.reset;
//   tankController.makeProduct.outPort.available = tankController.T2.inPort.available;
//   tankController.T5.outPort.set = tankController.emptyTanks.inPort[1].set;
//   tankController.T5.outPort.occupied = tankController.emptyTanks.inPort[1].occupied;
//   tankController.emptyTanks.outPort[1].reset = tankController.T6.inPort.reset;
//   tankController.emptyTanks.outPort[1].available = tankController.T6.inPort.available;
//   tankController.setValve1.y = tankController.valve1;
//   tankController.setValve2.y = tankController.valve2;
//   tankController.setValve3.y = tankController.valve3;
//   tankController.makeProduct.suspend[1].reset = tankController.T3.inPort.reset;
//   tankController.makeProduct.suspend[1].available = tankController.T3.inPort.available;
//   tankController.T3.outPort.set = tankController.s2.inPort[1].set;
//   tankController.T3.outPort.occupied = tankController.s2.inPort[1].occupied;
//   tankController.T4.outPort.set = tankController.makeProduct.resume[1].set;
//   tankController.T4.outPort.occupied = tankController.makeProduct.resume[1].occupied;
//   tankController.level1 = tankController.makeProduct.level1;
//   tankController.s2.outPort[1].reset = tankController.T5.inPort.reset;
//   tankController.s2.outPort[1].available = tankController.T5.inPort.available;
//   tankController.s2.outPort[2].reset = tankController.T4.inPort.reset;
//   tankController.s2.outPort[2].available = tankController.T4.inPort.available;
//   tankController.T2.outPort.set = tankController.s1.inPort[1].set;
//   tankController.T2.outPort.occupied = tankController.s1.inPort[1].occupied;
//   tankController.T6.outPort.set = tankController.s1.inPort[2].set;
//   tankController.T6.outPort.occupied = tankController.s1.inPort[2].occupied;
//   der(tank1.level) = (tank1.inflow1.Fi - tank1.outflow1.Fo) * 1.0 / tank1.A / tank1.hmax;
//   if tank1.outflow1.open then
//   tank1.outflow1.Fo = sqrt(19.6133 * (tank1.hmax * tank1.level)) * tank1.a;
//   else
//   tank1.outflow1.Fo = 0.0;
//   end if;
//   tank1.levelSensor = tank1.level;
//   der(tank2.level) = (tank2.inflow1.Fi - tank2.outflow1.Fo) * 1.0 / tank2.A / tank2.hmax;
//   if tank2.outflow1.open then
//   tank2.outflow1.Fo = sqrt(19.6133 * (tank2.hmax * tank2.level)) * tank2.a;
//   else
//   tank2.outflow1.Fo = 0.0;
//   end if;
//   tank2.levelSensor = tank2.level;
//   valve1.outflow1.Fo = valve1.inflow1.Fi;
//   valve1.outflow1.open = valve1.valveControl;
//   if source.outflow1.open then
//   source.outflow1.Fo = source.maxflow;
//   else
//   source.outflow1.Fo = 0.0;
//   end if;
//   valve2.outflow1.Fo = valve2.inflow1.Fi;
//   valve2.outflow1.open = valve2.valveControl;
//   valve3.outflow1.Fo = valve3.inflow1.Fi;
//   valve3.outflow1.open = valve3.valveControl;
//   tankController.makeProduct.fillTank1.subgraphStatePort.activeSteps + (tankController.makeProduct.fillTank2.subgraphStatePort.activeSteps + (tankController.makeProduct.emptyTank2.subgraphStatePort.activeSteps + (tankController.makeProduct.wait1.subgraphStatePort.activeSteps + (tankController.makeProduct.wait2.subgraphStatePort.activeSteps + tankController.makeProduct.stateGraphRoot.subgraphStatePort.activeSteps)))) = 0.0;
//   tankController.makeProduct.fillTank1.subgraphStatePort.resume = tankController.makeProduct.fillTank2.subgraphStatePort.resume;
//   tankController.makeProduct.fillTank2.subgraphStatePort.resume = tankController.makeProduct.emptyTank2.subgraphStatePort.resume;
//   tankController.makeProduct.emptyTank2.subgraphStatePort.resume = tankController.makeProduct.wait1.subgraphStatePort.resume;
//   tankController.makeProduct.wait1.subgraphStatePort.resume = tankController.makeProduct.wait2.subgraphStatePort.resume;
//   tankController.makeProduct.wait2.subgraphStatePort.resume = tankController.makeProduct.stateGraphRoot.subgraphStatePort.resume;
//   tankController.makeProduct.fillTank1.subgraphStatePort.suspend = tankController.makeProduct.fillTank2.subgraphStatePort.suspend;
//   tankController.makeProduct.fillTank2.subgraphStatePort.suspend = tankController.makeProduct.emptyTank2.subgraphStatePort.suspend;
//   tankController.makeProduct.emptyTank2.subgraphStatePort.suspend = tankController.makeProduct.wait1.subgraphStatePort.suspend;
//   tankController.makeProduct.wait1.subgraphStatePort.suspend = tankController.makeProduct.wait2.subgraphStatePort.suspend;
//   tankController.makeProduct.wait2.subgraphStatePort.suspend = tankController.makeProduct.stateGraphRoot.subgraphStatePort.suspend;
//   tankController.s1.subgraphStatePort.activeSteps + (tankController.makeProduct.outerState.subgraphStatePort.activeSteps + (tankController.s2.subgraphStatePort.activeSteps + (tankController.emptyTanks.subgraphStatePort.activeSteps + stateGraphRoot.subgraphStatePort.activeSteps))) = 0.0;
//   tankController.s1.subgraphStatePort.resume = tankController.makeProduct.outerState.subgraphStatePort.resume;
//   tankController.makeProduct.outerState.subgraphStatePort.resume = tankController.s2.subgraphStatePort.resume;
//   tankController.s2.subgraphStatePort.resume = tankController.emptyTanks.subgraphStatePort.resume;
//   tankController.emptyTanks.subgraphStatePort.resume = stateGraphRoot.subgraphStatePort.resume;
//   tankController.s1.subgraphStatePort.suspend = tankController.makeProduct.outerState.subgraphStatePort.suspend;
//   tankController.makeProduct.outerState.subgraphStatePort.suspend = tankController.s2.subgraphStatePort.suspend;
//   tankController.s2.subgraphStatePort.suspend = tankController.emptyTanks.subgraphStatePort.suspend;
//   tankController.emptyTanks.subgraphStatePort.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   tank1.outflow1.open = valve2.outflow1.open;
//   tank1.outflow1.Fo = valve2.outflow1.Fo;
//   tank2.inflow1.Fi = valve2.inflow1.Fi;
//   tank2.outflow1.open = valve3.outflow1.open;
//   tank2.outflow1.Fo = valve3.outflow1.Fo;
//   tank1.inflow1.Fi = valve1.inflow1.Fi;
//   shut.on = tankController.shut;
//   stop.on = tankController.stop;
//   start.on = tankController.start;
//   tank1.levelSensor = tankController.level1;
//   tank2.levelSensor = tankController.level2;
//   tankController.valve1 = valve1.valveControl;
//   tankController.valve2 = valve2.valveControl;
//   tankController.valve3 = valve3.valveControl;
//   source.outflow1.open = valve1.outflow1.open;
//   source.outflow1.Fo = valve1.outflow1.Fo;
// algorithm
//   when time >= pre(start.table.nextTime) AND start.table.n > 0 then
//     if start.table.index < start.table.n then
//       start.table.index := 1 + start.table.index;
//       start.table.nextTime := start.table.table[start.table.index];
//       start.table.y :=  NOT start.table.y;
//     elseif start.table.index == start.table.n then
//       start.table.index := 1 + start.table.index;
//       start.table.y :=  NOT start.table.y;
//     end if;
//   end when;
//   start.on := start.table.y;
//   when {pre(start.reset[1]),pre(start.reset[2])} then
//     start.on := false;
//   end when;
//   when time >= pre(stop.table.nextTime) AND stop.table.n > 0 then
//     if stop.table.index < stop.table.n then
//       stop.table.index := 1 + stop.table.index;
//       stop.table.nextTime := stop.table.table[stop.table.index];
//       stop.table.y :=  NOT stop.table.y;
//     elseif stop.table.index == stop.table.n then
//       stop.table.index := 1 + stop.table.index;
//       stop.table.y :=  NOT stop.table.y;
//     end if;
//   end when;
//   stop.on := stop.table.y;
//   when {pre(stop.reset[1]),pre(stop.reset[2])} then
//     stop.on := false;
//   end when;
//   when time >= pre(shut.table.nextTime) AND shut.table.n > 0 then
//     if shut.table.index < shut.table.n then
//       shut.table.index := 1 + shut.table.index;
//       shut.table.nextTime := shut.table.table[shut.table.index];
//       shut.table.y :=  NOT shut.table.y;
//     elseif shut.table.index == shut.table.n then
//       shut.table.index := 1 + shut.table.index;
//       shut.table.y :=  NOT shut.table.y;
//     end if;
//   end when;
//   shut.on := shut.table.y;
//   when {pre(shut.reset[1]),pre(shut.reset[2])} then
//     shut.on := false;
//   end when;
// end Modelica.StateGraph.Examples.ControlledTanks;
// "
// ""
// endResult
