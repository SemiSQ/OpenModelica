//name:         DCEE_start
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Electrical.Machines.Examples.DCEE_start);
getErrorString();
// Result:
// true
// "function Modelica.SIunits.Conversions.from_rpm
// input Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// output Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// algorithm
//   rs := 0.10471975511966 * rpm;
// end Modelica.SIunits.Conversions.from_rpm;
// 
// function Modelica.SIunits.Conversions.to_rpm
// input Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.DCEE_start
// parameter Real Va(quantity = "ElectricPotential", unit = "V") = 100.0 "actual armature voltage";
// parameter Real tStart(quantity = "Time", unit = "s") = 0.2 "armature voltage ramp";
// parameter Real tRamp(quantity = "Time", unit = "s") = 0.8 "armature voltage ramp";
// parameter Real Ve(quantity = "ElectricPotential", unit = "V") = 100.0 "actual excitation voltage";
// parameter Real T_Load(quantity = "Torque", unit = "N.m") = 63.66 "nominal load torque";
// parameter Real tStep(quantity = "Time", unit = "s") = 1.5 "time of load torque step";
// parameter Real J_Load(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "load's moment of inertia";
// output Real Ramp1.y "Connector of Real output signal";
// parameter Real Ramp1.height = Va "Height of ramps";
// parameter Real Ramp1.duration(min = 1e-60) = tRamp "Durations of ramp";
// parameter Real Ramp1.offset = 0.0 "Offset of output signal";
// parameter Real Ramp1.startTime(quantity = "Time", unit = "s") = tStart "Output = offset for time < startTime";
// Real LoadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = LoadInertia.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real LoadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real LoadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real LoadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real LoadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real LoadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = J_Load "Moment of inertia";
// parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real LoadInertia.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real LoadInertia.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real LoadInertia.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real LoadInertia.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = LoadInertia.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real LoadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// Real TorqueStep1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(TorqueStep1.flange.phi) "Angular velocity at flange";
// Real TorqueStep1.tau(quantity = "Torque", unit = "N.m") = TorqueStep1.flange.tau "accelerating torque acting at flange";
// Real TorqueStep1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real TorqueStep1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real TorqueStep1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real TorqueStep1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real TorqueStep1.stepTorque(quantity = "Torque", unit = "N.m") = -T_Load "height of torque step (if negative, torque is acting as load)";
// parameter Real TorqueStep1.offsetTorque(quantity = "Torque", unit = "N.m") = 0.0 "offset of torque";
// parameter Real TorqueStep1.startTime(quantity = "Time", unit = "s") = tStep "output = offset for time < startTime";
// Real ConstantVoltage1.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real ConstantVoltage1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real ConstantVoltage1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real ConstantVoltage1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real ConstantVoltage1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real ConstantVoltage1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real ConstantVoltage1.V(quantity = "ElectricPotential", unit = "V") = Ve "Value of constant voltage";
// parameter Real DCEE1.J_Rotor(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "rotor's moment of inertia";
// output Real DCEE1.phi_mechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = DCEE1.flange_a.phi "mechanical angle of rotor against stator";
// output Real DCEE1.w_mechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(DCEE1.phi_mechanical) "mechanical angular velocity of rotor against stator";
// output Real DCEE1.rpm_mechanical(quantity = "AngularVelocity", unit = "rev/min") = Modelica.SIunits.Conversions.to_rpm(DCEE1.w_mechanical) "mechanical speed of rotor against stator [rpm]";
// output Real DCEE1.tau_electrical(quantity = "Torque", unit = "N.m") = DCEE1.inertiaRotor.flange_a.tau "electromagnetic torque";
// output Real DCEE1.tau_shaft(quantity = "Torque", unit = "N.m") = -DCEE1.flange_a.tau "shaft torque";
// Real DCEE1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real DCEE1.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = DCEE1.inertiaRotor.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real DCEE1.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real DCEE1.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real DCEE1.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = DCEE1.J_Rotor "Moment of inertia";
// parameter Integer DCEE1.inertiaRotor.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real DCEE1.inertiaRotor.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real DCEE1.inertiaRotor.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real DCEE1.inertiaRotor.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer DCEE1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real DCEE1.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = DCEE1.inertiaRotor.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real DCEE1.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// parameter Real DCEE1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
// Real DCEE1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real DCEE1.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.internalSupport.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// output Real DCEE1.va(quantity = "ElectricPotential", unit = "V") = DCEE1.pin_ap.v - DCEE1.pin_an.v "armature voltage";
// output Real DCEE1.ia(quantity = "ElectricCurrent", unit = "A") = DCEE1.pin_ap.i "armature current";
// Real DCEE1.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real DCEE1.VaNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "|Nominal parameters|nominal armature voltage";
// parameter Real DCEE1.IaNominal(quantity = "ElectricCurrent", unit = "A") = 100.0 "|Nominal parameters|nominal armature current";
// parameter Real DCEE1.rpmNominal(quantity = "AngularVelocity", unit = "rev/min") = 1425.0 "|Nominal parameters|nominal speed";
// parameter Real DCEE1.Ra(quantity = "Resistance", unit = "Ohm") = 0.05 "|Nominal resistances and inductances|warm armature resistance";
// parameter Real DCEE1.La(quantity = "Inductance", unit = "H") = 0.0015 "|Nominal resistances and inductances|armature inductance";
// parameter Real DCEE1.IeNominal(quantity = "ElectricCurrent", unit = "A") = 1.0 "|Excitation|nominal excitation current";
// parameter Real DCEE1.Re(quantity = "Resistance", unit = "Ohm") = 100.0 "|Excitation|warm field excitation resistance";
// parameter Real DCEE1.Le(quantity = "Inductance", unit = "H") = 1.0 "|Excitation|total field excitation inductance";
// output Real DCEE1.ve(quantity = "ElectricPotential", unit = "V") = DCEE1.pin_ep.v - DCEE1.pin_en.v "Field excitation voltage";
// output Real DCEE1.ie(quantity = "ElectricCurrent", unit = "A") = DCEE1.pin_ep.i "Field excitation current";
// Real DCEE1.ra.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real DCEE1.ra.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real DCEE1.ra.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.ra.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.ra.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.ra.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real DCEE1.ra.R(quantity = "Resistance", unit = "Ohm") = DCEE1.Ra "Resistance";
// Real DCEE1.la.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real DCEE1.la.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real DCEE1.la.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.la.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.la.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.la.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real DCEE1.la.L(quantity = "Inductance", unit = "H") = DCEE1.La "Inductance";
// Real DCEE1.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real DCEE1.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real DCEE1.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real DCEE1.re.R(quantity = "Resistance", unit = "Ohm") = DCEE1.Re "Resistance";
// Real DCEE1.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real DCEE1.airGapDC.Le(quantity = "Inductance", unit = "H") = DCEE1.Le "Excitation inductance";
// parameter Real DCEE1.airGapDC.TurnsRatio = DCEE1.TurnsRatio "Ratio of armature turns over number of turns of the excitation winding";
// Real DCEE1.airGapDC.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Angluar velocity";
// Real DCEE1.airGapDC.vei(quantity = "ElectricPotential", unit = "V") "Voltage drop across field excitation inductance";
// Real DCEE1.airGapDC.ie(quantity = "ElectricCurrent", unit = "A") "Excitation current";
// Real DCEE1.airGapDC.psi_e(quantity = "MagneticFlux", unit = "Wb") "Excitation flux";
// Real DCEE1.airGapDC.vai(quantity = "ElectricPotential", unit = "V") "Induced armature voltage";
// Real DCEE1.airGapDC.ia(quantity = "ElectricCurrent", unit = "A") "Armature current";
// output Real DCEE1.airGapDC.tau_electrical(quantity = "Torque", unit = "N.m");
// Real DCEE1.airGapDC.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.airGapDC.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real DCEE1.airGapDC.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real DCEE1.airGapDC.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real DCEE1.airGapDC.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.airGapDC.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.airGapDC.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.airGapDC.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.airGapDC.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.airGapDC.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real DCEE1.airGapDC.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real DCEE1.airGapDC.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// protected parameter Real DCEE1.TurnsRatio = (DCEE1.VaNominal - DCEE1.Ra * DCEE1.IaNominal) * 1.0 / DCEE1.IeNominal / DCEE1.Le / Modelica.SIunits.Conversions.from_rpm(DCEE1.rpmNominal) "Ratio of armature turns over number of turns of the excitation winding";
// Real SignalVoltage1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real SignalVoltage1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SignalVoltage1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SignalVoltage1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SignalVoltage1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// input Real SignalVoltage1.v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
// Real Grounda.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Grounda.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Grounde.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Grounde.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   Ramp1.y = Ramp1.offset + (if time < Ramp1.startTime then 0.0 else if time < Ramp1.startTime + Ramp1.duration then ((time - Ramp1.startTime) * Ramp1.height) / Ramp1.duration else Ramp1.height);
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   TorqueStep1.tau = (-TorqueStep1.offsetTorque) - (if time < TorqueStep1.startTime then 0.0 else TorqueStep1.stepTorque);
//   TorqueStep1.bearing.phi = 0.0;
//   ConstantVoltage1.v = ConstantVoltage1.V;
//   ConstantVoltage1.v = ConstantVoltage1.p.v - ConstantVoltage1.n.v;
//   0.0 = ConstantVoltage1.p.i + ConstantVoltage1.n.i;
//   ConstantVoltage1.i = ConstantVoltage1.p.i;
//   DCEE1.inertiaRotor.w = der(DCEE1.inertiaRotor.phi);
//   DCEE1.inertiaRotor.a = der(DCEE1.inertiaRotor.w);
//   DCEE1.inertiaRotor.J * DCEE1.inertiaRotor.a = DCEE1.inertiaRotor.flange_a.tau + DCEE1.inertiaRotor.flange_b.tau;
//   DCEE1.inertiaRotor.flange_a.phi = DCEE1.inertiaRotor.phi;
//   DCEE1.inertiaRotor.flange_b.phi = DCEE1.inertiaRotor.phi;
//   DCEE1.fixedHousing.flange_b.phi = DCEE1.fixedHousing.phi0;
//   DCEE1.ra.R * DCEE1.ra.i = DCEE1.ra.v;
//   DCEE1.ra.v = DCEE1.ra.p.v - DCEE1.ra.n.v;
//   0.0 = DCEE1.ra.p.i + DCEE1.ra.n.i;
//   DCEE1.ra.i = DCEE1.ra.p.i;
//   DCEE1.la.L * der(DCEE1.la.i) = DCEE1.la.v;
//   DCEE1.la.v = DCEE1.la.p.v - DCEE1.la.n.v;
//   0.0 = DCEE1.la.p.i + DCEE1.la.n.i;
//   DCEE1.la.i = DCEE1.la.p.i;
//   DCEE1.re.R * DCEE1.re.i = DCEE1.re.v;
//   DCEE1.re.v = DCEE1.re.p.v - DCEE1.re.n.v;
//   0.0 = DCEE1.re.p.i + DCEE1.re.n.i;
//   DCEE1.re.i = DCEE1.re.p.i;
//   DCEE1.airGapDC.vai = DCEE1.airGapDC.pin_ap.v - DCEE1.airGapDC.pin_an.v;
//   DCEE1.airGapDC.ia = DCEE1.airGapDC.pin_ap.i;
//   DCEE1.airGapDC.ia = -DCEE1.airGapDC.pin_an.i;
//   DCEE1.airGapDC.vei = DCEE1.airGapDC.pin_ep.v - DCEE1.airGapDC.pin_en.v;
//   DCEE1.airGapDC.ie = DCEE1.airGapDC.pin_ep.i;
//   DCEE1.airGapDC.ie = -DCEE1.airGapDC.pin_en.i;
//   DCEE1.airGapDC.psi_e = DCEE1.airGapDC.Le * DCEE1.airGapDC.ie;
//   DCEE1.airGapDC.vei = der(DCEE1.airGapDC.psi_e);
//   DCEE1.airGapDC.w = der(DCEE1.airGapDC.flange_a.phi) - der(DCEE1.airGapDC.support.phi);
//   DCEE1.airGapDC.vai = DCEE1.airGapDC.TurnsRatio * (DCEE1.airGapDC.psi_e * DCEE1.airGapDC.w);
//   DCEE1.airGapDC.tau_electrical = DCEE1.airGapDC.TurnsRatio * (DCEE1.airGapDC.psi_e * DCEE1.airGapDC.ia);
//   DCEE1.airGapDC.flange_a.tau = -DCEE1.airGapDC.tau_electrical;
//   DCEE1.airGapDC.support.tau = DCEE1.airGapDC.tau_electrical;
// assert(DCEE1.VaNominal > DCEE1.Ra * DCEE1.IaNominal,"VaNominal has to be > (Ra+Re)*IaNominal");
//   DCEE1.inertiaRotor.flange_b.tau + (-DCEE1.flange_a.tau) = 0.0;
// DCEE1.inertiaRotor.flange_b.phi = DCEE1.flange_a.phi;
//   DCEE1.airGapDC.support.tau + ((-DCEE1.internalSupport.tau) + DCEE1.fixedHousing.flange_b.tau) = 0.0;
// DCEE1.airGapDC.support.phi = DCEE1.internalSupport.phi;
// DCEE1.internalSupport.phi = DCEE1.fixedHousing.flange_b.phi;
//   DCEE1.airGapDC.pin_en.i + (-DCEE1.pin_en.i) = 0.0;
// DCEE1.airGapDC.pin_en.v = DCEE1.pin_en.v;
//   DCEE1.re.n.i + DCEE1.airGapDC.pin_ep.i = 0.0;
// DCEE1.re.n.v = DCEE1.airGapDC.pin_ep.v;
//   DCEE1.la.n.i + DCEE1.airGapDC.pin_ap.i = 0.0;
// DCEE1.la.n.v = DCEE1.airGapDC.pin_ap.v;
//   DCEE1.la.p.i + DCEE1.ra.n.i = 0.0;
// DCEE1.la.p.v = DCEE1.ra.n.v;
//   DCEE1.re.p.i + (-DCEE1.pin_ep.i) = 0.0;
// DCEE1.re.p.v = DCEE1.pin_ep.v;
//   DCEE1.airGapDC.flange_a.tau + DCEE1.inertiaRotor.flange_a.tau = 0.0;
// DCEE1.airGapDC.flange_a.phi = DCEE1.inertiaRotor.flange_a.phi;
//   (-DCEE1.pin_ap.i) + DCEE1.ra.p.i = 0.0;
// DCEE1.pin_ap.v = DCEE1.ra.p.v;
//   DCEE1.airGapDC.pin_an.i + (-DCEE1.pin_an.i) = 0.0;
// DCEE1.airGapDC.pin_an.v = DCEE1.pin_an.v;
//   SignalVoltage1.v = SignalVoltage1.p.v - SignalVoltage1.n.v;
//   0.0 = SignalVoltage1.p.i + SignalVoltage1.n.i;
//   SignalVoltage1.i = SignalVoltage1.p.i;
//   Grounda.p.v = 0.0;
//   Grounde.p.v = 0.0;
//   DCEE1.pin_en.i + (ConstantVoltage1.n.i + Grounde.p.i) = 0.0;
// DCEE1.pin_en.v = ConstantVoltage1.n.v;
// ConstantVoltage1.n.v = Grounde.p.v;
//   DCEE1.pin_an.i + (SignalVoltage1.n.i + Grounda.p.i) = 0.0;
// DCEE1.pin_an.v = SignalVoltage1.n.v;
// SignalVoltage1.n.v = Grounda.p.v;
//   SignalVoltage1.p.i + DCEE1.pin_ap.i = 0.0;
// SignalVoltage1.p.v = DCEE1.pin_ap.v;
// Ramp1.y = SignalVoltage1.v;
//   DCEE1.pin_ep.i + ConstantVoltage1.p.i = 0.0;
// DCEE1.pin_ep.v = ConstantVoltage1.p.v;
//   DCEE1.flange_a.tau + LoadInertia.flange_a.tau = 0.0;
// DCEE1.flange_a.phi = LoadInertia.flange_a.phi;
//   LoadInertia.flange_b.tau + TorqueStep1.flange.tau = 0.0;
// LoadInertia.flange_b.phi = TorqueStep1.flange.phi;
//   DCEE1.internalSupport.tau = 0.0;
//   TorqueStep1.bearing.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.DCEE_start;
// "
// ""
// endResult
