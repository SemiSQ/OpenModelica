//name:         DCPM_start
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadModel(Modelica,{"2.2.1"});
instantiateModel(Modelica.Electrical.Machines.Examples.DCPM_start);
getErrorString();
// Result:
// true
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.SIunits.Conversions.from_rpm \"Convert from revolutions per minute to radian per second\"
//   input Real rpm(quantity = \"AngularVelocity\", unit = \"rev/min\") \"revolutions per minute value\";
//   output Real rs(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") \"radian per second value\";
// algorithm
//   rs := 0.10471975511965977 * rpm;
// end Modelica.SIunits.Conversions.from_rpm;
// 
// function Modelica.SIunits.Conversions.to_rpm \"Convert from radian per second to revolutions per minute\"
//   input Real rs(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") \"radian per second value\";
//   output Real rpm(quantity = \"AngularVelocity\", unit = \"rev/min\") \"revolutions per minute value\";
// algorithm
//   rpm := 9.549296585513721 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.DCPM_start
//   parameter Real Va(quantity = \"ElectricPotential\", unit = \"V\") = 100.0 \"actual armature voltage\";
//   parameter Real tStart(quantity = \"Time\", unit = \"s\") = 0.2 \"armature voltage ramp\";
//   parameter Real tRamp(quantity = \"Time\", unit = \"s\") = 0.8 \"armature voltage ramp\";
//   parameter Real T_Load(quantity = \"Torque\", unit = \"N.m\") = 63.66 \"nominal load torque\";
//   parameter Real tStep(quantity = \"Time\", unit = \"s\") = 1.5 \"time of load torque step\";
//   parameter Real J_Load(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.15 \"load's moment of inertia\";
//   parameter Real DCPM1.J_Rotor(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.15 \"rotor's moment of inertia\";
//   output Real DCPM1.phi_mechanical(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = DCPM1.flange_a.phi \"mechanical angle of rotor against stator\";
//   output Real DCPM1.w_mechanical(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = der(DCPM1.phi_mechanical) \"mechanical angular velocity of rotor against stator\";
//   output Real DCPM1.rpm_mechanical(quantity = \"AngularVelocity\", unit = \"rev/min\") = Modelica.SIunits.Conversions.to_rpm(DCPM1.w_mechanical) \"mechanical speed of rotor against stator [rpm]\";
//   output Real DCPM1.tau_electrical(quantity = \"Torque\", unit = \"N.m\") = DCPM1.inertiaRotor.flange_a.tau \"electromagnetic torque\";
//   output Real DCPM1.tau_shaft(quantity = \"Torque\", unit = \"N.m\") = -DCPM1.flange_a.tau \"shaft torque\";
//   Real DCPM1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real DCPM1.fixedHousing.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real DCPM1.fixedHousing.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.fixedHousing.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real DCPM1.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real DCPM1.va(quantity = \"ElectricPotential\", unit = \"V\") = DCPM1.pin_ap.v - DCPM1.pin_an.v \"armature voltage\";
//   output Real DCPM1.ia(quantity = \"ElectricCurrent\", unit = \"A\") = DCPM1.pin_ap.i \"armature current\";
//   Real DCPM1.pin_ap.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.pin_ap.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.pin_an.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.pin_an.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real DCPM1.VaNominal(quantity = \"ElectricPotential\", unit = \"V\") = 100.0 \"|Nominal parameters|nominal armature voltage\";
//   parameter Real DCPM1.IaNominal(quantity = \"ElectricCurrent\", unit = \"A\") = 100.0 \"|Nominal parameters|nominal armature current\";
//   parameter Real DCPM1.rpmNominal(quantity = \"AngularVelocity\", unit = \"rev/min\") = 1425.0 \"|Nominal parameters|nominal speed\";
//   parameter Real DCPM1.Ra(quantity = \"Resistance\", unit = \"Ohm\") = 0.05 \"|Nominal resistances and inductances|warm armature resistance\";
//   parameter Real DCPM1.La(quantity = \"Inductance\", unit = \"H\") = 0.0015 \"|Nominal resistances and inductances|armature inductance\";
//   Real DCPM1.eGround.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.eGround.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected constant Real DCPM1.IeNominal(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0 \"equivalent excitation current\";
//   protected constant Real DCPM1.Le(quantity = \"Inductance\", unit = \"H\") = 1.0 \"arbitrary excitation inductance\";
//   Real DCPM1.inertiaRotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = DCPM1.inertiaRotor.phi_start, StateSelect = StateSelect.default) \"Absolute rotation angle of component (= flange_a.phi = flange_b.phi)\";
//   Real DCPM1.inertiaRotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.inertiaRotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real DCPM1.inertiaRotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.inertiaRotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real DCPM1.inertiaRotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = DCPM1.J_Rotor \"Moment of inertia\";
//   parameter Integer DCPM1.inertiaRotor.initType(min = 1, max = 9) = 1 \"Type of initialization (defines usage of start values below)\";
//   parameter Real DCPM1.inertiaRotor.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial or guess value of rotor rotation angle phi\";
//   parameter Real DCPM1.inertiaRotor.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = 0.0 \"Initial or guess value of angular velocity w = der(phi)\";
//   parameter Real DCPM1.inertiaRotor.a_start(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial value of angular acceleration a = der(w)\";
//   parameter Integer DCPM1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 \"Priority to use phi and w as states\";
//   Real DCPM1.inertiaRotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\", start = DCPM1.inertiaRotor.w_start, StateSelect = StateSelect.default) \"Absolute angular velocity of component\";
//   Real DCPM1.inertiaRotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component\";
//   Real DCPM1.ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real DCPM1.ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real DCPM1.ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real DCPM1.ra.R(quantity = \"Resistance\", unit = \"Ohm\") = DCPM1.Ra \"Resistance\";
//   Real DCPM1.la.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real DCPM1.la.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real DCPM1.la.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.la.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.la.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.la.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real DCPM1.la.L(quantity = \"Inductance\", unit = \"H\") = DCPM1.La \"Inductance\";
//   Real DCPM1.ie.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real DCPM1.ie.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real DCPM1.ie.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.ie.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.ie.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.ie.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real DCPM1.ie.I(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0 \"Value of constant current\";
//   protected parameter Real DCPM1.TurnsRatio = (DCPM1.VaNominal - DCPM1.Ra * DCPM1.IaNominal) / Modelica.SIunits.Conversions.from_rpm(DCPM1.rpmNominal) \"Ratio of armature turns over number of turns of the excitation winding\";
//   parameter Real DCPM1.airGapDC.Le(quantity = \"Inductance\", unit = \"H\") = 1.0 \"Excitation inductance\";
//   parameter Real DCPM1.airGapDC.TurnsRatio = DCPM1.TurnsRatio \"Ratio of armature turns over number of turns of the excitation winding\";
//   Real DCPM1.airGapDC.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") \"Angluar velocity\";
//   Real DCPM1.airGapDC.vei(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop across field excitation inductance\";
//   Real DCPM1.airGapDC.ie(quantity = \"ElectricCurrent\", unit = \"A\") \"Excitation current\";
//   Real DCPM1.airGapDC.psi_e(quantity = \"MagneticFlux\", unit = \"Wb\") \"Excitation flux\";
//   Real DCPM1.airGapDC.vai(quantity = \"ElectricPotential\", unit = \"V\") \"Induced armature voltage\";
//   Real DCPM1.airGapDC.ia(quantity = \"ElectricCurrent\", unit = \"A\") \"Armature current\";
//   output Real DCPM1.airGapDC.tau_electrical(quantity = \"Torque\", unit = \"N.m\");
//   Real DCPM1.airGapDC.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.airGapDC.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real DCPM1.airGapDC.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real DCPM1.airGapDC.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real DCPM1.airGapDC.pin_ap.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.airGapDC.pin_ap.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.airGapDC.pin_ep.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.airGapDC.pin_ep.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.airGapDC.pin_an.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.airGapDC.pin_an.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real DCPM1.airGapDC.pin_en.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real DCPM1.airGapDC.pin_en.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Ground1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Ground1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SignalVoltage1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real SignalVoltage1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   output Real Ramp1.y \"Connector of Real output signal\";
//   parameter Real Ramp1.height = Va \"Height of ramps\";
//   parameter Real Ramp1.duration(min = 1e-60) = tRamp \"Durations of ramp\";
//   parameter Real Ramp1.offset = 0.0 \"Offset of output signal\";
//   parameter Real Ramp1.startTime(quantity = \"Time\", unit = \"s\") = tStart \"Output = offset for time < startTime\";
//   Real TorqueStep1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = der(TorqueStep1.flange.phi) \"Angular velocity at flange\";
//   Real TorqueStep1.tau(quantity = \"Torque\", unit = \"N.m\") = TorqueStep1.flange.tau \"accelerating torque acting at flange\";
//   Real TorqueStep1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real TorqueStep1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real TorqueStep1.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real TorqueStep1.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real TorqueStep1.stepTorque(quantity = \"Torque\", unit = \"N.m\") = -T_Load \"height of torque step (if negative, torque is acting as load)\";
//   parameter Real TorqueStep1.offsetTorque(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"offset of torque\";
//   parameter Real TorqueStep1.startTime(quantity = \"Time\", unit = \"s\") = tStep \"output = offset for time < startTime\";
//   Real LoadInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = LoadInertia.phi_start, StateSelect = StateSelect.default) \"Absolute rotation angle of component (= flange_a.phi = flange_b.phi)\";
//   Real LoadInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real LoadInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real LoadInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real LoadInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real LoadInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = J_Load \"Moment of inertia\";
//   parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 \"Type of initialization (defines usage of start values below)\";
//   parameter Real LoadInertia.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial or guess value of rotor rotation angle phi\";
//   parameter Real LoadInertia.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = 0.0 \"Initial or guess value of angular velocity w = der(phi)\";
//   parameter Real LoadInertia.a_start(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial value of angular acceleration a = der(w)\";
//   parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 \"Priority to use phi and w as states\";
//   Real LoadInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\", start = LoadInertia.w_start, StateSelect = StateSelect.default) \"Absolute angular velocity of component\";
//   Real LoadInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component\";
// equation
//   DCPM1.fixedHousing.flange_b.phi = DCPM1.fixedHousing.phi0;
//   DCPM1.eGround.p.v = 0.0;
//   DCPM1.inertiaRotor.w = der(DCPM1.inertiaRotor.phi);
//   DCPM1.inertiaRotor.a = der(DCPM1.inertiaRotor.w);
//   DCPM1.inertiaRotor.J * DCPM1.inertiaRotor.a = DCPM1.inertiaRotor.flange_a.tau + DCPM1.inertiaRotor.flange_b.tau;
//   DCPM1.inertiaRotor.flange_a.phi = DCPM1.inertiaRotor.phi;
//   DCPM1.inertiaRotor.flange_b.phi = DCPM1.inertiaRotor.phi;
//   DCPM1.ra.R * DCPM1.ra.i = DCPM1.ra.v;
//   DCPM1.ra.v = DCPM1.ra.p.v - DCPM1.ra.n.v;
//   0.0 = DCPM1.ra.p.i + DCPM1.ra.n.i;
//   DCPM1.ra.i = DCPM1.ra.p.i;
//   DCPM1.la.L * der(DCPM1.la.i) = DCPM1.la.v;
//   DCPM1.la.v = DCPM1.la.p.v - DCPM1.la.n.v;
//   0.0 = DCPM1.la.p.i + DCPM1.la.n.i;
//   DCPM1.la.i = DCPM1.la.p.i;
//   DCPM1.ie.i = DCPM1.ie.I;
//   DCPM1.ie.v = DCPM1.ie.p.v - DCPM1.ie.n.v;
//   0.0 = DCPM1.ie.p.i + DCPM1.ie.n.i;
//   DCPM1.ie.i = DCPM1.ie.p.i;
//   DCPM1.airGapDC.vai = DCPM1.airGapDC.pin_ap.v - DCPM1.airGapDC.pin_an.v;
//   DCPM1.airGapDC.ia = DCPM1.airGapDC.pin_ap.i;
//   DCPM1.airGapDC.ia = -DCPM1.airGapDC.pin_an.i;
//   DCPM1.airGapDC.vei = DCPM1.airGapDC.pin_ep.v - DCPM1.airGapDC.pin_en.v;
//   DCPM1.airGapDC.ie = DCPM1.airGapDC.pin_ep.i;
//   DCPM1.airGapDC.ie = -DCPM1.airGapDC.pin_en.i;
//   DCPM1.airGapDC.psi_e = DCPM1.airGapDC.Le * DCPM1.airGapDC.ie;
//   DCPM1.airGapDC.vei = der(DCPM1.airGapDC.psi_e);
//   DCPM1.airGapDC.w = der(DCPM1.airGapDC.flange_a.phi) - der(DCPM1.airGapDC.support.phi);
//   DCPM1.airGapDC.vai = DCPM1.airGapDC.TurnsRatio * DCPM1.airGapDC.psi_e * DCPM1.airGapDC.w;
//   DCPM1.airGapDC.tau_electrical = DCPM1.airGapDC.TurnsRatio * DCPM1.airGapDC.psi_e * DCPM1.airGapDC.ia;
//   DCPM1.airGapDC.flange_a.tau = -DCPM1.airGapDC.tau_electrical;
//   DCPM1.airGapDC.support.tau = DCPM1.airGapDC.tau_electrical;
//   assert(DCPM1.VaNominal > DCPM1.Ra * DCPM1.IaNominal,\"VaNominal has to be > (Ra+Re)*IaNominal\");
//   Ground1.p.v = 0.0;
//   SignalVoltage1.v = SignalVoltage1.p.v - SignalVoltage1.n.v;
//   0.0 = SignalVoltage1.p.i + SignalVoltage1.n.i;
//   SignalVoltage1.i = SignalVoltage1.p.i;
//   Ramp1.y = Ramp1.offset + (if time < Ramp1.startTime then 0.0 else if time < Ramp1.startTime + Ramp1.duration then (time - Ramp1.startTime) * Ramp1.height / Ramp1.duration else Ramp1.height);
//   TorqueStep1.tau = (-TorqueStep1.offsetTorque) - (if time < TorqueStep1.startTime then 0.0 else TorqueStep1.stepTorque);
//   TorqueStep1.bearing.phi = 0.0;
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   DCPM1.flange_a.tau + LoadInertia.flange_a.tau = 0.0;
//   DCPM1.fixedHousing.flange_b.tau + (-DCPM1.internalSupport.tau) + DCPM1.airGapDC.support.tau = 0.0;
//   DCPM1.internalSupport.tau = 0.0;
//   DCPM1.pin_ap.i + SignalVoltage1.p.i = 0.0;
//   DCPM1.pin_an.i + Ground1.p.i + SignalVoltage1.n.i = 0.0;
//   DCPM1.eGround.p.i + DCPM1.ie.p.i + DCPM1.airGapDC.pin_en.i = 0.0;
//   DCPM1.inertiaRotor.flange_a.tau + DCPM1.airGapDC.flange_a.tau = 0.0;
//   (-DCPM1.flange_a.tau) + DCPM1.inertiaRotor.flange_b.tau = 0.0;
//   (-DCPM1.pin_ap.i) + DCPM1.ra.p.i = 0.0;
//   DCPM1.ra.n.i + DCPM1.la.p.i = 0.0;
//   DCPM1.la.n.i + DCPM1.airGapDC.pin_ap.i = 0.0;
//   DCPM1.ie.n.i + DCPM1.airGapDC.pin_ep.i = 0.0;
//   (-DCPM1.pin_an.i) + DCPM1.airGapDC.pin_an.i = 0.0;
//   DCPM1.airGapDC.pin_ep.v = DCPM1.ie.n.v;
//   DCPM1.airGapDC.pin_en.v = DCPM1.eGround.p.v;
//   DCPM1.airGapDC.pin_en.v = DCPM1.ie.p.v;
//   DCPM1.airGapDC.pin_ap.v = DCPM1.la.n.v;
//   DCPM1.airGapDC.flange_a.phi = DCPM1.inertiaRotor.flange_a.phi;
//   DCPM1.airGapDC.support.phi = DCPM1.fixedHousing.flange_b.phi;
//   DCPM1.airGapDC.support.phi = DCPM1.internalSupport.phi;
//   DCPM1.airGapDC.pin_an.v = DCPM1.pin_an.v;
//   DCPM1.pin_ap.v = DCPM1.ra.p.v;
//   DCPM1.la.p.v = DCPM1.ra.n.v;
//   DCPM1.flange_a.phi = DCPM1.inertiaRotor.flange_b.phi;
//   TorqueStep1.flange.tau + LoadInertia.flange_b.tau = 0.0;
//   TorqueStep1.bearing.tau = 0.0;
//   LoadInertia.flange_b.phi = TorqueStep1.flange.phi;
//   DCPM1.flange_a.phi = LoadInertia.flange_a.phi;
//   Ramp1.y = SignalVoltage1.v;
//   DCPM1.pin_ap.v = SignalVoltage1.p.v;
//   DCPM1.pin_an.v = Ground1.p.v;
//   DCPM1.pin_an.v = SignalVoltage1.n.v;
// end Modelica.Electrical.Machines.Examples.DCPM_start;
// "
// "Notification: Modelica language version set to 2.x due to loading of MSL 2.2.1.
// "
// endResult
