//name:         ExecutionPaths
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadModel(Modelica,{"2.2.1"});
instantiateModel(Modelica.StateGraph.Examples.ExecutionPaths);
getErrorString();
// Result:
// true
// "function Modelica.StateGraph.Temporary.allTrue \"Returns true, if all elements of the Boolean input vector are true\"
//   input Boolean[:] b;
//   output Boolean result;
// algorithm
//   result := true;
//   for i in 1:size(b,1) loop
//     result := result and b[i];
//   end for;
// end Modelica.StateGraph.Temporary.allTrue;
// 
// function Modelica.StateGraph.Temporary.anyTrue \"Returns true, if at least on element of the Boolean input vector is true\"
//   input Boolean[:] b;
//   output Boolean result;
// algorithm
//   result := false;
//   for i in 1:size(b,1) loop
//     result := result or b[i];
//   end for;
// end Modelica.StateGraph.Temporary.anyTrue;
// 
// class Modelica.StateGraph.Examples.ExecutionPaths
//   output Boolean stateGraphRoot.suspend = false;
//   output Boolean stateGraphRoot.resume = false;
//   output Boolean stateGraphRoot.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   output Boolean stateGraphRoot.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   input Real stateGraphRoot.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   output Integer stateGraphRoot.activeSteps \"Number of active steps within the stategraph\";
//   parameter Integer step0.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step0.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step0.localActive = step0.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step0.inPort[1].occupied \"true, if step is active\";
//   input Boolean step0.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step0.outPort[1].available \"true, if step is active\";
//   input Boolean step0.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step0.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step0.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step0.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step0.newActive \"Value of active in the next iteration\";
//   protected Boolean step0.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step0.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition1.localCondition = transition1.condition \"= true, if transition may fire\";
//   parameter Boolean transition1.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition1.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition1.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition1.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition1.fire \"= true, if transition fires\";
//   input Boolean transition1.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition1.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition1.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition1.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition1.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition1.t_dummy;
//   input Boolean transition1.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer step1.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step1.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step1.localActive = step1.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step1.inPort[1].occupied \"true, if step is active\";
//   input Boolean step1.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step1.outPort[1].available \"true, if step is active\";
//   input Boolean step1.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step1.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step1.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step1.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step1.newActive \"Value of active in the next iteration\";
//   protected Boolean step1.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step1.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition2.localCondition = transition2.condition \"= true, if transition may fire\";
//   parameter Boolean transition2.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition2.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition2.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition2.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition2.fire \"= true, if transition fires\";
//   input Boolean transition2.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition2.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition2.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition2.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition2.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition2.t_dummy;
//   input Boolean transition2.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer step6.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step6.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step6.localActive = step6.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step6.inPort[1].occupied \"true, if step is active\";
//   input Boolean step6.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step6.outPort[1].available \"true, if step is active\";
//   input Boolean step6.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step6.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step6.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step6.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step6.newActive \"Value of active in the next iteration\";
//   protected Boolean step6.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step6.active \"= true if step is active, otherwise the step is not active\";
//   parameter Integer step2.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step2.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step2.localActive = step2.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step2.inPort[1].occupied \"true, if step is active\";
//   input Boolean step2.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step2.outPort[1].available \"true, if step is active\";
//   input Boolean step2.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step2.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step2.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step2.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step2.newActive \"Value of active in the next iteration\";
//   protected Boolean step2.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step2.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition3.localCondition = transition3.condition \"= true, if transition may fire\";
//   parameter Boolean transition3.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition3.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition3.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition3.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition3.fire \"= true, if transition fires\";
//   input Boolean transition3.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition3.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition3.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition3.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition3.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition3.t_dummy;
//   input Boolean transition3.condition = true \"= true, if transition may fire (time varying expression)\";
//   input Boolean transition4.localCondition = transition4.condition \"= true, if transition may fire\";
//   parameter Boolean transition4.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition4.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition4.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition4.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition4.fire \"= true, if transition fires\";
//   input Boolean transition4.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition4.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition4.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition4.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition4.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition4.t_dummy;
//   input Boolean transition4.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer step3.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step3.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step3.localActive = step3.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step3.inPort[1].occupied \"true, if step is active\";
//   input Boolean step3.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step3.outPort[1].available \"true, if step is active\";
//   input Boolean step3.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step3.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step3.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step3.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step3.newActive \"Value of active in the next iteration\";
//   protected Boolean step3.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step3.active \"= true if step is active, otherwise the step is not active\";
//   parameter Integer step4.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step4.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step4.localActive = step4.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step4.inPort[1].occupied \"true, if step is active\";
//   input Boolean step4.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step4.outPort[1].available \"true, if step is active\";
//   input Boolean step4.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step4.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step4.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step4.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step4.newActive \"Value of active in the next iteration\";
//   protected Boolean step4.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step4.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition5.localCondition = transition5.condition \"= true, if transition may fire\";
//   parameter Boolean transition5.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition5.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition5.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition5.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition5.fire \"= true, if transition fires\";
//   input Boolean transition5.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition5.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition5.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition5.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition5.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition5.t_dummy;
//   input Boolean transition5.condition = true \"= true, if transition may fire (time varying expression)\";
//   input Boolean transition6.localCondition = transition6.condition \"= true, if transition may fire\";
//   parameter Boolean transition6.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition6.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition6.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition6.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition6.fire \"= true, if transition fires\";
//   input Boolean transition6.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition6.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition6.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition6.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition6.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition6.t_dummy;
//   input Boolean transition6.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer step5.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step5.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step5.localActive = step5.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step5.inPort[1].occupied \"true, if step is active\";
//   input Boolean step5.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step5.outPort[1].available \"true, if step is active\";
//   input Boolean step5.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step5.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step5.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step5.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step5.newActive \"Value of active in the next iteration\";
//   protected Boolean step5.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step5.active \"= true if step is active, otherwise the step is not active\";
//   output Real setReal.y = time \"Value of Real output\";
//   input Boolean transition7.localCondition = transition7.condition \"= true, if transition may fire\";
//   parameter Boolean transition7.enableTimer = false \"= true, if timer is enabled\";
//   parameter Real transition7.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 0.0 \"Wait time before transition fires\";
//   output Real transition7.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition7.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition7.fire \"= true, if transition fires\";
//   input Boolean transition7.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition7.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition7.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition7.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition7.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition7.t_dummy;
//   input Boolean transition7.condition;
//   output Boolean setCondition.y = time > 7.0 \"Value of Boolean output\";
//   input Boolean transition4a.localCondition = transition4a.condition \"= true, if transition may fire\";
//   parameter Boolean transition4a.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition4a.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition4a.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition4a.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition4a.fire \"= true, if transition fires\";
//   input Boolean transition4a.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition4a.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition4a.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition4a.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition4a.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition4a.t_dummy;
//   input Boolean transition4a.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer step4a.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step4a.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step4a.localActive = step4a.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step4a.inPort[1].occupied \"true, if step is active\";
//   input Boolean step4a.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step4a.outPort[1].available \"true, if step is active\";
//   input Boolean step4a.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step4a.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step4a.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step4a.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step4a.newActive \"Value of active in the next iteration\";
//   protected Boolean step4a.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step4a.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition6a.localCondition = transition6a.condition \"= true, if transition may fire\";
//   parameter Boolean transition6a.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition6a.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 2.0 \"Wait time before transition fires\";
//   output Real transition6a.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition6a.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition6a.fire \"= true, if transition fires\";
//   input Boolean transition6a.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition6a.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition6a.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition6a.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition6a.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition6a.t_dummy;
//   input Boolean transition6a.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer NumericValue1.precision(min = 0) = 3 \"Number of significant digits to be shown\";
//   parameter Boolean NumericValue1.hideConnector = false \"= true, if connector is not shown in the dynamic object diagram\";
//   input Real NumericValue1.Value \"Real value to be shown in icon\";
//   parameter Integer alternative.nBranches(min = 1) = 3 \"Number of alternative branches\";
//   input Boolean alternative.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean alternative.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean alternative.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean alternative.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   output Boolean alternative.join[1].occupied \"true, if step is active\";
//   input Boolean alternative.join[1].set \"true, if transition fires and step is activated\";
//   output Boolean alternative.join[2].occupied \"true, if step is active\";
//   input Boolean alternative.join[2].set \"true, if transition fires and step is activated\";
//   output Boolean alternative.join[3].occupied \"true, if step is active\";
//   input Boolean alternative.join[3].set \"true, if transition fires and step is activated\";
//   output Boolean alternative.split[1].available \"true, if step is active\";
//   input Boolean alternative.split[1].reset \"true, if transition fires and step is deactivated\";
//   output Boolean alternative.split[2].available \"true, if step is active\";
//   input Boolean alternative.split[2].reset \"true, if transition fires and step is deactivated\";
//   output Boolean alternative.split[3].available \"true, if step is active\";
//   input Boolean alternative.split[3].reset \"true, if transition fires and step is deactivated\";
//   parameter Integer Parallel1.nBranches(min = 1) = 2 \"Number of parallel branches that are executed in parallel\";
//   output Boolean Parallel1.inPort.occupied \"true, if step is active\";
//   input Boolean Parallel1.inPort.set \"true, if transition fires and step is activated\";
//   output Boolean Parallel1.outPort.available \"true, if step is active\";
//   input Boolean Parallel1.outPort.reset \"true, if transition fires and step is deactivated\";
//   input Boolean Parallel1.join[1].available \"true, if step connected to the transition input is active\";
//   output Boolean Parallel1.join[1].reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean Parallel1.join[2].available \"true, if step connected to the transition input is active\";
//   output Boolean Parallel1.join[2].reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean Parallel1.split[1].occupied \"true, if step connected to the transition output is active\";
//   output Boolean Parallel1.split[1].set \"true, if transition fires and step connected to the transition output becomes active\";
//   input Boolean Parallel1.split[2].occupied \"true, if step connected to the transition output is active\";
//   output Boolean Parallel1.split[2].set \"true, if transition fires and step connected to the transition output becomes active\";
// initial equation
//   step0.active = true;
//   pre(step0.newActive) = pre(step0.localActive);
//   pre(step0.oldActive) = pre(step0.localActive);
//   pre(transition1.enableFire) = false;
//   step1.active = false;
//   pre(step1.newActive) = pre(step1.localActive);
//   pre(step1.oldActive) = pre(step1.localActive);
//   pre(transition2.enableFire) = false;
//   step6.active = false;
//   pre(step6.newActive) = pre(step6.localActive);
//   pre(step6.oldActive) = pre(step6.localActive);
//   step2.active = false;
//   pre(step2.newActive) = pre(step2.localActive);
//   pre(step2.oldActive) = pre(step2.localActive);
//   pre(transition3.enableFire) = false;
//   pre(transition4.enableFire) = false;
//   step3.active = false;
//   pre(step3.newActive) = pre(step3.localActive);
//   pre(step3.oldActive) = pre(step3.localActive);
//   step4.active = false;
//   pre(step4.newActive) = pre(step4.localActive);
//   pre(step4.oldActive) = pre(step4.localActive);
//   pre(transition5.enableFire) = false;
//   pre(transition6.enableFire) = false;
//   step5.active = false;
//   pre(step5.newActive) = pre(step5.localActive);
//   pre(step5.oldActive) = pre(step5.localActive);
//   pre(transition7.enableFire) = false;
//   pre(transition4a.enableFire) = false;
//   step4a.active = false;
//   pre(step4a.newActive) = pre(step4a.localActive);
//   pre(step4a.oldActive) = pre(step4a.localActive);
//   pre(transition6a.enableFire) = false;
// equation
//   stateGraphRoot.activeSteps = -integer(stateGraphRoot.subgraphStatePort.activeSteps);
//   stateGraphRoot.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   stateGraphRoot.resume = stateGraphRoot.subgraphStatePort.resume;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step0.localActive = pre(step0.newActive);
//   step0.newActive = if step0.subgraphStatePort.resume then step0.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step0.inPort[1].set}) or step0.localActive and not Modelica.StateGraph.Temporary.anyTrue({step0.outPort[1].reset})) and not step0.subgraphStatePort.suspend;
//   when step0.subgraphStatePort.suspend then
//   step0.oldActive = step0.localActive;
//   end when;
//   step0.subgraphStatePort.activeSteps = if step0.localActive then 1.0 else 0.0;
//   step0.inPort[1].occupied = step0.localActive;
//   step0.outPort[1].available = step0.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition1.enableFire then
//   transition1.t_start = time;
//   end when;
//   transition1.t_dummy = time - transition1.t_start;
//   transition1.t = if transition1.enableFire then transition1.t_dummy else 0.0;
//   transition1.fire = transition1.enableFire and time >= transition1.t_start + transition1.waitTime;
//   transition1.enableFire = transition1.localCondition and transition1.inPort.available and not transition1.outPort.occupied;
//   transition1.inPort.reset = transition1.fire;
//   transition1.outPort.set = transition1.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step1.localActive = pre(step1.newActive);
//   step1.newActive = if step1.subgraphStatePort.resume then step1.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step1.inPort[1].set}) or step1.localActive and not Modelica.StateGraph.Temporary.anyTrue({step1.outPort[1].reset})) and not step1.subgraphStatePort.suspend;
//   when step1.subgraphStatePort.suspend then
//   step1.oldActive = step1.localActive;
//   end when;
//   step1.subgraphStatePort.activeSteps = if step1.localActive then 1.0 else 0.0;
//   step1.inPort[1].occupied = step1.localActive;
//   step1.outPort[1].available = step1.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition2.enableFire then
//   transition2.t_start = time;
//   end when;
//   transition2.t_dummy = time - transition2.t_start;
//   transition2.t = if transition2.enableFire then transition2.t_dummy else 0.0;
//   transition2.fire = transition2.enableFire and time >= transition2.t_start + transition2.waitTime;
//   transition2.enableFire = transition2.localCondition and transition2.inPort.available and not transition2.outPort.occupied;
//   transition2.inPort.reset = transition2.fire;
//   transition2.outPort.set = transition2.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step6.localActive = pre(step6.newActive);
//   step6.newActive = if step6.subgraphStatePort.resume then step6.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step6.inPort[1].set}) or step6.localActive and not Modelica.StateGraph.Temporary.anyTrue({step6.outPort[1].reset})) and not step6.subgraphStatePort.suspend;
//   when step6.subgraphStatePort.suspend then
//   step6.oldActive = step6.localActive;
//   end when;
//   step6.subgraphStatePort.activeSteps = if step6.localActive then 1.0 else 0.0;
//   step6.inPort[1].occupied = step6.localActive;
//   step6.outPort[1].available = step6.localActive;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step2.localActive = pre(step2.newActive);
//   step2.newActive = if step2.subgraphStatePort.resume then step2.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step2.inPort[1].set}) or step2.localActive and not Modelica.StateGraph.Temporary.anyTrue({step2.outPort[1].reset})) and not step2.subgraphStatePort.suspend;
//   when step2.subgraphStatePort.suspend then
//   step2.oldActive = step2.localActive;
//   end when;
//   step2.subgraphStatePort.activeSteps = if step2.localActive then 1.0 else 0.0;
//   step2.inPort[1].occupied = step2.localActive;
//   step2.outPort[1].available = step2.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition3.enableFire then
//   transition3.t_start = time;
//   end when;
//   transition3.t_dummy = time - transition3.t_start;
//   transition3.t = if transition3.enableFire then transition3.t_dummy else 0.0;
//   transition3.fire = transition3.enableFire and time >= transition3.t_start + transition3.waitTime;
//   transition3.enableFire = transition3.localCondition and transition3.inPort.available and not transition3.outPort.occupied;
//   transition3.inPort.reset = transition3.fire;
//   transition3.outPort.set = transition3.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition4.enableFire then
//   transition4.t_start = time;
//   end when;
//   transition4.t_dummy = time - transition4.t_start;
//   transition4.t = if transition4.enableFire then transition4.t_dummy else 0.0;
//   transition4.fire = transition4.enableFire and time >= transition4.t_start + transition4.waitTime;
//   transition4.enableFire = transition4.localCondition and transition4.inPort.available and not transition4.outPort.occupied;
//   transition4.inPort.reset = transition4.fire;
//   transition4.outPort.set = transition4.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step3.localActive = pre(step3.newActive);
//   step3.newActive = if step3.subgraphStatePort.resume then step3.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step3.inPort[1].set}) or step3.localActive and not Modelica.StateGraph.Temporary.anyTrue({step3.outPort[1].reset})) and not step3.subgraphStatePort.suspend;
//   when step3.subgraphStatePort.suspend then
//   step3.oldActive = step3.localActive;
//   end when;
//   step3.subgraphStatePort.activeSteps = if step3.localActive then 1.0 else 0.0;
//   step3.inPort[1].occupied = step3.localActive;
//   step3.outPort[1].available = step3.localActive;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step4.localActive = pre(step4.newActive);
//   step4.newActive = if step4.subgraphStatePort.resume then step4.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step4.inPort[1].set}) or step4.localActive and not Modelica.StateGraph.Temporary.anyTrue({step4.outPort[1].reset})) and not step4.subgraphStatePort.suspend;
//   when step4.subgraphStatePort.suspend then
//   step4.oldActive = step4.localActive;
//   end when;
//   step4.subgraphStatePort.activeSteps = if step4.localActive then 1.0 else 0.0;
//   step4.inPort[1].occupied = step4.localActive;
//   step4.outPort[1].available = step4.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition5.enableFire then
//   transition5.t_start = time;
//   end when;
//   transition5.t_dummy = time - transition5.t_start;
//   transition5.t = if transition5.enableFire then transition5.t_dummy else 0.0;
//   transition5.fire = transition5.enableFire and time >= transition5.t_start + transition5.waitTime;
//   transition5.enableFire = transition5.localCondition and transition5.inPort.available and not transition5.outPort.occupied;
//   transition5.inPort.reset = transition5.fire;
//   transition5.outPort.set = transition5.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition6.enableFire then
//   transition6.t_start = time;
//   end when;
//   transition6.t_dummy = time - transition6.t_start;
//   transition6.t = if transition6.enableFire then transition6.t_dummy else 0.0;
//   transition6.fire = transition6.enableFire and time >= transition6.t_start + transition6.waitTime;
//   transition6.enableFire = transition6.localCondition and transition6.inPort.available and not transition6.outPort.occupied;
//   transition6.inPort.reset = transition6.fire;
//   transition6.outPort.set = transition6.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step5.localActive = pre(step5.newActive);
//   step5.newActive = if step5.subgraphStatePort.resume then step5.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step5.inPort[1].set}) or step5.localActive and not Modelica.StateGraph.Temporary.anyTrue({step5.outPort[1].reset})) and not step5.subgraphStatePort.suspend;
//   when step5.subgraphStatePort.suspend then
//   step5.oldActive = step5.localActive;
//   end when;
//   step5.subgraphStatePort.activeSteps = if step5.localActive then 1.0 else 0.0;
//   step5.inPort[1].occupied = step5.localActive;
//   step5.outPort[1].available = step5.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   transition7.t_start = 0.0;
//   transition7.t_dummy = 0.0;
//   transition7.t = 0.0;
//   transition7.fire = transition7.enableFire;
//   transition7.enableFire = transition7.localCondition and transition7.inPort.available and not transition7.outPort.occupied;
//   transition7.inPort.reset = transition7.fire;
//   transition7.outPort.set = transition7.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition4a.enableFire then
//   transition4a.t_start = time;
//   end when;
//   transition4a.t_dummy = time - transition4a.t_start;
//   transition4a.t = if transition4a.enableFire then transition4a.t_dummy else 0.0;
//   transition4a.fire = transition4a.enableFire and time >= transition4a.t_start + transition4a.waitTime;
//   transition4a.enableFire = transition4a.localCondition and transition4a.inPort.available and not transition4a.outPort.occupied;
//   transition4a.inPort.reset = transition4a.fire;
//   transition4a.outPort.set = transition4a.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step4a.localActive = pre(step4a.newActive);
//   step4a.newActive = if step4a.subgraphStatePort.resume then step4a.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step4a.inPort[1].set}) or step4a.localActive and not Modelica.StateGraph.Temporary.anyTrue({step4a.outPort[1].reset})) and not step4a.subgraphStatePort.suspend;
//   when step4a.subgraphStatePort.suspend then
//   step4a.oldActive = step4a.localActive;
//   end when;
//   step4a.subgraphStatePort.activeSteps = if step4a.localActive then 1.0 else 0.0;
//   step4a.inPort[1].occupied = step4a.localActive;
//   step4a.outPort[1].available = step4a.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition6a.enableFire then
//   transition6a.t_start = time;
//   end when;
//   transition6a.t_dummy = time - transition6a.t_start;
//   transition6a.t = if transition6a.enableFire then transition6a.t_dummy else 0.0;
//   transition6a.fire = transition6a.enableFire and time >= transition6a.t_start + transition6a.waitTime;
//   transition6a.enableFire = transition6a.localCondition and transition6a.inPort.available and not transition6a.outPort.occupied;
//   transition6a.inPort.reset = transition6a.fire;
//   transition6a.outPort.set = transition6a.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   assert(true,\"Connector split[1] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[1] is not connected to exactly one other connector\");
//   assert(true,\"Connector split[2] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[2] is not connected to exactly one other connector\");
//   assert(true,\"Connector split[3] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[3] is not connected to exactly one other connector\");
//   alternative.split[1].available = alternative.inPort.available;
//   alternative.split[2].available = alternative.split[1].available and not alternative.split[1].reset;
//   alternative.split[3].available = alternative.split[2].available and not alternative.split[2].reset;
//   alternative.join[1].occupied = alternative.outPort.occupied;
//   alternative.join[2].occupied = alternative.outPort.occupied;
//   alternative.join[3].occupied = alternative.outPort.occupied;
//   alternative.inPort.reset = Modelica.StateGraph.Temporary.anyTrue({alternative.split[1].reset,alternative.split[2].reset,alternative.split[3].reset});
//   alternative.outPort.set = Modelica.StateGraph.Temporary.anyTrue({alternative.join[1].set,alternative.join[2].set,alternative.join[3].set});
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   assert(true,\"Connector split[1] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[1] is not connected to exactly one other connector\");
//   assert(true,\"Connector split[2] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[2] is not connected to exactly one other connector\");
//   Parallel1.split[1].set = Parallel1.inPort.set;
//   Parallel1.split[2].set = Parallel1.inPort.set;
//   Parallel1.join[1].reset = Parallel1.outPort.reset;
//   Parallel1.join[2].reset = Parallel1.outPort.reset;
//   Parallel1.inPort.occupied = Modelica.StateGraph.Temporary.anyTrue({Parallel1.split[1].occupied,Parallel1.split[2].occupied});
//   Parallel1.outPort.available = Modelica.StateGraph.Temporary.allTrue({Parallel1.join[1].available,Parallel1.join[2].available});
//   step0.subgraphStatePort.activeSteps + (step1.subgraphStatePort.activeSteps + (step6.subgraphStatePort.activeSteps + (step2.subgraphStatePort.activeSteps + (step3.subgraphStatePort.activeSteps + (step4.subgraphStatePort.activeSteps + (step5.subgraphStatePort.activeSteps + (step4a.subgraphStatePort.activeSteps + stateGraphRoot.subgraphStatePort.activeSteps))))))) = 0.0;
//   step0.subgraphStatePort.resume = step1.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step6.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step2.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step3.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step4.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step5.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = stateGraphRoot.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step4a.subgraphStatePort.resume;
//   step0.subgraphStatePort.suspend = step1.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step6.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step2.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step3.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step4.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step5.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step4a.subgraphStatePort.suspend;
//   step3.inPort[1].set = transition3.outPort.set;
//   step3.inPort[1].occupied = transition3.outPort.occupied;
//   step3.outPort[1].reset = transition5.inPort.reset;
//   step3.outPort[1].available = transition5.inPort.available;
//   step4.inPort[1].set = transition4.outPort.set;
//   step4.inPort[1].occupied = transition4.outPort.occupied;
//   step4.outPort[1].reset = transition6.inPort.reset;
//   step4.outPort[1].available = transition6.inPort.available;
//   step0.inPort[1].set = transition7.outPort.set;
//   step0.inPort[1].occupied = transition7.outPort.occupied;
//   step6.outPort[1].reset = transition7.inPort.reset;
//   step6.outPort[1].available = transition7.inPort.available;
//   step4a.inPort[1].set = transition4a.outPort.set;
//   step4a.inPort[1].occupied = transition4a.outPort.occupied;
//   step4a.outPort[1].reset = transition6a.inPort.reset;
//   step4a.outPort[1].available = transition6a.inPort.available;
//   setCondition.y = transition7.condition;
//   NumericValue1.Value = setReal.y;
//   alternative.split[1].reset = transition3.inPort.reset;
//   alternative.split[1].available = transition3.inPort.available;
//   alternative.split[2].reset = transition4.inPort.reset;
//   alternative.split[2].available = transition4.inPort.available;
//   alternative.split[3].reset = transition4a.inPort.reset;
//   alternative.split[3].available = transition4a.inPort.available;
//   alternative.join[1].set = transition5.outPort.set;
//   alternative.join[1].occupied = transition5.outPort.occupied;
//   alternative.join[2].set = transition6.outPort.set;
//   alternative.join[2].occupied = transition6.outPort.occupied;
//   alternative.join[3].set = transition6a.outPort.set;
//   alternative.join[3].occupied = transition6a.outPort.occupied;
//   alternative.inPort.reset = step2.outPort[1].reset;
//   alternative.inPort.available = step2.outPort[1].available;
//   alternative.outPort.set = step5.inPort[1].set;
//   alternative.outPort.occupied = step5.inPort[1].occupied;
//   step0.outPort[1].reset = transition1.inPort.reset;
//   step0.outPort[1].available = transition1.inPort.available;
//   step6.inPort[1].set = transition2.outPort.set;
//   step6.inPort[1].occupied = transition2.outPort.occupied;
//   Parallel1.split[2].set = step1.inPort[1].set;
//   Parallel1.split[2].occupied = step1.inPort[1].occupied;
//   Parallel1.join[1].reset = step5.outPort[1].reset;
//   Parallel1.join[1].available = step5.outPort[1].available;
//   Parallel1.outPort.reset = transition2.inPort.reset;
//   Parallel1.outPort.available = transition2.inPort.available;
//   Parallel1.inPort.set = transition1.outPort.set;
//   Parallel1.inPort.occupied = transition1.outPort.occupied;
//   Parallel1.join[2].reset = step1.outPort[1].reset;
//   Parallel1.join[2].available = step1.outPort[1].available;
//   Parallel1.split[1].set = step2.inPort[1].set;
//   Parallel1.split[1].occupied = step2.inPort[1].occupied;
// end Modelica.StateGraph.Examples.ExecutionPaths;
// "
// ""
// endResult
