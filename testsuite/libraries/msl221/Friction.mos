//name:         Friction
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.Mechanics.Translational.Examples.Friction);
getErrorString();
// Result:
// true
// "function Modelica.Math.sin
// input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
// output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// fclass Modelica.Mechanics.Translational.Examples.Friction
// Real Stop1.s(quantity = "Length", unit = "m", StateSelect = StateSelect.always) "absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
// parameter Real Stop1.L(quantity = "Length", unit = "m") = 1.0 "length of component from left flange to right flange (= flange_b.s - flange_a.s)";
// Real Stop1.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Stop1.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
// Real Stop1.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Stop1.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
// parameter Real Stop1.smax(quantity = "Length", unit = "m") = 25.0 "right stop for (right end of) sliding mass";
// parameter Real Stop1.smin(quantity = "Length", unit = "m") = -25.0 "left stop for (left end of) sliding mass";
// parameter Real Stop1.v_small(quantity = "Velocity", unit = "m/s") = 0.001 "Relative velocity near to zero (see model info text)";
// Real Stop1.v_relfric(quantity = "Velocity", unit = "m/s") "Relative velocity between frictional surfaces";
// Real Stop1.a_relfric(quantity = "Acceleration", unit = "m/s2") "Relative acceleration between frictional surfaces";
// Real Stop1.f(quantity = "Force", unit = "N") "Friction force (positive, if directed in opposite direction of v_rel)";
// Real Stop1.f0(quantity = "Force", unit = "N") "Friction force for v=0 and forward sliding";
// Real Stop1.f0_max(quantity = "Force", unit = "N") "Maximum friction force for v=0 and locked";
// Boolean Stop1.free "true, if frictional element is not active";
// Real Stop1.sa "Path parameter of friction characteristic f = f(a_relfric)";
// Boolean Stop1.startForward "true, if v_rel=0 and start of forward sliding or v_rel > v_small";
// Boolean Stop1.startBackward "true, if v_rel=0 and start of backward sliding or v_rel < -v_small";
// Boolean Stop1.locked "true, if v_rel=0 and not sliding";
// constant Integer Stop1.Unknown = 3 "Value of mode is not known";
// constant Integer Stop1.Free = 2 "Element is not active";
// constant Integer Stop1.Forward = 1 "v_rel > 0 (forward sliding)";
// constant Integer Stop1.Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
// constant Integer Stop1.Backward = -1 "v_rel < 0 (backward sliding)";
// Integer Stop1.mode(min = -1, max = 3, start = 3);
// Real Stop1.v(quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.always) "Absolute velocity of flange_a and flange_b";
// Real Stop1.a(quantity = "Acceleration", unit = "m/s2") "Absolute acceleration of flange_a and flange_b";
// parameter Real Stop1.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "mass";
// parameter Real Stop1.F_prop(unit = "N/ (m/s)", min = 0.0) = 1.0 "velocity dependent friction";
// parameter Real Stop1.F_Coulomb(quantity = "Force", unit = "N") = 5.0 "constant friction: Coulomb force";
// parameter Real Stop1.F_Stribeck(quantity = "Force", unit = "N") = 10.0 "Stribeck effect";
// parameter Real Stop1.fexp(unit = "1/ (m/s)", min = 0.0) = 2.0 "exponential decay";
// Real Force1.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Force1.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
// input Real Force1.f(quantity = "Force", unit = "N") "driving force as input signal";
// output Real Sine1.y "Connector of Real output signal";
// parameter Real Sine1.amplitude = 25.0 "Amplitude of sine wave";
// parameter Real Sine1.freqHz(quantity = "Frequency", unit = "Hz") = 0.25 "Frequency of sine wave";
// parameter Real Sine1.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phase of sine wave";
// parameter Real Sine1.offset = 0.0 "Offset of output signal";
// parameter Real Sine1.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
// protected constant Real Sine1.pi = 3.14159265358979;
// Real Stop2.s(quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.always) "absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
// parameter Real Stop2.L(quantity = "Length", unit = "m") = 1.0 "length of component from left flange to right flange (= flange_b.s - flange_a.s)";
// Real Stop2.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Stop2.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
// Real Stop2.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Stop2.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
// parameter Real Stop2.smax(quantity = "Length", unit = "m") = 0.9 "right stop for (right end of) sliding mass";
// parameter Real Stop2.smin(quantity = "Length", unit = "m") = -0.9 "left stop for (left end of) sliding mass";
// parameter Real Stop2.v_small(quantity = "Velocity", unit = "m/s") = 0.001 "Relative velocity near to zero (see model info text)";
// Real Stop2.v_relfric(quantity = "Velocity", unit = "m/s") "Relative velocity between frictional surfaces";
// Real Stop2.a_relfric(quantity = "Acceleration", unit = "m/s2") "Relative acceleration between frictional surfaces";
// Real Stop2.f(quantity = "Force", unit = "N") "Friction force (positive, if directed in opposite direction of v_rel)";
// Real Stop2.f0(quantity = "Force", unit = "N") "Friction force for v=0 and forward sliding";
// Real Stop2.f0_max(quantity = "Force", unit = "N") "Maximum friction force for v=0 and locked";
// Boolean Stop2.free "true, if frictional element is not active";
// Real Stop2.sa "Path parameter of friction characteristic f = f(a_relfric)";
// Boolean Stop2.startForward "true, if v_rel=0 and start of forward sliding or v_rel > v_small";
// Boolean Stop2.startBackward "true, if v_rel=0 and start of backward sliding or v_rel < -v_small";
// Boolean Stop2.locked "true, if v_rel=0 and not sliding";
// constant Integer Stop2.Unknown = 3 "Value of mode is not known";
// constant Integer Stop2.Free = 2 "Element is not active";
// constant Integer Stop2.Forward = 1 "v_rel > 0 (forward sliding)";
// constant Integer Stop2.Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
// constant Integer Stop2.Backward = -1 "v_rel < 0 (backward sliding)";
// Integer Stop2.mode(min = -1, max = 3, start = 3);
// Real Stop2.v(quantity = "Velocity", unit = "m/s", start = -5.0, StateSelect = StateSelect.always) "Absolute velocity of flange_a and flange_b";
// Real Stop2.a(quantity = "Acceleration", unit = "m/s2") "Absolute acceleration of flange_a and flange_b";
// parameter Real Stop2.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "mass";
// parameter Real Stop2.F_prop(unit = "N/ (m/s)", min = 0.0) = 1.0 "velocity dependent friction";
// parameter Real Stop2.F_Coulomb(quantity = "Force", unit = "N") = 3.0 "constant friction: Coulomb force";
// parameter Real Stop2.F_Stribeck(quantity = "Force", unit = "N") = 5.0 "Stribeck effect";
// parameter Real Stop2.fexp(unit = "1/ (m/s)", min = 0.0) = 2.0 "exponential decay";
// Real Spring1.s_rel(quantity = "Length", unit = "m", min = 0.0) "relative distance (= flange_b.s - flange_a.s)";
// Real Spring1.f(quantity = "Force", unit = "N") "forcee between flanges (positive in direction of flange axis R)";
// Real Spring1.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Spring1.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
// Real Spring1.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Spring1.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
// parameter Real Spring1.s_rel0(quantity = "Length", unit = "m", min = 0.0) = 1.0 "unstretched spring length";
// parameter Real Spring1.c(unit = "N/m", min = 0.0) = 500.0 "spring constant ";
// parameter Real Fixed1.s0(quantity = "Length", unit = "m") = -1.75 "fixed offset position of housing";
// Real Fixed1.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
// Real Fixed1.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
// equation
//   Stop1.f0 = Stop1.F_Coulomb + Stop1.F_Stribeck;
//   Stop1.f0_max = 1.001 * Stop1.f0;
//   Stop1.free = Stop1.f0 <= 0.0 AND Stop1.F_prop <= 0.0 AND Stop1.s > Stop1.smin + Stop1.L / 2.0 AND Stop1.s < Stop1.smax - Stop1.L / 2.0;
//   Stop1.v = der(Stop1.s);
//   Stop1.a = der(Stop1.v);
//   Stop1.v_relfric = Stop1.v;
//   Stop1.a_relfric = Stop1.a;
//   0.0 = Stop1.flange_a.f + Stop1.flange_b.f - Stop1.f - Stop1.m * der(Stop1.v);
//   Stop1.f = if Stop1.locked then Stop1.sa else if Stop1.free then 0.0 else if Stop1.startForward then Stop1.F_prop * Stop1.v + (Stop1.F_Coulomb + Stop1.F_Stribeck) else if Stop1.startBackward then Stop1.F_prop * Stop1.v - Stop1.F_Coulomb - Stop1.F_Stribeck else if pre(Stop1.mode) == 1 then Stop1.F_prop * Stop1.v + (Stop1.F_Coulomb + Stop1.F_Stribeck * exp((-Stop1.fexp) * abs(Stop1.v))) else Stop1.F_prop * Stop1.v - Stop1.F_Coulomb - Stop1.F_Stribeck * exp((-Stop1.fexp) * abs(Stop1.v));
//   Stop1.mode = if Stop1.free then 2 else if (pre(Stop1.mode) == 1 OR pre(Stop1.mode) == 2 OR Stop1.startForward) AND Stop1.v_relfric > 0.0 AND Stop1.s < Stop1.smax - Stop1.L / 2.0 then 1 else if (pre(Stop1.mode) == -1 OR pre(Stop1.mode) == 2 OR Stop1.startBackward) AND Stop1.v_relfric < 0.0 AND Stop1.s > Stop1.smin + Stop1.L / 2.0 then -1 else 0;
//   Stop1.a_relfric = if Stop1.locked then 0.0 else if Stop1.free then Stop1.sa else if Stop1.startForward then Stop1.sa - Stop1.f0_max else if Stop1.startBackward then Stop1.sa + Stop1.f0_max else if pre(Stop1.mode) == 1 then Stop1.sa - Stop1.f0 else Stop1.sa + Stop1.f0;
//   Stop1.locked =  NOT Stop1.free AND  NOT (pre(Stop1.mode) == 1 OR Stop1.startForward OR pre(Stop1.mode) == -1 OR Stop1.startBackward);
//   Stop1.startBackward = pre(Stop1.mode) == 0 AND (Stop1.sa < -Stop1.f0_max AND Stop1.s > Stop1.smin + Stop1.L / 2.0 OR pre(Stop1.startBackward) AND Stop1.sa < -Stop1.f0 AND Stop1.s > Stop1.smin + Stop1.L / 2.0) OR pre(Stop1.mode) == 1 AND Stop1.v_relfric < -Stop1.v_small OR initial() AND Stop1.v_relfric < 0.0;
//   Stop1.startForward = pre(Stop1.mode) == 0 AND (Stop1.sa > Stop1.f0_max AND Stop1.s < Stop1.smax - Stop1.L / 2.0 OR pre(Stop1.startForward) AND Stop1.sa > Stop1.f0 AND Stop1.s < Stop1.smax - Stop1.L / 2.0) OR pre(Stop1.mode) == -1 AND Stop1.v_relfric > Stop1.v_small OR initial() AND Stop1.v_relfric > 0.0;
//   Stop1.flange_a.s = Stop1.s - Stop1.L / 2.0;
//   Stop1.flange_b.s = Stop1.s + Stop1.L / 2.0;
//   Force1.flange_b.f = -Force1.f;
//   Sine1.y = Sine1.offset + (if time < Sine1.startTime then 0.0 else Sine1.amplitude * Modelica.Math.sin(6.28318530717959 * (Sine1.freqHz * (time - Sine1.startTime)) + Sine1.phase));
//   Stop2.f0 = Stop2.F_Coulomb + Stop2.F_Stribeck;
//   Stop2.f0_max = 1.001 * Stop2.f0;
//   Stop2.free = Stop2.f0 <= 0.0 AND Stop2.F_prop <= 0.0 AND Stop2.s > Stop2.smin + Stop2.L / 2.0 AND Stop2.s < Stop2.smax - Stop2.L / 2.0;
//   Stop2.v = der(Stop2.s);
//   Stop2.a = der(Stop2.v);
//   Stop2.v_relfric = Stop2.v;
//   Stop2.a_relfric = Stop2.a;
//   0.0 = Stop2.flange_a.f + Stop2.flange_b.f - Stop2.f - Stop2.m * der(Stop2.v);
//   Stop2.f = if Stop2.locked then Stop2.sa else if Stop2.free then 0.0 else if Stop2.startForward then Stop2.F_prop * Stop2.v + (Stop2.F_Coulomb + Stop2.F_Stribeck) else if Stop2.startBackward then Stop2.F_prop * Stop2.v - Stop2.F_Coulomb - Stop2.F_Stribeck else if pre(Stop2.mode) == 1 then Stop2.F_prop * Stop2.v + (Stop2.F_Coulomb + Stop2.F_Stribeck * exp((-Stop2.fexp) * abs(Stop2.v))) else Stop2.F_prop * Stop2.v - Stop2.F_Coulomb - Stop2.F_Stribeck * exp((-Stop2.fexp) * abs(Stop2.v));
//   Stop2.mode = if Stop2.free then 2 else if (pre(Stop2.mode) == 1 OR pre(Stop2.mode) == 2 OR Stop2.startForward) AND Stop2.v_relfric > 0.0 AND Stop2.s < Stop2.smax - Stop2.L / 2.0 then 1 else if (pre(Stop2.mode) == -1 OR pre(Stop2.mode) == 2 OR Stop2.startBackward) AND Stop2.v_relfric < 0.0 AND Stop2.s > Stop2.smin + Stop2.L / 2.0 then -1 else 0;
//   Stop2.a_relfric = if Stop2.locked then 0.0 else if Stop2.free then Stop2.sa else if Stop2.startForward then Stop2.sa - Stop2.f0_max else if Stop2.startBackward then Stop2.sa + Stop2.f0_max else if pre(Stop2.mode) == 1 then Stop2.sa - Stop2.f0 else Stop2.sa + Stop2.f0;
//   Stop2.locked =  NOT Stop2.free AND  NOT (pre(Stop2.mode) == 1 OR Stop2.startForward OR pre(Stop2.mode) == -1 OR Stop2.startBackward);
//   Stop2.startBackward = pre(Stop2.mode) == 0 AND (Stop2.sa < -Stop2.f0_max AND Stop2.s > Stop2.smin + Stop2.L / 2.0 OR pre(Stop2.startBackward) AND Stop2.sa < -Stop2.f0 AND Stop2.s > Stop2.smin + Stop2.L / 2.0) OR pre(Stop2.mode) == 1 AND Stop2.v_relfric < -Stop2.v_small OR initial() AND Stop2.v_relfric < 0.0;
//   Stop2.startForward = pre(Stop2.mode) == 0 AND (Stop2.sa > Stop2.f0_max AND Stop2.s < Stop2.smax - Stop2.L / 2.0 OR pre(Stop2.startForward) AND Stop2.sa > Stop2.f0 AND Stop2.s < Stop2.smax - Stop2.L / 2.0) OR pre(Stop2.mode) == -1 AND Stop2.v_relfric > Stop2.v_small OR initial() AND Stop2.v_relfric > 0.0;
//   Stop2.flange_a.s = Stop2.s - Stop2.L / 2.0;
//   Stop2.flange_b.s = Stop2.s + Stop2.L / 2.0;
//   Spring1.f = Spring1.c * (Spring1.s_rel - Spring1.s_rel0);
//   Spring1.s_rel = Spring1.flange_b.s - Spring1.flange_a.s;
//   Spring1.flange_b.f = Spring1.f;
//   Spring1.flange_a.f = -Spring1.f;
//   Fixed1.flange_b.s = Fixed1.s0;
//   Force1.flange_b.f + Stop1.flange_a.f = 0.0;
// Force1.flange_b.s = Stop1.flange_a.s;
//   Fixed1.flange_b.f + Spring1.flange_a.f = 0.0;
// Fixed1.flange_b.s = Spring1.flange_a.s;
//   Spring1.flange_b.f + Stop2.flange_a.f = 0.0;
// Spring1.flange_b.s = Stop2.flange_a.s;
// Sine1.y = Force1.f;
//   Stop1.flange_b.f = 0.0;
//   Stop2.flange_b.f = 0.0;
// algorithm
//   when initial() then
//     assert(Stop1.s > Stop1.smin + Stop1.L / 2.0 OR Stop1.s >= Stop1.smin + Stop1.L / 2.0 AND Stop1.v >= 0.0, "Error in initialization of hard stop. (s - L/2) must be >= smin ");
//     assert(Stop1.s < Stop1.smax - Stop1.L / 2.0 OR Stop1.s <= Stop1.smax - Stop1.L / 2.0 AND Stop1.v <= 0.0, "Error in initialization of hard stop. (s + L/2) must be <= smax ");
//   end when;
//   when NOT Stop1.s < Stop1.smax - Stop1.L / 2.0 then
//     reinit(Stop1.s, Stop1.smax - Stop1.L / 2.0);
//     if NOT initial() OR Stop1.v > 0.0 then
//       reinit(Stop1.v, 0.0);
//     end if;
//   end when;
//   when NOT Stop1.s > Stop1.smin + Stop1.L / 2.0 then
//     reinit(Stop1.s, Stop1.smin + Stop1.L / 2.0);
//     if NOT initial() OR Stop1.v < 0.0 then
//       reinit(Stop1.v, 0.0);
//     end if;
//   end when;
//   when initial() then
//     assert(Stop2.s > Stop2.smin + Stop2.L / 2.0 OR Stop2.s >= Stop2.smin + Stop2.L / 2.0 AND Stop2.v >= 0.0, "Error in initialization of hard stop. (s - L/2) must be >= smin ");
//     assert(Stop2.s < Stop2.smax - Stop2.L / 2.0 OR Stop2.s <= Stop2.smax - Stop2.L / 2.0 AND Stop2.v <= 0.0, "Error in initialization of hard stop. (s + L/2) must be <= smax ");
//   end when;
//   when NOT Stop2.s < Stop2.smax - Stop2.L / 2.0 then
//     reinit(Stop2.s, Stop2.smax - Stop2.L / 2.0);
//     if NOT initial() OR Stop2.v > 0.0 then
//       reinit(Stop2.v, 0.0);
//     end if;
//   end when;
//   when NOT Stop2.s > Stop2.smin + Stop2.L / 2.0 then
//     reinit(Stop2.s, Stop2.smin + Stop2.L / 2.0);
//     if NOT initial() OR Stop2.v < 0.0 then
//       reinit(Stop2.v, 0.0);
//     end if;
//   end when;
// end Modelica.Mechanics.Translational.Examples.Friction;
// "
// ""
// endResult
