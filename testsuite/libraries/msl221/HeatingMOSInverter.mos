//name:         HeatingMOSInverter
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Electrical.Analog.Examples.HeatingMOSInverter);
getErrorString();
// Result:
// true
// "function Modelica.Electrical.Analog.Semiconductors.pow
//   input Real x;
//   input Real y;
//   output Real z;
// algorithm
//   z := x ^ y;
// end Modelica.Electrical.Analog.Semiconductors.pow;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.sin;
// 
// function Modelica.SIunits.Conversions.from_degC
//   input Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
//   output Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Kelvin value\";
// algorithm
//   Kelvin := Celsius - -273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// class Modelica.Electrical.Analog.Examples.HeatingMOSInverter
//   parameter Real HeatCapacitor1.C(quantity = \"HeatCapacity\", unit = \"J/K\") = 0.01 \"Heat capacity of part (= cp*m)\";
//   parameter Boolean HeatCapacitor1.steadyStateStart = false \"true, if component shall start in steady state\";
//   Real HeatCapacitor1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 293.15) \"Temperature of part\";
//   Real HeatCapacitor1.port.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real HeatCapacitor1.port.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real TC1.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate from port_a -> port_b\";
//   Real TC1.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"port_a.T - port_b.T\";
//   Real TC1.port_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real TC1.port_a.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real TC1.port_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real TC1.port_b.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real TC1.G(quantity = \"ThermalConductance\", unit = \"W/K\") = 0.01 \"Constant thermal conductance of material\";
//   Real TC2.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate from port_a -> port_b\";
//   Real TC2.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"port_a.T - port_b.T\";
//   Real TC2.port_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real TC2.port_a.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real TC2.port_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real TC2.port_b.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real TC2.G(quantity = \"ThermalConductance\", unit = \"W/K\") = 0.01 \"Constant thermal conductance of material\";
//   parameter Real FixedTemperature1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.0 \"Fixed temperature at port\";
//   Real FixedTemperature1.port.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real FixedTemperature1.port.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real TC3.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate from port_a -> port_b\";
//   Real TC3.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"port_a.T - port_b.T\";
//   Real TC3.port_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real TC3.port_a.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real TC3.port_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real TC3.port_b.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real TC3.G(quantity = \"ThermalConductance\", unit = \"W/K\") = 0.01 \"Constant thermal conductance of material\";
//   Real G.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real G.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real H_PMOS.W(quantity = \"Length\", unit = \"m\") = 2e-05 \"Width\";
//   parameter Real H_PMOS.L(quantity = \"Length\", unit = \"m\") = 6e-06 \"Length\";
//   parameter Real H_PMOS.Beta(quantity = \"Transconductance\", unit = \"A/(V*V)\") = 1.05e-05 \"Transconductance parameter\";
//   parameter Real H_PMOS.Vt(quantity = \"ElectricPotential\", unit = \"V\") = -1.0 \"Zero bias threshold voltage\";
//   parameter Real H_PMOS.K2 = 0.41 \"Bulk threshold parameter\";
//   parameter Real H_PMOS.K5 = 0.839 \"Reduction of pinch-off region\";
//   parameter Real H_PMOS.dW(quantity = \"Length\", unit = \"m\") = -2.5e-06 \"Narrowing of channel\";
//   parameter Real H_PMOS.dL(quantity = \"Length\", unit = \"m\") = -2.1e-06 \"Shortening of channel\";
//   parameter Real H_PMOS.RDS(quantity = \"Resistance\", unit = \"Ohm\") = 10000000.0 \"Drain-Source-Resistance\";
//   parameter Real H_PMOS.Tnom(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Parameter measurement temperature\";
//   parameter Real H_PMOS.kvt = -0.0029 \"fitting parameter for Vt\";
//   parameter Real H_PMOS.kk2 = 0.00062 \"fitting parameter for Kk2\";
//   Real H_PMOS.D.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_PMOS.D.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_PMOS.G.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_PMOS.G.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_PMOS.S.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_PMOS.S.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_PMOS.B.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_PMOS.B.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_PMOS.heatPort.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 300.15) \"Port temperature\";
//   Real H_PMOS.heatPort.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected Real H_PMOS.v;
//   protected Real H_PMOS.uds;
//   protected Real H_PMOS.ubs;
//   protected Real H_PMOS.ugst;
//   protected Real H_PMOS.ud;
//   protected Real H_PMOS.us;
//   protected Real H_PMOS.id;
//   protected Real H_PMOS.gds;
//   protected Real H_PMOS.beta_t;
//   protected Real H_PMOS.vt_t;
//   protected Real H_PMOS.k2_t;
//   parameter Real H_NMOS.W(quantity = \"Length\", unit = \"m\") = 2e-05 \"Width\";
//   parameter Real H_NMOS.L(quantity = \"Length\", unit = \"m\") = 6e-06 \"Length\";
//   parameter Real H_NMOS.Beta(quantity = \"Transconductance\", unit = \"A/(V*V)\") = 4.1e-05 \"Transconductance parameter\";
//   parameter Real H_NMOS.Vt(quantity = \"ElectricPotential\", unit = \"V\") = 0.8 \"Zero bias threshold voltage\";
//   parameter Real H_NMOS.K2 = 1.144 \"Bulk threshold parameter\";
//   parameter Real H_NMOS.K5 = 0.7311 \"Reduction of pinch-off region\";
//   parameter Real H_NMOS.dW(quantity = \"Length\", unit = \"m\") = -2.5e-06 \"narrowing of channel\";
//   parameter Real H_NMOS.dL(quantity = \"Length\", unit = \"m\") = -1.5e-06 \"shortening of channel\";
//   parameter Real H_NMOS.RDS(quantity = \"Resistance\", unit = \"Ohm\") = 10000000.0 \"Drain-Source-Resistance\";
//   parameter Real H_NMOS.Tnom(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Parameter measurement temperature\";
//   parameter Real H_NMOS.kvt = -0.00696 \"fitting parameter for Vt\";
//   parameter Real H_NMOS.kk2 = 0.0006 \"fitting parameter for K22\";
//   Real H_NMOS.D.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_NMOS.D.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_NMOS.G.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_NMOS.G.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_NMOS.S.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_NMOS.S.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_NMOS.B.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real H_NMOS.B.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real H_NMOS.heatPort.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 300.15) \"Port temperature\";
//   Real H_NMOS.heatPort.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected Real H_NMOS.v;
//   protected Real H_NMOS.uds;
//   protected Real H_NMOS.ubs;
//   protected Real H_NMOS.ugst;
//   protected Real H_NMOS.ud;
//   protected Real H_NMOS.us;
//   protected Real H_NMOS.id;
//   protected Real H_NMOS.gds;
//   protected Real H_NMOS.beta_t;
//   protected Real H_NMOS.vt_t;
//   protected Real H_NMOS.k2_t;
//   Real Sin.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real Sin.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real Sin.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Sin.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Sin.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Sin.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real Sin.offset(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offset\";
//   parameter Real Sin.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Time offset\";
//   output Real Sin.signalSource.y \"Connector of Real output signal\";
//   parameter Real Sin.signalSource.amplitude = Sin.V \"Amplitude of sine wave\";
//   parameter Real Sin.signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\") = Sin.freqHz \"Frequency of sine wave\";
//   parameter Real Sin.signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Sin.phase \"Phase of sine wave\";
//   parameter Real Sin.signalSource.offset = Sin.offset \"Offset of output signal\";
//   parameter Real Sin.signalSource.startTime(quantity = \"Time\", unit = \"s\") = Sin.startTime \"Output = offset for time < startTime\";
//   protected constant Real Sin.signalSource.pi = 3.14159265358979;
//   parameter Real Sin.V(quantity = \"ElectricPotential\", unit = \"V\") = 5.0 \"Amplitude of sine wave\";
//   parameter Real Sin.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Phase of sine wave\";
//   parameter Real Sin.freqHz(quantity = \"Frequency\", unit = \"Hz\") = 1.0 \"Frequency of sine wave\";
//   Real V.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real V.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real V.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real V.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real V.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real V.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real V.offset(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offset\";
//   parameter Real V.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Time offset\";
//   output Real V.signalSource.y \"Connector of Real output signal\";
//   parameter Real V.signalSource.height = V.V \"Height of ramps\";
//   parameter Real V.signalSource.duration(min = 1e-60) = V.duration \"Durations of ramp\";
//   parameter Real V.signalSource.offset = V.offset \"Offset of output signal\";
//   parameter Real V.signalSource.startTime(quantity = \"Time\", unit = \"s\") = V.startTime \"Output = offset for time < startTime\";
//   parameter Real V.V(quantity = \"ElectricPotential\", unit = \"V\") = 5.0 \"Height of ramp\";
//   parameter Real V.duration(quantity = \"Time\", unit = \"s\", min = 1e-60) = 0.01 \"Duration of ramp\";
//   Real Capacitor1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real Capacitor1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real Capacitor1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Capacitor1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Capacitor1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Capacitor1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real Capacitor1.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 1e-05 \"Capacitance\";
// equation
//   HeatCapacitor1.T = HeatCapacitor1.port.T;
//   HeatCapacitor1.C * der(HeatCapacitor1.T) = HeatCapacitor1.port.Q_flow;
//   TC1.Q_flow = TC1.G * TC1.dT;
//   TC1.dT = TC1.port_a.T - TC1.port_b.T;
//   TC1.port_a.Q_flow = TC1.Q_flow;
//   TC1.port_b.Q_flow = -TC1.Q_flow;
//   TC2.Q_flow = TC2.G * TC2.dT;
//   TC2.dT = TC2.port_a.T - TC2.port_b.T;
//   TC2.port_a.Q_flow = TC2.Q_flow;
//   TC2.port_b.Q_flow = -TC2.Q_flow;
//   FixedTemperature1.port.T = FixedTemperature1.T;
//   TC3.Q_flow = TC3.G * TC3.dT;
//   TC3.dT = TC3.port_a.T - TC3.port_b.T;
//   TC3.port_a.Q_flow = TC3.Q_flow;
//   TC3.port_b.Q_flow = -TC3.Q_flow;
//   G.p.v = 0.0;
//   assert(H_PMOS.L + H_PMOS.dL > 0.0,\"Effective length must be positive\");
//   assert(H_PMOS.W + H_PMOS.dW > 0.0,\"Effective width  must be positive\");
//   assert(H_PMOS.heatPort.T > 0.0,\"temperature must be positive\");
//   H_PMOS.gds = if H_PMOS.RDS < 1e-20 AND H_PMOS.RDS > -1e-20 then 1e+20 else 1.0 / H_PMOS.RDS;
//   H_PMOS.v = H_PMOS.beta_t * (H_PMOS.W + H_PMOS.dW) / (H_PMOS.L + H_PMOS.dL);
//   H_PMOS.ud = if H_PMOS.D.v > H_PMOS.S.v then H_PMOS.S.v else H_PMOS.D.v;
//   H_PMOS.us = if H_PMOS.D.v > H_PMOS.S.v then H_PMOS.D.v else H_PMOS.S.v;
//   H_PMOS.uds = H_PMOS.ud - H_PMOS.us;
//   H_PMOS.ubs = if H_PMOS.B.v < H_PMOS.us then 0.0 else H_PMOS.B.v - H_PMOS.us;
//   H_PMOS.ugst = (H_PMOS.G.v + (H_PMOS.k2_t * H_PMOS.ubs + ((-H_PMOS.vt_t) + (-H_PMOS.us)))) * H_PMOS.K5;
//   H_PMOS.id = if H_PMOS.ugst >= 0.0 then H_PMOS.uds * H_PMOS.gds else if H_PMOS.ugst < H_PMOS.uds then (-H_PMOS.v) * (H_PMOS.uds * (H_PMOS.ugst - H_PMOS.uds / 2.0)) + H_PMOS.uds * H_PMOS.gds else 0.5 * ((-H_PMOS.v) * H_PMOS.ugst ^ 2.0) + H_PMOS.uds * H_PMOS.gds;
//   H_PMOS.beta_t = H_PMOS.Beta * Modelica.Electrical.Analog.Semiconductors.pow(H_PMOS.heatPort.T / H_PMOS.Tnom,-1.5);
//   H_PMOS.vt_t = H_PMOS.Vt * (1.0 + (H_PMOS.heatPort.T - H_PMOS.Tnom) * H_PMOS.kvt);
//   H_PMOS.k2_t = H_PMOS.K2 * (1.0 + (H_PMOS.heatPort.T - H_PMOS.Tnom) * H_PMOS.kk2);
//   H_PMOS.G.i = 0.0;
//   H_PMOS.D.i = if H_PMOS.D.v > H_PMOS.S.v then -H_PMOS.id else H_PMOS.id;
//   H_PMOS.S.i = if H_PMOS.D.v > H_PMOS.S.v then H_PMOS.id else -H_PMOS.id;
//   H_PMOS.B.i = 0.0;
//   H_PMOS.heatPort.Q_flow = (-H_PMOS.D.i) * (H_PMOS.D.v - H_PMOS.S.v);
//   assert(H_NMOS.L + H_NMOS.dL > 0.0,\"Effective length must be positive\");
//   assert(H_NMOS.W + H_NMOS.dW > 0.0,\"Effective width  must be positive\");
//   assert(H_NMOS.heatPort.T > 0.0,\"temperature must be positive\");
//   H_NMOS.gds = if H_NMOS.RDS < 1e-20 AND H_NMOS.RDS > -1e-20 then 1e+20 else 1.0 / H_NMOS.RDS;
//   H_NMOS.v = H_NMOS.beta_t * (H_NMOS.W + H_NMOS.dW) / (H_NMOS.L + H_NMOS.dL);
//   H_NMOS.ud = if H_NMOS.D.v < H_NMOS.S.v then H_NMOS.S.v else H_NMOS.D.v;
//   H_NMOS.us = if H_NMOS.D.v < H_NMOS.S.v then H_NMOS.D.v else H_NMOS.S.v;
//   H_NMOS.uds = H_NMOS.ud - H_NMOS.us;
//   H_NMOS.ubs = if H_NMOS.B.v > H_NMOS.us then 0.0 else H_NMOS.B.v - H_NMOS.us;
//   H_NMOS.ugst = (H_NMOS.G.v + (H_NMOS.k2_t * H_NMOS.ubs + ((-H_NMOS.vt_t) + (-H_NMOS.us)))) * H_NMOS.K5;
//   H_NMOS.id = if H_NMOS.ugst <= 0.0 then H_NMOS.uds * H_NMOS.gds else if H_NMOS.ugst > H_NMOS.uds then H_NMOS.v * (H_NMOS.uds * (H_NMOS.ugst - H_NMOS.uds / 2.0)) + H_NMOS.uds * H_NMOS.gds else 0.5 * (H_NMOS.v * H_NMOS.ugst ^ 2.0) + H_NMOS.uds * H_NMOS.gds;
//   H_NMOS.beta_t = H_NMOS.Beta * Modelica.Electrical.Analog.Semiconductors.pow(H_NMOS.heatPort.T / H_NMOS.Tnom,-1.5);
//   H_NMOS.vt_t = H_NMOS.Vt * (1.0 + (H_NMOS.heatPort.T - H_NMOS.Tnom) * H_NMOS.kvt);
//   H_NMOS.k2_t = H_NMOS.K2 * (1.0 + (H_NMOS.heatPort.T - H_NMOS.Tnom) * H_NMOS.kk2);
//   H_NMOS.G.i = 0.0;
//   H_NMOS.D.i = if H_NMOS.D.v < H_NMOS.S.v then -H_NMOS.id else H_NMOS.id;
//   H_NMOS.S.i = if H_NMOS.D.v < H_NMOS.S.v then H_NMOS.id else -H_NMOS.id;
//   H_NMOS.B.i = 0.0;
//   H_NMOS.heatPort.Q_flow = (-H_NMOS.D.i) * (H_NMOS.D.v - H_NMOS.S.v);
//   Sin.signalSource.y = Sin.signalSource.offset + (if time < Sin.signalSource.startTime then 0.0 else Sin.signalSource.amplitude * sin(6.28318530717959 * (Sin.signalSource.freqHz * (time - Sin.signalSource.startTime)) + Sin.signalSource.phase));
//   Sin.v = Sin.signalSource.y;
//   Sin.v = Sin.p.v - Sin.n.v;
//   0.0 = Sin.p.i + Sin.n.i;
//   Sin.i = Sin.p.i;
//   V.signalSource.y = V.signalSource.offset + (if time < V.signalSource.startTime then 0.0 else if time < V.signalSource.startTime + V.signalSource.duration then ((time - V.signalSource.startTime) * V.signalSource.height) / V.signalSource.duration else V.signalSource.height);
//   V.v = V.signalSource.y;
//   V.v = V.p.v - V.n.v;
//   0.0 = V.p.i + V.n.i;
//   V.i = V.p.i;
//   Capacitor1.i = Capacitor1.C * der(Capacitor1.v);
//   Capacitor1.v = Capacitor1.p.v - Capacitor1.n.v;
//   0.0 = Capacitor1.p.i + Capacitor1.n.i;
//   Capacitor1.i = Capacitor1.p.i;
//   H_PMOS.S.i + (H_NMOS.D.i + Capacitor1.p.i) = 0.0;
//   Capacitor1.p.v = H_NMOS.D.v;
//   Capacitor1.p.v = H_PMOS.S.v;
//   Capacitor1.n.i + (V.n.i + (Sin.n.i + (H_NMOS.B.i + (H_NMOS.S.i + G.p.i)))) = 0.0;
//   Capacitor1.n.v = G.p.v;
//   Capacitor1.n.v = H_NMOS.B.v;
//   Capacitor1.n.v = H_NMOS.S.v;
//   Capacitor1.n.v = Sin.n.v;
//   Capacitor1.n.v = V.n.v;
//   V.p.i + (H_PMOS.B.i + H_PMOS.D.i) = 0.0;
//   H_PMOS.B.v = H_PMOS.D.v;
//   H_PMOS.B.v = V.p.v;
//   H_NMOS.G.i + (H_PMOS.G.i + Sin.p.i) = 0.0;
//   H_NMOS.G.v = H_PMOS.G.v;
//   H_NMOS.G.v = Sin.p.v;
//   TC1.port_b.Q_flow + (TC2.port_b.Q_flow + (TC3.port_a.Q_flow + HeatCapacitor1.port.Q_flow)) = 0.0;
//   HeatCapacitor1.port.T = TC1.port_b.T;
//   HeatCapacitor1.port.T = TC2.port_b.T;
//   HeatCapacitor1.port.T = TC3.port_a.T;
//   TC1.port_a.Q_flow + H_PMOS.heatPort.Q_flow = 0.0;
//   H_PMOS.heatPort.T = TC1.port_a.T;
//   TC2.port_a.Q_flow + H_NMOS.heatPort.Q_flow = 0.0;
//   H_NMOS.heatPort.T = TC2.port_a.T;
//   TC3.port_b.Q_flow + FixedTemperature1.port.Q_flow = 0.0;
//   FixedTemperature1.port.T = TC3.port_b.T;
// end Modelica.Electrical.Analog.Examples.HeatingMOSInverter;
// "
// ""
// endResult
