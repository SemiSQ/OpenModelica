//name:         IndirectCooling
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling);
getErrorString();
// Result:
// true
// "function Modelica.Thermal.FluidHeatFlow.Media.Medium "Automatically generated record constructor for Modelica.Thermal.FluidHeatFlow.Media.Medium"
// input Real(quantity="Density", unit="kg/m3", displayUnit="g/cm3", min=0.0) rho = 1.0;
// input Real(quantity="SpecificHeatCapacity", unit="J/(kg.K)") cp = 1.0;
// input Real(quantity="SpecificHeatCapacity", unit="J/(kg.K)") cv = 1.0;
// input Real(quantity="ThermalConductivity", unit="W/(m.K)") lamda = 1.0;
// input Real(quantity="KinematicViscosity", unit="m2/s", min=0.0) nue = 1.0;
// output Medium res;
// end Modelica.Thermal.FluidHeatFlow.Media.Medium;
// 
// function Modelica.SIunits.Conversions.from_degC
// input Real Celsius(quantity = "ThermodynamicTemperature", unit = "degC") "Celsius value";
// output Real Kelvin(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Kelvin value";
// algorithm
//   Kelvin := Celsius - -273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// fclass Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling
// parameter Real outerMedium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerMedium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerMedium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerMedium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerMedium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real innerMedium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerMedium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerMedium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerMedium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerMedium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real TAmb(quantity = "CelsiusTemperature", unit = "degC") = 20.0 "ambient temperature";
// output Real dTSource(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source over Ambient";
// output Real dTtoPipe(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source over inner Coolant";
// output Real dTinnerCoolant(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.dT "inner Coolant's temperature increase";
// output Real dTCooler(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPipe.heatPort.T - outerPipe.heatPort.T "Cooler's temperature increase between inner and outer pipes";
// output Real dTouterCoolant(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPipe.dT "outer Coolant's temperature increase";
// parameter Real Ambient1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// output Real Ambient1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "outlet temperature of medium";
// output Real Ambient1.T_port(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Ambient1.flowPort.h / Ambient1.medium.cp "temperature at flowPort_a";
// parameter Real Ambient1.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient1.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient1.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient1.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient1.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Ambient1.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Ambient1.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Ambient1.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Ambient1.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Ambient1.h(quantity = "SpecificEnergy", unit = "J/kg") = Ambient1.medium.cp * Ambient1.T;
// parameter Real Ambient1.p_Ambient(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.0;
// parameter Real Ambient1.T_Ambient(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb);
// parameter Real outerPump.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerPump.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerPump.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerPump.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerPump.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real outerPump.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.0 "mass of medium";
// parameter Real outerPump.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real outerPump.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = outerPump.flowPort_a.p - outerPump.flowPort_b.p "pressure drop a->b";
// Real outerPump.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = outerPump.flowPort_a.m_flow / outerPump.medium.rho "Volume flow a->b";
// Real outerPump.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real outerPump.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = outerPump.T0) "outlet temperature of medium";
// output Real outerPump.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPump.flowPort_a.h / outerPump.medium.cp "temperature at flowPort_a";
// output Real outerPump.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPump.flowPort_b.h / outerPump.medium.cp "temperature at flowPort_b";
// output Real outerPump.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(outerPump.V_flow >= 0.0) then outerPump.T - outerPump.T_a else outerPump.T_b - outerPump.T "temperature increase of coolant in flow direction";
// parameter Real outerPump.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerPump.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerPump.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerPump.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerPump.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real outerPump.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real outerPump.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real outerPump.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real outerPump.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real outerPump.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerPump.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerPump.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerPump.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerPump.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real outerPump.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real outerPump.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real outerPump.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real outerPump.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real outerPump.h(quantity = "SpecificEnergy", unit = "J/kg") = outerPump.medium.cp * outerPump.T "medium's specific enthalpy";
// protected Real outerPump.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPump.T "temperature relevant for heat exchange with ambient";
// input Real outerPump.VolumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
// parameter Real Ambient2.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient2.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient2.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient2.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient2.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// output Real Ambient2.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "outlet temperature of medium";
// output Real Ambient2.T_port(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Ambient2.flowPort.h / Ambient2.medium.cp "temperature at flowPort_a";
// parameter Real Ambient2.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient2.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient2.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient2.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient2.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Ambient2.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Ambient2.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Ambient2.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Ambient2.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Ambient2.h(quantity = "SpecificEnergy", unit = "J/kg") = Ambient2.medium.cp * Ambient2.T;
// parameter Real Ambient2.p_Ambient(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.0;
// parameter Real Ambient2.T_Ambient(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb);
// parameter Real HeatCapacitor1.C(quantity = "HeatCapacity", unit = "J/K") = 0.05 "Heat capacity of part (= cp*m)";
// parameter Boolean HeatCapacitor1.steadyStateStart = false "true, if component shall start in steady state";
// Real HeatCapacitor1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = Modelica.SIunits.Conversions.from_degC(TAmb)) "Temperature of part";
// Real HeatCapacitor1.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real HeatCapacitor1.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real PrescribedHeatFlow1.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
// parameter Real PrescribedHeatFlow1.alpha(unit = "1/K") = 0.0 "Temperature coefficient of heat flow rate";
// Real PrescribedHeatFlow1.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real PrescribedHeatFlow1.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// input Real PrescribedHeatFlow1.Q_flow(quantity = "Power", unit = "W");
// parameter Real Pipe1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Pipe1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Pipe1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Pipe1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Pipe1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real Pipe1.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.1 "mass of medium";
// parameter Real Pipe1.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real Pipe1.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = Pipe1.flowPort_a.p - Pipe1.flowPort_b.p "pressure drop a->b";
// Real Pipe1.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = Pipe1.flowPort_a.m_flow / Pipe1.medium.rho "Volume flow a->b";
// Real Pipe1.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real Pipe1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = Pipe1.T0) "outlet temperature of medium";
// output Real Pipe1.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.flowPort_a.h / Pipe1.medium.cp "temperature at flowPort_a";
// output Real Pipe1.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.flowPort_b.h / Pipe1.medium.cp "temperature at flowPort_b";
// output Real Pipe1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(Pipe1.V_flow >= 0.0) then Pipe1.T - Pipe1.T_a else Pipe1.T_b - Pipe1.T "temperature increase of coolant in flow direction";
// parameter Real Pipe1.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Pipe1.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Pipe1.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Pipe1.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Pipe1.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Pipe1.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Pipe1.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Pipe1.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Pipe1.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real Pipe1.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Pipe1.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Pipe1.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Pipe1.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Pipe1.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Pipe1.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Pipe1.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Pipe1.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Pipe1.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Pipe1.h(quantity = "SpecificEnergy", unit = "J/kg") = Pipe1.medium.cp * Pipe1.T "medium's specific enthalpy";
// protected Real Pipe1.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.T "temperature relevant for heat exchange with ambient";
// parameter Real Pipe1.V_flowLaminar(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60) = 1.0 "|SimpleFriction|laminar volume flow";
// parameter Real Pipe1.dpLaminar(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 1000.0 "|SimpleFriction|laminar pressure drop";
// parameter Real Pipe1.V_flowNominal(quantity = "VolumeFlowRate", unit = "m3/s") = 2.0 "|SimpleFriction|nominal volume flow";
// parameter Real Pipe1.dpNominal(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 2000.0 "|SimpleFriction|nominal pressure drop";
// parameter Real Pipe1.frictionLoss(min = 0.0, max = 1.0) = 0.0 "|SimpleFriction|part of friction losses fed to medium";
// Real Pipe1.pressureDrop(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Pipe1.VolumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
// Real Pipe1.Q_friction(quantity = "Power", unit = "W");
// protected parameter Real Pipe1.k(fixed = false);
// parameter Real Pipe1.h_g(quantity = "Length", unit = "m") = 0.0 "geodetic height (heigth difference from flowPort_a to flowPort_b)";
// Real Pipe1.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real Pipe1.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real AbsolutePressure1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real AbsolutePressure1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real AbsolutePressure1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real AbsolutePressure1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real AbsolutePressure1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real AbsolutePressure1.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 10000.0 "pressure ground";
// parameter Real AbsolutePressure1.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real AbsolutePressure1.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real AbsolutePressure1.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real AbsolutePressure1.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real AbsolutePressure1.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real AbsolutePressure1.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real AbsolutePressure1.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real AbsolutePressure1.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real AbsolutePressure1.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// output Real HeatFlow.y "Connector of Real output signal";
// parameter Real HeatFlow.k = 10.0 "Constant output value";
// output Real outerVolumeFlow.y "Connector of Real output signal";
// parameter Real outerVolumeFlow.k = 1.0 "Constant output value";
// output Real innerVolumeFlow.y "Connector of Real output signal";
// parameter Real innerVolumeFlow.k = 1.0 "Constant output value";
// output Real outerGc.y "Connector of Real output signal";
// parameter Real outerGc.k = 2.0 "Constant output value";
// output Real innerGc.y "Connector of Real output signal";
// parameter Real innerGc.k = 2.0 "Constant output value";
// parameter Real outerPipe.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerPipe.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerPipe.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerPipe.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerPipe.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real outerPipe.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.1 "mass of medium";
// parameter Real outerPipe.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real outerPipe.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = outerPipe.flowPort_a.p - outerPipe.flowPort_b.p "pressure drop a->b";
// Real outerPipe.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = outerPipe.flowPort_a.m_flow / outerPipe.medium.rho "Volume flow a->b";
// Real outerPipe.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real outerPipe.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = outerPipe.T0) "outlet temperature of medium";
// output Real outerPipe.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPipe.flowPort_a.h / outerPipe.medium.cp "temperature at flowPort_a";
// output Real outerPipe.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPipe.flowPort_b.h / outerPipe.medium.cp "temperature at flowPort_b";
// output Real outerPipe.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(outerPipe.V_flow >= 0.0) then outerPipe.T - outerPipe.T_a else outerPipe.T_b - outerPipe.T "temperature increase of coolant in flow direction";
// parameter Real outerPipe.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerPipe.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerPipe.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerPipe.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerPipe.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real outerPipe.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real outerPipe.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real outerPipe.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real outerPipe.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real outerPipe.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real outerPipe.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real outerPipe.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real outerPipe.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real outerPipe.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real outerPipe.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real outerPipe.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real outerPipe.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real outerPipe.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real outerPipe.h(quantity = "SpecificEnergy", unit = "J/kg") = outerPipe.medium.cp * outerPipe.T "medium's specific enthalpy";
// protected Real outerPipe.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = outerPipe.T "temperature relevant for heat exchange with ambient";
// parameter Real outerPipe.V_flowLaminar(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60) = 0.1 "|SimpleFriction|laminar volume flow";
// parameter Real outerPipe.dpLaminar(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.1 "|SimpleFriction|laminar pressure drop";
// parameter Real outerPipe.V_flowNominal(quantity = "VolumeFlowRate", unit = "m3/s") = 1.0 "|SimpleFriction|nominal volume flow";
// parameter Real outerPipe.dpNominal(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 1.0 "|SimpleFriction|nominal pressure drop";
// parameter Real outerPipe.frictionLoss(min = 0.0, max = 1.0) = 0.0 "|SimpleFriction|part of friction losses fed to medium";
// Real outerPipe.pressureDrop(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real outerPipe.VolumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
// Real outerPipe.Q_friction(quantity = "Power", unit = "W");
// protected parameter Real outerPipe.k(fixed = false);
// parameter Real outerPipe.h_g(quantity = "Length", unit = "m") = 0.0 "geodetic height (heigth difference from flowPort_a to flowPort_b)";
// Real outerPipe.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real outerPipe.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real innerPipe.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerPipe.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerPipe.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerPipe.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerPipe.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real innerPipe.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.1 "mass of medium";
// parameter Real innerPipe.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real innerPipe.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = innerPipe.flowPort_a.p - innerPipe.flowPort_b.p "pressure drop a->b";
// Real innerPipe.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = innerPipe.flowPort_a.m_flow / innerPipe.medium.rho "Volume flow a->b";
// Real innerPipe.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real innerPipe.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = innerPipe.T0) "outlet temperature of medium";
// output Real innerPipe.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPipe.flowPort_a.h / innerPipe.medium.cp "temperature at flowPort_a";
// output Real innerPipe.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPipe.flowPort_b.h / innerPipe.medium.cp "temperature at flowPort_b";
// output Real innerPipe.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(innerPipe.V_flow >= 0.0) then innerPipe.T - innerPipe.T_a else innerPipe.T_b - innerPipe.T "temperature increase of coolant in flow direction";
// parameter Real innerPipe.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerPipe.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerPipe.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerPipe.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerPipe.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real innerPipe.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real innerPipe.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real innerPipe.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real innerPipe.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real innerPipe.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerPipe.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerPipe.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerPipe.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerPipe.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real innerPipe.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real innerPipe.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real innerPipe.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real innerPipe.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real innerPipe.h(quantity = "SpecificEnergy", unit = "J/kg") = innerPipe.medium.cp * innerPipe.T "medium's specific enthalpy";
// protected Real innerPipe.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPipe.T "temperature relevant for heat exchange with ambient";
// parameter Real innerPipe.V_flowLaminar(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60) = 0.1 "|SimpleFriction|laminar volume flow";
// parameter Real innerPipe.dpLaminar(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.1 "|SimpleFriction|laminar pressure drop";
// parameter Real innerPipe.V_flowNominal(quantity = "VolumeFlowRate", unit = "m3/s") = 1.0 "|SimpleFriction|nominal volume flow";
// parameter Real innerPipe.dpNominal(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 1.0 "|SimpleFriction|nominal pressure drop";
// parameter Real innerPipe.frictionLoss(min = 0.0, max = 1.0) = 0.0 "|SimpleFriction|part of friction losses fed to medium";
// Real innerPipe.pressureDrop(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real innerPipe.VolumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
// Real innerPipe.Q_friction(quantity = "Power", unit = "W");
// protected parameter Real innerPipe.k(fixed = false);
// parameter Real innerPipe.h_g(quantity = "Length", unit = "m") = 0.0 "geodetic height (heigth difference from flowPort_a to flowPort_b)";
// Real innerPipe.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real innerPipe.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real innerConvection.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from solid -> fluid";
// Real innerConvection.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "= solid.T - fluid.T";
// Real innerConvection.solid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real innerConvection.solid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real innerConvection.fluid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real innerConvection.fluid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// input Real innerConvection.Gc(quantity = "ThermalConductance", unit = "W/K") "Signal representing the convective thermal conductance in [W/K]";
// parameter Real innerPump.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerPump.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerPump.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerPump.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerPump.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real innerPump.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.0 "mass of medium";
// parameter Real innerPump.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real innerPump.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = innerPump.flowPort_a.p - innerPump.flowPort_b.p "pressure drop a->b";
// Real innerPump.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = innerPump.flowPort_a.m_flow / innerPump.medium.rho "Volume flow a->b";
// Real innerPump.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real innerPump.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = innerPump.T0) "outlet temperature of medium";
// output Real innerPump.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPump.flowPort_a.h / innerPump.medium.cp "temperature at flowPort_a";
// output Real innerPump.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPump.flowPort_b.h / innerPump.medium.cp "temperature at flowPort_b";
// output Real innerPump.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(innerPump.V_flow >= 0.0) then innerPump.T - innerPump.T_a else innerPump.T_b - innerPump.T "temperature increase of coolant in flow direction";
// parameter Real innerPump.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerPump.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerPump.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerPump.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerPump.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real innerPump.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real innerPump.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real innerPump.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real innerPump.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real innerPump.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real innerPump.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real innerPump.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real innerPump.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real innerPump.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real innerPump.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real innerPump.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real innerPump.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real innerPump.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real innerPump.h(quantity = "SpecificEnergy", unit = "J/kg") = innerPump.medium.cp * innerPump.T "medium's specific enthalpy";
// protected Real innerPump.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = innerPump.T "temperature relevant for heat exchange with ambient";
// input Real innerPump.VolumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
// Real ThermalConductor1.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from port_a -> port_b";
// Real ThermalConductor1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "port_a.T - port_b.T";
// Real ThermalConductor1.port_a.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real ThermalConductor1.port_a.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real ThermalConductor1.port_b.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real ThermalConductor1.port_b.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real ThermalConductor1.G(quantity = "ThermalConductance", unit = "W/K") = 1.0 "Constant thermal conductance of material";
// Real outerConvection.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from solid -> fluid";
// Real outerConvection.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "= solid.T - fluid.T";
// Real outerConvection.solid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real outerConvection.solid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real outerConvection.fluid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real outerConvection.fluid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// input Real outerConvection.Gc(quantity = "ThermalConductance", unit = "W/K") "Signal representing the convective thermal conductance in [W/K]";
// initial algorithm
//   assert(Pipe1.V_flowNominal > Pipe1.V_flowLaminar, "SimpleFriction: V_flowNominal has to be > V_flowLaminar!");
//   Pipe1.k := Pipe1.dpLaminar * Pipe1.V_flowNominal / Pipe1.V_flowLaminar;
//   assert(Pipe1.dpNominal >= Pipe1.k, "SimpleFriction: dpNominal has to be > dpLaminar*V_flowNominal/V_flowLaminar!");
//   Pipe1.k := (Pipe1.dpNominal - Pipe1.k) * (Pipe1.V_flowNominal - Pipe1.V_flowLaminar) ^ -2.0;
//   assert(outerPipe.V_flowNominal > outerPipe.V_flowLaminar, "SimpleFriction: V_flowNominal has to be > V_flowLaminar!");
//   outerPipe.k := outerPipe.dpLaminar * outerPipe.V_flowNominal / outerPipe.V_flowLaminar;
//   assert(outerPipe.dpNominal >= outerPipe.k, "SimpleFriction: dpNominal has to be > dpLaminar*V_flowNominal/V_flowLaminar!");
//   outerPipe.k := (outerPipe.dpNominal - outerPipe.k) * (outerPipe.V_flowNominal - outerPipe.V_flowLaminar) ^ -2.0;
//   assert(innerPipe.V_flowNominal > innerPipe.V_flowLaminar, "SimpleFriction: V_flowNominal has to be > V_flowLaminar!");
//   innerPipe.k := innerPipe.dpLaminar * innerPipe.V_flowNominal / innerPipe.V_flowLaminar;
//   assert(innerPipe.dpNominal >= innerPipe.k, "SimpleFriction: dpNominal has to be > dpLaminar*V_flowNominal/V_flowLaminar!");
//   innerPipe.k := (innerPipe.dpNominal - innerPipe.k) * (innerPipe.V_flowNominal - innerPipe.V_flowLaminar) ^ -2.0;
// equation
//   Ambient1.flowPort.p = Ambient1.p_Ambient;
//   Ambient1.T = Ambient1.T_Ambient;
//   Ambient1.flowPort.H_flow = semiLinear(Ambient1.flowPort.m_flow,Ambient1.flowPort.h,Ambient1.h);
//   outerPump.Q_flow = 0.0;
//   outerPump.V_flow = outerPump.VolumeFlow;
//   outerPump.flowPort_a.m_flow + outerPump.flowPort_b.m_flow = 0.0;
//   outerPump.flowPort_a.H_flow + (outerPump.flowPort_b.H_flow + outerPump.Q_flow) = 0.0;
//   outerPump.flowPort_a.H_flow = semiLinear(outerPump.flowPort_a.m_flow,outerPump.flowPort_a.h,outerPump.h);
//   outerPump.flowPort_b.H_flow = semiLinear(outerPump.flowPort_b.m_flow,outerPump.flowPort_b.h,outerPump.h);
//   Ambient2.flowPort.p = Ambient2.p_Ambient;
//   Ambient2.T = Ambient2.T_Ambient;
//   Ambient2.flowPort.H_flow = semiLinear(Ambient2.flowPort.m_flow,Ambient2.flowPort.h,Ambient2.h);
//   HeatCapacitor1.T = HeatCapacitor1.port.T;
//   HeatCapacitor1.C * der(HeatCapacitor1.T) = HeatCapacitor1.port.Q_flow;
//   PrescribedHeatFlow1.port.Q_flow = (-PrescribedHeatFlow1.Q_flow) * (1.0 + PrescribedHeatFlow1.alpha * (PrescribedHeatFlow1.port.T - PrescribedHeatFlow1.T_ref));
//   Pipe1.VolumeFlow = Pipe1.V_flow;
//   Pipe1.dp = Pipe1.pressureDrop + 9.80665 * (Pipe1.medium.rho * Pipe1.h_g);
//   Pipe1.Q_flow = Pipe1.heatPort.Q_flow + Pipe1.Q_friction;
//   Pipe1.heatPort.T = Pipe1.T_q;
//   Pipe1.flowPort_b.H_flow = semiLinear(Pipe1.flowPort_b.m_flow,Pipe1.flowPort_b.h,Pipe1.h);
//   Pipe1.flowPort_a.H_flow = semiLinear(Pipe1.flowPort_a.m_flow,Pipe1.flowPort_a.h,Pipe1.h);
//   Pipe1.flowPort_a.H_flow + (Pipe1.flowPort_b.H_flow + Pipe1.Q_flow) = Pipe1.m * (Pipe1.medium.cv * der(Pipe1.T));
//   Pipe1.flowPort_a.m_flow + Pipe1.flowPort_b.m_flow = 0.0;
//   if Pipe1.VolumeFlow > Pipe1.V_flowLaminar then
//   Pipe1.pressureDrop = Pipe1.dpLaminar * Pipe1.VolumeFlow / Pipe1.V_flowLaminar + Pipe1.k * (Pipe1.VolumeFlow - Pipe1.V_flowLaminar) ^ 2.0;
//   elseif Pipe1.VolumeFlow < -Pipe1.V_flowLaminar then
//   Pipe1.pressureDrop = Pipe1.dpLaminar * Pipe1.VolumeFlow / Pipe1.V_flowLaminar - Pipe1.k * (Pipe1.VolumeFlow + Pipe1.V_flowLaminar) ^ 2.0;
//   else
//   Pipe1.pressureDrop = Pipe1.dpLaminar * Pipe1.VolumeFlow / Pipe1.V_flowLaminar;
//   end if;
//   Pipe1.Q_friction = Pipe1.frictionLoss * (Pipe1.VolumeFlow * Pipe1.pressureDrop);
//   AbsolutePressure1.flowPort.p = AbsolutePressure1.p;
//   AbsolutePressure1.flowPort.H_flow = 0.0;
//   HeatFlow.y = HeatFlow.k;
//   outerVolumeFlow.y = outerVolumeFlow.k;
//   innerVolumeFlow.y = innerVolumeFlow.k;
//   outerGc.y = outerGc.k;
//   innerGc.y = innerGc.k;
//   outerPipe.VolumeFlow = outerPipe.V_flow;
//   outerPipe.dp = outerPipe.pressureDrop + 9.80665 * (outerPipe.medium.rho * outerPipe.h_g);
//   outerPipe.Q_flow = outerPipe.heatPort.Q_flow + outerPipe.Q_friction;
//   outerPipe.heatPort.T = outerPipe.T_q;
//   outerPipe.flowPort_b.H_flow = semiLinear(outerPipe.flowPort_b.m_flow,outerPipe.flowPort_b.h,outerPipe.h);
//   outerPipe.flowPort_a.H_flow = semiLinear(outerPipe.flowPort_a.m_flow,outerPipe.flowPort_a.h,outerPipe.h);
//   outerPipe.flowPort_a.H_flow + (outerPipe.flowPort_b.H_flow + outerPipe.Q_flow) = outerPipe.m * (outerPipe.medium.cv * der(outerPipe.T));
//   outerPipe.flowPort_a.m_flow + outerPipe.flowPort_b.m_flow = 0.0;
//   if outerPipe.VolumeFlow > outerPipe.V_flowLaminar then
//   outerPipe.pressureDrop = outerPipe.dpLaminar * outerPipe.VolumeFlow / outerPipe.V_flowLaminar + outerPipe.k * (outerPipe.VolumeFlow - outerPipe.V_flowLaminar) ^ 2.0;
//   elseif outerPipe.VolumeFlow < -outerPipe.V_flowLaminar then
//   outerPipe.pressureDrop = outerPipe.dpLaminar * outerPipe.VolumeFlow / outerPipe.V_flowLaminar - outerPipe.k * (outerPipe.VolumeFlow + outerPipe.V_flowLaminar) ^ 2.0;
//   else
//   outerPipe.pressureDrop = outerPipe.dpLaminar * outerPipe.VolumeFlow / outerPipe.V_flowLaminar;
//   end if;
//   outerPipe.Q_friction = outerPipe.frictionLoss * (outerPipe.VolumeFlow * outerPipe.pressureDrop);
//   innerPipe.VolumeFlow = innerPipe.V_flow;
//   innerPipe.dp = innerPipe.pressureDrop + 9.80665 * (innerPipe.medium.rho * innerPipe.h_g);
//   innerPipe.Q_flow = innerPipe.heatPort.Q_flow + innerPipe.Q_friction;
//   innerPipe.heatPort.T = innerPipe.T_q;
//   innerPipe.flowPort_b.H_flow = semiLinear(innerPipe.flowPort_b.m_flow,innerPipe.flowPort_b.h,innerPipe.h);
//   innerPipe.flowPort_a.H_flow = semiLinear(innerPipe.flowPort_a.m_flow,innerPipe.flowPort_a.h,innerPipe.h);
//   innerPipe.flowPort_a.H_flow + (innerPipe.flowPort_b.H_flow + innerPipe.Q_flow) = innerPipe.m * (innerPipe.medium.cv * der(innerPipe.T));
//   innerPipe.flowPort_a.m_flow + innerPipe.flowPort_b.m_flow = 0.0;
//   if innerPipe.VolumeFlow > innerPipe.V_flowLaminar then
//   innerPipe.pressureDrop = innerPipe.dpLaminar * innerPipe.VolumeFlow / innerPipe.V_flowLaminar + innerPipe.k * (innerPipe.VolumeFlow - innerPipe.V_flowLaminar) ^ 2.0;
//   elseif innerPipe.VolumeFlow < -innerPipe.V_flowLaminar then
//   innerPipe.pressureDrop = innerPipe.dpLaminar * innerPipe.VolumeFlow / innerPipe.V_flowLaminar - innerPipe.k * (innerPipe.VolumeFlow + innerPipe.V_flowLaminar) ^ 2.0;
//   else
//   innerPipe.pressureDrop = innerPipe.dpLaminar * innerPipe.VolumeFlow / innerPipe.V_flowLaminar;
//   end if;
//   innerPipe.Q_friction = innerPipe.frictionLoss * (innerPipe.VolumeFlow * innerPipe.pressureDrop);
//   innerConvection.dT = innerConvection.solid.T - innerConvection.fluid.T;
//   innerConvection.solid.Q_flow = innerConvection.Q_flow;
//   innerConvection.fluid.Q_flow = -innerConvection.Q_flow;
//   innerConvection.Q_flow = innerConvection.Gc * innerConvection.dT;
//   innerPump.Q_flow = 0.0;
//   innerPump.V_flow = innerPump.VolumeFlow;
//   innerPump.flowPort_a.m_flow + innerPump.flowPort_b.m_flow = 0.0;
//   innerPump.flowPort_a.H_flow + (innerPump.flowPort_b.H_flow + innerPump.Q_flow) = 0.0;
//   innerPump.flowPort_a.H_flow = semiLinear(innerPump.flowPort_a.m_flow,innerPump.flowPort_a.h,innerPump.h);
//   innerPump.flowPort_b.H_flow = semiLinear(innerPump.flowPort_b.m_flow,innerPump.flowPort_b.h,innerPump.h);
//   ThermalConductor1.Q_flow = ThermalConductor1.G * ThermalConductor1.dT;
//   ThermalConductor1.dT = ThermalConductor1.port_a.T - ThermalConductor1.port_b.T;
//   ThermalConductor1.port_a.Q_flow = ThermalConductor1.Q_flow;
//   ThermalConductor1.port_b.Q_flow = -ThermalConductor1.Q_flow;
//   outerConvection.dT = outerConvection.solid.T - outerConvection.fluid.T;
//   outerConvection.solid.Q_flow = outerConvection.Q_flow;
//   outerConvection.fluid.Q_flow = -outerConvection.Q_flow;
//   outerConvection.Q_flow = outerConvection.Gc * outerConvection.dT;
// assert(outerPipe.flowPort_b.medium.rho == Ambient2.flowPort.medium.rho,"automatically generated from connect");
// assert(outerPipe.flowPort_b.medium.cp == Ambient2.flowPort.medium.cp,"automatically generated from connect");
// assert(outerPipe.flowPort_b.medium.cv == Ambient2.flowPort.medium.cv,"automatically generated from connect");
// assert(outerPipe.flowPort_b.medium.lamda == Ambient2.flowPort.medium.lamda,"automatically generated from connect");
// assert(outerPipe.flowPort_b.medium.nue == Ambient2.flowPort.medium.nue,"automatically generated from connect");
// assert(outerPump.flowPort_b.medium.rho == outerPipe.flowPort_a.medium.rho,"automatically generated from connect");
// assert(outerPump.flowPort_b.medium.cp == outerPipe.flowPort_a.medium.cp,"automatically generated from connect");
// assert(outerPump.flowPort_b.medium.cv == outerPipe.flowPort_a.medium.cv,"automatically generated from connect");
// assert(outerPump.flowPort_b.medium.lamda == outerPipe.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(outerPump.flowPort_b.medium.nue == outerPipe.flowPort_a.medium.nue,"automatically generated from connect");
// assert(innerPipe.flowPort_b.medium.rho == AbsolutePressure1.flowPort.medium.rho,"automatically generated from connect");
// assert(innerPipe.flowPort_b.medium.cp == AbsolutePressure1.flowPort.medium.cp,"automatically generated from connect");
// assert(innerPipe.flowPort_b.medium.cv == AbsolutePressure1.flowPort.medium.cv,"automatically generated from connect");
// assert(innerPipe.flowPort_b.medium.lamda == AbsolutePressure1.flowPort.medium.lamda,"automatically generated from connect");
// assert(innerPipe.flowPort_b.medium.nue == AbsolutePressure1.flowPort.medium.nue,"automatically generated from connect");
// assert(AbsolutePressure1.flowPort.medium.rho == Pipe1.flowPort_a.medium.rho,"automatically generated from connect");
// assert(AbsolutePressure1.flowPort.medium.cp == Pipe1.flowPort_a.medium.cp,"automatically generated from connect");
// assert(AbsolutePressure1.flowPort.medium.cv == Pipe1.flowPort_a.medium.cv,"automatically generated from connect");
// assert(AbsolutePressure1.flowPort.medium.lamda == Pipe1.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(AbsolutePressure1.flowPort.medium.nue == Pipe1.flowPort_a.medium.nue,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.rho == outerPump.flowPort_a.medium.rho,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.cp == outerPump.flowPort_a.medium.cp,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.cv == outerPump.flowPort_a.medium.cv,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.lamda == outerPump.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.nue == outerPump.flowPort_a.medium.nue,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.rho == innerPump.flowPort_a.medium.rho,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.cp == innerPump.flowPort_a.medium.cp,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.cv == innerPump.flowPort_a.medium.cv,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.lamda == innerPump.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.nue == innerPump.flowPort_a.medium.nue,"automatically generated from connect");
// assert(innerPump.flowPort_b.medium.rho == innerPipe.flowPort_a.medium.rho,"automatically generated from connect");
// assert(innerPump.flowPort_b.medium.cp == innerPipe.flowPort_a.medium.cp,"automatically generated from connect");
// assert(innerPump.flowPort_b.medium.cv == innerPipe.flowPort_a.medium.cv,"automatically generated from connect");
// assert(innerPump.flowPort_b.medium.lamda == innerPipe.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(innerPump.flowPort_b.medium.nue == innerPipe.flowPort_a.medium.nue,"automatically generated from connect");
// outerGc.y = outerConvection.Gc;
//   outerConvection.solid.Q_flow + innerConvection.solid.Q_flow = 0.0;
// outerConvection.solid.T = innerConvection.solid.T;
//   outerPipe.heatPort.Q_flow + outerConvection.fluid.Q_flow = 0.0;
// outerPipe.heatPort.T = outerConvection.fluid.T;
//   Pipe1.heatPort.Q_flow + ThermalConductor1.port_b.Q_flow = 0.0;
// Pipe1.heatPort.T = ThermalConductor1.port_b.T;
//   HeatCapacitor1.port.Q_flow + (PrescribedHeatFlow1.port.Q_flow + ThermalConductor1.port_a.Q_flow) = 0.0;
// HeatCapacitor1.port.T = PrescribedHeatFlow1.port.T;
// PrescribedHeatFlow1.port.T = ThermalConductor1.port_a.T;
//   innerPump.flowPort_b.H_flow + innerPipe.flowPort_a.H_flow = 0.0;
// innerPump.flowPort_b.h = innerPipe.flowPort_a.h;
//   innerPump.flowPort_b.m_flow + innerPipe.flowPort_a.m_flow = 0.0;
// innerPump.flowPort_b.p = innerPipe.flowPort_a.p;
// innerVolumeFlow.y = innerPump.VolumeFlow;
//   Pipe1.flowPort_b.H_flow + innerPump.flowPort_a.H_flow = 0.0;
// Pipe1.flowPort_b.h = innerPump.flowPort_a.h;
//   Pipe1.flowPort_b.m_flow + innerPump.flowPort_a.m_flow = 0.0;
// Pipe1.flowPort_b.p = innerPump.flowPort_a.p;
//   Ambient1.flowPort.H_flow + outerPump.flowPort_a.H_flow = 0.0;
// Ambient1.flowPort.h = outerPump.flowPort_a.h;
//   Ambient1.flowPort.m_flow + outerPump.flowPort_a.m_flow = 0.0;
// Ambient1.flowPort.p = outerPump.flowPort_a.p;
//   innerPipe.flowPort_b.H_flow + (AbsolutePressure1.flowPort.H_flow + Pipe1.flowPort_a.H_flow) = 0.0;
// innerPipe.flowPort_b.h = AbsolutePressure1.flowPort.h;
// AbsolutePressure1.flowPort.h = Pipe1.flowPort_a.h;
//   innerPipe.flowPort_b.m_flow + (AbsolutePressure1.flowPort.m_flow + Pipe1.flowPort_a.m_flow) = 0.0;
// innerPipe.flowPort_b.p = AbsolutePressure1.flowPort.p;
// AbsolutePressure1.flowPort.p = Pipe1.flowPort_a.p;
// HeatFlow.y = PrescribedHeatFlow1.Q_flow;
// outerVolumeFlow.y = outerPump.VolumeFlow;
//   outerPump.flowPort_b.H_flow + outerPipe.flowPort_a.H_flow = 0.0;
// outerPump.flowPort_b.h = outerPipe.flowPort_a.h;
//   outerPump.flowPort_b.m_flow + outerPipe.flowPort_a.m_flow = 0.0;
// outerPump.flowPort_b.p = outerPipe.flowPort_a.p;
//   outerPipe.flowPort_b.H_flow + Ambient2.flowPort.H_flow = 0.0;
// outerPipe.flowPort_b.h = Ambient2.flowPort.h;
//   outerPipe.flowPort_b.m_flow + Ambient2.flowPort.m_flow = 0.0;
// outerPipe.flowPort_b.p = Ambient2.flowPort.p;
//   innerConvection.fluid.Q_flow + innerPipe.heatPort.Q_flow = 0.0;
// innerConvection.fluid.T = innerPipe.heatPort.T;
// innerGc.y = innerConvection.Gc;
// end Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling;
// "
// ""
// endResult
