//name:         NandGatee
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadModel(Modelica,{"2.2.1"});
instantiateModel(Modelica.Electrical.Analog.Examples.NandGate);
getErrorString();
// Result:
// true
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// class Modelica.Electrical.Analog.Examples.NandGate
//   Real Gnd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Gnd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Gnd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Gnd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Gnd5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Gnd5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real Nand.TP1.W(quantity = \"Length\", unit = \"m\") = 6.5e-06 \"Width\";
//   parameter Real Nand.TP1.L(quantity = \"Length\", unit = \"m\") = 3.1e-06 \"Length\";
//   parameter Real Nand.TP1.Beta(quantity = \"Transconductance\", unit = \"A/(V*V)\") = 1.05e-05 \"Transconductance parameter\";
//   parameter Real Nand.TP1.Vt(quantity = \"ElectricPotential\", unit = \"V\") = -1.0 \"Zero bias threshold voltage\";
//   parameter Real Nand.TP1.K2 = 0.41 \"Bulk threshold parameter\";
//   parameter Real Nand.TP1.K5 = 0.8385 \"Reduction of pinch-off region\";
//   parameter Real Nand.TP1.dW(quantity = \"Length\", unit = \"m\") = -2.5e-06 \"Narrowing of channel\";
//   parameter Real Nand.TP1.dL(quantity = \"Length\", unit = \"m\") = -2.1e-06 \"Shortening of channel\";
//   parameter Real Nand.TP1.RDS(quantity = \"Resistance\", unit = \"Ohm\") = 10000000.0 \"Drain-Source-Resistance\";
//   Real Nand.TP1.D.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP1.D.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TP1.G.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP1.G.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TP1.S.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP1.S.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TP1.B.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP1.B.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected Real Nand.TP1.v;
//   protected Real Nand.TP1.uds;
//   protected Real Nand.TP1.ubs;
//   protected Real Nand.TP1.ugst;
//   protected Real Nand.TP1.ud;
//   protected Real Nand.TP1.us;
//   protected Real Nand.TP1.id;
//   protected Real Nand.TP1.gds;
//   parameter Real Nand.TP2.W(quantity = \"Length\", unit = \"m\") = 6.5e-06 \"Width\";
//   parameter Real Nand.TP2.L(quantity = \"Length\", unit = \"m\") = 3.1e-06 \"Length\";
//   parameter Real Nand.TP2.Beta(quantity = \"Transconductance\", unit = \"A/(V*V)\") = 1.05e-05 \"Transconductance parameter\";
//   parameter Real Nand.TP2.Vt(quantity = \"ElectricPotential\", unit = \"V\") = -1.0 \"Zero bias threshold voltage\";
//   parameter Real Nand.TP2.K2 = 0.41 \"Bulk threshold parameter\";
//   parameter Real Nand.TP2.K5 = 0.8385 \"Reduction of pinch-off region\";
//   parameter Real Nand.TP2.dW(quantity = \"Length\", unit = \"m\") = -2.5e-06 \"Narrowing of channel\";
//   parameter Real Nand.TP2.dL(quantity = \"Length\", unit = \"m\") = -2.1e-06 \"Shortening of channel\";
//   parameter Real Nand.TP2.RDS(quantity = \"Resistance\", unit = \"Ohm\") = 10000000.0 \"Drain-Source-Resistance\";
//   Real Nand.TP2.D.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP2.D.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TP2.G.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP2.G.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TP2.S.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP2.S.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TP2.B.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TP2.B.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected Real Nand.TP2.v;
//   protected Real Nand.TP2.uds;
//   protected Real Nand.TP2.ubs;
//   protected Real Nand.TP2.ugst;
//   protected Real Nand.TP2.ud;
//   protected Real Nand.TP2.us;
//   protected Real Nand.TP2.id;
//   protected Real Nand.TP2.gds;
//   parameter Real Nand.TN1.W(quantity = \"Length\", unit = \"m\") = 6.5e-06 \"Width\";
//   parameter Real Nand.TN1.L(quantity = \"Length\", unit = \"m\") = 3.1e-06 \"Length\";
//   parameter Real Nand.TN1.Beta(quantity = \"Transconductance\", unit = \"A/(V*V)\") = 4.1e-05 \"Transconductance parameter\";
//   parameter Real Nand.TN1.Vt(quantity = \"ElectricPotential\", unit = \"V\") = 0.8 \"Zero bias threshold voltage\";
//   parameter Real Nand.TN1.K2 = 1.144 \"Bulk threshold parameter\";
//   parameter Real Nand.TN1.K5 = 0.7311 \"Reduction of pinch-off region\";
//   parameter Real Nand.TN1.dW(quantity = \"Length\", unit = \"m\") = -2.5e-06 \"narrowing of channel\";
//   parameter Real Nand.TN1.dL(quantity = \"Length\", unit = \"m\") = -1.5e-06 \"shortening of channel\";
//   parameter Real Nand.TN1.RDS(quantity = \"Resistance\", unit = \"Ohm\") = 10000000.0 \"Drain-Source-Resistance\";
//   Real Nand.TN1.D.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN1.D.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TN1.G.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN1.G.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TN1.S.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN1.S.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TN1.B.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN1.B.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected Real Nand.TN1.v;
//   protected Real Nand.TN1.uds;
//   protected Real Nand.TN1.ubs;
//   protected Real Nand.TN1.ugst;
//   protected Real Nand.TN1.ud;
//   protected Real Nand.TN1.us;
//   protected Real Nand.TN1.id;
//   protected Real Nand.TN1.gds;
//   parameter Real Nand.TN2.W(quantity = \"Length\", unit = \"m\") = 6.5e-06 \"Width\";
//   parameter Real Nand.TN2.L(quantity = \"Length\", unit = \"m\") = 3.1e-06 \"Length\";
//   parameter Real Nand.TN2.Beta(quantity = \"Transconductance\", unit = \"A/(V*V)\") = 4.1e-05 \"Transconductance parameter\";
//   parameter Real Nand.TN2.Vt(quantity = \"ElectricPotential\", unit = \"V\") = 0.8 \"Zero bias threshold voltage\";
//   parameter Real Nand.TN2.K2 = 1.144 \"Bulk threshold parameter\";
//   parameter Real Nand.TN2.K5 = 0.7311 \"Reduction of pinch-off region\";
//   parameter Real Nand.TN2.dW(quantity = \"Length\", unit = \"m\") = -2.5e-06 \"narrowing of channel\";
//   parameter Real Nand.TN2.dL(quantity = \"Length\", unit = \"m\") = -1.5e-06 \"shortening of channel\";
//   parameter Real Nand.TN2.RDS(quantity = \"Resistance\", unit = \"Ohm\") = 10000000.0 \"Drain-Source-Resistance\";
//   Real Nand.TN2.D.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN2.D.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TN2.G.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN2.G.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TN2.S.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN2.S.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.TN2.B.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.TN2.B.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected Real Nand.TN2.v;
//   protected Real Nand.TN2.uds;
//   protected Real Nand.TN2.ubs;
//   protected Real Nand.TN2.ugst;
//   protected Real Nand.TN2.ud;
//   protected Real Nand.TN2.us;
//   protected Real Nand.TN2.id;
//   protected Real Nand.TN2.gds;
//   Real Nand.Gnd.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Gnd.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.Gnd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Gnd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.Gnd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Gnd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.Gnd6.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Gnd6.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.Gnd7.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Gnd7.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.Gnd8.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Gnd8.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.x1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.x1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.x2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.x2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.Vdd.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.Vdd.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.y.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.y.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.C4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real Nand.C4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real Nand.C4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.C4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.C4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.C4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real Nand.C4.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 4e-14 \"Capacitance\";
//   Real Nand.C7.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real Nand.C7.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real Nand.C7.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.C7.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Nand.C7.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Nand.C7.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real Nand.C7.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 4e-14 \"Capacitance\";
//   Real VIN1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real VIN1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real VIN1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real VIN1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real VIN1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real VIN1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real VIN1.offset(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offset\";
//   parameter Real VIN1.startTime(quantity = \"Time\", unit = \"s\") = 2e-08 \"Time offset\";
//   output Real VIN1.signalSource.y \"Connector of Real output signal\";
//   parameter Real VIN1.signalSource.amplitude = VIN1.V \"Amplitude of trapezoid\";
//   parameter Real VIN1.signalSource.rising(quantity = \"Time\", unit = \"s\", min = 0.0) = VIN1.rising \"Rising duration of trapezoid\";
//   parameter Real VIN1.signalSource.width(quantity = \"Time\", unit = \"s\", min = 0.0) = VIN1.width \"Width duration of trapezoid\";
//   parameter Real VIN1.signalSource.falling(quantity = \"Time\", unit = \"s\", min = 0.0) = VIN1.falling \"Falling duration of trapezoid\";
//   parameter Real VIN1.signalSource.period(quantity = \"Time\", unit = \"s\", min = 1e-60) = VIN1.period \"Time for one period\";
//   parameter Integer VIN1.signalSource.nperiod = VIN1.nperiod \"Number of periods (< 0 means infinite number of periods)\";
//   parameter Real VIN1.signalSource.offset = VIN1.offset \"Offset of output signal\";
//   parameter Real VIN1.signalSource.startTime(quantity = \"Time\", unit = \"s\") = VIN1.startTime \"Output = offset for time < startTime\";
//   protected Real VIN1.signalSource.T0(quantity = \"Time\", unit = \"s\", start = VIN1.signalSource.startTime) \"Start time of current period\";
//   protected Integer VIN1.signalSource.counter(start = VIN1.signalSource.nperiod) \"Period counter\";
//   protected Integer VIN1.signalSource.counter2(start = VIN1.signalSource.nperiod);
//   protected parameter Real VIN1.signalSource.T_rising(quantity = \"Time\", unit = \"s\") = VIN1.signalSource.rising \"End time of rising phase within one period\";
//   protected parameter Real VIN1.signalSource.T_width(quantity = \"Time\", unit = \"s\") = VIN1.signalSource.T_rising + VIN1.signalSource.width \"End time of width phase within one period\";
//   protected parameter Real VIN1.signalSource.T_falling(quantity = \"Time\", unit = \"s\") = VIN1.signalSource.T_width + VIN1.signalSource.falling \"End time of falling phase within one period\";
//   parameter Real VIN1.V(quantity = \"ElectricPotential\", unit = \"V\") = 3.5 \"Amplitude of trapezoid\";
//   parameter Real VIN1.rising(quantity = \"Time\", unit = \"s\", min = 0.0) = 1e-09 \"Rising duration of trapezoid\";
//   parameter Real VIN1.width(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.9e-08 \"Width duration of trapezoid\";
//   parameter Real VIN1.falling(quantity = \"Time\", unit = \"s\", min = 0.0) = 1e-09 \"Falling duration of trapezoid\";
//   parameter Real VIN1.period(quantity = \"Time\", unit = \"s\", min = 1e-60) = 4e-08 \"Time for one period\";
//   parameter Integer VIN1.nperiod = -1 \"Number of periods (< 0 means infinite number of periods)\";
//   Real VIN2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real VIN2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real VIN2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real VIN2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real VIN2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real VIN2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real VIN2.offset(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offset\";
//   parameter Real VIN2.startTime(quantity = \"Time\", unit = \"s\") = 1e-08 \"Time offset\";
//   output Real VIN2.signalSource.y \"Connector of Real output signal\";
//   parameter Real VIN2.signalSource.amplitude = VIN2.V \"Amplitude of trapezoid\";
//   parameter Real VIN2.signalSource.rising(quantity = \"Time\", unit = \"s\", min = 0.0) = VIN2.rising \"Rising duration of trapezoid\";
//   parameter Real VIN2.signalSource.width(quantity = \"Time\", unit = \"s\", min = 0.0) = VIN2.width \"Width duration of trapezoid\";
//   parameter Real VIN2.signalSource.falling(quantity = \"Time\", unit = \"s\", min = 0.0) = VIN2.falling \"Falling duration of trapezoid\";
//   parameter Real VIN2.signalSource.period(quantity = \"Time\", unit = \"s\", min = 1e-60) = VIN2.period \"Time for one period\";
//   parameter Integer VIN2.signalSource.nperiod = VIN2.nperiod \"Number of periods (< 0 means infinite number of periods)\";
//   parameter Real VIN2.signalSource.offset = VIN2.offset \"Offset of output signal\";
//   parameter Real VIN2.signalSource.startTime(quantity = \"Time\", unit = \"s\") = VIN2.startTime \"Output = offset for time < startTime\";
//   protected Real VIN2.signalSource.T0(quantity = \"Time\", unit = \"s\", start = VIN2.signalSource.startTime) \"Start time of current period\";
//   protected Integer VIN2.signalSource.counter(start = VIN2.signalSource.nperiod) \"Period counter\";
//   protected Integer VIN2.signalSource.counter2(start = VIN2.signalSource.nperiod);
//   protected parameter Real VIN2.signalSource.T_rising(quantity = \"Time\", unit = \"s\") = VIN2.signalSource.rising \"End time of rising phase within one period\";
//   protected parameter Real VIN2.signalSource.T_width(quantity = \"Time\", unit = \"s\") = VIN2.signalSource.T_rising + VIN2.signalSource.width \"End time of width phase within one period\";
//   protected parameter Real VIN2.signalSource.T_falling(quantity = \"Time\", unit = \"s\") = VIN2.signalSource.T_width + VIN2.signalSource.falling \"End time of falling phase within one period\";
//   parameter Real VIN2.V(quantity = \"ElectricPotential\", unit = \"V\") = 3.5 \"Amplitude of trapezoid\";
//   parameter Real VIN2.rising(quantity = \"Time\", unit = \"s\", min = 0.0) = 1e-09 \"Rising duration of trapezoid\";
//   parameter Real VIN2.width(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.9e-08 \"Width duration of trapezoid\";
//   parameter Real VIN2.falling(quantity = \"Time\", unit = \"s\", min = 0.0) = 1e-09 \"Falling duration of trapezoid\";
//   parameter Real VIN2.period(quantity = \"Time\", unit = \"s\", min = 1e-60) = 4e-08 \"Time for one period\";
//   parameter Integer VIN2.nperiod = -1 \"Number of periods (< 0 means infinite number of periods)\";
//   Real VDD.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real VDD.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real VDD.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real VDD.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real VDD.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real VDD.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real VDD.offset(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offset\";
//   parameter Real VDD.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Time offset\";
//   output Real VDD.signalSource.y \"Connector of Real output signal\";
//   parameter Real VDD.signalSource.height = VDD.V \"Height of ramps\";
//   parameter Real VDD.signalSource.duration(min = 1e-60) = VDD.duration \"Durations of ramp\";
//   parameter Real VDD.signalSource.offset = VDD.offset \"Offset of output signal\";
//   parameter Real VDD.signalSource.startTime(quantity = \"Time\", unit = \"s\") = VDD.startTime \"Output = offset for time < startTime\";
//   parameter Real VDD.V(quantity = \"ElectricPotential\", unit = \"V\") = 5.0 \"Height of ramp\";
//   parameter Real VDD.duration(quantity = \"Time\", unit = \"s\", min = 1e-60) = 1e-09 \"Duration of ramp\";
// equation
//   Gnd1.p.v = 0.0;
//   Gnd4.p.v = 0.0;
//   Gnd5.p.v = 0.0;
//   Nand.TP1.gds = if Nand.TP1.RDS < 1e-20 and Nand.TP1.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TP1.RDS;
//   Nand.TP1.v = (Nand.TP1.Beta * (Nand.TP1.W + Nand.TP1.dW)) / (Nand.TP1.L + Nand.TP1.dL);
//   Nand.TP1.ud = if Nand.TP1.D.v > Nand.TP1.S.v then Nand.TP1.S.v else Nand.TP1.D.v;
//   Nand.TP1.us = if Nand.TP1.D.v > Nand.TP1.S.v then Nand.TP1.D.v else Nand.TP1.S.v;
//   Nand.TP1.uds = Nand.TP1.ud - Nand.TP1.us;
//   Nand.TP1.ubs = if Nand.TP1.B.v < Nand.TP1.us then 0.0 else Nand.TP1.B.v - Nand.TP1.us;
//   Nand.TP1.ugst = (Nand.TP1.G.v + (Nand.TP1.K2 * Nand.TP1.ubs + ((-Nand.TP1.Vt) - Nand.TP1.us))) * Nand.TP1.K5;
//   Nand.TP1.id = if Nand.TP1.ugst >= 0.0 then Nand.TP1.uds * Nand.TP1.gds else if Nand.TP1.ugst < Nand.TP1.uds then (-Nand.TP1.v) * (Nand.TP1.uds * (Nand.TP1.ugst + (-Nand.TP1.uds) / 2.0)) + Nand.TP1.uds * Nand.TP1.gds else ((-Nand.TP1.v) * Nand.TP1.ugst ^ 2.0) / 2.0 + Nand.TP1.uds * Nand.TP1.gds;
//   Nand.TP1.G.i = 0.0;
//   Nand.TP1.D.i = if Nand.TP1.D.v > Nand.TP1.S.v then -Nand.TP1.id else Nand.TP1.id;
//   Nand.TP1.S.i = if Nand.TP1.D.v > Nand.TP1.S.v then Nand.TP1.id else -Nand.TP1.id;
//   Nand.TP1.B.i = 0.0;
//   Nand.TP2.gds = if Nand.TP2.RDS < 1e-20 and Nand.TP2.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TP2.RDS;
//   Nand.TP2.v = (Nand.TP2.Beta * (Nand.TP2.W + Nand.TP2.dW)) / (Nand.TP2.L + Nand.TP2.dL);
//   Nand.TP2.ud = if Nand.TP2.D.v > Nand.TP2.S.v then Nand.TP2.S.v else Nand.TP2.D.v;
//   Nand.TP2.us = if Nand.TP2.D.v > Nand.TP2.S.v then Nand.TP2.D.v else Nand.TP2.S.v;
//   Nand.TP2.uds = Nand.TP2.ud - Nand.TP2.us;
//   Nand.TP2.ubs = if Nand.TP2.B.v < Nand.TP2.us then 0.0 else Nand.TP2.B.v - Nand.TP2.us;
//   Nand.TP2.ugst = (Nand.TP2.G.v + (Nand.TP2.K2 * Nand.TP2.ubs + ((-Nand.TP2.Vt) - Nand.TP2.us))) * Nand.TP2.K5;
//   Nand.TP2.id = if Nand.TP2.ugst >= 0.0 then Nand.TP2.uds * Nand.TP2.gds else if Nand.TP2.ugst < Nand.TP2.uds then (-Nand.TP2.v) * (Nand.TP2.uds * (Nand.TP2.ugst + (-Nand.TP2.uds) / 2.0)) + Nand.TP2.uds * Nand.TP2.gds else ((-Nand.TP2.v) * Nand.TP2.ugst ^ 2.0) / 2.0 + Nand.TP2.uds * Nand.TP2.gds;
//   Nand.TP2.G.i = 0.0;
//   Nand.TP2.D.i = if Nand.TP2.D.v > Nand.TP2.S.v then -Nand.TP2.id else Nand.TP2.id;
//   Nand.TP2.S.i = if Nand.TP2.D.v > Nand.TP2.S.v then Nand.TP2.id else -Nand.TP2.id;
//   Nand.TP2.B.i = 0.0;
//   Nand.TN1.gds = if Nand.TN1.RDS < 1e-20 and Nand.TN1.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TN1.RDS;
//   Nand.TN1.v = (Nand.TN1.Beta * (Nand.TN1.W + Nand.TN1.dW)) / (Nand.TN1.L + Nand.TN1.dL);
//   Nand.TN1.ud = if Nand.TN1.D.v < Nand.TN1.S.v then Nand.TN1.S.v else Nand.TN1.D.v;
//   Nand.TN1.us = if Nand.TN1.D.v < Nand.TN1.S.v then Nand.TN1.D.v else Nand.TN1.S.v;
//   Nand.TN1.uds = Nand.TN1.ud - Nand.TN1.us;
//   Nand.TN1.ubs = if Nand.TN1.B.v > Nand.TN1.us then 0.0 else Nand.TN1.B.v - Nand.TN1.us;
//   Nand.TN1.ugst = (Nand.TN1.G.v + (Nand.TN1.K2 * Nand.TN1.ubs + ((-Nand.TN1.Vt) - Nand.TN1.us))) * Nand.TN1.K5;
//   Nand.TN1.id = if Nand.TN1.ugst <= 0.0 then Nand.TN1.uds * Nand.TN1.gds else if Nand.TN1.ugst > Nand.TN1.uds then Nand.TN1.v * (Nand.TN1.uds * (Nand.TN1.ugst + (-Nand.TN1.uds) / 2.0)) + Nand.TN1.uds * Nand.TN1.gds else (Nand.TN1.v * Nand.TN1.ugst ^ 2.0) / 2.0 + Nand.TN1.uds * Nand.TN1.gds;
//   Nand.TN1.G.i = 0.0;
//   Nand.TN1.D.i = if Nand.TN1.D.v < Nand.TN1.S.v then -Nand.TN1.id else Nand.TN1.id;
//   Nand.TN1.S.i = if Nand.TN1.D.v < Nand.TN1.S.v then Nand.TN1.id else -Nand.TN1.id;
//   Nand.TN1.B.i = 0.0;
//   Nand.TN2.gds = if Nand.TN2.RDS < 1e-20 and Nand.TN2.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TN2.RDS;
//   Nand.TN2.v = (Nand.TN2.Beta * (Nand.TN2.W + Nand.TN2.dW)) / (Nand.TN2.L + Nand.TN2.dL);
//   Nand.TN2.ud = if Nand.TN2.D.v < Nand.TN2.S.v then Nand.TN2.S.v else Nand.TN2.D.v;
//   Nand.TN2.us = if Nand.TN2.D.v < Nand.TN2.S.v then Nand.TN2.D.v else Nand.TN2.S.v;
//   Nand.TN2.uds = Nand.TN2.ud - Nand.TN2.us;
//   Nand.TN2.ubs = if Nand.TN2.B.v > Nand.TN2.us then 0.0 else Nand.TN2.B.v - Nand.TN2.us;
//   Nand.TN2.ugst = (Nand.TN2.G.v + (Nand.TN2.K2 * Nand.TN2.ubs + ((-Nand.TN2.Vt) - Nand.TN2.us))) * Nand.TN2.K5;
//   Nand.TN2.id = if Nand.TN2.ugst <= 0.0 then Nand.TN2.uds * Nand.TN2.gds else if Nand.TN2.ugst > Nand.TN2.uds then Nand.TN2.v * (Nand.TN2.uds * (Nand.TN2.ugst + (-Nand.TN2.uds) / 2.0)) + Nand.TN2.uds * Nand.TN2.gds else (Nand.TN2.v * Nand.TN2.ugst ^ 2.0) / 2.0 + Nand.TN2.uds * Nand.TN2.gds;
//   Nand.TN2.G.i = 0.0;
//   Nand.TN2.D.i = if Nand.TN2.D.v < Nand.TN2.S.v then -Nand.TN2.id else Nand.TN2.id;
//   Nand.TN2.S.i = if Nand.TN2.D.v < Nand.TN2.S.v then Nand.TN2.id else -Nand.TN2.id;
//   Nand.TN2.B.i = 0.0;
//   Nand.Gnd.p.v = 0.0;
//   Nand.Gnd2.p.v = 0.0;
//   Nand.Gnd3.p.v = 0.0;
//   Nand.Gnd6.p.v = 0.0;
//   Nand.Gnd7.p.v = 0.0;
//   Nand.Gnd8.p.v = 0.0;
//   Nand.C4.i = Nand.C4.C * der(Nand.C4.v);
//   Nand.C4.v = Nand.C4.p.v - Nand.C4.n.v;
//   0.0 = Nand.C4.p.i + Nand.C4.n.i;
//   Nand.C4.i = Nand.C4.p.i;
//   Nand.C7.i = Nand.C7.C * der(Nand.C7.v);
//   Nand.C7.v = Nand.C7.p.v - Nand.C7.n.v;
//   0.0 = Nand.C7.p.i + Nand.C7.n.i;
//   Nand.C7.i = Nand.C7.p.i;
//   when pre(VIN1.signalSource.counter2) <> 0 and sample(VIN1.signalSource.startTime,VIN1.signalSource.period) then
//   VIN1.signalSource.T0 = time;
//   VIN1.signalSource.counter2 = pre(VIN1.signalSource.counter);
//   VIN1.signalSource.counter = pre(VIN1.signalSource.counter) - (if pre(VIN1.signalSource.counter) > 0 then 1 else 0);
//   end when;
//   VIN1.signalSource.y = VIN1.signalSource.offset + (if time < VIN1.signalSource.startTime or VIN1.signalSource.counter2 == 0 or time >= VIN1.signalSource.T0 + VIN1.signalSource.T_falling then 0.0 else if time < VIN1.signalSource.T0 + VIN1.signalSource.T_rising then ((time - VIN1.signalSource.T0) * VIN1.signalSource.amplitude) / VIN1.signalSource.T_rising else if time < VIN1.signalSource.T0 + VIN1.signalSource.T_width then VIN1.signalSource.amplitude else ((VIN1.signalSource.T0 + (VIN1.signalSource.T_falling - time)) * VIN1.signalSource.amplitude) / (VIN1.signalSource.T_falling - VIN1.signalSource.T_width));
//   VIN1.v = VIN1.signalSource.y;
//   VIN1.v = VIN1.p.v - VIN1.n.v;
//   0.0 = VIN1.p.i + VIN1.n.i;
//   VIN1.i = VIN1.p.i;
//   when pre(VIN2.signalSource.counter2) <> 0 and sample(VIN2.signalSource.startTime,VIN2.signalSource.period) then
//   VIN2.signalSource.T0 = time;
//   VIN2.signalSource.counter2 = pre(VIN2.signalSource.counter);
//   VIN2.signalSource.counter = pre(VIN2.signalSource.counter) - (if pre(VIN2.signalSource.counter) > 0 then 1 else 0);
//   end when;
//   VIN2.signalSource.y = VIN2.signalSource.offset + (if time < VIN2.signalSource.startTime or VIN2.signalSource.counter2 == 0 or time >= VIN2.signalSource.T0 + VIN2.signalSource.T_falling then 0.0 else if time < VIN2.signalSource.T0 + VIN2.signalSource.T_rising then ((time - VIN2.signalSource.T0) * VIN2.signalSource.amplitude) / VIN2.signalSource.T_rising else if time < VIN2.signalSource.T0 + VIN2.signalSource.T_width then VIN2.signalSource.amplitude else ((VIN2.signalSource.T0 + (VIN2.signalSource.T_falling - time)) * VIN2.signalSource.amplitude) / (VIN2.signalSource.T_falling - VIN2.signalSource.T_width));
//   VIN2.v = VIN2.signalSource.y;
//   VIN2.v = VIN2.p.v - VIN2.n.v;
//   0.0 = VIN2.p.i + VIN2.n.i;
//   VIN2.i = VIN2.p.i;
//   VDD.signalSource.y = VDD.signalSource.offset + (if time < VDD.signalSource.startTime then 0.0 else if time < VDD.signalSource.startTime + VDD.signalSource.duration then ((time - VDD.signalSource.startTime) * VDD.signalSource.height) / VDD.signalSource.duration else VDD.signalSource.height);
//   VDD.v = VDD.signalSource.y;
//   VDD.v = VDD.p.v - VDD.n.v;
//   0.0 = VDD.p.i + VDD.n.i;
//   VDD.i = VDD.p.i;
//   Gnd1.p.i + VDD.n.i = 0.0;
//   Gnd4.p.i + VIN1.n.i = 0.0;
//   Gnd5.p.i + VIN2.n.i = 0.0;
//   Nand.TP1.D.i + Nand.TP2.D.i + (-Nand.Vdd.i) = 0.0;
//   Nand.TP1.G.i + Nand.TN1.G.i + (-Nand.x2.i) = 0.0;
//   Nand.TP1.S.i + Nand.TP2.S.i + Nand.TN1.D.i + (-Nand.y.i) + Nand.C4.p.i = 0.0;
//   Nand.TP1.B.i + Nand.Gnd8.p.i = 0.0;
//   Nand.TP2.G.i + Nand.TN2.G.i + (-Nand.x1.i) = 0.0;
//   Nand.TP2.B.i + Nand.Gnd6.p.i = 0.0;
//   Nand.TN1.S.i + Nand.TN2.D.i + Nand.C7.p.i = 0.0;
//   Nand.TN1.B.i + Nand.Gnd7.p.i = 0.0;
//   Nand.TN2.S.i + Nand.TN2.B.i + Nand.Gnd.p.i = 0.0;
//   Nand.Gnd2.p.i + Nand.C4.n.i = 0.0;
//   Nand.Gnd3.p.i + Nand.C7.n.i = 0.0;
//   Nand.x1.i + VIN1.p.i = 0.0;
//   Nand.x2.i + VIN2.p.i = 0.0;
//   Nand.Vdd.i + VDD.p.i = 0.0;
//   Nand.y.i = 0.0;
//   Nand.TP1.D.v = Nand.TP2.D.v;
//   Nand.TP1.D.v = Nand.Vdd.v;
//   Nand.C4.p.v = Nand.TN1.D.v;
//   Nand.C4.p.v = Nand.TP1.S.v;
//   Nand.C4.p.v = Nand.TP2.S.v;
//   Nand.C4.p.v = Nand.y.v;
//   Nand.TN1.G.v = Nand.TP1.G.v;
//   Nand.TN1.G.v = Nand.x2.v;
//   Nand.TN2.G.v = Nand.TP2.G.v;
//   Nand.TN2.G.v = Nand.x1.v;
//   Nand.Gnd8.p.v = Nand.TP1.B.v;
//   Nand.Gnd7.p.v = Nand.TN1.B.v;
//   Nand.Gnd6.p.v = Nand.TP2.B.v;
//   Nand.Gnd.p.v = Nand.TN2.B.v;
//   Nand.Gnd.p.v = Nand.TN2.S.v;
//   Nand.C7.p.v = Nand.TN1.S.v;
//   Nand.C7.p.v = Nand.TN2.D.v;
//   Nand.C4.n.v = Nand.Gnd2.p.v;
//   Nand.C7.n.v = Nand.Gnd3.p.v;
//   Gnd4.p.v = VIN1.n.v;
//   Nand.x1.v = VIN1.p.v;
//   Gnd5.p.v = VIN2.n.v;
//   Nand.x2.v = VIN2.p.v;
//   Gnd1.p.v = VDD.n.v;
//   Nand.Vdd.v = VDD.p.v;
// end Modelica.Electrical.Analog.Examples.NandGate;
// "
// "Notification: Modelica language version set to 2.x due to loading of MSL 2.2.1.
// [NandGate.mo:54:3-54:128:writable] Warning: Component Nand has the same name as its type .Modelica.Electrical.Analog.Examples.Utilities.Nand.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// "
// endResult
