//name:         PID_Controller
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Blocks.Examples.PID_Controller);
getErrorString();
// Result:
// true
// "class Modelica.Blocks.Examples.PID_Controller
//   parameter Real driveAngle(quantity = "Angle", unit = "rad", displayUnit = "deg") = 1.57;
//   input Real PI.u_s "Connector of setpoint input signal";
//   output Real PI.y "Connector of actuator output signal";
//   input Real PI.u_m "Connector of measurement input signal";
//   output Real PI.controlError = PI.u_s - PI.u_m "Control error (set point - measurement)";
//   parameter Integer PI.controllerType(min = 1, max = 4) = 2 "Type of controller";
//   parameter Real PI.k(min = 0.0) = 100.0 "Gain of controller";
//   parameter Real PI.Ti(quantity = "Time", unit = "s", min = 1e-60) = 0.1 "Time constant of Integrator block";
//   parameter Real PI.Td(quantity = "Time", unit = "s", min = 0.0) = 0.1 "Time constant of Derivative block";
//   parameter Real PI.yMax = 12.0 "Upper limit of output";
//   parameter Real PI.yMin = -PI.yMax "Lower limit of output";
//   parameter Real PI.wp(min = 0.0) = 1.0 "Set-point weight for Proportional block (0..1)";
//   parameter Real PI.wd(min = 0.0) = 0.0 "Set-point weight for Derivative block (0..1)";
//   parameter Real PI.Ni(min = 1e-13) = 0.1 "Ni*Ti is time constant of anti-windup compensation";
//   parameter Real PI.Nd(min = 1e-13) = 10.0 "The higher Nd, the more ideal the derivative block";
//   parameter Integer PI.initType(min = 1, max = 5) = 2 "Type of initialization";
//   parameter Boolean PI.limitsAtInit = false "= false, if limits are ignored during initializiation";
//   parameter Real PI.xi_start = 0.0 "Initial or guess value value for integrator output (= integrator state)";
//   parameter Real PI.xd_start = 0.0 "Initial or guess value for state of derivative block";
//   parameter Real PI.y_start = 0.0 "Initial value of output";
//   input Real PI.addP.u1 "Connector of Real input signal 1";
//   input Real PI.addP.u2 "Connector of Real input signal 2";
//   output Real PI.addP.y "Connector of Real output signal";
//   parameter Real PI.addP.k1 = PI.wp "Gain of upper input";
//   parameter Real PI.addP.k2 = -1.0 "Gain of lower input";
//   parameter Real PI.P.k = 1.0 "Gain value multiplied with input signal";
//   input Real PI.P.u "Input signal connector";
//   output Real PI.P.y "Output signal connector";
//   parameter Real PI.gainPID.k = PI.k "Gain value multiplied with input signal";
//   input Real PI.gainPID.u "Input signal connector";
//   output Real PI.gainPID.y "Output signal connector";
//   parameter Real PI.addPID.k1 = 1.0 "Gain of upper input";
//   parameter Real PI.addPID.k2 = 1.0 "Gain of middle input";
//   parameter Real PI.addPID.k3 = 1.0 "Gain of lower input";
//   input Real PI.addPID.u1 "Connector 1 of Real input signals";
//   input Real PI.addPID.u2 "Connector 2 of Real input signals";
//   input Real PI.addPID.u3 "Connector 3 of Real input signals";
//   output Real PI.addPID.y "Connector of Real output signals";
//   input Real PI.limiter.u "Connector of Real input signal";
//   output Real PI.limiter.y "Connector of Real output signal";
//   parameter Real PI.limiter.uMax = PI.yMax "Upper limits of input signals";
//   parameter Real PI.limiter.uMin = PI.yMin "Lower limits of input signals";
//   parameter Boolean PI.limiter.limitsAtInit = PI.limitsAtInit "= false, if limits are ignored during initializiation (i.e., y=u)";
//   protected parameter Boolean PI.with_I = PI.controllerType == 2 OR PI.controllerType == 4;
//   protected parameter Boolean PI.with_D = PI.controllerType == 3 OR PI.controllerType == 4;
//   input Real PI.I.u "Connector of Real input signal";
//   output Real PI.I.y(start = PI.I.y_start) "Connector of Real output signal";
//   parameter Real PI.I.k = 1.0 / PI.Ti "Integrator gain";
//   parameter Integer PI.I.initType(min = 1, max = 4) = if PI.initType == 2 then 2 else if PI.initType == 3 OR PI.initType == 5 then 3 else 1 "Type of initialization (InitialState and InitialOutput are identical)";
//   parameter Real PI.I.y_start = PI.xi_start "Initial or guess value of output (= state)";
//   parameter Real PI.addI.k1 = 1.0 "Gain of upper input";
//   parameter Real PI.addI.k2 = -1.0 "Gain of middle input";
//   parameter Real PI.addI.k3 = 1.0 "Gain of lower input";
//   input Real PI.addI.u1 "Connector 1 of Real input signals";
//   input Real PI.addI.u2 "Connector 2 of Real input signals";
//   input Real PI.addI.u3 "Connector 3 of Real input signals";
//   output Real PI.addI.y "Connector of Real output signals";
//   input Real PI.addSat.u1 "Connector of Real input signal 1";
//   input Real PI.addSat.u2 "Connector of Real input signal 2";
//   output Real PI.addSat.y "Connector of Real output signal";
//   parameter Real PI.addSat.k1 = 1.0 "Gain of upper input";
//   parameter Real PI.addSat.k2 = -1.0 "Gain of lower input";
//   parameter Real PI.gainTrack.k = 1.0 / PI.Ni / PI.k "Gain value multiplied with input signal";
//   input Real PI.gainTrack.u "Input signal connector";
//   output Real PI.gainTrack.y "Output signal connector";
//   output Real PI.Dzero.y "Connector of Real output signal";
//   parameter Real PI.Dzero.k = 0.0 "Constant output value";
//   Real inertia1.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = inertia1.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real inertia1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real inertia1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real inertia1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real inertia1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real inertia1.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.0 "Moment of inertia";
//   parameter Integer inertia1.initType(min = 1, max = 9) = 7 "Type of initialization (defines usage of start values below)";
//   parameter Real inertia1.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real inertia1.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real inertia1.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer inertia1.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real inertia1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = inertia1.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real inertia1.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   input Real torque.tau(quantity = "Torque", unit = "N.m") "Torque driving the flange (a positive value accelerates the flange)";
//   Real torque.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real torque.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real torque.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real torque.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real spring.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = spring.phi_rel_start, StateSelect = StateSelect.prefer) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
//   Real spring.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
//   Real spring.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real spring.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real spring.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real spring.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real spring.c(unit = "N.m/rad", min = 0.0) = 10000.0 "Spring constant";
//   parameter Real spring.phi_rel0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Unstretched spring angle";
//   parameter Real spring.d(unit = "N.m.s/rad", min = 0.0) = 100.0 "Damping constant";
//   parameter Integer spring.initType(min = 1, max = 5) = 2 "Type of initialization (defines usage of start values below)";
//   parameter Real spring.phi_rel_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of relative rotation angle phi_rel";
//   parameter Real spring.w_rel_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of relative angular velocity w_rel = der(phi_rel)";
//   parameter Integer spring.stateSelection(min = 1, max = 5) = 4 "Priority to use phi_rel and w_rel as states";
//   Real spring.w_rel(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = spring.w_rel_start, StateSelect = StateSelect.prefer) "Relative angular velocity between flange_b and flange_a";
//   Real inertia2.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = inertia2.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real inertia2.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real inertia2.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real inertia2.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real inertia2.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real inertia2.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 2.0 "Moment of inertia";
//   parameter Integer inertia2.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real inertia2.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real inertia2.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real inertia2.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer inertia2.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real inertia2.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = inertia2.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real inertia2.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   parameter Integer kinematicPTP.nout(min = 1) = 1 "Number of outputs";
//   output Real kinematicPTP.y[1] "Connector of Real output signals";
//   parameter Real kinematicPTP.deltaq[1] = driveAngle "Distance to move";
//   parameter Real kinematicPTP.qd_max[1](min = 1e-60) = 1.0 "Maximum velocities der(q)";
//   parameter Real kinematicPTP.qdd_max[1](min = 1e-60) = 1.0 "Maximum accelerations der(qd)";
//   parameter Real kinematicPTP.startTime(quantity = "Time", unit = "s") = 0.5 "Time instant at which movement starts";
//   protected parameter Real kinematicPTP.p_deltaq[1] = kinematicPTP.deltaq[1];
//   protected parameter Real kinematicPTP.p_qd_max[1] = kinematicPTP.qd_max[1];
//   protected parameter Real kinematicPTP.p_qdd_max[1] = kinematicPTP.qdd_max[1];
//   protected Real kinematicPTP.sd_max;
//   protected Real kinematicPTP.sdd_max;
//   protected Real kinematicPTP.sdd;
//   protected Real kinematicPTP.aux1[1];
//   protected Real kinematicPTP.aux2[1];
//   protected Real kinematicPTP.Ta1(quantity = "Time", unit = "s");
//   protected Real kinematicPTP.Ta2(quantity = "Time", unit = "s");
//   protected Real kinematicPTP.Tv(quantity = "Time", unit = "s");
//   protected Real kinematicPTP.Te(quantity = "Time", unit = "s");
//   protected Boolean kinematicPTP.noWphase;
//   input Real integrator.u "Connector of Real input signal";
//   output Real integrator.y(start = integrator.y_start) "Connector of Real output signal";
//   parameter Real integrator.k = 1.0 "Integrator gain";
//   parameter Integer integrator.initType(min = 1, max = 4) = 3 "Type of initialization (InitialState and InitialOutput are identical)";
//   parameter Real integrator.y_start = 0.0 "Initial or guess value of output (= state)";
//   Real speedSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real speedSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real speedSensor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Absolute angular velocity of flange";
//   Real loadTorque.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(loadTorque.flange.phi) "Angular velocity at flange";
//   Real loadTorque.tau(quantity = "Torque", unit = "N.m") = loadTorque.flange.tau "accelerating torque acting at flange";
//   Real loadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadTorque.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorque.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadTorque.tau_constant(quantity = "Torque", unit = "N.m") = 10.0 "constant torque (if negative, torque is acting as load)";
// initial equation
//   der(PI.I.y) = 0.0;
//   inertia1.phi = inertia1.phi_start;
//   inertia1.a = inertia1.a_start;
//   der(spring.phi_rel) = 0.0;
//   der(spring.w_rel) = 0.0;
//   integrator.y = integrator.y_start;
// equation
//   PI.addP.y = PI.addP.k1 * PI.addP.u1 + PI.addP.k2 * PI.addP.u2;
//   PI.P.y = PI.P.k * PI.P.u;
//   PI.gainPID.y = PI.gainPID.k * PI.gainPID.u;
//   PI.addPID.y = PI.addPID.k1 * PI.addPID.u1 + (PI.addPID.k2 * PI.addPID.u2 + PI.addPID.k3 * PI.addPID.u3);
//   assert(PI.limiter.uMax >= PI.limiter.uMin,"Limiter: Limits must be consistent. However, uMax (=" + String(PI.limiter.uMax,0,true,6) + ") < uMin (=" + String(PI.limiter.uMin,0,true,6) + ")");
//   if initial() AND  NOT PI.limiter.limitsAtInit then
//   PI.limiter.y = PI.limiter.u;
//   assert(PI.limiter.u >= PI.limiter.uMin - 0.01 * abs(PI.limiter.uMin) AND PI.limiter.u <= PI.limiter.uMax + 0.01 * abs(PI.limiter.uMax),"Limiter: During initialization the limits have been ignored.\n" + "However, the result is that the input u is not within the required limits:\n" + "  u = " + String(PI.limiter.u,0,true,6) + ", uMin = " + String(PI.limiter.uMin,0,true,6) + ", uMax = " + String(PI.limiter.uMax,0,true,6));
//   else
//   PI.limiter.y = if PI.limiter.u > PI.limiter.uMax then PI.limiter.uMax else if PI.limiter.u < PI.limiter.uMin then PI.limiter.uMin else PI.limiter.u;
//   end if;
//   der(PI.I.y) = PI.I.k * PI.I.u;
//   PI.addI.y = PI.addI.k1 * PI.addI.u1 + (PI.addI.k2 * PI.addI.u2 + PI.addI.k3 * PI.addI.u3);
//   PI.addSat.y = PI.addSat.k1 * PI.addSat.u1 + PI.addSat.k2 * PI.addSat.u2;
//   PI.gainTrack.y = PI.gainTrack.k * PI.gainTrack.u;
//   PI.Dzero.y = PI.Dzero.k;
//   assert(PI.yMax >= PI.yMin,"LimPID: Limits must be consistent. However, yMax (=" + String(PI.yMax,0,true,6) + ") < yMin (=" + String(PI.yMin,0,true,6) + ")");
//   assert(PI.limitsAtInit OR  NOT PI.limitsAtInit AND PI.y >= PI.yMin AND PI.y <= PI.yMax,"LimPID: During initialization the limits have been switched off.\n" + "After initialization, the output y (=" + String(PI.y,0,true,6) + ") is outside of the limits of yMin (=" + String(PI.yMin,0,true,6) + ") and yMax (=" + String(PI.yMax,0,true,6) + ")");
//   inertia1.w = der(inertia1.phi);
//   inertia1.a = der(inertia1.w);
//   inertia1.J * inertia1.a = inertia1.flange_a.tau + inertia1.flange_b.tau;
//   inertia1.flange_a.phi = inertia1.phi;
//   inertia1.flange_b.phi = inertia1.phi;
//   torque.flange_b.tau = -torque.tau;
//   torque.bearing.phi = 0.0;
//   spring.w_rel = der(spring.phi_rel);
//   spring.tau = spring.c * (spring.phi_rel - spring.phi_rel0) + spring.d * spring.w_rel;
//   spring.phi_rel = spring.flange_b.phi - spring.flange_a.phi;
//   spring.flange_b.tau = spring.tau;
//   spring.flange_a.tau = -spring.tau;
//   inertia2.w = der(inertia2.phi);
//   inertia2.a = der(inertia2.w);
//   inertia2.J * inertia2.a = inertia2.flange_a.tau + inertia2.flange_b.tau;
//   inertia2.flange_a.phi = inertia2.phi;
//   inertia2.flange_b.phi = inertia2.phi;
//   kinematicPTP.aux1[1] = kinematicPTP.p_deltaq[1] / kinematicPTP.p_qd_max[1];
//   kinematicPTP.aux2[1] = kinematicPTP.p_deltaq[1] / kinematicPTP.p_qdd_max[1];
//   kinematicPTP.sd_max = 1.0 / max({abs(kinematicPTP.aux1[1])});
//   kinematicPTP.sdd_max = 1.0 / max({abs(kinematicPTP.aux2[1])});
//   kinematicPTP.Ta1 = sqrt(1.0 / kinematicPTP.sdd_max);
//   kinematicPTP.Ta2 = kinematicPTP.sd_max / kinematicPTP.sdd_max;
//   kinematicPTP.noWphase = kinematicPTP.Ta2 >= kinematicPTP.Ta1;
//   kinematicPTP.Tv = if kinematicPTP.noWphase then kinematicPTP.Ta1 else 1.0 / kinematicPTP.sd_max;
//   kinematicPTP.Te = if kinematicPTP.noWphase then 2.0 * kinematicPTP.Ta1 else kinematicPTP.Tv + kinematicPTP.Ta2;
//   kinematicPTP.sdd = if time < kinematicPTP.startTime then 0.0 else if kinematicPTP.noWphase then if time < kinematicPTP.Ta1 + kinematicPTP.startTime then kinematicPTP.sdd_max else if time < kinematicPTP.Te + kinematicPTP.startTime then -kinematicPTP.sdd_max else 0.0 else if time < kinematicPTP.Ta2 + kinematicPTP.startTime then kinematicPTP.sdd_max else if time < kinematicPTP.Tv + kinematicPTP.startTime then 0.0 else if time < kinematicPTP.Te + kinematicPTP.startTime then -kinematicPTP.sdd_max else 0.0;
//   kinematicPTP.y[1] = kinematicPTP.sdd * kinematicPTP.p_deltaq[1];
//   der(integrator.y) = integrator.k * integrator.u;
//   speedSensor.w = der(speedSensor.flange_a.phi);
//   0.0 = speedSensor.flange_a.tau;
//   loadTorque.tau = -loadTorque.tau_constant;
//   loadTorque.bearing.phi = 0.0;
//   spring.flange_b.tau + inertia2.flange_a.tau = 0.0;
//   inertia2.flange_a.phi = spring.flange_b.phi;
//   speedSensor.flange_a.tau + (inertia1.flange_b.tau + spring.flange_a.tau) = 0.0;
//   inertia1.flange_b.phi = speedSensor.flange_a.phi;
//   inertia1.flange_b.phi = spring.flange_a.phi;
//   torque.flange_b.tau + inertia1.flange_a.tau = 0.0;
//   inertia1.flange_a.phi = torque.flange_b.phi;
//   integrator.u = kinematicPTP.y[1];
//   loadTorque.flange.tau + inertia2.flange_b.tau = 0.0;
//   inertia2.flange_b.phi = loadTorque.flange.phi;
//   PI.y = torque.tau;
//   PI.u_m = speedSensor.w;
//   PI.u_s = integrator.y;
//   loadTorque.bearing.tau = 0.0;
//   torque.bearing.tau = 0.0;
//   PI.P.u = PI.addP.y;
//   PI.I.u = PI.addI.y;
//   PI.P.y = PI.addPID.u1;
//   PI.I.y = PI.addPID.u3;
//   PI.addPID.y = PI.gainPID.u;
//   PI.addSat.u2 = PI.gainPID.y;
//   PI.addSat.u2 = PI.limiter.u;
//   PI.addI.u3 = PI.gainTrack.y;
//   PI.Dzero.y = PI.addPID.u2;
//   PI.addI.u1 = PI.addP.u1;
//   PI.addI.u1 = PI.u_s;
//   PI.addSat.u1 = PI.limiter.y;
//   PI.addSat.u1 = PI.y;
//   PI.addI.u2 = PI.addP.u2;
//   PI.addI.u2 = PI.u_m;
//   PI.addSat.y = PI.gainTrack.u;
// end Modelica.Blocks.Examples.PID_Controller;
// "
// "[Sources.mo:252:5-252:102:writable] Warning: Variable kinematicPTP.qdd_max: Non-array modification '1e-60' for array component, possibly due to missing 'each'.
// 
// [Sources.mo:251:5-251:97:writable] Warning: Variable kinematicPTP.qd_max: Non-array modification '1e-60' for array component, possibly due to missing 'each'.
// 
// [Sources.mo:252:5-252:102:writable] Warning: Variable kinematicPTP.qdd_max: Non-array modification '1e-60' for array component, possibly due to missing 'each'.
// 
// "
// endResult
