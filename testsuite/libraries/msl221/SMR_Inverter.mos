//name:         SMR_Inverter
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadModel(Modelica,{"2.2.1"});
instantiateModel(Modelica.Electrical.Machines.Examples.SMR_Inverter);
getErrorString();
// Result:
// true
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = atan2(u1, u2);
// end Modelica.Math.atan2;
// 
// function Modelica.SIunits.Conversions.to_rpm \"Convert from radian per second to revolutions per minute\"
//   input Real rs(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") \"radian per second value\";
//   output Real rpm(quantity = \"AngularVelocity\", unit = \"rev/min\") \"revolutions per minute value\";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.SMR_Inverter
//   constant Integer m = 3 \"number of phases\";
//   parameter Real VNominal(quantity = \"ElectricPotential\", unit = \"V\") = 100.0 \"nominal RMS voltage per phase\";
//   parameter Real fNominal(quantity = \"Frequency\", unit = \"Hz\") = 50.0 \"nominal frequency\";
//   parameter Real f(quantity = \"Frequency\", unit = \"Hz\") = 50.0 \"actual frequency\";
//   parameter Real tRamp(quantity = \"Time\", unit = \"s\") = 1.0 \"frequency ramp\";
//   parameter Real T_Load(quantity = \"Torque\", unit = \"N.m\") = 46.0 \"nominal load torque\";
//   parameter Real tStep(quantity = \"Time\", unit = \"s\") = 1.2 \"time of load torque step\";
//   parameter Real J_Load(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.29 \"load's moment of inertia\";
//   parameter Real SMR1.J_Rotor(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.29 \"rotor's moment of inertia\";
//   output Real SMR1.phi_mechanical(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = SMR1.flange_a.phi \"mechanical angle of rotor against stator\";
//   output Real SMR1.w_mechanical(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = der(SMR1.phi_mechanical) \"mechanical angular velocity of rotor against stator\";
//   output Real SMR1.rpm_mechanical(quantity = \"AngularVelocity\", unit = \"rev/min\") = Modelica.SIunits.Conversions.to_rpm(SMR1.w_mechanical) \"mechanical speed of rotor against stator [rpm]\";
//   output Real SMR1.tau_electrical(quantity = \"Torque\", unit = \"N.m\") = SMR1.inertiaRotor.flange_a.tau \"electromagnetic torque\";
//   output Real SMR1.tau_shaft(quantity = \"Torque\", unit = \"N.m\") = -SMR1.flange_a.tau \"shaft torque\";
//   Real SMR1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real SMR1.fixedHousing.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real SMR1.fixedHousing.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.fixedHousing.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real SMR1.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   constant Real SMR1.pi = 3.14159265358979;
//   constant Integer SMR1.m = 3 \"number of phases\";
//   parameter Integer SMR1.p(min = 1) = 2 \"number of pole pairs (Integer)\";
//   constant Real SMR1.fNominal(quantity = \"Frequency\", unit = \"Hz\") = 50.0 \"nominal frequency\";
//   parameter Real SMR1.Rs(quantity = \"Resistance\", unit = \"Ohm\") = 0.03 \"|Nominal resistances and inductances|warm stator resistance per phase\";
//   parameter Boolean SMR1.DamperCage = true \"damper cage is present?\";
//   parameter Real SMR1.Rr(quantity = \"Resistance\", unit = \"Ohm\") = 0.04 \"warm damper resistance in d-axis\";
//   output Real SMR1.i_0_s(quantity = \"ElectricCurrent\", unit = \"A\", StateSelect = StateSelect.default) = SMR1.spacePhasorS.zero.i \"stator zero-sequence current\";
//   output Real SMR1.idq_ss[1](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.airGapR.i_ss[1] \"stator space phasor current / stator fixed frame\";
//   output Real SMR1.idq_ss[2](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.airGapR.i_ss[2] \"stator space phasor current / stator fixed frame\";
//   output Real SMR1.idq_sr[1](quantity = \"ElectricCurrent\", unit = \"A\", StateSelect = StateSelect.prefer) = SMR1.airGapR.i_sr[1] \"stator space phasor current / rotor fixed frame\";
//   output Real SMR1.idq_sr[2](quantity = \"ElectricCurrent\", unit = \"A\", StateSelect = StateSelect.prefer) = SMR1.airGapR.i_sr[2] \"stator space phasor current / rotor fixed frame\";
//   constant Integer SMR1.spacePhasorS.m = 3 \"number of phases\";
//   constant Real SMR1.spacePhasorS.pi = 3.14159265358979;
//   Real SMR1.spacePhasorS.zero.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.zero.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.ground.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.ground.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.gnd.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.gnd.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.spacePhasor.v_[1](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.spacePhasorS.spacePhasor.v_[2](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.spacePhasorS.spacePhasor.i_[1](quantity = \"ElectricCurrent\", unit = \"A\");
//   Real SMR1.spacePhasorS.spacePhasor.i_[2](quantity = \"ElectricCurrent\", unit = \"A\");
//   Real SMR1.spacePhasorS.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"instantaneous phase voltages\";
//   Real SMR1.spacePhasorS.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"instantaneous phase voltages\";
//   Real SMR1.spacePhasorS.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"instantaneous phase voltages\";
//   Real SMR1.spacePhasorS.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"instantaneous phase currents\";
//   Real SMR1.spacePhasorS.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"instantaneous phase currents\";
//   Real SMR1.spacePhasorS.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"instantaneous phase currents\";
//   parameter Integer SMR1.spacePhasorS.plug_p.m(min = 1) = 3 \"number of phases\";
//   Real SMR1.spacePhasorS.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer SMR1.spacePhasorS.plug_n.m(min = 1) = 3 \"number of phases\";
//   Real SMR1.spacePhasorS.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.spacePhasorS.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.spacePhasorS.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected parameter Real SMR1.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real SMR1.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real SMR1.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real SMR1.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real SMR1.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real SMR1.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real SMR1.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real SMR1.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real SMR1.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real SMR1.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real SMR1.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real SMR1.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   Real SMR1.inertiaRotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = SMR1.inertiaRotor.phi_start, StateSelect = StateSelect.default) \"Absolute rotation angle of component (= flange_a.phi = flange_b.phi)\";
//   Real SMR1.inertiaRotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.inertiaRotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real SMR1.inertiaRotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.inertiaRotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real SMR1.inertiaRotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = SMR1.J_Rotor \"Moment of inertia\";
//   parameter Integer SMR1.inertiaRotor.initType(min = 1, max = 9) = 1 \"Type of initialization (defines usage of start values below)\";
//   parameter Real SMR1.inertiaRotor.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial or guess value of rotor rotation angle phi\";
//   parameter Real SMR1.inertiaRotor.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = 0.0 \"Initial or guess value of angular velocity w = der(phi)\";
//   parameter Real SMR1.inertiaRotor.a_start(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial value of angular acceleration a = der(w)\";
//   parameter Integer SMR1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 \"Priority to use phi and w as states\";
//   Real SMR1.inertiaRotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\", start = SMR1.inertiaRotor.w_start, StateSelect = StateSelect.default) \"Absolute angular velocity of component\";
//   Real SMR1.inertiaRotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component\";
//   output Real SMR1.vs[1](quantity = \"ElectricPotential\", unit = \"V\") = SMR1.plug_sp.pin[1].v - SMR1.plug_sn.pin[1].v \"stator instantaneous voltages\";
//   output Real SMR1.vs[2](quantity = \"ElectricPotential\", unit = \"V\") = SMR1.plug_sp.pin[2].v - SMR1.plug_sn.pin[2].v \"stator instantaneous voltages\";
//   output Real SMR1.vs[3](quantity = \"ElectricPotential\", unit = \"V\") = SMR1.plug_sp.pin[3].v - SMR1.plug_sn.pin[3].v \"stator instantaneous voltages\";
//   output Real SMR1.is[1](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.plug_sp.pin[1].i \"stator instantaneous currents\";
//   output Real SMR1.is[2](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.plug_sp.pin[2].i \"stator instantaneous currents\";
//   output Real SMR1.is[3](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.plug_sp.pin[3].i \"stator instantaneous currents\";
//   parameter Integer SMR1.plug_sp.m(min = 1) = 3 \"number of phases\";
//   Real SMR1.plug_sp.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.plug_sp.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.plug_sp.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.plug_sp.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.plug_sp.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.plug_sp.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer SMR1.plug_sn.m(min = 1) = 3 \"number of phases\";
//   Real SMR1.plug_sn.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.plug_sn.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.plug_sn.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.plug_sn.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.plug_sn.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.plug_sn.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.Lssigma(quantity = \"Inductance\", unit = \"H\") = 0.000318309886183791 \"|Nominal resistances and inductances|stator stray inductance per phase\";
//   parameter Real SMR1.Lmd(quantity = \"Inductance\", unit = \"H\") = 0.00923098669932993 \"|Nominal resistances and inductances|main field inductance in d-axis\";
//   parameter Real SMR1.Lmq(quantity = \"Inductance\", unit = \"H\") = 0.00286478897565412 \"|Nominal resistances and inductances|main field inductance in q-axis\";
//   parameter Real SMR1.Lrsigma(quantity = \"Inductance\", unit = \"H\") = 0.000159154943091895 \"damper stray inductance in d-axis\";
//   output Real SMR1.idq_rs[1](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.airGapR.i_rs[1] \"rotor space phasor current / stator fixed frame\";
//   output Real SMR1.idq_rs[2](quantity = \"ElectricCurrent\", unit = \"A\") = SMR1.airGapR.i_rs[2] \"rotor space phasor current / stator fixed frame\";
//   output Real SMR1.idq_rr[1](quantity = \"ElectricCurrent\", unit = \"A\", StateSelect = StateSelect.prefer) = SMR1.airGapR.i_rr[1] \"rotor space phasor current / rotor fixed frame\";
//   output Real SMR1.idq_rr[2](quantity = \"ElectricCurrent\", unit = \"A\", StateSelect = StateSelect.prefer) = SMR1.airGapR.i_rr[2] \"rotor space phasor current / rotor fixed frame\";
//   parameter Real SMR1.Rrq(quantity = \"Resistance\", unit = \"Ohm\") = SMR1.Rr \"warm damper resistance in q-axis\";
//   constant Integer SMR1.airGapR.m = 3 \"number of phases\";
//   parameter Integer SMR1.airGapR.p(min = 1) = SMR1.p \"number of pole pairs\";
//   parameter Real SMR1.airGapR.Lmd(quantity = \"Inductance\", unit = \"H\") = SMR1.Lmd \"main field inductance d-axis\";
//   parameter Real SMR1.airGapR.Lmq(quantity = \"Inductance\", unit = \"H\") = SMR1.Lmq \"main field inductance q-axis\";
//   output Real SMR1.airGapR.tau_electrical(quantity = \"Torque\", unit = \"N.m\");
//   Real SMR1.airGapR.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotor displacement angle\";
//   Real SMR1.airGapR.i_ss[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Stator current space phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.i_ss[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Stator current space phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.i_sr[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Stator current space phasor with respect to the rotor fixed frame\";
//   Real SMR1.airGapR.i_sr[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Stator current space phasor with respect to the rotor fixed frame\";
//   Real SMR1.airGapR.i_rs[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Rotor current space phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.i_rs[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Rotor current space phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.i_rr[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Rotor current space phasor with respect to the rotor fixed frame\";
//   Real SMR1.airGapR.i_rr[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Rotor current space phasor with respect to the rotor fixed frame\";
//   Real SMR1.airGapR.i_mr[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetizing current space phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.i_mr[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetizing current space phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.psi_ms[1](quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetizing flux phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.psi_ms[2](quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetizing flux phasor with respect to the stator fixed frame\";
//   Real SMR1.airGapR.psi_mr[1](quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetizing flux phasor with respect to the rotor fixed frame\";
//   Real SMR1.airGapR.psi_mr[2](quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetizing flux phasor with respect to the rotor fixed frame\";
//   Real SMR1.airGapR.RotationMatrix[1,1] \"matrix of rotation from rotor to stator\";
//   Real SMR1.airGapR.RotationMatrix[1,2] \"matrix of rotation from rotor to stator\";
//   Real SMR1.airGapR.RotationMatrix[2,1] \"matrix of rotation from rotor to stator\";
//   Real SMR1.airGapR.RotationMatrix[2,2] \"matrix of rotation from rotor to stator\";
//   Real SMR1.airGapR.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.airGapR.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real SMR1.airGapR.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real SMR1.airGapR.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real SMR1.airGapR.spacePhasor_s.v_[1](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.airGapR.spacePhasor_s.v_[2](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.airGapR.spacePhasor_s.i_[1](quantity = \"ElectricCurrent\", unit = \"A\");
//   Real SMR1.airGapR.spacePhasor_s.i_[2](quantity = \"ElectricCurrent\", unit = \"A\");
//   Real SMR1.airGapR.spacePhasor_r.v_[1](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.airGapR.spacePhasor_r.v_[2](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.airGapR.spacePhasor_r.i_[1](quantity = \"ElectricCurrent\", unit = \"A\");
//   Real SMR1.airGapR.spacePhasor_r.i_[2](quantity = \"ElectricCurrent\", unit = \"A\");
//   protected parameter Real SMR1.airGapR.L[1,1](quantity = \"Inductance\", unit = \"H\") = SMR1.airGapR.Lmd \"inductance matrix\";
//   protected parameter Real SMR1.airGapR.L[1,2](quantity = \"Inductance\", unit = \"H\") = 0.0 \"inductance matrix\";
//   protected parameter Real SMR1.airGapR.L[2,1](quantity = \"Inductance\", unit = \"H\") = 0.0 \"inductance matrix\";
//   protected parameter Real SMR1.airGapR.L[2,2](quantity = \"Inductance\", unit = \"H\") = SMR1.airGapR.Lmq \"inductance matrix\";
//   parameter Real SMR1.Lrsigmaq(quantity = \"Inductance\", unit = \"H\") = SMR1.Lrsigma \"damper stray inductance in q-axis\";
//   parameter Real SMR1.damperCage.Lrsigma(quantity = \"Inductance\", unit = \"H\") = SMR1.Lrsigma \"stray inductance in d-axis per phase translated to stator\";
//   parameter Real SMR1.damperCage.Lrsigmaq(quantity = \"Inductance\", unit = \"H\") = SMR1.Lrsigmaq \"stray inductance in q-axis per phase translated to stator\";
//   parameter Real SMR1.damperCage.Rr(quantity = \"Resistance\", unit = \"Ohm\") = SMR1.Rr \"warm resistance in d-axis per phase translated to stator\";
//   parameter Real SMR1.damperCage.Rrq(quantity = \"Resistance\", unit = \"Ohm\") = SMR1.Rrq \"warm resistance in q-axis per phase translated to stator\";
//   Real SMR1.damperCage.spacePhasor_r.v_[1](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.damperCage.spacePhasor_r.v_[2](quantity = \"ElectricPotential\", unit = \"V\");
//   Real SMR1.damperCage.spacePhasor_r.i_[1](quantity = \"ElectricCurrent\", unit = \"A\");
//   Real SMR1.damperCage.spacePhasor_r.i_[2](quantity = \"ElectricCurrent\", unit = \"A\");
//   parameter Integer SMR1.rs.m(min = 1) = 3 \"number of phases\";
//   Real SMR1.rs.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real SMR1.rs.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real SMR1.rs.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real SMR1.rs.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real SMR1.rs.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real SMR1.rs.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer SMR1.rs.plug_p.m(min = 1) = SMR1.rs.m \"number of phases\";
//   Real SMR1.rs.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer SMR1.rs.plug_n.m(min = 1) = SMR1.rs.m \"number of phases\";
//   Real SMR1.rs.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.rs.R[1](quantity = \"Resistance\", unit = \"Ohm\") = SMR1.Rs \"Resistance\";
//   parameter Real SMR1.rs.R[2](quantity = \"Resistance\", unit = \"Ohm\") = SMR1.Rs \"Resistance\";
//   parameter Real SMR1.rs.R[3](quantity = \"Resistance\", unit = \"Ohm\") = SMR1.Rs \"Resistance\";
//   Real SMR1.rs.resistor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real SMR1.rs.resistor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SMR1.rs.resistor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.resistor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.resistor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.resistor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.rs.resistor[1].R(quantity = \"Resistance\", unit = \"Ohm\") = SMR1.rs.R[1] \"Resistance\";
//   Real SMR1.rs.resistor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real SMR1.rs.resistor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SMR1.rs.resistor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.resistor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.resistor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.resistor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.rs.resistor[2].R(quantity = \"Resistance\", unit = \"Ohm\") = SMR1.rs.R[2] \"Resistance\";
//   Real SMR1.rs.resistor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real SMR1.rs.resistor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SMR1.rs.resistor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.resistor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.rs.resistor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.rs.resistor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.rs.resistor[3].R(quantity = \"Resistance\", unit = \"Ohm\") = SMR1.rs.R[3] \"Resistance\";
//   parameter Integer SMR1.lssigma.m(min = 1) = 3 \"number of phases\";
//   Real SMR1.lssigma.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real SMR1.lssigma.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real SMR1.lssigma.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real SMR1.lssigma.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real SMR1.lssigma.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real SMR1.lssigma.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer SMR1.lssigma.plug_p.m(min = 1) = SMR1.lssigma.m \"number of phases\";
//   Real SMR1.lssigma.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer SMR1.lssigma.plug_n.m(min = 1) = SMR1.lssigma.m \"number of phases\";
//   Real SMR1.lssigma.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.lssigma.L[1](quantity = \"Inductance\", unit = \"H\") = SMR1.Lssigma \"Inductance\";
//   parameter Real SMR1.lssigma.L[2](quantity = \"Inductance\", unit = \"H\") = SMR1.Lssigma \"Inductance\";
//   parameter Real SMR1.lssigma.L[3](quantity = \"Inductance\", unit = \"H\") = SMR1.Lssigma \"Inductance\";
//   Real SMR1.lssigma.inductor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real SMR1.lssigma.inductor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SMR1.lssigma.inductor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.inductor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.inductor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.inductor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.lssigma.inductor[1].L(quantity = \"Inductance\", unit = \"H\") = SMR1.lssigma.L[1] \"Inductance\";
//   Real SMR1.lssigma.inductor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real SMR1.lssigma.inductor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SMR1.lssigma.inductor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.inductor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.inductor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.inductor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.lssigma.inductor[2].L(quantity = \"Inductance\", unit = \"H\") = SMR1.lssigma.L[2] \"Inductance\";
//   Real SMR1.lssigma.inductor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real SMR1.lssigma.inductor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SMR1.lssigma.inductor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.inductor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SMR1.lssigma.inductor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SMR1.lssigma.inductor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real SMR1.lssigma.inductor[3].L(quantity = \"Inductance\", unit = \"H\") = SMR1.lssigma.L[3] \"Inductance\";
//   constant Integer CurrentRMSsensor1.m(min = 1) = 3 \"number of phases\";
//   parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nout = 2 \"Number of outputs\";
//   constant Integer CurrentRMSsensor1.ToSpacePhasor1.m = 3 \"number of phases\";
//   constant Real CurrentRMSsensor1.ToSpacePhasor1.pi = 3.14159265358979;
//   output Real CurrentRMSsensor1.ToSpacePhasor1.zero;
//   output Real CurrentRMSsensor1.ToSpacePhasor1.y[1] \"Connector of Real output signals\";
//   output Real CurrentRMSsensor1.ToSpacePhasor1.y[2] \"Connector of Real output signals\";
//   parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nin = 3 \"Number of inputs\";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[1] \"Connector of Real input signals\";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[2] \"Connector of Real input signals\";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[3] \"Connector of Real input signals\";
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer CurrentRMSsensor1.ToPolar1.n = 2 \"Number of inputs (= number of outputs)\";
//   constant Real CurrentRMSsensor1.ToPolar1.small = 1e-60;
//   input Real CurrentRMSsensor1.ToPolar1.u[1] \"Connector of Real input signals\";
//   input Real CurrentRMSsensor1.ToPolar1.u[2] \"Connector of Real input signals\";
//   output Real CurrentRMSsensor1.ToPolar1.y[1] \"Connector of Real output signals\";
//   output Real CurrentRMSsensor1.ToPolar1.y[2] \"Connector of Real output signals\";
//   parameter Real CurrentRMSsensor1.Gain1.k = 0.707106781186547 \"Gain value multiplied with input signal\";
//   input Real CurrentRMSsensor1.Gain1.u \"Input signal connector\";
//   output Real CurrentRMSsensor1.Gain1.y \"Output signal connector\";
//   output Real CurrentRMSsensor1.I(quantity = \"ElectricCurrent\", unit = \"A\");
//   parameter Integer CurrentRMSsensor1.plug_p.m(min = 1) = 3 \"number of phases\";
//   Real CurrentRMSsensor1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer CurrentRMSsensor1.plug_n.m(min = 1) = 3 \"number of phases\";
//   Real CurrentRMSsensor1.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.m(min = 1) = 3 \"number of phases\";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_p.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m \"number of phases\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_n.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m \"number of phases\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"current in the branch from p to n as output signal\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"current in the branch from p to n as output signal\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"current in the branch from p to n as output signal\";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[1] \"current in the branch from p to n as output signal\";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[2] \"current in the branch from p to n as output signal\";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[3] \"current in the branch from p to n as output signal\";
//   constant Integer RotorAngle1.m = 3 \"number of phases\";
//   parameter Integer RotorAngle1.p(min = 1) = SMR1.p \"number of pole pairs\";
//   output Real RotorAngle1.rotorAngle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Integer RotorAngle1.ToSpacePhasorVS.nout = 2 \"Number of outputs\";
//   constant Integer RotorAngle1.ToSpacePhasorVS.m = 3 \"number of phases\";
//   constant Real RotorAngle1.ToSpacePhasorVS.pi = 3.14159265358979;
//   output Real RotorAngle1.ToSpacePhasorVS.zero;
//   output Real RotorAngle1.ToSpacePhasorVS.y[1] \"Connector of Real output signals\";
//   output Real RotorAngle1.ToSpacePhasorVS.y[2] \"Connector of Real output signals\";
//   parameter Integer RotorAngle1.ToSpacePhasorVS.nin = 3 \"Number of inputs\";
//   input Real RotorAngle1.ToSpacePhasorVS.u[1] \"Connector of Real input signals\";
//   input Real RotorAngle1.ToSpacePhasorVS.u[2] \"Connector of Real input signals\";
//   input Real RotorAngle1.ToSpacePhasorVS.u[3] \"Connector of Real input signals\";
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[3,2] = -0.866025403784438;
//   Real RotorAngle1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real RotorAngle1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real RotorAngle1.relativeAngleSensor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real RotorAngle1.relativeAngleSensor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real RotorAngle1.relativeAngleSensor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real RotorAngle1.relativeAngleSensor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real RotorAngle1.relativeAngleSensor.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Relative angle between two flanges (= flange_b.phi - flange_a.phi)\";
//   output Real RotorAngle1.constant_.y \"Connector of Real output signal\";
//   parameter Real RotorAngle1.constant_.k = 1.5707963267949 \"Constant output value\";
//   parameter Integer RotorAngle1.rotatorVS2R.n = 2 \"Number of inputs (= number of outputs)\";
//   input Real RotorAngle1.rotatorVS2R.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[1,1] = cos(-RotorAngle1.rotatorVS2R.angle);
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[1,2] = -sin(-RotorAngle1.rotatorVS2R.angle);
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[2,1] = sin(-RotorAngle1.rotatorVS2R.angle);
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[2,2] = cos(-RotorAngle1.rotatorVS2R.angle);
//   input Real RotorAngle1.rotatorVS2R.u[1] \"Connector of Real input signals\";
//   input Real RotorAngle1.rotatorVS2R.u[2] \"Connector of Real input signals\";
//   output Real RotorAngle1.rotatorVS2R.y[1] \"Connector of Real output signals\";
//   output Real RotorAngle1.rotatorVS2R.y[2] \"Connector of Real output signals\";
//   parameter Integer RotorAngle1.ToPolarVSR.n = 2 \"Number of inputs (= number of outputs)\";
//   constant Real RotorAngle1.ToPolarVSR.small = 1e-60;
//   input Real RotorAngle1.ToPolarVSR.u[1] \"Connector of Real input signals\";
//   input Real RotorAngle1.ToPolarVSR.u[2] \"Connector of Real input signals\";
//   output Real RotorAngle1.ToPolarVSR.y[1] \"Connector of Real output signals\";
//   output Real RotorAngle1.ToPolarVSR.y[2] \"Connector of Real output signals\";
//   parameter Integer RotorAngle1.deMultiplex2.n1 = 1 \"dimension of output signal connector 1\";
//   parameter Integer RotorAngle1.deMultiplex2.n2 = 1 \"dimension of output signal connector 2\";
//   output Real RotorAngle1.deMultiplex2.y1[1] \"Connector of Real output signals 1\";
//   input Real RotorAngle1.deMultiplex2.u[1] \"Connector of Real input signals\";
//   input Real RotorAngle1.deMultiplex2.u[2] \"Connector of Real input signals\";
//   output Real RotorAngle1.deMultiplex2.y2[1] \"Connector of Real output signals 2\";
//   parameter Real RotorAngle1.fixedHousing.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real RotorAngle1.fixedHousing.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real RotorAngle1.fixedHousing.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Integer RotorAngle1.plug_p.m(min = 1) = 3 \"number of phases\";
//   Real RotorAngle1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer RotorAngle1.plug_n.m(min = 1) = 3 \"number of phases\";
//   Real RotorAngle1.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer RotorAngle1.VoltageSensor1.m(min = 1) = 3 \"number of phases\";
//   parameter Integer RotorAngle1.VoltageSensor1.plug_p.m(min = 1) = RotorAngle1.VoltageSensor1.m \"number of phases\";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer RotorAngle1.VoltageSensor1.plug_n.m(min = 1) = RotorAngle1.VoltageSensor1.m \"number of phases\";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real RotorAngle1.VoltageSensor1.v[1] \"Voltage between pin p and n (= p.v - n.v) as output signal\";
//   output Real RotorAngle1.VoltageSensor1.v[2] \"Voltage between pin p and n (= p.v - n.v) as output signal\";
//   output Real RotorAngle1.VoltageSensor1.v[3] \"Voltage between pin p and n (= p.v - n.v) as output signal\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real RotorAngle1.VoltageSensor1.voltageSensor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as output signal\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real RotorAngle1.VoltageSensor1.voltageSensor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as output signal\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real RotorAngle1.VoltageSensor1.voltageSensor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as output signal\";
//   input Real RotorAngle1.add.u1 \"Connector of Real input signal 1\";
//   input Real RotorAngle1.add.u2 \"Connector of Real input signal 2\";
//   output Real RotorAngle1.add.y \"Connector of Real output signal\";
//   parameter Real RotorAngle1.add.k1 = Real(RotorAngle1.p) \"Gain of upper input\";
//   parameter Real RotorAngle1.add.k2 = 1.0 \"Gain of lower input\";
//   constant Integer TerminalBox1.m = 3 \"number of phases\";
//   parameter String TerminalBox1.StarDelta = \"Y\";
//   parameter Integer TerminalBox1.positiveMachinePlug.m(min = 1) = 3 \"number of phases\";
//   Real TerminalBox1.positiveMachinePlug.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.positiveMachinePlug.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.positiveMachinePlug.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.positiveMachinePlug.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.positiveMachinePlug.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.positiveMachinePlug.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer TerminalBox1.negativeMachinePlug.m(min = 1) = 3 \"number of phases\";
//   Real TerminalBox1.negativeMachinePlug.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.negativeMachinePlug.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.negativeMachinePlug.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.negativeMachinePlug.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.negativeMachinePlug.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.negativeMachinePlug.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer TerminalBox1.plugToGrid.m(min = 1) = 3 \"number of phases\";
//   Real TerminalBox1.plugToGrid.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.plugToGrid.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.plugToGrid.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.plugToGrid.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.plugToGrid.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.plugToGrid.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer TerminalBox1.star.m(min = 1) = 3 \"number of phases\";
//   Real TerminalBox1.star.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.star.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer TerminalBox1.star.plug_p.m(min = 1) = TerminalBox1.star.m \"number of phases\";
//   Real TerminalBox1.star.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.star.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.star.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.star.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.star.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.star.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real TerminalBox1.starpoint.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real TerminalBox1.starpoint.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Ground1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Ground1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer Star1.m(min = 1) = 3 \"number of phases\";
//   Real Star1.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Star1.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer Star1.plug_p.m(min = 1) = Star1.m \"number of phases\";
//   Real Star1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Star1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Star1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Star1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real Star1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real Star1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer SignalVoltage1.m(min = 1) = 3 \"number of phases\";
//   Real SignalVoltage1.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real SignalVoltage1.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real SignalVoltage1.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer SignalVoltage1.plug_p.m(min = 1) = SignalVoltage1.m \"number of phases\";
//   Real SignalVoltage1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer SignalVoltage1.plug_n.m(min = 1) = SignalVoltage1.m \"number of phases\";
//   Real SignalVoltage1.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real SignalVoltage1.v[1] \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   input Real SignalVoltage1.v[2] \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   input Real SignalVoltage1.v[3] \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real SignalVoltage1.signalVoltage[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SignalVoltage1.signalVoltage[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.signalVoltage[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.signalVoltage[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.signalVoltage[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real SignalVoltage1.signalVoltage[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real SignalVoltage1.signalVoltage[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SignalVoltage1.signalVoltage[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.signalVoltage[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.signalVoltage[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.signalVoltage[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real SignalVoltage1.signalVoltage[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real SignalVoltage1.signalVoltage[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real SignalVoltage1.signalVoltage[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.signalVoltage[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real SignalVoltage1.signalVoltage[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real SignalVoltage1.signalVoltage[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real SignalVoltage1.signalVoltage[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   input Real VfController1.u(quantity = \"Frequency\", unit = \"Hz\") \"Connector of Real input signal\";
//   constant Real VfController1.pi = 3.14159265358979;
//   parameter Integer VfController1.m = 3 \"number of phases\";
//   parameter Real VfController1.VNominal(quantity = \"ElectricPotential\", unit = \"V\") = VNominal \"nominal RMS voltage per phase\";
//   parameter Real VfController1.fNominal(quantity = \"Frequency\", unit = \"Hz\") = fNominal \"nominal frequency\";
//   parameter Real VfController1.BasePhase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"common phase shift\";
//   output Real VfController1.x(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true) \"Integrator state\";
//   output Real VfController1.amplitude(quantity = \"ElectricPotential\", unit = \"V\");
//   parameter Integer VfController1.nout = VfController1.m \"Number of outputs\";
//   output Real VfController1.y[1] \"Connector of Real output signals\";
//   output Real VfController1.y[2] \"Connector of Real output signals\";
//   output Real VfController1.y[3] \"Connector of Real output signals\";
//   output Real Ramp1.y \"Connector of Real output signal\";
//   parameter Real Ramp1.height = f \"Height of ramps\";
//   parameter Real Ramp1.duration(min = 1e-60) = tRamp \"Durations of ramp\";
//   parameter Real Ramp1.offset = 0.0 \"Offset of output signal\";
//   parameter Real Ramp1.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Output = offset for time < startTime\";
//   Real TorqueStep1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = der(TorqueStep1.flange.phi) \"Angular velocity at flange\";
//   Real TorqueStep1.tau(quantity = \"Torque\", unit = \"N.m\") = TorqueStep1.flange.tau \"accelerating torque acting at flange\";
//   Real TorqueStep1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real TorqueStep1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real TorqueStep1.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real TorqueStep1.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real TorqueStep1.stepTorque(quantity = \"Torque\", unit = \"N.m\") = -T_Load \"height of torque step (if negative, torque is acting as load)\";
//   parameter Real TorqueStep1.offsetTorque(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"offset of torque\";
//   parameter Real TorqueStep1.startTime(quantity = \"Time\", unit = \"s\") = tStep \"output = offset for time < startTime\";
//   Real LoadInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = LoadInertia.phi_start, StateSelect = StateSelect.default) \"Absolute rotation angle of component (= flange_a.phi = flange_b.phi)\";
//   Real LoadInertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real LoadInertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real LoadInertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real LoadInertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real LoadInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = J_Load \"Moment of inertia\";
//   parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 \"Type of initialization (defines usage of start values below)\";
//   parameter Real LoadInertia.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial or guess value of rotor rotation angle phi\";
//   parameter Real LoadInertia.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\") = 0.0 \"Initial or guess value of angular velocity w = der(phi)\";
//   parameter Real LoadInertia.a_start(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial value of angular acceleration a = der(w)\";
//   parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 \"Priority to use phi and w as states\";
//   Real LoadInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rev/min\", start = LoadInertia.w_start, StateSelect = StateSelect.default) \"Absolute angular velocity of component\";
//   Real LoadInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component\";
// equation
//   SMR1.fixedHousing.flange_b.phi = SMR1.fixedHousing.phi0;
//   SMR1.spacePhasorS.gnd.p.v = 0.0;
//   SMR1.spacePhasorS.v[1] = SMR1.spacePhasorS.plug_p.pin[1].v - SMR1.spacePhasorS.plug_n.pin[1].v;
//   SMR1.spacePhasorS.v[2] = SMR1.spacePhasorS.plug_p.pin[2].v - SMR1.spacePhasorS.plug_n.pin[2].v;
//   SMR1.spacePhasorS.v[3] = SMR1.spacePhasorS.plug_p.pin[3].v - SMR1.spacePhasorS.plug_n.pin[3].v;
//   SMR1.spacePhasorS.i[1] = SMR1.spacePhasorS.plug_p.pin[1].i;
//   SMR1.spacePhasorS.i[2] = SMR1.spacePhasorS.plug_p.pin[2].i;
//   SMR1.spacePhasorS.i[3] = SMR1.spacePhasorS.plug_p.pin[3].i;
//   SMR1.spacePhasorS.i[1] = -SMR1.spacePhasorS.plug_n.pin[1].i;
//   SMR1.spacePhasorS.i[2] = -SMR1.spacePhasorS.plug_n.pin[2].i;
//   SMR1.spacePhasorS.i[3] = -SMR1.spacePhasorS.plug_n.pin[3].i;
//   SMR1.spacePhasorS.zero.v = 0.333333333333333 * (SMR1.spacePhasorS.v[1] + (SMR1.spacePhasorS.v[2] + SMR1.spacePhasorS.v[3]));
//   SMR1.spacePhasorS.spacePhasor.v_[1] = SMR1.spacePhasorS.TransformationMatrix[1,1] * SMR1.spacePhasorS.v[1] + SMR1.spacePhasorS.TransformationMatrix[1,2] * SMR1.spacePhasorS.v[2] + SMR1.spacePhasorS.TransformationMatrix[1,3] * SMR1.spacePhasorS.v[3];
//   SMR1.spacePhasorS.spacePhasor.v_[2] = SMR1.spacePhasorS.TransformationMatrix[2,1] * SMR1.spacePhasorS.v[1] + SMR1.spacePhasorS.TransformationMatrix[2,2] * SMR1.spacePhasorS.v[2] + SMR1.spacePhasorS.TransformationMatrix[2,3] * SMR1.spacePhasorS.v[3];
//   -SMR1.spacePhasorS.zero.i = 0.333333333333333 * (SMR1.spacePhasorS.i[1] + (SMR1.spacePhasorS.i[2] + SMR1.spacePhasorS.i[3]));
//   -SMR1.spacePhasorS.spacePhasor.i_[1] = SMR1.spacePhasorS.TransformationMatrix[1,1] * SMR1.spacePhasorS.i[1] + SMR1.spacePhasorS.TransformationMatrix[1,2] * SMR1.spacePhasorS.i[2] + SMR1.spacePhasorS.TransformationMatrix[1,3] * SMR1.spacePhasorS.i[3];
//   -SMR1.spacePhasorS.spacePhasor.i_[2] = SMR1.spacePhasorS.TransformationMatrix[2,1] * SMR1.spacePhasorS.i[1] + SMR1.spacePhasorS.TransformationMatrix[2,2] * SMR1.spacePhasorS.i[2] + SMR1.spacePhasorS.TransformationMatrix[2,3] * SMR1.spacePhasorS.i[3];
//   SMR1.inertiaRotor.w = der(SMR1.inertiaRotor.phi);
//   SMR1.inertiaRotor.a = der(SMR1.inertiaRotor.w);
//   SMR1.inertiaRotor.J * SMR1.inertiaRotor.a = SMR1.inertiaRotor.flange_a.tau + SMR1.inertiaRotor.flange_b.tau;
//   SMR1.inertiaRotor.flange_a.phi = SMR1.inertiaRotor.phi;
//   SMR1.inertiaRotor.flange_b.phi = SMR1.inertiaRotor.phi;
//   SMR1.airGapR.gamma = Real(SMR1.airGapR.p) * (SMR1.airGapR.flange_a.phi - SMR1.airGapR.support.phi);
//   SMR1.airGapR.RotationMatrix[1,1] = cos(SMR1.airGapR.gamma);
//   SMR1.airGapR.RotationMatrix[1,2] = -sin(SMR1.airGapR.gamma);
//   SMR1.airGapR.RotationMatrix[2,1] = sin(SMR1.airGapR.gamma);
//   SMR1.airGapR.RotationMatrix[2,2] = cos(SMR1.airGapR.gamma);
//   SMR1.airGapR.i_ss[1] = SMR1.airGapR.spacePhasor_s.i_[1];
//   SMR1.airGapR.i_ss[2] = SMR1.airGapR.spacePhasor_s.i_[2];
//   SMR1.airGapR.i_ss[1] = SMR1.airGapR.RotationMatrix[1,1] * SMR1.airGapR.i_sr[1] + SMR1.airGapR.RotationMatrix[1,2] * SMR1.airGapR.i_sr[2];
//   SMR1.airGapR.i_ss[2] = SMR1.airGapR.RotationMatrix[2,1] * SMR1.airGapR.i_sr[1] + SMR1.airGapR.RotationMatrix[2,2] * SMR1.airGapR.i_sr[2];
//   SMR1.airGapR.i_rr[1] = SMR1.airGapR.spacePhasor_r.i_[1];
//   SMR1.airGapR.i_rr[2] = SMR1.airGapR.spacePhasor_r.i_[2];
//   SMR1.airGapR.i_rs[1] = SMR1.airGapR.RotationMatrix[1,1] * SMR1.airGapR.i_rr[1] + SMR1.airGapR.RotationMatrix[1,2] * SMR1.airGapR.i_rr[2];
//   SMR1.airGapR.i_rs[2] = SMR1.airGapR.RotationMatrix[2,1] * SMR1.airGapR.i_rr[1] + SMR1.airGapR.RotationMatrix[2,2] * SMR1.airGapR.i_rr[2];
//   SMR1.airGapR.i_mr[1] = SMR1.airGapR.i_sr[1] + SMR1.airGapR.i_rr[1];
//   SMR1.airGapR.i_mr[2] = SMR1.airGapR.i_sr[2] + SMR1.airGapR.i_rr[2];
//   SMR1.airGapR.psi_mr[1] = SMR1.airGapR.L[1,1] * SMR1.airGapR.i_mr[1] + SMR1.airGapR.L[1,2] * SMR1.airGapR.i_mr[2];
//   SMR1.airGapR.psi_mr[2] = SMR1.airGapR.L[2,1] * SMR1.airGapR.i_mr[1] + SMR1.airGapR.L[2,2] * SMR1.airGapR.i_mr[2];
//   SMR1.airGapR.psi_ms[1] = SMR1.airGapR.RotationMatrix[1,1] * SMR1.airGapR.psi_mr[1] + SMR1.airGapR.RotationMatrix[1,2] * SMR1.airGapR.psi_mr[2];
//   SMR1.airGapR.psi_ms[2] = SMR1.airGapR.RotationMatrix[2,1] * SMR1.airGapR.psi_mr[1] + SMR1.airGapR.RotationMatrix[2,2] * SMR1.airGapR.psi_mr[2];
//   SMR1.airGapR.spacePhasor_s.v_[1] = der(SMR1.airGapR.psi_ms[1]);
//   SMR1.airGapR.spacePhasor_s.v_[2] = der(SMR1.airGapR.psi_ms[2]);
//   SMR1.airGapR.spacePhasor_r.v_[1] = der(SMR1.airGapR.psi_mr[1]);
//   SMR1.airGapR.spacePhasor_r.v_[2] = der(SMR1.airGapR.psi_mr[2]);
//   SMR1.airGapR.tau_electrical = 1.5 * (Real(SMR1.airGapR.p) * (SMR1.airGapR.spacePhasor_s.i_[2] * SMR1.airGapR.psi_ms[1] - SMR1.airGapR.spacePhasor_s.i_[1] * SMR1.airGapR.psi_ms[2]));
//   SMR1.airGapR.flange_a.tau = -SMR1.airGapR.tau_electrical;
//   SMR1.airGapR.support.tau = SMR1.airGapR.tau_electrical;
//   SMR1.damperCage.spacePhasor_r.v_[1] = SMR1.damperCage.Rr * SMR1.damperCage.spacePhasor_r.i_[1] + SMR1.damperCage.Lrsigma * der(SMR1.damperCage.spacePhasor_r.i_[1]);
//   SMR1.damperCage.spacePhasor_r.v_[2] = SMR1.damperCage.Rrq * SMR1.damperCage.spacePhasor_r.i_[2] + SMR1.damperCage.Lrsigmaq * der(SMR1.damperCage.spacePhasor_r.i_[2]);
//   SMR1.rs.resistor[1].R * SMR1.rs.resistor[1].i = SMR1.rs.resistor[1].v;
//   SMR1.rs.resistor[1].v = SMR1.rs.resistor[1].p.v - SMR1.rs.resistor[1].n.v;
//   0.0 = SMR1.rs.resistor[1].p.i + SMR1.rs.resistor[1].n.i;
//   SMR1.rs.resistor[1].i = SMR1.rs.resistor[1].p.i;
//   SMR1.rs.resistor[2].R * SMR1.rs.resistor[2].i = SMR1.rs.resistor[2].v;
//   SMR1.rs.resistor[2].v = SMR1.rs.resistor[2].p.v - SMR1.rs.resistor[2].n.v;
//   0.0 = SMR1.rs.resistor[2].p.i + SMR1.rs.resistor[2].n.i;
//   SMR1.rs.resistor[2].i = SMR1.rs.resistor[2].p.i;
//   SMR1.rs.resistor[3].R * SMR1.rs.resistor[3].i = SMR1.rs.resistor[3].v;
//   SMR1.rs.resistor[3].v = SMR1.rs.resistor[3].p.v - SMR1.rs.resistor[3].n.v;
//   0.0 = SMR1.rs.resistor[3].p.i + SMR1.rs.resistor[3].n.i;
//   SMR1.rs.resistor[3].i = SMR1.rs.resistor[3].p.i;
//   SMR1.rs.v[1] = SMR1.rs.plug_p.pin[1].v - SMR1.rs.plug_n.pin[1].v;
//   SMR1.rs.v[2] = SMR1.rs.plug_p.pin[2].v - SMR1.rs.plug_n.pin[2].v;
//   SMR1.rs.v[3] = SMR1.rs.plug_p.pin[3].v - SMR1.rs.plug_n.pin[3].v;
//   SMR1.rs.i[1] = SMR1.rs.plug_p.pin[1].i;
//   SMR1.rs.i[2] = SMR1.rs.plug_p.pin[2].i;
//   SMR1.rs.i[3] = SMR1.rs.plug_p.pin[3].i;
//   SMR1.lssigma.inductor[1].L * der(SMR1.lssigma.inductor[1].i) = SMR1.lssigma.inductor[1].v;
//   SMR1.lssigma.inductor[1].v = SMR1.lssigma.inductor[1].p.v - SMR1.lssigma.inductor[1].n.v;
//   0.0 = SMR1.lssigma.inductor[1].p.i + SMR1.lssigma.inductor[1].n.i;
//   SMR1.lssigma.inductor[1].i = SMR1.lssigma.inductor[1].p.i;
//   SMR1.lssigma.inductor[2].L * der(SMR1.lssigma.inductor[2].i) = SMR1.lssigma.inductor[2].v;
//   SMR1.lssigma.inductor[2].v = SMR1.lssigma.inductor[2].p.v - SMR1.lssigma.inductor[2].n.v;
//   0.0 = SMR1.lssigma.inductor[2].p.i + SMR1.lssigma.inductor[2].n.i;
//   SMR1.lssigma.inductor[2].i = SMR1.lssigma.inductor[2].p.i;
//   SMR1.lssigma.inductor[3].L * der(SMR1.lssigma.inductor[3].i) = SMR1.lssigma.inductor[3].v;
//   SMR1.lssigma.inductor[3].v = SMR1.lssigma.inductor[3].p.v - SMR1.lssigma.inductor[3].n.v;
//   0.0 = SMR1.lssigma.inductor[3].p.i + SMR1.lssigma.inductor[3].n.i;
//   SMR1.lssigma.inductor[3].i = SMR1.lssigma.inductor[3].p.i;
//   SMR1.lssigma.v[1] = SMR1.lssigma.plug_p.pin[1].v - SMR1.lssigma.plug_n.pin[1].v;
//   SMR1.lssigma.v[2] = SMR1.lssigma.plug_p.pin[2].v - SMR1.lssigma.plug_n.pin[2].v;
//   SMR1.lssigma.v[3] = SMR1.lssigma.plug_p.pin[3].v - SMR1.lssigma.plug_n.pin[3].v;
//   SMR1.lssigma.i[1] = SMR1.lssigma.plug_p.pin[1].i;
//   SMR1.lssigma.i[2] = SMR1.lssigma.plug_p.pin[2].i;
//   SMR1.lssigma.i[3] = SMR1.lssigma.plug_p.pin[3].i;
//   assert(SMR1.spacePhasorS.plug_n.m == SMR1.plug_sn.m,\"automatically generated from connect\");
//   assert(SMR1.rs.plug_p.m == SMR1.plug_sp.m,\"automatically generated from connect\");
//   assert(SMR1.rs.plug_n.m == SMR1.lssigma.plug_p.m,\"automatically generated from connect\");
//   assert(SMR1.lssigma.plug_n.m == SMR1.spacePhasorS.plug_p.m,\"automatically generated from connect\");
//   CurrentRMSsensor1.ToSpacePhasor1.zero = 0.333333333333333 * (CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.u[3]));
//   CurrentRMSsensor1.ToSpacePhasor1.y[1] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3];
//   CurrentRMSsensor1.ToSpacePhasor1.y[2] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3];
//   CurrentRMSsensor1.ToPolar1.y[1] = sqrt(CurrentRMSsensor1.ToPolar1.u[1] ^ 2.0 + CurrentRMSsensor1.ToPolar1.u[2] ^ 2.0);
//   CurrentRMSsensor1.ToPolar1.y[2] = if noEvent(CurrentRMSsensor1.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(CurrentRMSsensor1.ToPolar1.u[2],CurrentRMSsensor1.ToPolar1.u[1]);
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.Gain1.k * CurrentRMSsensor1.Gain1.u;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   assert(CurrentRMSsensor1.CurrentSensor1.plug_n.m == CurrentRMSsensor1.plug_n.m,\"automatically generated from connect\");
//   assert(CurrentRMSsensor1.plug_p.m == CurrentRMSsensor1.CurrentSensor1.plug_p.m,\"automatically generated from connect\");
//   RotorAngle1.ToSpacePhasorVS.zero = 0.333333333333333 * (RotorAngle1.ToSpacePhasorVS.u[1] + (RotorAngle1.ToSpacePhasorVS.u[2] + RotorAngle1.ToSpacePhasorVS.u[3]));
//   RotorAngle1.ToSpacePhasorVS.y[1] = RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,1] * RotorAngle1.ToSpacePhasorVS.u[1] + RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,2] * RotorAngle1.ToSpacePhasorVS.u[2] + RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,3] * RotorAngle1.ToSpacePhasorVS.u[3];
//   RotorAngle1.ToSpacePhasorVS.y[2] = RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,1] * RotorAngle1.ToSpacePhasorVS.u[1] + RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,2] * RotorAngle1.ToSpacePhasorVS.u[2] + RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,3] * RotorAngle1.ToSpacePhasorVS.u[3];
//   RotorAngle1.relativeAngleSensor.phi_rel = RotorAngle1.relativeAngleSensor.flange_b.phi - RotorAngle1.relativeAngleSensor.flange_a.phi;
//   0.0 = RotorAngle1.relativeAngleSensor.flange_a.tau;
//   0.0 = RotorAngle1.relativeAngleSensor.flange_b.tau;
//   RotorAngle1.constant_.y = RotorAngle1.constant_.k;
//   RotorAngle1.rotatorVS2R.y[1] = RotorAngle1.rotatorVS2R.RotationMatrix[1,1] * RotorAngle1.rotatorVS2R.u[1] + RotorAngle1.rotatorVS2R.RotationMatrix[1,2] * RotorAngle1.rotatorVS2R.u[2];
//   RotorAngle1.rotatorVS2R.y[2] = RotorAngle1.rotatorVS2R.RotationMatrix[2,1] * RotorAngle1.rotatorVS2R.u[1] + RotorAngle1.rotatorVS2R.RotationMatrix[2,2] * RotorAngle1.rotatorVS2R.u[2];
//   RotorAngle1.ToPolarVSR.y[1] = sqrt(RotorAngle1.ToPolarVSR.u[1] ^ 2.0 + RotorAngle1.ToPolarVSR.u[2] ^ 2.0);
//   RotorAngle1.ToPolarVSR.y[2] = if noEvent(RotorAngle1.ToPolarVSR.y[1] <= 1e-60) then 0.0 else atan2(RotorAngle1.ToPolarVSR.u[2],RotorAngle1.ToPolarVSR.u[1]);
//   RotorAngle1.deMultiplex2.u[1] = RotorAngle1.deMultiplex2.y1[1];
//   RotorAngle1.deMultiplex2.u[2] = RotorAngle1.deMultiplex2.y2[1];
//   RotorAngle1.fixedHousing.flange_b.phi = RotorAngle1.fixedHousing.phi0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].v = RotorAngle1.VoltageSensor1.voltageSensor[1].p.v - RotorAngle1.VoltageSensor1.voltageSensor[1].n.v;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].v = RotorAngle1.VoltageSensor1.voltageSensor[2].p.v - RotorAngle1.VoltageSensor1.voltageSensor[2].n.v;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].v = RotorAngle1.VoltageSensor1.voltageSensor[3].p.v - RotorAngle1.VoltageSensor1.voltageSensor[3].n.v;
//   RotorAngle1.add.y = RotorAngle1.add.k1 * RotorAngle1.add.u1 + RotorAngle1.add.k2 * RotorAngle1.add.u2;
//   assert(RotorAngle1.plug_p.m == RotorAngle1.VoltageSensor1.plug_p.m,\"automatically generated from connect\");
//   assert(RotorAngle1.plug_n.m == RotorAngle1.VoltageSensor1.plug_n.m,\"automatically generated from connect\");
//   assert(TerminalBox1.positiveMachinePlug.m == TerminalBox1.plugToGrid.m,\"automatically generated from connect\");
//   assert(TerminalBox1.negativeMachinePlug.m == TerminalBox1.star.plug_p.m,\"automatically generated from connect\");
//   Ground1.p.v = 0.0;
//   SignalVoltage1.signalVoltage[1].v = SignalVoltage1.signalVoltage[1].p.v - SignalVoltage1.signalVoltage[1].n.v;
//   0.0 = SignalVoltage1.signalVoltage[1].p.i + SignalVoltage1.signalVoltage[1].n.i;
//   SignalVoltage1.signalVoltage[1].i = SignalVoltage1.signalVoltage[1].p.i;
//   SignalVoltage1.signalVoltage[2].v = SignalVoltage1.signalVoltage[2].p.v - SignalVoltage1.signalVoltage[2].n.v;
//   0.0 = SignalVoltage1.signalVoltage[2].p.i + SignalVoltage1.signalVoltage[2].n.i;
//   SignalVoltage1.signalVoltage[2].i = SignalVoltage1.signalVoltage[2].p.i;
//   SignalVoltage1.signalVoltage[3].v = SignalVoltage1.signalVoltage[3].p.v - SignalVoltage1.signalVoltage[3].n.v;
//   0.0 = SignalVoltage1.signalVoltage[3].p.i + SignalVoltage1.signalVoltage[3].n.i;
//   SignalVoltage1.signalVoltage[3].i = SignalVoltage1.signalVoltage[3].p.i;
//   SignalVoltage1.i[1] = SignalVoltage1.plug_p.pin[1].i;
//   SignalVoltage1.i[2] = SignalVoltage1.plug_p.pin[2].i;
//   SignalVoltage1.i[3] = SignalVoltage1.plug_p.pin[3].i;
//   VfController1.amplitude = 1.4142135623731 * (VfController1.VNominal * (if abs(VfController1.u) < VfController1.fNominal then abs(VfController1.u) / VfController1.fNominal else 1.0));
//   der(VfController1.x) = 6.28318530717959 * VfController1.u;
//   VfController1.y[1] = VfController1.amplitude * sin(VfController1.x + VfController1.BasePhase);
//   VfController1.y[2] = VfController1.amplitude * sin(VfController1.x + (VfController1.BasePhase + -6.28318530717959 / Real(VfController1.m)));
//   VfController1.y[3] = VfController1.amplitude * sin(VfController1.x + (VfController1.BasePhase + -12.5663706143592 / Real(VfController1.m)));
//   Ramp1.y = Ramp1.offset + (if time < Ramp1.startTime then 0.0 else if time < Ramp1.startTime + Ramp1.duration then ((time - Ramp1.startTime) * Ramp1.height) / Ramp1.duration else Ramp1.height);
//   TorqueStep1.tau = -TorqueStep1.offsetTorque - (if time < TorqueStep1.startTime then 0.0 else TorqueStep1.stepTorque);
//   TorqueStep1.bearing.phi = 0.0;
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   assert(TerminalBox1.plugToGrid.m == CurrentRMSsensor1.plug_n.m,\"automatically generated from connect\");
//   assert(TerminalBox1.negativeMachinePlug.m == SMR1.plug_sn.m,\"automatically generated from connect\");
//   assert(TerminalBox1.positiveMachinePlug.m == SMR1.plug_sp.m,\"automatically generated from connect\");
//   assert(SMR1.plug_sp.m == RotorAngle1.plug_p.m,\"automatically generated from connect\");
//   assert(SMR1.plug_sn.m == RotorAngle1.plug_n.m,\"automatically generated from connect\");
//   assert(SignalVoltage1.plug_n.m == Star1.plug_p.m,\"automatically generated from connect\");
//   assert(CurrentRMSsensor1.plug_p.m == SignalVoltage1.plug_p.m,\"automatically generated from connect\");
//   SMR1.flange_a.tau + RotorAngle1.flange.tau + LoadInertia.flange_a.tau = 0.0;
//   SMR1.fixedHousing.flange_b.tau + -SMR1.internalSupport.tau + SMR1.airGapR.support.tau = 0.0;
//   SMR1.internalSupport.tau = 0.0;
//   SMR1.spacePhasorS.zero.i + SMR1.spacePhasorS.ground.i = 0.0;
//   -SMR1.spacePhasorS.ground.i + SMR1.spacePhasorS.gnd.p.i = 0.0;
//   SMR1.spacePhasorS.spacePhasor.i_[1] + SMR1.airGapR.spacePhasor_s.i_[1] = 0.0;
//   SMR1.spacePhasorS.spacePhasor.i_[2] + SMR1.airGapR.spacePhasor_s.i_[2] = 0.0;
//   SMR1.spacePhasorS.plug_p.pin[1].i + SMR1.lssigma.plug_n.pin[1].i = 0.0;
//   SMR1.spacePhasorS.plug_p.pin[2].i + SMR1.lssigma.plug_n.pin[2].i = 0.0;
//   SMR1.spacePhasorS.plug_p.pin[3].i + SMR1.lssigma.plug_n.pin[3].i = 0.0;
//   SMR1.spacePhasorS.plug_n.pin[1].i + -SMR1.plug_sn.pin[1].i = 0.0;
//   SMR1.spacePhasorS.plug_n.pin[2].i + -SMR1.plug_sn.pin[2].i = 0.0;
//   SMR1.spacePhasorS.plug_n.pin[3].i + -SMR1.plug_sn.pin[3].i = 0.0;
//   SMR1.spacePhasorS.gnd.p.v = SMR1.spacePhasorS.ground.v;
//   SMR1.inertiaRotor.flange_a.tau + SMR1.airGapR.flange_a.tau = 0.0;
//   -SMR1.flange_a.tau + SMR1.inertiaRotor.flange_b.tau = 0.0;
//   SMR1.plug_sp.pin[1].i + RotorAngle1.plug_p.pin[1].i + TerminalBox1.positiveMachinePlug.pin[1].i = 0.0;
//   SMR1.plug_sp.pin[2].i + RotorAngle1.plug_p.pin[2].i + TerminalBox1.positiveMachinePlug.pin[2].i = 0.0;
//   SMR1.plug_sp.pin[3].i + RotorAngle1.plug_p.pin[3].i + TerminalBox1.positiveMachinePlug.pin[3].i = 0.0;
//   SMR1.plug_sn.pin[1].i + RotorAngle1.plug_n.pin[1].i + TerminalBox1.negativeMachinePlug.pin[1].i = 0.0;
//   SMR1.plug_sn.pin[2].i + RotorAngle1.plug_n.pin[2].i + TerminalBox1.negativeMachinePlug.pin[2].i = 0.0;
//   SMR1.plug_sn.pin[3].i + RotorAngle1.plug_n.pin[3].i + TerminalBox1.negativeMachinePlug.pin[3].i = 0.0;
//   SMR1.airGapR.spacePhasor_r.i_[1] + SMR1.damperCage.spacePhasor_r.i_[1] = 0.0;
//   SMR1.airGapR.spacePhasor_r.i_[2] + SMR1.damperCage.spacePhasor_r.i_[2] = 0.0;
//   -SMR1.plug_sp.pin[1].i + SMR1.rs.plug_p.pin[1].i = 0.0;
//   -SMR1.plug_sp.pin[2].i + SMR1.rs.plug_p.pin[2].i = 0.0;
//   -SMR1.plug_sp.pin[3].i + SMR1.rs.plug_p.pin[3].i = 0.0;
//   SMR1.rs.plug_n.pin[1].i + SMR1.lssigma.plug_p.pin[1].i = 0.0;
//   SMR1.rs.plug_n.pin[2].i + SMR1.lssigma.plug_p.pin[2].i = 0.0;
//   SMR1.rs.plug_n.pin[3].i + SMR1.lssigma.plug_p.pin[3].i = 0.0;
//   -SMR1.rs.plug_p.pin[1].i + SMR1.rs.resistor[1].p.i = 0.0;
//   -SMR1.rs.plug_n.pin[1].i + SMR1.rs.resistor[1].n.i = 0.0;
//   -SMR1.rs.plug_p.pin[2].i + SMR1.rs.resistor[2].p.i = 0.0;
//   -SMR1.rs.plug_n.pin[2].i + SMR1.rs.resistor[2].n.i = 0.0;
//   -SMR1.rs.plug_p.pin[3].i + SMR1.rs.resistor[3].p.i = 0.0;
//   -SMR1.rs.plug_n.pin[3].i + SMR1.rs.resistor[3].n.i = 0.0;
//   SMR1.rs.plug_n.pin[1].v = SMR1.rs.resistor[1].n.v;
//   SMR1.rs.plug_n.pin[2].v = SMR1.rs.resistor[2].n.v;
//   SMR1.rs.plug_n.pin[3].v = SMR1.rs.resistor[3].n.v;
//   SMR1.rs.plug_p.pin[1].v = SMR1.rs.resistor[1].p.v;
//   SMR1.rs.plug_p.pin[2].v = SMR1.rs.resistor[2].p.v;
//   SMR1.rs.plug_p.pin[3].v = SMR1.rs.resistor[3].p.v;
//   -SMR1.lssigma.plug_p.pin[1].i + SMR1.lssigma.inductor[1].p.i = 0.0;
//   -SMR1.lssigma.plug_n.pin[1].i + SMR1.lssigma.inductor[1].n.i = 0.0;
//   -SMR1.lssigma.plug_p.pin[2].i + SMR1.lssigma.inductor[2].p.i = 0.0;
//   -SMR1.lssigma.plug_n.pin[2].i + SMR1.lssigma.inductor[2].n.i = 0.0;
//   -SMR1.lssigma.plug_p.pin[3].i + SMR1.lssigma.inductor[3].p.i = 0.0;
//   -SMR1.lssigma.plug_n.pin[3].i + SMR1.lssigma.inductor[3].n.i = 0.0;
//   SMR1.lssigma.inductor[1].n.v = SMR1.lssigma.plug_n.pin[1].v;
//   SMR1.lssigma.inductor[2].n.v = SMR1.lssigma.plug_n.pin[2].v;
//   SMR1.lssigma.inductor[3].n.v = SMR1.lssigma.plug_n.pin[3].v;
//   SMR1.lssigma.inductor[1].p.v = SMR1.lssigma.plug_p.pin[1].v;
//   SMR1.lssigma.inductor[2].p.v = SMR1.lssigma.plug_p.pin[2].v;
//   SMR1.lssigma.inductor[3].p.v = SMR1.lssigma.plug_p.pin[3].v;
//   SMR1.airGapR.support.phi = SMR1.fixedHousing.flange_b.phi;
//   SMR1.airGapR.support.phi = SMR1.internalSupport.phi;
//   SMR1.airGapR.flange_a.phi = SMR1.inertiaRotor.flange_a.phi;
//   SMR1.plug_sn.pin[1].v = SMR1.spacePhasorS.plug_n.pin[1].v;
//   SMR1.plug_sn.pin[2].v = SMR1.spacePhasorS.plug_n.pin[2].v;
//   SMR1.plug_sn.pin[3].v = SMR1.spacePhasorS.plug_n.pin[3].v;
//   SMR1.plug_sp.pin[1].v = SMR1.rs.plug_p.pin[1].v;
//   SMR1.plug_sp.pin[2].v = SMR1.rs.plug_p.pin[2].v;
//   SMR1.plug_sp.pin[3].v = SMR1.rs.plug_p.pin[3].v;
//   SMR1.lssigma.plug_p.pin[1].v = SMR1.rs.plug_n.pin[1].v;
//   SMR1.lssigma.plug_p.pin[2].v = SMR1.rs.plug_n.pin[2].v;
//   SMR1.lssigma.plug_p.pin[3].v = SMR1.rs.plug_n.pin[3].v;
//   SMR1.lssigma.plug_n.pin[1].v = SMR1.spacePhasorS.plug_p.pin[1].v;
//   SMR1.lssigma.plug_n.pin[2].v = SMR1.spacePhasorS.plug_p.pin[2].v;
//   SMR1.lssigma.plug_n.pin[3].v = SMR1.spacePhasorS.plug_p.pin[3].v;
//   SMR1.spacePhasorS.ground.v = SMR1.spacePhasorS.zero.v;
//   SMR1.airGapR.spacePhasor_s.v_[2] = SMR1.spacePhasorS.spacePhasor.v_[2];
//   SMR1.airGapR.spacePhasor_s.v_[1] = SMR1.spacePhasorS.spacePhasor.v_[1];
//   SMR1.airGapR.spacePhasor_r.v_[2] = SMR1.damperCage.spacePhasor_r.v_[2];
//   SMR1.airGapR.spacePhasor_r.v_[1] = SMR1.damperCage.spacePhasor_r.v_[1];
//   SMR1.flange_a.phi = SMR1.inertiaRotor.flange_b.phi;
//   CurrentRMSsensor1.plug_p.pin[1].i + SignalVoltage1.plug_p.pin[1].i = 0.0;
//   CurrentRMSsensor1.plug_p.pin[2].i + SignalVoltage1.plug_p.pin[2].i = 0.0;
//   CurrentRMSsensor1.plug_p.pin[3].i + SignalVoltage1.plug_p.pin[3].i = 0.0;
//   CurrentRMSsensor1.plug_n.pin[1].i + TerminalBox1.plugToGrid.pin[1].i = 0.0;
//   CurrentRMSsensor1.plug_n.pin[2].i + TerminalBox1.plugToGrid.pin[2].i = 0.0;
//   CurrentRMSsensor1.plug_n.pin[3].i + TerminalBox1.plugToGrid.pin[3].i = 0.0;
//   -CurrentRMSsensor1.plug_p.pin[1].i + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   -CurrentRMSsensor1.plug_p.pin[2].i + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   -CurrentRMSsensor1.plug_p.pin[3].i + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   -CurrentRMSsensor1.plug_n.pin[1].i + CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i = 0.0;
//   -CurrentRMSsensor1.plug_n.pin[2].i + CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i = 0.0;
//   -CurrentRMSsensor1.plug_n.pin[3].i + CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i = 0.0;
//   -CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i + CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   -CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i + CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i = 0.0;
//   -CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i + CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   -CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i + CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i = 0.0;
//   -CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i + CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   -CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i + CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i = CurrentRMSsensor1.CurrentSensor1.i[3];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i = CurrentRMSsensor1.CurrentSensor1.i[2];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i = CurrentRMSsensor1.CurrentSensor1.i[1];
//   CurrentRMSsensor1.ToPolar1.u[2] = CurrentRMSsensor1.ToSpacePhasor1.y[2];
//   CurrentRMSsensor1.ToPolar1.u[1] = CurrentRMSsensor1.ToSpacePhasor1.y[1];
//   CurrentRMSsensor1.CurrentSensor1.i[3] = CurrentRMSsensor1.ToSpacePhasor1.u[3];
//   CurrentRMSsensor1.CurrentSensor1.i[2] = CurrentRMSsensor1.ToSpacePhasor1.u[2];
//   CurrentRMSsensor1.CurrentSensor1.i[1] = CurrentRMSsensor1.ToSpacePhasor1.u[1];
//   CurrentRMSsensor1.Gain1.u = CurrentRMSsensor1.ToPolar1.y[1];
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v = CurrentRMSsensor1.plug_n.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v = CurrentRMSsensor1.plug_n.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v = CurrentRMSsensor1.plug_n.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v = CurrentRMSsensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v = CurrentRMSsensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v = CurrentRMSsensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.I;
//   RotorAngle1.relativeAngleSensor.flange_a.tau + RotorAngle1.fixedHousing.flange_b.tau = 0.0;
//   -RotorAngle1.flange.tau + RotorAngle1.relativeAngleSensor.flange_b.tau = 0.0;
//   -RotorAngle1.plug_p.pin[1].i + RotorAngle1.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   -RotorAngle1.plug_p.pin[2].i + RotorAngle1.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   -RotorAngle1.plug_p.pin[3].i + RotorAngle1.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   -RotorAngle1.plug_n.pin[1].i + RotorAngle1.VoltageSensor1.plug_n.pin[1].i = 0.0;
//   -RotorAngle1.plug_n.pin[2].i + RotorAngle1.VoltageSensor1.plug_n.pin[2].i = 0.0;
//   -RotorAngle1.plug_n.pin[3].i + RotorAngle1.VoltageSensor1.plug_n.pin[3].i = 0.0;
//   -RotorAngle1.VoltageSensor1.plug_p.pin[1].i + RotorAngle1.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   -RotorAngle1.VoltageSensor1.plug_n.pin[1].i + RotorAngle1.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   -RotorAngle1.VoltageSensor1.plug_p.pin[2].i + RotorAngle1.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   -RotorAngle1.VoltageSensor1.plug_n.pin[2].i + RotorAngle1.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   -RotorAngle1.VoltageSensor1.plug_p.pin[3].i + RotorAngle1.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   -RotorAngle1.VoltageSensor1.plug_n.pin[3].i + RotorAngle1.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.v[3] = RotorAngle1.VoltageSensor1.voltageSensor[3].v;
//   RotorAngle1.VoltageSensor1.v[2] = RotorAngle1.VoltageSensor1.voltageSensor[2].v;
//   RotorAngle1.VoltageSensor1.v[1] = RotorAngle1.VoltageSensor1.voltageSensor[1].v;
//   RotorAngle1.VoltageSensor1.plug_p.pin[1].v = RotorAngle1.VoltageSensor1.voltageSensor[1].p.v;
//   RotorAngle1.VoltageSensor1.plug_p.pin[2].v = RotorAngle1.VoltageSensor1.voltageSensor[2].p.v;
//   RotorAngle1.VoltageSensor1.plug_p.pin[3].v = RotorAngle1.VoltageSensor1.voltageSensor[3].p.v;
//   RotorAngle1.VoltageSensor1.plug_n.pin[1].v = RotorAngle1.VoltageSensor1.voltageSensor[1].n.v;
//   RotorAngle1.VoltageSensor1.plug_n.pin[2].v = RotorAngle1.VoltageSensor1.voltageSensor[2].n.v;
//   RotorAngle1.VoltageSensor1.plug_n.pin[3].v = RotorAngle1.VoltageSensor1.voltageSensor[3].n.v;
//   RotorAngle1.add.u2 = RotorAngle1.constant_.y;
//   RotorAngle1.add.y = RotorAngle1.rotatorVS2R.angle;
//   RotorAngle1.add.u1 = RotorAngle1.relativeAngleSensor.phi_rel;
//   RotorAngle1.VoltageSensor1.plug_p.pin[1].v = RotorAngle1.plug_p.pin[1].v;
//   RotorAngle1.VoltageSensor1.plug_p.pin[2].v = RotorAngle1.plug_p.pin[2].v;
//   RotorAngle1.VoltageSensor1.plug_p.pin[3].v = RotorAngle1.plug_p.pin[3].v;
//   RotorAngle1.VoltageSensor1.plug_n.pin[1].v = RotorAngle1.plug_n.pin[1].v;
//   RotorAngle1.VoltageSensor1.plug_n.pin[2].v = RotorAngle1.plug_n.pin[2].v;
//   RotorAngle1.VoltageSensor1.plug_n.pin[3].v = RotorAngle1.plug_n.pin[3].v;
//   RotorAngle1.ToSpacePhasorVS.u[3] = RotorAngle1.VoltageSensor1.v[3];
//   RotorAngle1.ToSpacePhasorVS.u[2] = RotorAngle1.VoltageSensor1.v[2];
//   RotorAngle1.ToSpacePhasorVS.u[1] = RotorAngle1.VoltageSensor1.v[1];
//   RotorAngle1.fixedHousing.flange_b.phi = RotorAngle1.relativeAngleSensor.flange_a.phi;
//   RotorAngle1.flange.phi = RotorAngle1.relativeAngleSensor.flange_b.phi;
//   RotorAngle1.deMultiplex2.y2[1] = RotorAngle1.rotorAngle;
//   RotorAngle1.ToPolarVSR.y[2] = RotorAngle1.deMultiplex2.u[2];
//   RotorAngle1.ToPolarVSR.y[1] = RotorAngle1.deMultiplex2.u[1];
//   RotorAngle1.ToPolarVSR.u[2] = RotorAngle1.rotatorVS2R.y[2];
//   RotorAngle1.ToPolarVSR.u[1] = RotorAngle1.rotatorVS2R.y[1];
//   RotorAngle1.ToSpacePhasorVS.y[2] = RotorAngle1.rotatorVS2R.u[2];
//   RotorAngle1.ToSpacePhasorVS.y[1] = RotorAngle1.rotatorVS2R.u[1];
//   TerminalBox1.star.pin_n.i + -TerminalBox1.starpoint.i = 0.0;
//   -TerminalBox1.negativeMachinePlug.pin[1].i + TerminalBox1.star.plug_p.pin[1].i = 0.0;
//   -TerminalBox1.negativeMachinePlug.pin[2].i + TerminalBox1.star.plug_p.pin[2].i = 0.0;
//   -TerminalBox1.negativeMachinePlug.pin[3].i + TerminalBox1.star.plug_p.pin[3].i = 0.0;
//   TerminalBox1.star.pin_n.v = TerminalBox1.star.plug_p.pin[1].v;
//   TerminalBox1.star.pin_n.v = TerminalBox1.star.plug_p.pin[2].v;
//   TerminalBox1.star.pin_n.v = TerminalBox1.star.plug_p.pin[3].v;
//   -TerminalBox1.star.pin_n.i + -TerminalBox1.star.plug_p.pin[1].i + -TerminalBox1.star.plug_p.pin[2].i + -TerminalBox1.star.plug_p.pin[3].i = 0.0;
//   TerminalBox1.starpoint.i = 0.0;
//   TerminalBox1.star.pin_n.v = TerminalBox1.starpoint.v;
//   TerminalBox1.plugToGrid.pin[1].v = TerminalBox1.positiveMachinePlug.pin[1].v;
//   -TerminalBox1.positiveMachinePlug.pin[1].i + -TerminalBox1.plugToGrid.pin[1].i = 0.0;
//   TerminalBox1.plugToGrid.pin[2].v = TerminalBox1.positiveMachinePlug.pin[2].v;
//   -TerminalBox1.positiveMachinePlug.pin[2].i + -TerminalBox1.plugToGrid.pin[2].i = 0.0;
//   TerminalBox1.plugToGrid.pin[3].v = TerminalBox1.positiveMachinePlug.pin[3].v;
//   -TerminalBox1.positiveMachinePlug.pin[3].i + -TerminalBox1.plugToGrid.pin[3].i = 0.0;
//   TerminalBox1.negativeMachinePlug.pin[1].v = TerminalBox1.star.plug_p.pin[1].v;
//   TerminalBox1.negativeMachinePlug.pin[2].v = TerminalBox1.star.plug_p.pin[2].v;
//   TerminalBox1.negativeMachinePlug.pin[3].v = TerminalBox1.star.plug_p.pin[3].v;
//   Ground1.p.i + Star1.pin_n.i = 0.0;
//   Star1.plug_p.pin[1].i + SignalVoltage1.plug_n.pin[1].i = 0.0;
//   Star1.plug_p.pin[2].i + SignalVoltage1.plug_n.pin[2].i = 0.0;
//   Star1.plug_p.pin[3].i + SignalVoltage1.plug_n.pin[3].i = 0.0;
//   Star1.pin_n.v = Star1.plug_p.pin[1].v;
//   Star1.pin_n.v = Star1.plug_p.pin[2].v;
//   Star1.pin_n.v = Star1.plug_p.pin[3].v;
//   -Star1.pin_n.i + -Star1.plug_p.pin[1].i + -Star1.plug_p.pin[2].i + -Star1.plug_p.pin[3].i = 0.0;
//   -SignalVoltage1.plug_p.pin[1].i + SignalVoltage1.signalVoltage[1].p.i = 0.0;
//   -SignalVoltage1.plug_n.pin[1].i + SignalVoltage1.signalVoltage[1].n.i = 0.0;
//   -SignalVoltage1.plug_p.pin[2].i + SignalVoltage1.signalVoltage[2].p.i = 0.0;
//   -SignalVoltage1.plug_n.pin[2].i + SignalVoltage1.signalVoltage[2].n.i = 0.0;
//   -SignalVoltage1.plug_p.pin[3].i + SignalVoltage1.signalVoltage[3].p.i = 0.0;
//   -SignalVoltage1.plug_n.pin[3].i + SignalVoltage1.signalVoltage[3].n.i = 0.0;
//   SignalVoltage1.plug_p.pin[1].v = SignalVoltage1.signalVoltage[1].p.v;
//   SignalVoltage1.plug_p.pin[2].v = SignalVoltage1.signalVoltage[2].p.v;
//   SignalVoltage1.plug_p.pin[3].v = SignalVoltage1.signalVoltage[3].p.v;
//   SignalVoltage1.plug_n.pin[1].v = SignalVoltage1.signalVoltage[1].n.v;
//   SignalVoltage1.plug_n.pin[2].v = SignalVoltage1.signalVoltage[2].n.v;
//   SignalVoltage1.plug_n.pin[3].v = SignalVoltage1.signalVoltage[3].n.v;
//   SignalVoltage1.signalVoltage[3].v = SignalVoltage1.v[3];
//   SignalVoltage1.signalVoltage[2].v = SignalVoltage1.v[2];
//   SignalVoltage1.signalVoltage[1].v = SignalVoltage1.v[1];
//   TorqueStep1.flange.tau + LoadInertia.flange_b.tau = 0.0;
//   TorqueStep1.bearing.tau = 0.0;
//   CurrentRMSsensor1.plug_n.pin[1].v = TerminalBox1.plugToGrid.pin[1].v;
//   CurrentRMSsensor1.plug_n.pin[2].v = TerminalBox1.plugToGrid.pin[2].v;
//   CurrentRMSsensor1.plug_n.pin[3].v = TerminalBox1.plugToGrid.pin[3].v;
//   RotorAngle1.plug_n.pin[1].v = SMR1.plug_sn.pin[1].v;
//   RotorAngle1.plug_n.pin[1].v = TerminalBox1.negativeMachinePlug.pin[1].v;
//   RotorAngle1.plug_n.pin[2].v = SMR1.plug_sn.pin[2].v;
//   RotorAngle1.plug_n.pin[2].v = TerminalBox1.negativeMachinePlug.pin[2].v;
//   RotorAngle1.plug_n.pin[3].v = SMR1.plug_sn.pin[3].v;
//   RotorAngle1.plug_n.pin[3].v = TerminalBox1.negativeMachinePlug.pin[3].v;
//   RotorAngle1.plug_p.pin[1].v = SMR1.plug_sp.pin[1].v;
//   RotorAngle1.plug_p.pin[1].v = TerminalBox1.positiveMachinePlug.pin[1].v;
//   RotorAngle1.plug_p.pin[2].v = SMR1.plug_sp.pin[2].v;
//   RotorAngle1.plug_p.pin[2].v = TerminalBox1.positiveMachinePlug.pin[2].v;
//   RotorAngle1.plug_p.pin[3].v = SMR1.plug_sp.pin[3].v;
//   RotorAngle1.plug_p.pin[3].v = TerminalBox1.positiveMachinePlug.pin[3].v;
//   LoadInertia.flange_a.phi = RotorAngle1.flange.phi;
//   LoadInertia.flange_a.phi = SMR1.flange_a.phi;
//   LoadInertia.flange_b.phi = TorqueStep1.flange.phi;
//   Ramp1.y = VfController1.u;
//   SignalVoltage1.plug_n.pin[1].v = Star1.plug_p.pin[1].v;
//   SignalVoltage1.plug_n.pin[2].v = Star1.plug_p.pin[2].v;
//   SignalVoltage1.plug_n.pin[3].v = Star1.plug_p.pin[3].v;
//   SignalVoltage1.v[3] = VfController1.y[3];
//   SignalVoltage1.v[2] = VfController1.y[2];
//   SignalVoltage1.v[1] = VfController1.y[1];
//   CurrentRMSsensor1.plug_p.pin[1].v = SignalVoltage1.plug_p.pin[1].v;
//   CurrentRMSsensor1.plug_p.pin[2].v = SignalVoltage1.plug_p.pin[2].v;
//   CurrentRMSsensor1.plug_p.pin[3].v = SignalVoltage1.plug_p.pin[3].v;
//   Ground1.p.v = Star1.pin_n.v;
// end Modelica.Electrical.Machines.Examples.SMR_Inverter;
// "
// "Notification: Modelica language version set to 2.x due to loading of MSL 2.2.1.
// "
// endResult
