//name:         ShowExceptions
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.StateGraph.Examples.ShowExceptions);
getErrorString();
// Result:
// true
// "function Modelica.StateGraph.Temporary.anyTrue
//   input Boolean[:] b;
//   output Boolean result;
// algorithm
//   result := false;
//   for i in 1:size(b,1) loop
//     result := result OR b[i];
//   end for;
// end Modelica.StateGraph.Temporary.anyTrue;
// 
// class Modelica.StateGraph.Examples.ShowExceptions
//   output Boolean stateGraphRoot.suspend = false;
//   output Boolean stateGraphRoot.resume = false;
//   output Boolean stateGraphRoot.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   output Boolean stateGraphRoot.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   input Real stateGraphRoot.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   output Integer stateGraphRoot.activeSteps \"Number of active steps within the stategraph\";
//   output Boolean compositeStep.stateGraphRoot.suspend = Modelica.StateGraph.Temporary.anyTrue({compositeStep.suspend[1].reset}) OR compositeStep.outerState.subgraphStatePort.suspend;
//   output Boolean compositeStep.stateGraphRoot.resume = Modelica.StateGraph.Temporary.anyTrue({compositeStep.resume[1].set}) OR compositeStep.outerState.subgraphStatePort.resume;
//   output Boolean compositeStep.stateGraphRoot.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   output Boolean compositeStep.stateGraphRoot.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   input Real compositeStep.stateGraphRoot.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   parameter Integer compositeStep.nSuspend = 1 \"Number of suspend ports\";
//   parameter Integer compositeStep.nResume = 1 \"Number of resume ports\";
//   output Boolean compositeStep.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean compositeStep.outerState.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.outerState.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.outerState.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   output Boolean compositeStep.inPort.occupied \"true, if step is active\";
//   input Boolean compositeStep.inPort.set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.outPort.available \"true, if step is active\";
//   input Boolean compositeStep.outPort.reset \"true, if transition fires and step is deactivated\";
//   output Boolean compositeStep.suspend[1].available \"true, if step is active\";
//   input Boolean compositeStep.suspend[1].reset \"true, if transition fires and step is deactived\";
//   output Boolean compositeStep.resume[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.resume[1].set \"true, if transition fires and step is activated\";
//   protected Boolean compositeStep.newActive \"Value of active in the next iteration\";
//   protected Integer compositeStep.activeSteps \"Number of active steps within the CompositeStep\";
//   input Boolean compositeStep.transition1.localCondition = compositeStep.transition1.condition \"= true, if transition may fire\";
//   parameter Boolean compositeStep.transition1.enableTimer = false \"= true, if timer is enabled\";
//   parameter Real compositeStep.transition1.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 0.0 \"Wait time before transition fires\";
//   output Real compositeStep.transition1.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean compositeStep.transition1.enableFire \"= true, if all firing conditions are true\";
//   output Boolean compositeStep.transition1.fire \"= true, if transition fires\";
//   input Boolean compositeStep.transition1.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.transition1.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.transition1.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.transition1.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real compositeStep.transition1.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real compositeStep.transition1.t_dummy;
//   input Boolean compositeStep.transition1.condition = time > 8.0 \"= true, if transition may fire (time varying expression)\";
//   parameter Integer compositeStep.initStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer compositeStep.initStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean compositeStep.initStep.localActive = compositeStep.initStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.initStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.initStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.initStep.outPort[1].available \"true, if step is active\";
//   input Boolean compositeStep.initStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean compositeStep.initStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.initStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.initStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean compositeStep.initStep.newActive \"Value of active in the next iteration\";
//   protected Boolean compositeStep.initStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean compositeStep.initStep.active \"= true if step is active, otherwise the step is not active\";
//   parameter Integer compositeStep.exitStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer compositeStep.exitStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean compositeStep.exitStep.localActive = compositeStep.exitStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.exitStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.exitStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.exitStep.outPort[1].available \"true, if step is active\";
//   input Boolean compositeStep.exitStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean compositeStep.exitStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.exitStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.exitStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean compositeStep.exitStep.newActive \"Value of active in the next iteration\";
//   protected Boolean compositeStep.exitStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean compositeStep.exitStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.compositeStep11.stateGraphRoot.suspend = Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.suspend[1].reset}) OR compositeStep.compositeStep11.outerState.subgraphStatePort.suspend;
//   output Boolean compositeStep.compositeStep11.stateGraphRoot.resume = Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.resume[1].set}) OR compositeStep.compositeStep11.outerState.subgraphStatePort.resume;
//   output Boolean compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   output Boolean compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   input Real compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   parameter Integer compositeStep.compositeStep11.nSuspend = 1 \"Number of suspend ports\";
//   parameter Integer compositeStep.compositeStep11.nResume = 1 \"Number of resume ports\";
//   output Boolean compositeStep.compositeStep11.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean compositeStep.compositeStep11.outerState.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.compositeStep11.outerState.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.compositeStep11.outerState.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   output Boolean compositeStep.compositeStep11.inPort.occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.inPort.set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.compositeStep11.outPort.available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.outPort.reset \"true, if transition fires and step is deactivated\";
//   output Boolean compositeStep.compositeStep11.suspend[1].available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.suspend[1].reset \"true, if transition fires and step is deactived\";
//   output Boolean compositeStep.compositeStep11.resume[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.resume[1].set \"true, if transition fires and step is activated\";
//   protected Boolean compositeStep.compositeStep11.newActive \"Value of active in the next iteration\";
//   protected Integer compositeStep.compositeStep11.activeSteps \"Number of active steps within the CompositeStep\";
//   input Boolean compositeStep.compositeStep11.transition.localCondition = compositeStep.compositeStep11.transition.condition \"= true, if transition may fire\";
//   parameter Boolean compositeStep.compositeStep11.transition.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real compositeStep.compositeStep11.transition.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = compositeStep.compositeStep11.waitTime \"Wait time before transition fires\";
//   output Real compositeStep.compositeStep11.transition.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean compositeStep.compositeStep11.transition.enableFire \"= true, if all firing conditions are true\";
//   output Boolean compositeStep.compositeStep11.transition.fire \"= true, if transition fires\";
//   input Boolean compositeStep.compositeStep11.transition.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.compositeStep11.transition.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.compositeStep11.transition.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.compositeStep11.transition.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real compositeStep.compositeStep11.transition.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real compositeStep.compositeStep11.transition.t_dummy;
//   input Boolean compositeStep.compositeStep11.transition.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer compositeStep.compositeStep11.initStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer compositeStep.compositeStep11.initStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean compositeStep.compositeStep11.initStep.localActive = compositeStep.compositeStep11.initStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.compositeStep11.initStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.initStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.compositeStep11.initStep.outPort[1].available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.initStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean compositeStep.compositeStep11.initStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.compositeStep11.initStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.compositeStep11.initStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean compositeStep.compositeStep11.initStep.newActive \"Value of active in the next iteration\";
//   protected Boolean compositeStep.compositeStep11.initStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean compositeStep.compositeStep11.initStep.active \"= true if step is active, otherwise the step is not active\";
//   parameter Integer compositeStep.compositeStep11.exitStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer compositeStep.compositeStep11.exitStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean compositeStep.compositeStep11.exitStep.localActive = compositeStep.compositeStep11.exitStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.compositeStep11.exitStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.exitStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.compositeStep11.exitStep.outPort[1].available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep11.exitStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean compositeStep.compositeStep11.exitStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.compositeStep11.exitStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.compositeStep11.exitStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean compositeStep.compositeStep11.exitStep.newActive \"Value of active in the next iteration\";
//   protected Boolean compositeStep.compositeStep11.exitStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean compositeStep.compositeStep11.exitStep.active \"= true if step is active, otherwise the step is not active\";
//   parameter Real compositeStep.compositeStep11.waitTime = 3.0 \"waiting time in this composite step\";
//   output Boolean compositeStep.compositeStep12.stateGraphRoot.suspend = Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.suspend[1].reset}) OR compositeStep.compositeStep12.outerState.subgraphStatePort.suspend;
//   output Boolean compositeStep.compositeStep12.stateGraphRoot.resume = Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.resume[1].set}) OR compositeStep.compositeStep12.outerState.subgraphStatePort.resume;
//   output Boolean compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   output Boolean compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   input Real compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   parameter Integer compositeStep.compositeStep12.nSuspend = 1 \"Number of suspend ports\";
//   parameter Integer compositeStep.compositeStep12.nResume = 1 \"Number of resume ports\";
//   output Boolean compositeStep.compositeStep12.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean compositeStep.compositeStep12.outerState.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.compositeStep12.outerState.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.compositeStep12.outerState.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   output Boolean compositeStep.compositeStep12.inPort.occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.inPort.set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.compositeStep12.outPort.available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.outPort.reset \"true, if transition fires and step is deactivated\";
//   output Boolean compositeStep.compositeStep12.suspend[1].available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.suspend[1].reset \"true, if transition fires and step is deactived\";
//   output Boolean compositeStep.compositeStep12.resume[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.resume[1].set \"true, if transition fires and step is activated\";
//   protected Boolean compositeStep.compositeStep12.newActive \"Value of active in the next iteration\";
//   protected Integer compositeStep.compositeStep12.activeSteps \"Number of active steps within the CompositeStep\";
//   input Boolean compositeStep.compositeStep12.transition.localCondition = compositeStep.compositeStep12.transition.condition \"= true, if transition may fire\";
//   parameter Boolean compositeStep.compositeStep12.transition.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real compositeStep.compositeStep12.transition.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = compositeStep.compositeStep12.waitTime \"Wait time before transition fires\";
//   output Real compositeStep.compositeStep12.transition.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean compositeStep.compositeStep12.transition.enableFire \"= true, if all firing conditions are true\";
//   output Boolean compositeStep.compositeStep12.transition.fire \"= true, if transition fires\";
//   input Boolean compositeStep.compositeStep12.transition.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.compositeStep12.transition.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.compositeStep12.transition.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.compositeStep12.transition.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real compositeStep.compositeStep12.transition.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real compositeStep.compositeStep12.transition.t_dummy;
//   input Boolean compositeStep.compositeStep12.transition.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer compositeStep.compositeStep12.initStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer compositeStep.compositeStep12.initStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean compositeStep.compositeStep12.initStep.localActive = compositeStep.compositeStep12.initStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.compositeStep12.initStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.initStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.compositeStep12.initStep.outPort[1].available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.initStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean compositeStep.compositeStep12.initStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.compositeStep12.initStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.compositeStep12.initStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean compositeStep.compositeStep12.initStep.newActive \"Value of active in the next iteration\";
//   protected Boolean compositeStep.compositeStep12.initStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean compositeStep.compositeStep12.initStep.active \"= true if step is active, otherwise the step is not active\";
//   parameter Integer compositeStep.compositeStep12.exitStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer compositeStep.compositeStep12.exitStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean compositeStep.compositeStep12.exitStep.localActive = compositeStep.compositeStep12.exitStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean compositeStep.compositeStep12.exitStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.exitStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.compositeStep12.exitStep.outPort[1].available \"true, if step is active\";
//   input Boolean compositeStep.compositeStep12.exitStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean compositeStep.compositeStep12.exitStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean compositeStep.compositeStep12.exitStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real compositeStep.compositeStep12.exitStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean compositeStep.compositeStep12.exitStep.newActive \"Value of active in the next iteration\";
//   protected Boolean compositeStep.compositeStep12.exitStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean compositeStep.compositeStep12.exitStep.active \"= true if step is active, otherwise the step is not active\";
//   parameter Real compositeStep.compositeStep12.waitTime = 2.0 \"waiting time in this composite step\";
//   input Boolean compositeStep.transition2.localCondition = compositeStep.transition2.condition \"= true, if transition may fire\";
//   parameter Boolean compositeStep.transition2.enableTimer = false \"= true, if timer is enabled\";
//   parameter Real compositeStep.transition2.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 0.0 \"Wait time before transition fires\";
//   output Real compositeStep.transition2.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean compositeStep.transition2.enableFire \"= true, if all firing conditions are true\";
//   output Boolean compositeStep.transition2.fire \"= true, if transition fires\";
//   input Boolean compositeStep.transition2.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.transition2.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.transition2.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.transition2.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real compositeStep.transition2.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real compositeStep.transition2.t_dummy;
//   input Boolean compositeStep.transition2.condition = time > 4.0 \"= true, if transition may fire (time varying expression)\";
//   input Boolean compositeStep.transition3.localCondition = compositeStep.transition3.condition \"= true, if transition may fire\";
//   parameter Boolean compositeStep.transition3.enableTimer = false \"= true, if timer is enabled\";
//   parameter Real compositeStep.transition3.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 0.0 \"Wait time before transition fires\";
//   output Real compositeStep.transition3.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean compositeStep.transition3.enableFire \"= true, if all firing conditions are true\";
//   output Boolean compositeStep.transition3.fire \"= true, if transition fires\";
//   input Boolean compositeStep.transition3.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.transition3.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.transition3.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.transition3.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real compositeStep.transition3.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real compositeStep.transition3.t_dummy;
//   input Boolean compositeStep.transition3.condition = true \"= true, if transition may fire (time varying expression)\";
//   input Boolean compositeStep.transition4.localCondition = compositeStep.transition4.condition \"= true, if transition may fire\";
//   parameter Boolean compositeStep.transition4.enableTimer = false \"= true, if timer is enabled\";
//   parameter Real compositeStep.transition4.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 0.0 \"Wait time before transition fires\";
//   output Real compositeStep.transition4.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean compositeStep.transition4.enableFire \"= true, if all firing conditions are true\";
//   output Boolean compositeStep.transition4.fire \"= true, if transition fires\";
//   input Boolean compositeStep.transition4.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.transition4.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.transition4.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.transition4.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real compositeStep.transition4.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real compositeStep.transition4.t_dummy;
//   input Boolean compositeStep.transition4.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer compositeStep.Alternative1.nBranches(min = 1) = 2 \"Number of alternative branches\";
//   input Boolean compositeStep.Alternative1.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean compositeStep.Alternative1.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean compositeStep.Alternative1.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean compositeStep.Alternative1.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   output Boolean compositeStep.Alternative1.join[1].occupied \"true, if step is active\";
//   input Boolean compositeStep.Alternative1.join[1].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.Alternative1.join[2].occupied \"true, if step is active\";
//   input Boolean compositeStep.Alternative1.join[2].set \"true, if transition fires and step is activated\";
//   output Boolean compositeStep.Alternative1.split[1].available \"true, if step is active\";
//   input Boolean compositeStep.Alternative1.split[1].reset \"true, if transition fires and step is deactivated\";
//   output Boolean compositeStep.Alternative1.split[2].available \"true, if step is active\";
//   input Boolean compositeStep.Alternative1.split[2].reset \"true, if transition fires and step is deactivated\";
//   parameter Integer initialStep.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer initialStep.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean initialStep.localActive = initialStep.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean initialStep.inPort[1].occupied \"true, if step is active\";
//   input Boolean initialStep.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean initialStep.outPort[1].available \"true, if step is active\";
//   input Boolean initialStep.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean initialStep.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean initialStep.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real initialStep.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean initialStep.newActive \"Value of active in the next iteration\";
//   protected Boolean initialStep.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean initialStep.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition1.localCondition = transition1.condition \"= true, if transition may fire\";
//   parameter Boolean transition1.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition1.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition1.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition1.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition1.fire \"= true, if transition fires\";
//   input Boolean transition1.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition1.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition1.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition1.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition1.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition1.t_dummy;
//   input Boolean transition1.condition = true \"= true, if transition may fire (time varying expression)\";
//   input Boolean transition2.localCondition = transition2.condition \"= true, if transition may fire\";
//   parameter Boolean transition2.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition2.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition2.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition2.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition2.fire \"= true, if transition fires\";
//   input Boolean transition2.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition2.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition2.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition2.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition2.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition2.t_dummy;
//   input Boolean transition2.condition = true \"= true, if transition may fire (time varying expression)\";
//   input Boolean transition3.localCondition = transition3.condition \"= true, if transition may fire\";
//   parameter Boolean transition3.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition3.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 2.0 \"Wait time before transition fires\";
//   output Real transition3.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition3.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition3.fire \"= true, if transition fires\";
//   input Boolean transition3.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition3.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition3.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition3.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition3.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition3.t_dummy;
//   input Boolean transition3.condition = true \"= true, if transition may fire (time varying expression)\";
//   parameter Integer step1.nIn(min = 0) = 1 \"Number of input connections\";
//   parameter Integer step1.nOut(min = 0) = 1 \"Number of output connections\";
//   output Boolean step1.localActive = step1.active \"= true if step is active, otherwise the step is not active\";
//   output Boolean step1.inPort[1].occupied \"true, if step is active\";
//   input Boolean step1.inPort[1].set \"true, if transition fires and step is activated\";
//   output Boolean step1.outPort[1].available \"true, if step is active\";
//   input Boolean step1.outPort[1].reset \"true, if transition fires and step is deactivated\";
//   input Boolean step1.subgraphStatePort.suspend \"= true, if suspend transition of CompositeStep fires\";
//   input Boolean step1.subgraphStatePort.resume \"= true, if resume transition of CompositeStep fires\";
//   output Real step1.subgraphStatePort.activeSteps \"Number of active steps in the CompositeStep\";
//   protected Boolean step1.newActive \"Value of active in the next iteration\";
//   protected Boolean step1.oldActive \"Value of active when CompositeStep was aborted\";
//   output Boolean step1.active \"= true if step is active, otherwise the step is not active\";
//   input Boolean transition4.localCondition = transition4.condition \"= true, if transition may fire\";
//   parameter Boolean transition4.enableTimer = true \"= true, if timer is enabled\";
//   parameter Real transition4.waitTime(quantity = \"Time\", unit = \"s\", min = 0.0) = 1.0 \"Wait time before transition fires\";
//   output Real transition4.t(quantity = \"Time\", unit = \"s\") \"= actual waiting time (transition will fire when t > waitTime)\";
//   output Boolean transition4.enableFire \"= true, if all firing conditions are true\";
//   output Boolean transition4.fire \"= true, if transition fires\";
//   input Boolean transition4.inPort.available \"true, if step connected to the transition input is active\";
//   output Boolean transition4.inPort.reset \"true, if transition fires and the step connected to the transition input is deactivated\";
//   input Boolean transition4.outPort.occupied \"true, if step connected to the transition output is active\";
//   output Boolean transition4.outPort.set \"true, if transition fires and step connected to the transition output becomes active\";
//   protected Real transition4.t_start(quantity = \"Time\", unit = \"s\") \"Time instant at which the transition would fire, if waitTime would be zero\";
//   protected Real transition4.t_dummy;
//   input Boolean transition4.condition = true \"= true, if transition may fire (time varying expression)\";
// initial equation
//   pre(compositeStep.transition1.enableFire) = false;
//   compositeStep.initStep.active = false;
//   pre(compositeStep.initStep.newActive) = pre(compositeStep.initStep.localActive);
//   pre(compositeStep.initStep.oldActive) = pre(compositeStep.initStep.localActive);
//   compositeStep.exitStep.active = false;
//   pre(compositeStep.exitStep.newActive) = pre(compositeStep.exitStep.localActive);
//   pre(compositeStep.exitStep.oldActive) = pre(compositeStep.exitStep.localActive);
//   pre(compositeStep.compositeStep11.transition.enableFire) = false;
//   compositeStep.compositeStep11.initStep.active = false;
//   pre(compositeStep.compositeStep11.initStep.newActive) = pre(compositeStep.compositeStep11.initStep.localActive);
//   pre(compositeStep.compositeStep11.initStep.oldActive) = pre(compositeStep.compositeStep11.initStep.localActive);
//   compositeStep.compositeStep11.exitStep.active = false;
//   pre(compositeStep.compositeStep11.exitStep.newActive) = pre(compositeStep.compositeStep11.exitStep.localActive);
//   pre(compositeStep.compositeStep11.exitStep.oldActive) = pre(compositeStep.compositeStep11.exitStep.localActive);
//   pre(compositeStep.compositeStep11.newActive) = pre(compositeStep.compositeStep11.active);
//   pre(compositeStep.compositeStep12.transition.enableFire) = false;
//   compositeStep.compositeStep12.initStep.active = false;
//   pre(compositeStep.compositeStep12.initStep.newActive) = pre(compositeStep.compositeStep12.initStep.localActive);
//   pre(compositeStep.compositeStep12.initStep.oldActive) = pre(compositeStep.compositeStep12.initStep.localActive);
//   compositeStep.compositeStep12.exitStep.active = false;
//   pre(compositeStep.compositeStep12.exitStep.newActive) = pre(compositeStep.compositeStep12.exitStep.localActive);
//   pre(compositeStep.compositeStep12.exitStep.oldActive) = pre(compositeStep.compositeStep12.exitStep.localActive);
//   pre(compositeStep.compositeStep12.newActive) = pre(compositeStep.compositeStep12.active);
//   pre(compositeStep.transition2.enableFire) = false;
//   pre(compositeStep.transition3.enableFire) = false;
//   pre(compositeStep.transition4.enableFire) = false;
//   pre(compositeStep.newActive) = pre(compositeStep.active);
//   initialStep.active = true;
//   pre(initialStep.newActive) = pre(initialStep.localActive);
//   pre(initialStep.oldActive) = pre(initialStep.localActive);
//   pre(transition1.enableFire) = false;
//   pre(transition2.enableFire) = false;
//   pre(transition3.enableFire) = false;
//   step1.active = false;
//   pre(step1.newActive) = pre(step1.localActive);
//   pre(step1.oldActive) = pre(step1.localActive);
//   pre(transition4.enableFire) = false;
// equation
//   stateGraphRoot.activeSteps = -integer(stateGraphRoot.subgraphStatePort.activeSteps);
//   stateGraphRoot.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   stateGraphRoot.resume = stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.stateGraphRoot.suspend = compositeStep.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.stateGraphRoot.resume = compositeStep.stateGraphRoot.subgraphStatePort.resume;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   compositeStep.transition1.t_start = 0.0;
//   compositeStep.transition1.t_dummy = 0.0;
//   compositeStep.transition1.t = 0.0;
//   compositeStep.transition1.fire = compositeStep.transition1.enableFire;
//   compositeStep.transition1.enableFire = compositeStep.transition1.localCondition AND compositeStep.transition1.inPort.available AND  NOT compositeStep.transition1.outPort.occupied;
//   compositeStep.transition1.inPort.reset = compositeStep.transition1.fire;
//   compositeStep.transition1.outPort.set = compositeStep.transition1.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   compositeStep.initStep.localActive = pre(compositeStep.initStep.newActive);
//   compositeStep.initStep.newActive = if compositeStep.initStep.subgraphStatePort.resume then compositeStep.initStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.initStep.inPort[1].set}) OR compositeStep.initStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.initStep.outPort[1].reset})) AND  NOT compositeStep.initStep.subgraphStatePort.suspend;
//   when compositeStep.initStep.subgraphStatePort.suspend then
//   compositeStep.initStep.oldActive = compositeStep.initStep.localActive;
//   end when;
//   compositeStep.initStep.subgraphStatePort.activeSteps = if compositeStep.initStep.localActive then 1.0 else 0.0;
//   compositeStep.initStep.inPort[1].occupied = compositeStep.initStep.localActive;
//   compositeStep.initStep.outPort[1].available = compositeStep.initStep.localActive;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   compositeStep.exitStep.localActive = pre(compositeStep.exitStep.newActive);
//   compositeStep.exitStep.newActive = if compositeStep.exitStep.subgraphStatePort.resume then compositeStep.exitStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.exitStep.inPort[1].set}) OR compositeStep.exitStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.exitStep.outPort[1].reset})) AND  NOT compositeStep.exitStep.subgraphStatePort.suspend;
//   when compositeStep.exitStep.subgraphStatePort.suspend then
//   compositeStep.exitStep.oldActive = compositeStep.exitStep.localActive;
//   end when;
//   compositeStep.exitStep.subgraphStatePort.activeSteps = if compositeStep.exitStep.localActive then 1.0 else 0.0;
//   compositeStep.exitStep.inPort[1].occupied = compositeStep.exitStep.localActive;
//   compositeStep.exitStep.outPort[1].available = compositeStep.exitStep.localActive;
//   compositeStep.compositeStep11.stateGraphRoot.suspend = compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.compositeStep11.stateGraphRoot.resume = compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.resume;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when compositeStep.compositeStep11.transition.enableFire then
//   compositeStep.compositeStep11.transition.t_start = time;
//   end when;
//   compositeStep.compositeStep11.transition.t_dummy = time - compositeStep.compositeStep11.transition.t_start;
//   compositeStep.compositeStep11.transition.t = if compositeStep.compositeStep11.transition.enableFire then compositeStep.compositeStep11.transition.t_dummy else 0.0;
//   compositeStep.compositeStep11.transition.fire = compositeStep.compositeStep11.transition.enableFire AND time >= compositeStep.compositeStep11.transition.t_start + compositeStep.compositeStep11.transition.waitTime;
//   compositeStep.compositeStep11.transition.enableFire = compositeStep.compositeStep11.transition.localCondition AND compositeStep.compositeStep11.transition.inPort.available AND  NOT compositeStep.compositeStep11.transition.outPort.occupied;
//   compositeStep.compositeStep11.transition.inPort.reset = compositeStep.compositeStep11.transition.fire;
//   compositeStep.compositeStep11.transition.outPort.set = compositeStep.compositeStep11.transition.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   compositeStep.compositeStep11.initStep.localActive = pre(compositeStep.compositeStep11.initStep.newActive);
//   compositeStep.compositeStep11.initStep.newActive = if compositeStep.compositeStep11.initStep.subgraphStatePort.resume then compositeStep.compositeStep11.initStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.initStep.inPort[1].set}) OR compositeStep.compositeStep11.initStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.initStep.outPort[1].reset})) AND  NOT compositeStep.compositeStep11.initStep.subgraphStatePort.suspend;
//   when compositeStep.compositeStep11.initStep.subgraphStatePort.suspend then
//   compositeStep.compositeStep11.initStep.oldActive = compositeStep.compositeStep11.initStep.localActive;
//   end when;
//   compositeStep.compositeStep11.initStep.subgraphStatePort.activeSteps = if compositeStep.compositeStep11.initStep.localActive then 1.0 else 0.0;
//   compositeStep.compositeStep11.initStep.inPort[1].occupied = compositeStep.compositeStep11.initStep.localActive;
//   compositeStep.compositeStep11.initStep.outPort[1].available = compositeStep.compositeStep11.initStep.localActive;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   compositeStep.compositeStep11.exitStep.localActive = pre(compositeStep.compositeStep11.exitStep.newActive);
//   compositeStep.compositeStep11.exitStep.newActive = if compositeStep.compositeStep11.exitStep.subgraphStatePort.resume then compositeStep.compositeStep11.exitStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.exitStep.inPort[1].set}) OR compositeStep.compositeStep11.exitStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.exitStep.outPort[1].reset})) AND  NOT compositeStep.compositeStep11.exitStep.subgraphStatePort.suspend;
//   when compositeStep.compositeStep11.exitStep.subgraphStatePort.suspend then
//   compositeStep.compositeStep11.exitStep.oldActive = compositeStep.compositeStep11.exitStep.localActive;
//   end when;
//   compositeStep.compositeStep11.exitStep.subgraphStatePort.activeSteps = if compositeStep.compositeStep11.exitStep.localActive then 1.0 else 0.0;
//   compositeStep.compositeStep11.exitStep.inPort[1].occupied = compositeStep.compositeStep11.exitStep.localActive;
//   compositeStep.compositeStep11.exitStep.outPort[1].available = compositeStep.compositeStep11.exitStep.localActive;
//   compositeStep.compositeStep11.outerState.subgraphStatePort.activeSteps = if compositeStep.compositeStep11.active then 1.0 else 0.0;
//   compositeStep.compositeStep11.activeSteps = -integer(compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.activeSteps);
//   compositeStep.compositeStep11.active = pre(compositeStep.compositeStep11.newActive);
//   compositeStep.compositeStep11.newActive = compositeStep.compositeStep11.activeSteps > 0 AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.suspend[1].reset}) AND  NOT compositeStep.compositeStep11.outerState.subgraphStatePort.suspend OR Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep11.resume[1].set}) OR compositeStep.compositeStep11.outerState.subgraphStatePort.resume;
//   compositeStep.compositeStep11.resume[1].occupied = compositeStep.compositeStep11.active;
//   compositeStep.compositeStep11.suspend[1].available = compositeStep.compositeStep11.active;
//   assert(true,\"Connector suspend[1] of the CompositeStep is connected to more than one transition\");
//   compositeStep.compositeStep11.suspend[1].reset = false;
//   assert(true,\"Connector resume[1] of the CompositeStep is connected to more than one transition\");
//   compositeStep.compositeStep11.resume[1].set = false;
//   assert(true,\"Connector inPort of the CompositeStep has more than 2 connections. It should have only one connection from the outside to the inPort and one connection to a step inside the CompositeStep.\");
//   assert(true,\"Connector outPort of the CompositeStep has more than 2 connections. It should have only one connection from the outPort to the outside to the CompositeStep and one connection from a step inside the CompositeStep to the outPort connector.\");
//   compositeStep.compositeStep12.stateGraphRoot.suspend = compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.compositeStep12.stateGraphRoot.resume = compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.resume;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when compositeStep.compositeStep12.transition.enableFire then
//   compositeStep.compositeStep12.transition.t_start = time;
//   end when;
//   compositeStep.compositeStep12.transition.t_dummy = time - compositeStep.compositeStep12.transition.t_start;
//   compositeStep.compositeStep12.transition.t = if compositeStep.compositeStep12.transition.enableFire then compositeStep.compositeStep12.transition.t_dummy else 0.0;
//   compositeStep.compositeStep12.transition.fire = compositeStep.compositeStep12.transition.enableFire AND time >= compositeStep.compositeStep12.transition.t_start + compositeStep.compositeStep12.transition.waitTime;
//   compositeStep.compositeStep12.transition.enableFire = compositeStep.compositeStep12.transition.localCondition AND compositeStep.compositeStep12.transition.inPort.available AND  NOT compositeStep.compositeStep12.transition.outPort.occupied;
//   compositeStep.compositeStep12.transition.inPort.reset = compositeStep.compositeStep12.transition.fire;
//   compositeStep.compositeStep12.transition.outPort.set = compositeStep.compositeStep12.transition.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   compositeStep.compositeStep12.initStep.localActive = pre(compositeStep.compositeStep12.initStep.newActive);
//   compositeStep.compositeStep12.initStep.newActive = if compositeStep.compositeStep12.initStep.subgraphStatePort.resume then compositeStep.compositeStep12.initStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.initStep.inPort[1].set}) OR compositeStep.compositeStep12.initStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.initStep.outPort[1].reset})) AND  NOT compositeStep.compositeStep12.initStep.subgraphStatePort.suspend;
//   when compositeStep.compositeStep12.initStep.subgraphStatePort.suspend then
//   compositeStep.compositeStep12.initStep.oldActive = compositeStep.compositeStep12.initStep.localActive;
//   end when;
//   compositeStep.compositeStep12.initStep.subgraphStatePort.activeSteps = if compositeStep.compositeStep12.initStep.localActive then 1.0 else 0.0;
//   compositeStep.compositeStep12.initStep.inPort[1].occupied = compositeStep.compositeStep12.initStep.localActive;
//   compositeStep.compositeStep12.initStep.outPort[1].available = compositeStep.compositeStep12.initStep.localActive;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   compositeStep.compositeStep12.exitStep.localActive = pre(compositeStep.compositeStep12.exitStep.newActive);
//   compositeStep.compositeStep12.exitStep.newActive = if compositeStep.compositeStep12.exitStep.subgraphStatePort.resume then compositeStep.compositeStep12.exitStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.exitStep.inPort[1].set}) OR compositeStep.compositeStep12.exitStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.exitStep.outPort[1].reset})) AND  NOT compositeStep.compositeStep12.exitStep.subgraphStatePort.suspend;
//   when compositeStep.compositeStep12.exitStep.subgraphStatePort.suspend then
//   compositeStep.compositeStep12.exitStep.oldActive = compositeStep.compositeStep12.exitStep.localActive;
//   end when;
//   compositeStep.compositeStep12.exitStep.subgraphStatePort.activeSteps = if compositeStep.compositeStep12.exitStep.localActive then 1.0 else 0.0;
//   compositeStep.compositeStep12.exitStep.inPort[1].occupied = compositeStep.compositeStep12.exitStep.localActive;
//   compositeStep.compositeStep12.exitStep.outPort[1].available = compositeStep.compositeStep12.exitStep.localActive;
//   compositeStep.compositeStep12.outerState.subgraphStatePort.activeSteps = if compositeStep.compositeStep12.active then 1.0 else 0.0;
//   compositeStep.compositeStep12.activeSteps = -integer(compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.activeSteps);
//   compositeStep.compositeStep12.active = pre(compositeStep.compositeStep12.newActive);
//   compositeStep.compositeStep12.newActive = compositeStep.compositeStep12.activeSteps > 0 AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.suspend[1].reset}) AND  NOT compositeStep.compositeStep12.outerState.subgraphStatePort.suspend OR Modelica.StateGraph.Temporary.anyTrue({compositeStep.compositeStep12.resume[1].set}) OR compositeStep.compositeStep12.outerState.subgraphStatePort.resume;
//   compositeStep.compositeStep12.resume[1].occupied = compositeStep.compositeStep12.active;
//   compositeStep.compositeStep12.suspend[1].available = compositeStep.compositeStep12.active;
//   assert(true,\"Connector suspend[1] of the CompositeStep is connected to more than one transition\");
//   compositeStep.compositeStep12.suspend[1].reset = false;
//   assert(true,\"Connector resume[1] of the CompositeStep is connected to more than one transition\");
//   compositeStep.compositeStep12.resume[1].set = false;
//   assert(true,\"Connector inPort of the CompositeStep has more than 2 connections. It should have only one connection from the outside to the inPort and one connection to a step inside the CompositeStep.\");
//   assert(true,\"Connector outPort of the CompositeStep has more than 2 connections. It should have only one connection from the outPort to the outside to the CompositeStep and one connection from a step inside the CompositeStep to the outPort connector.\");
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   compositeStep.transition2.t_start = 0.0;
//   compositeStep.transition2.t_dummy = 0.0;
//   compositeStep.transition2.t = 0.0;
//   compositeStep.transition2.fire = compositeStep.transition2.enableFire;
//   compositeStep.transition2.enableFire = compositeStep.transition2.localCondition AND compositeStep.transition2.inPort.available AND  NOT compositeStep.transition2.outPort.occupied;
//   compositeStep.transition2.inPort.reset = compositeStep.transition2.fire;
//   compositeStep.transition2.outPort.set = compositeStep.transition2.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   compositeStep.transition3.t_start = 0.0;
//   compositeStep.transition3.t_dummy = 0.0;
//   compositeStep.transition3.t = 0.0;
//   compositeStep.transition3.fire = compositeStep.transition3.enableFire;
//   compositeStep.transition3.enableFire = compositeStep.transition3.localCondition AND compositeStep.transition3.inPort.available AND  NOT compositeStep.transition3.outPort.occupied;
//   compositeStep.transition3.inPort.reset = compositeStep.transition3.fire;
//   compositeStep.transition3.outPort.set = compositeStep.transition3.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   compositeStep.transition4.t_start = 0.0;
//   compositeStep.transition4.t_dummy = 0.0;
//   compositeStep.transition4.t = 0.0;
//   compositeStep.transition4.fire = compositeStep.transition4.enableFire;
//   compositeStep.transition4.enableFire = compositeStep.transition4.localCondition AND compositeStep.transition4.inPort.available AND  NOT compositeStep.transition4.outPort.occupied;
//   compositeStep.transition4.inPort.reset = compositeStep.transition4.fire;
//   compositeStep.transition4.outPort.set = compositeStep.transition4.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   assert(true,\"Connector split[1] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[1] is not connected to exactly one other connector\");
//   assert(true,\"Connector split[2] is not connected to exactly one other connector\");
//   assert(true,\"Connector join[2] is not connected to exactly one other connector\");
//   compositeStep.Alternative1.split[1].available = compositeStep.Alternative1.inPort.available;
//   compositeStep.Alternative1.split[2].available = compositeStep.Alternative1.split[1].available AND  NOT compositeStep.Alternative1.split[1].reset;
//   compositeStep.Alternative1.join[1].occupied = compositeStep.Alternative1.outPort.occupied;
//   compositeStep.Alternative1.join[2].occupied = compositeStep.Alternative1.outPort.occupied;
//   compositeStep.Alternative1.inPort.reset = Modelica.StateGraph.Temporary.anyTrue({compositeStep.Alternative1.split[1].reset,compositeStep.Alternative1.split[2].reset});
//   compositeStep.Alternative1.outPort.set = Modelica.StateGraph.Temporary.anyTrue({compositeStep.Alternative1.join[1].set,compositeStep.Alternative1.join[2].set});
//   compositeStep.outerState.subgraphStatePort.activeSteps = if compositeStep.active then 1.0 else 0.0;
//   compositeStep.activeSteps = -integer(compositeStep.stateGraphRoot.subgraphStatePort.activeSteps);
//   compositeStep.active = pre(compositeStep.newActive);
//   compositeStep.newActive = compositeStep.activeSteps > 0 AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.suspend[1].reset}) AND  NOT compositeStep.outerState.subgraphStatePort.suspend OR Modelica.StateGraph.Temporary.anyTrue({compositeStep.resume[1].set}) OR compositeStep.outerState.subgraphStatePort.resume;
//   compositeStep.resume[1].occupied = compositeStep.active;
//   compositeStep.suspend[1].available = compositeStep.active;
//   assert(true,\"Connector suspend[1] of the CompositeStep is connected to more than one transition\");
//   assert(true,\"Connector resume[1] of the CompositeStep is connected to more than one transition\");
//   assert(true,\"Connector inPort of the CompositeStep has more than 2 connections. It should have only one connection from the outside to the inPort and one connection to a step inside the CompositeStep.\");
//   assert(true,\"Connector outPort of the CompositeStep has more than 2 connections. It should have only one connection from the outPort to the outside to the CompositeStep and one connection from a step inside the CompositeStep to the outPort connector.\");
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   initialStep.localActive = pre(initialStep.newActive);
//   initialStep.newActive = if initialStep.subgraphStatePort.resume then initialStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({initialStep.inPort[1].set}) OR initialStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({initialStep.outPort[1].reset})) AND  NOT initialStep.subgraphStatePort.suspend;
//   when initialStep.subgraphStatePort.suspend then
//   initialStep.oldActive = initialStep.localActive;
//   end when;
//   initialStep.subgraphStatePort.activeSteps = if initialStep.localActive then 1.0 else 0.0;
//   initialStep.inPort[1].occupied = initialStep.localActive;
//   initialStep.outPort[1].available = initialStep.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition1.enableFire then
//   transition1.t_start = time;
//   end when;
//   transition1.t_dummy = time - transition1.t_start;
//   transition1.t = if transition1.enableFire then transition1.t_dummy else 0.0;
//   transition1.fire = transition1.enableFire AND time >= transition1.t_start + transition1.waitTime;
//   transition1.enableFire = transition1.localCondition AND transition1.inPort.available AND  NOT transition1.outPort.occupied;
//   transition1.inPort.reset = transition1.fire;
//   transition1.outPort.set = transition1.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition2.enableFire then
//   transition2.t_start = time;
//   end when;
//   transition2.t_dummy = time - transition2.t_start;
//   transition2.t = if transition2.enableFire then transition2.t_dummy else 0.0;
//   transition2.fire = transition2.enableFire AND time >= transition2.t_start + transition2.waitTime;
//   transition2.enableFire = transition2.localCondition AND transition2.inPort.available AND  NOT transition2.outPort.occupied;
//   transition2.inPort.reset = transition2.fire;
//   transition2.outPort.set = transition2.fire;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition3.enableFire then
//   transition3.t_start = time;
//   end when;
//   transition3.t_dummy = time - transition3.t_start;
//   transition3.t = if transition3.enableFire then transition3.t_dummy else 0.0;
//   transition3.fire = transition3.enableFire AND time >= transition3.t_start + transition3.waitTime;
//   transition3.enableFire = transition3.localCondition AND transition3.inPort.available AND  NOT transition3.outPort.occupied;
//   transition3.inPort.reset = transition3.fire;
//   transition3.outPort.set = transition3.fire;
//   assert(true,\"Connector inPort[1] of the step is connected to more than one transition\");
//   assert(true,\"Connector outPort[1] of the step is connected to more than one transition\");
//   step1.localActive = pre(step1.newActive);
//   step1.newActive = if step1.subgraphStatePort.resume then step1.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step1.inPort[1].set}) OR step1.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({step1.outPort[1].reset})) AND  NOT step1.subgraphStatePort.suspend;
//   when step1.subgraphStatePort.suspend then
//   step1.oldActive = step1.localActive;
//   end when;
//   step1.subgraphStatePort.activeSteps = if step1.localActive then 1.0 else 0.0;
//   step1.inPort[1].occupied = step1.localActive;
//   step1.outPort[1].available = step1.localActive;
//   assert(true,\"Connector inPort is not connected to exactly one other connector\");
//   assert(true,\"Connector outPort is not connected to exactly one other connector\");
//   when transition4.enableFire then
//   transition4.t_start = time;
//   end when;
//   transition4.t_dummy = time - transition4.t_start;
//   transition4.t = if transition4.enableFire then transition4.t_dummy else 0.0;
//   transition4.fire = transition4.enableFire AND time >= transition4.t_start + transition4.waitTime;
//   transition4.enableFire = transition4.localCondition AND transition4.inPort.available AND  NOT transition4.outPort.occupied;
//   transition4.inPort.reset = transition4.fire;
//   transition4.outPort.set = transition4.fire;
//   compositeStep.compositeStep11.initStep.subgraphStatePort.activeSteps + (compositeStep.compositeStep11.exitStep.subgraphStatePort.activeSteps + compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.activeSteps) = 0.0;
//   compositeStep.compositeStep11.initStep.subgraphStatePort.resume = compositeStep.compositeStep11.exitStep.subgraphStatePort.resume;
//   compositeStep.compositeStep11.initStep.subgraphStatePort.resume = compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.compositeStep11.initStep.subgraphStatePort.suspend = compositeStep.compositeStep11.exitStep.subgraphStatePort.suspend;
//   compositeStep.compositeStep11.initStep.subgraphStatePort.suspend = compositeStep.compositeStep11.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.compositeStep12.initStep.subgraphStatePort.activeSteps + (compositeStep.compositeStep12.exitStep.subgraphStatePort.activeSteps + compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.activeSteps) = 0.0;
//   compositeStep.compositeStep12.initStep.subgraphStatePort.resume = compositeStep.compositeStep12.exitStep.subgraphStatePort.resume;
//   compositeStep.compositeStep12.initStep.subgraphStatePort.resume = compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.compositeStep12.initStep.subgraphStatePort.suspend = compositeStep.compositeStep12.exitStep.subgraphStatePort.suspend;
//   compositeStep.compositeStep12.initStep.subgraphStatePort.suspend = compositeStep.compositeStep12.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.initStep.subgraphStatePort.activeSteps + (compositeStep.exitStep.subgraphStatePort.activeSteps + (compositeStep.compositeStep11.outerState.subgraphStatePort.activeSteps + (compositeStep.compositeStep12.outerState.subgraphStatePort.activeSteps + compositeStep.stateGraphRoot.subgraphStatePort.activeSteps))) = 0.0;
//   compositeStep.initStep.subgraphStatePort.resume = compositeStep.exitStep.subgraphStatePort.resume;
//   compositeStep.initStep.subgraphStatePort.resume = compositeStep.compositeStep11.outerState.subgraphStatePort.resume;
//   compositeStep.initStep.subgraphStatePort.resume = compositeStep.compositeStep12.outerState.subgraphStatePort.resume;
//   compositeStep.initStep.subgraphStatePort.resume = compositeStep.stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.initStep.subgraphStatePort.suspend = compositeStep.exitStep.subgraphStatePort.suspend;
//   compositeStep.initStep.subgraphStatePort.suspend = compositeStep.compositeStep11.outerState.subgraphStatePort.suspend;
//   compositeStep.initStep.subgraphStatePort.suspend = compositeStep.compositeStep12.outerState.subgraphStatePort.suspend;
//   compositeStep.initStep.subgraphStatePort.suspend = compositeStep.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.outerState.subgraphStatePort.activeSteps + (initialStep.subgraphStatePort.activeSteps + (step1.subgraphStatePort.activeSteps + stateGraphRoot.subgraphStatePort.activeSteps)) = 0.0;
//   compositeStep.outerState.subgraphStatePort.resume = initialStep.subgraphStatePort.resume;
//   compositeStep.outerState.subgraphStatePort.resume = stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.outerState.subgraphStatePort.resume = step1.subgraphStatePort.resume;
//   compositeStep.outerState.subgraphStatePort.suspend = initialStep.subgraphStatePort.suspend;
//   compositeStep.outerState.subgraphStatePort.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.outerState.subgraphStatePort.suspend = step1.subgraphStatePort.suspend;
//   initialStep.inPort[1].set = transition2.outPort.set;
//   initialStep.inPort[1].occupied = transition2.outPort.occupied;
//   compositeStep.suspend[1].reset = transition3.inPort.reset;
//   compositeStep.suspend[1].available = transition3.inPort.available;
//   compositeStep.resume[1].set = transition4.outPort.set;
//   compositeStep.resume[1].occupied = transition4.outPort.occupied;
//   step1.outPort[1].reset = transition4.inPort.reset;
//   step1.outPort[1].available = transition4.inPort.available;
//   compositeStep.inPort.set = transition1.outPort.set;
//   compositeStep.inPort.occupied = transition1.outPort.occupied;
//   initialStep.outPort[1].reset = transition1.inPort.reset;
//   initialStep.outPort[1].available = transition1.inPort.available;
//   compositeStep.outPort.reset = transition2.inPort.reset;
//   compositeStep.outPort.available = transition2.inPort.available;
//   step1.inPort[1].set = transition3.outPort.set;
//   step1.inPort[1].occupied = transition3.outPort.occupied;
//   compositeStep.Alternative1.join[2].set = compositeStep.transition4.outPort.set;
//   compositeStep.Alternative1.join[2].occupied = compositeStep.transition4.outPort.occupied;
//   compositeStep.Alternative1.join[1].set = compositeStep.transition3.outPort.set;
//   compositeStep.Alternative1.join[1].occupied = compositeStep.transition3.outPort.occupied;
//   compositeStep.Alternative1.split[2].reset = compositeStep.transition2.inPort.reset;
//   compositeStep.Alternative1.split[2].available = compositeStep.transition2.inPort.available;
//   compositeStep.Alternative1.split[1].reset = compositeStep.transition1.inPort.reset;
//   compositeStep.Alternative1.split[1].available = compositeStep.transition1.inPort.available;
//   compositeStep.Alternative1.outPort.set = compositeStep.exitStep.inPort[1].set;
//   compositeStep.Alternative1.outPort.occupied = compositeStep.exitStep.inPort[1].occupied;
//   compositeStep.Alternative1.inPort.reset = compositeStep.initStep.outPort[1].reset;
//   compositeStep.Alternative1.inPort.available = compositeStep.initStep.outPort[1].available;
//   compositeStep.compositeStep12.outPort.reset = compositeStep.transition4.inPort.reset;
//   compositeStep.compositeStep12.outPort.available = compositeStep.transition4.inPort.available;
//   compositeStep.compositeStep11.outPort.reset = compositeStep.transition3.inPort.reset;
//   compositeStep.compositeStep11.outPort.available = compositeStep.transition3.inPort.available;
//   compositeStep.compositeStep12.inPort.set = compositeStep.transition2.outPort.set;
//   compositeStep.compositeStep12.inPort.occupied = compositeStep.transition2.outPort.occupied;
//   compositeStep.compositeStep11.inPort.set = compositeStep.transition1.outPort.set;
//   compositeStep.compositeStep11.inPort.occupied = compositeStep.transition1.outPort.occupied;
//   compositeStep.inPort.set = compositeStep.initStep.inPort[1].set;
//   compositeStep.inPort.occupied = compositeStep.initStep.inPort[1].occupied;
//   compositeStep.exitStep.outPort[1].reset = compositeStep.outPort.reset;
//   compositeStep.exitStep.outPort[1].available = compositeStep.outPort.available;
//   compositeStep.compositeStep12.exitStep.inPort[1].set = compositeStep.compositeStep12.transition.outPort.set;
//   compositeStep.compositeStep12.exitStep.inPort[1].occupied = compositeStep.compositeStep12.transition.outPort.occupied;
//   compositeStep.compositeStep12.initStep.outPort[1].reset = compositeStep.compositeStep12.transition.inPort.reset;
//   compositeStep.compositeStep12.initStep.outPort[1].available = compositeStep.compositeStep12.transition.inPort.available;
//   compositeStep.compositeStep12.inPort.set = compositeStep.compositeStep12.initStep.inPort[1].set;
//   compositeStep.compositeStep12.inPort.occupied = compositeStep.compositeStep12.initStep.inPort[1].occupied;
//   compositeStep.compositeStep12.exitStep.outPort[1].reset = compositeStep.compositeStep12.outPort.reset;
//   compositeStep.compositeStep12.exitStep.outPort[1].available = compositeStep.compositeStep12.outPort.available;
//   compositeStep.compositeStep11.exitStep.inPort[1].set = compositeStep.compositeStep11.transition.outPort.set;
//   compositeStep.compositeStep11.exitStep.inPort[1].occupied = compositeStep.compositeStep11.transition.outPort.occupied;
//   compositeStep.compositeStep11.initStep.outPort[1].reset = compositeStep.compositeStep11.transition.inPort.reset;
//   compositeStep.compositeStep11.initStep.outPort[1].available = compositeStep.compositeStep11.transition.inPort.available;
//   compositeStep.compositeStep11.inPort.set = compositeStep.compositeStep11.initStep.inPort[1].set;
//   compositeStep.compositeStep11.inPort.occupied = compositeStep.compositeStep11.initStep.inPort[1].occupied;
//   compositeStep.compositeStep11.exitStep.outPort[1].reset = compositeStep.compositeStep11.outPort.reset;
//   compositeStep.compositeStep11.exitStep.outPort[1].available = compositeStep.compositeStep11.outPort.available;
// end Modelica.StateGraph.Examples.ShowExceptions;
// "
// ""
// endResult
