//name:         ShowLogicalSources
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadModel(Modelica,{"2.2.1"});
instantiateModel(Modelica.Blocks.Examples.ShowLogicalSources);
getErrorString();
// Result:
// true
// "function Modelica.Blocks.Sources.BooleanTable.getFirstIndex \"Get first index of table and check table\"
//   input Real[:] table \"Vector of time instants\";
//   input Real simulationStartTime(quantity = \"Time\", unit = \"s\") \"Simulation start time\";
//   input Boolean startValue \"Value of y for y < table[1]\";
//   output Integer index \"First index to be used\";
//   output Real nextTime(quantity = \"Time\", unit = \"s\") \"Time instant of first event\";
//   output Boolean y \"Value of y at simulationStartTime\";
//   protected Real t_last(quantity = \"Time\", unit = \"s\");
//   protected Integer j;
//   protected Integer n = size(table,1) \"Number of table points\";
// algorithm
//   if size(table,1) == 0 then
//     index := 0;
//     nextTime := -1e+60;
//     y := startValue;
//   elseif size(table,1) == 1 then
//     index := 1;
//     if table[1] > simulationStartTime then
//       nextTime := table[1];
//       y := startValue;
//     else
//       nextTime := simulationStartTime;
//       y := startValue;
//     end if;
//   else
//     t_last := table[1];
//     for i in 2:n loop
//       assert( table[i] > t_last, \"Time values of table not strict monotonically increasing: table[\" + String(i + -1,0,true) + \"] = \" + String(table[i + -1],0,true,6) + \"table[\" + String(i,0,true) + \"] = \" + String(table[i],0,true,6));
//     end for;
//     j := 1;
//     y := startValue;
//     while j < n and table[j] <= simulationStartTime loop
//       y := not y;
//       j := 1 + j;
//     end while;
//     if j == 1 then
//       nextTime := table[1];
//       y := startValue;
//     elseif j == n and table[n] <= simulationStartTime then
//       nextTime := simulationStartTime + -1.0;
//       y := not y;
//     else
//       nextTime := table[j];
//     end if;
//     index := j;
//   end if;
// end Modelica.Blocks.Sources.BooleanTable.getFirstIndex;
// 
// class Modelica.Blocks.Examples.ShowLogicalSources
//   output Boolean table.y \"Connector of Boolean output signal\";
//   parameter Boolean table.startValue = false \"Start value of y. At time = table[1], y changes to 'not startValue'\";
//   parameter Real table.table[1](quantity = \"Time\", unit = \"s\") = 2.0 \"Vector of time points. At every time point, the output y gets its opposite value\";
//   parameter Real table.table[2](quantity = \"Time\", unit = \"s\") = 4.0 \"Vector of time points. At every time point, the output y gets its opposite value\";
//   parameter Real table.table[3](quantity = \"Time\", unit = \"s\") = 6.0 \"Vector of time points. At every time point, the output y gets its opposite value\";
//   parameter Real table.table[4](quantity = \"Time\", unit = \"s\") = 8.0 \"Vector of time points. At every time point, the output y gets its opposite value\";
//   protected Real table.nextTime(quantity = \"Time\", unit = \"s\");
//   protected Integer table.index \"Index of actual table entry\";
//   protected parameter Integer table.n = 4 \"Number of table points\";
//   output Boolean const.y \"Connector of Boolean output signal\";
//   parameter Boolean const.k = true \"Constant output value\";
//   output Boolean step.y \"Connector of Boolean output signal\";
//   parameter Real step.startTime(quantity = \"Time\", unit = \"s\") = 4.0 \"Time instant of step start\";
//   parameter Boolean step.startValue = false \"Output before startTime\";
//   output Boolean pulse.y \"Connector of Boolean output signal\";
//   parameter Real pulse.width(min = 1e-60, max = 100.0) = 50.0 \"Width of pulse in % of period\";
//   parameter Real pulse.period(quantity = \"Time\", unit = \"s\", min = 1e-60) = 1.5 \"Time for one period\";
//   parameter Real pulse.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Time instant of first pulse\";
//   protected discrete Real pulse.pulsStart(quantity = \"Time\", unit = \"s\") \"Start time of pulse\";
//   protected parameter Real pulse.Twidth(quantity = \"Time\", unit = \"s\") = (pulse.period * pulse.width) / 100.0 \"width of one pulse\";
//   output Boolean sample.y \"Connector of Boolean output signal\";
//   parameter Real sample.period(quantity = \"Time\", unit = \"s\", min = 1e-60) = 0.5 \"Sample period\";
//   parameter Real sample.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Time instant of first sample trigger\";
//   output Boolean booleanExpression.y = pulse.y and step.y \"Value of Boolean output\";
// initial equation
//   pulse.pulsStart = pulse.startTime;
// initial algorithm
//   (table.index, table.nextTime, table.y) := Modelica.Blocks.Sources.BooleanTable.getFirstIndex({table.table[1],table.table[2],table.table[3],table.table[4]},time,table.startValue);
// equation
//   const.y = const.k;
//   step.y = if time >= step.startTime then not step.startValue else step.startValue;
//   when sample(pulse.startTime,pulse.period) then
//   pulse.pulsStart = time;
//   end when;
//   pulse.y = time >= pulse.pulsStart and time < pulse.pulsStart + pulse.Twidth;
//   sample.y = sample(sample.startTime,sample.period);
// algorithm
//   when time >= pre(table.nextTime) and table.n > 0 then
//     if table.index < table.n then
//       table.index := 1 + table.index;
//       table.nextTime := table.table[table.index];
//       table.y := not table.y;
//     elseif table.index == table.n then
//       table.index := 1 + table.index;
//       table.y := not table.y;
//     end if;
//   end when;
// end Modelica.Blocks.Examples.ShowLogicalSources;
// "
// ""
// endResult
