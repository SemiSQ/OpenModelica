//name:         ShowLogicalSources
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.Blocks.Examples.ShowLogicalSources);
getErrorString();
// Result:
// true
// "function Modelica.Blocks.Sources.BooleanTable.getFirstIndex
// input Real[:] table "Vector of time instants";
// input Real simulationStartTime(quantity = "Time", unit = "s") "Simulation start time";
// input Boolean startValue "Value of y for y < table[1]";
// output Integer index "First index to be used";
// output Real nextTime(quantity = "Time", unit = "s") "Time instant of first event";
// output Boolean y "Value of y at simulationStartTime";
// protected Real t_last(quantity = "Time", unit = "s");
// protected Integer j;
// protected Integer n = size(table,1) "Number of table points";
// algorithm
//   if size(table,1) == 0 then
//     index := 0;
//     nextTime := -1e+60;
//     y := startValue;
//   elseif size(table,1) == 1 then
//     index := 1;
//     if table[1] > simulationStartTime then
//       nextTime := table[1];
//       y := startValue;
//     else
//       nextTime := simulationStartTime;
//       y := startValue;
//     end if;
//   else
//     t_last := table[1];
//     for i in 2:n loop
//       assert( table[i] > t_last, "Time values of table not strict monotonically increasing: table[" + String(i - 1,0,true,6) + "] = " + String(table[i - 1],0,true,6) + "table[" + String(i,0,true,6) + "] = " + String(table[i],0,true,6));
//     end for;
//     j := 1;
//     y := startValue;
//     while j < n AND table[j] <= simulationStartTime loop
//       y :=  NOT y;
//       j := 1 + j;
//     end while;
//     if j == 1 then
//       nextTime := table[1];
//       y := startValue;
//     elseif j == n AND table[n] <= simulationStartTime then
//       nextTime := simulationStartTime - 1.0;
//       y :=  NOT y;
//     else
//       nextTime := table[j];
//     end if;
//     index := j;
//   end if;
// end Modelica.Blocks.Sources.BooleanTable.getFirstIndex;
// 
// class Modelica.Blocks.Examples.ShowLogicalSources
// output Boolean table.y "Connector of Boolean output signal";
// parameter Boolean table.startValue = false "Start value of y. At time = table[1], y changes to 'not startValue'";
// parameter Real table.table[1](quantity = "Time", unit = "s") = 2.0 "Vector of time points. At every time point, the output y gets its opposite value";
// parameter Real table.table[2](quantity = "Time", unit = "s") = 4.0 "Vector of time points. At every time point, the output y gets its opposite value";
// parameter Real table.table[3](quantity = "Time", unit = "s") = 6.0 "Vector of time points. At every time point, the output y gets its opposite value";
// parameter Real table.table[4](quantity = "Time", unit = "s") = 8.0 "Vector of time points. At every time point, the output y gets its opposite value";
// protected parameter Integer table.n = 4 "Number of table points";
// protected Real table.nextTime(quantity = "Time", unit = "s");
// protected Integer table.index "Index of actual table entry";
// output Boolean const.y "Connector of Boolean output signal";
// parameter Boolean const.k = true "Constant output value";
// output Boolean step.y "Connector of Boolean output signal";
// parameter Real step.startTime(quantity = "Time", unit = "s") = 4.0 "Time instant of step start";
// parameter Boolean step.startValue = false "Output before startTime";
// output Boolean pulse.y "Connector of Boolean output signal";
// parameter Real pulse.width(min = 1e-60, max = 100.0) = 50.0 "Width of pulse in % of period";
// parameter Real pulse.period(quantity = "Time", unit = "s", min = 1e-60) = 1.5 "Time for one period";
// parameter Real pulse.startTime(quantity = "Time", unit = "s") = 0.0 "Time instant of first pulse";
// protected parameter Real pulse.Twidth(quantity = "Time", unit = "s") = pulse.period * pulse.width / 100.0 "width of one pulse";
// protected discrete Real pulse.pulsStart(quantity = "Time", unit = "s") "Start time of pulse";
// output Boolean sample.y "Connector of Boolean output signal";
// parameter Real sample.period(quantity = "Time", unit = "s", min = 1e-60) = 0.5 "Sample period";
// parameter Real sample.startTime(quantity = "Time", unit = "s") = 0.0 "Time instant of first sample trigger";
// output Boolean booleanExpression.y = pulse.y AND step.y "Value of Boolean output";
// initial equation
//   pulse.pulsStart = pulse.startTime;
// initial algorithm
//   (table.index, table.nextTime, table.y) := Modelica.Blocks.Sources.BooleanTable.getFirstIndex({table.table[1],table.table[2],table.table[3],table.table[4]},time,table.startValue);
// equation
//   const.y = const.k;
//   step.y = if time >= step.startTime then  NOT step.startValue else step.startValue;
//   when sample(pulse.startTime,pulse.period) then
//   pulse.pulsStart = time;
//   end when;
//   pulse.y = time >= pulse.pulsStart AND time < pulse.pulsStart + pulse.Twidth;
//   sample.y = sample(sample.startTime,sample.period);
// algorithm
//   when time >= pre(table.nextTime) AND table.n > 0 then
//     if table.index < table.n then
//       table.index := 1 + table.index;
//       table.nextTime := table.table[table.index];
//       table.y :=  NOT table.y;
//     elseif table.index == table.n then
//       table.index := 1 + table.index;
//       table.y :=  NOT table.y;
//     end if;
//   end when;
// end Modelica.Blocks.Examples.ShowLogicalSources;
// "
// ""
// endResult
