//name:        Modelica.Electrical.Machines.Examples [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Electrical.Machines.Examples
//status:      correct
//env: OPENMODELICALIBRARY=../../../libraries/msl31/
//
// instantiate example
//

loadModel(Modelica); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_DOL); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMC_DOL); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_YD); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMC_YD); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMS_Start); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMS_Start); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.SMEE_Generator); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.SMEE_Generator); getErrorString();

// Result:
// true
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_DOL
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "start time";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 150.843571262114 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aimc.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aimc.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aimc.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aimc.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aimc.Jr) "stator's moment of inertia";
//   output Real aimc.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aimc.flange.phi - aimc.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aimc.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aimc.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aimc.tauElectrical(quantity = "Torque", unit = "N.m") = aimc.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aimc.tauShaft(quantity = "Torque", unit = "N.m") = -aimc.flange.tau "shaft torque";
//   Real aimc.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aimc.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aimc.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aimc.m = 3 "number of phases";
//   parameter Integer aimc.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aimc.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aimc.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aimc.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aimc.vs[1](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[1].v - aimc.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aimc.vs[2](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[2].v - aimc.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aimc.vs[3](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[3].v - aimc.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aimc.is[1](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aimc.is[2](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aimc.is[3](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aimc.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aimc.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aimc.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aimc.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.m(min = 1) = 3 "number of phases";
//   Real aimc.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.rs.plug_p.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.plug_n.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.mh(min = 1) = aimc.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aimc.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aimc.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aimc.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[1].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Reference temperature";
//   parameter Real aimc.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[2].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Reference temperature";
//   parameter Real aimc.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[3].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Reference temperature";
//   parameter Real aimc.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aimc.lssigma.m(min = 1) = 3 "number of phases";
//   Real aimc.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.lssigma.plug_p.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.lssigma.plug_n.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   Real aimc.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[1] "Inductance";
//   Real aimc.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[2] "Inductance";
//   Real aimc.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[3] "Inductance";
//   constant Integer aimc.spacePhasorS.m = 3 "number of phases";
//   constant Real aimc.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aimc.spacePhasorS.turnsRatio = 1.0;
//   Real aimc.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aimc.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aimc.airGapS.m = 3 "number of phases";
//   parameter Integer aimc.airGapS.p(min = 1) = aimc.p "number of pole pairs";
//   output Real aimc.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aimc.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aimc.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.airGapS.Lm(quantity = "Inductance", unit = "H") = aimc.Lm "main field inductance";
//   Real aimc.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aimc.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   protected parameter Real aimc.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   parameter Real aimc.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aimc.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aimc.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "rotor stray inductance (equivalent three phase winding)";
//   parameter Real aimc.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance (equivalent three phase winding)";
//   parameter Real aimc.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = aimc.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real aimc.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = aimc.Rr "warm rotor resistance per phase translated to stator";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aimc.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real booleanStep[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[1].startValue = false "Output before startTime";
//   output Boolean booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real booleanStep[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[2].startValue = false "Output before startTime";
//   output Boolean booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real booleanStep[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[3].startValue = false "Output before startTime";
//   parameter Integer idealCloser.m(min = 1) = 3 "number of phases";
//   Real idealCloser.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer idealCloser.plug_p.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.plug_n.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.mh(min = 1) = idealCloser.m "Number of heatPorts=number of phases";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real idealCloser.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean idealCloser.control[1] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[2] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[3] "true => p--n connected, false => switch open";
//   Real idealCloser.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[1].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[1] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[1] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[1].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[2].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[2] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[2] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[2].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[3].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[3] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[3] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[3].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer TerminalBox1.m = 3 "number of phases";
//   parameter String TerminalBox1.terminalConnection(start = "Y") = "D" "choose Y=star/D=delta";
//   parameter Integer TerminalBox1.plug_sp.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plug_sn.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plugSupply.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer TerminalBox1.delta.plug_p.m(min = 1) = TerminalBox1.delta.m "number of phases";
//   Real TerminalBox1.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.delta.plug_n.m(min = 1) = TerminalBox1.delta.m "number of phases";
//   Real TerminalBox1.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.inertiaRotor.w = der(aimc.inertiaRotor.phi);
//   aimc.inertiaRotor.a = der(aimc.inertiaRotor.w);
//   aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.inertiaRotor.flange_a.tau + aimc.inertiaRotor.flange_b.tau;
//   assert(1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[1].R_actual = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref));
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].i = aimc.rs.resistor[1].p.i;
//   0.0 = aimc.rs.resistor[1].p.i + aimc.rs.resistor[1].n.i;
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].p.v - aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[1].T_heatPort = aimc.rs.resistor[1].T;
//   assert(1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[2].R_actual = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref));
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].i = aimc.rs.resistor[2].p.i;
//   0.0 = aimc.rs.resistor[2].p.i + aimc.rs.resistor[2].n.i;
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].p.v - aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[2].T_heatPort = aimc.rs.resistor[2].T;
//   assert(1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[3].R_actual = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref));
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].i = aimc.rs.resistor[3].p.i;
//   0.0 = aimc.rs.resistor[3].p.i + aimc.rs.resistor[3].n.i;
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].p.v - aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[3].T_heatPort = aimc.rs.resistor[3].T;
//   aimc.rs.v[1] = aimc.rs.plug_p.pin[1].v - aimc.rs.plug_n.pin[1].v;
//   aimc.rs.v[2] = aimc.rs.plug_p.pin[2].v - aimc.rs.plug_n.pin[2].v;
//   aimc.rs.v[3] = aimc.rs.plug_p.pin[3].v - aimc.rs.plug_n.pin[3].v;
//   aimc.rs.i[1] = aimc.rs.plug_p.pin[1].i;
//   aimc.rs.i[2] = aimc.rs.plug_p.pin[2].i;
//   aimc.rs.i[3] = aimc.rs.plug_p.pin[3].i;
//   aimc.lssigma.inductor[1].L * der(aimc.lssigma.inductor[1].i) = aimc.lssigma.inductor[1].v;
//   aimc.lssigma.inductor[1].v = aimc.lssigma.inductor[1].p.v - aimc.lssigma.inductor[1].n.v;
//   0.0 = aimc.lssigma.inductor[1].p.i + aimc.lssigma.inductor[1].n.i;
//   aimc.lssigma.inductor[1].i = aimc.lssigma.inductor[1].p.i;
//   aimc.lssigma.inductor[2].L * der(aimc.lssigma.inductor[2].i) = aimc.lssigma.inductor[2].v;
//   aimc.lssigma.inductor[2].v = aimc.lssigma.inductor[2].p.v - aimc.lssigma.inductor[2].n.v;
//   0.0 = aimc.lssigma.inductor[2].p.i + aimc.lssigma.inductor[2].n.i;
//   aimc.lssigma.inductor[2].i = aimc.lssigma.inductor[2].p.i;
//   aimc.lssigma.inductor[3].L * der(aimc.lssigma.inductor[3].i) = aimc.lssigma.inductor[3].v;
//   aimc.lssigma.inductor[3].v = aimc.lssigma.inductor[3].p.v - aimc.lssigma.inductor[3].n.v;
//   0.0 = aimc.lssigma.inductor[3].p.i + aimc.lssigma.inductor[3].n.i;
//   aimc.lssigma.inductor[3].i = aimc.lssigma.inductor[3].p.i;
//   aimc.lssigma.v[1] = aimc.lssigma.plug_p.pin[1].v - aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.v[2] = aimc.lssigma.plug_p.pin[2].v - aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.v[3] = aimc.lssigma.plug_p.pin[3].v - aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.i[1] = aimc.lssigma.plug_p.pin[1].i;
//   aimc.lssigma.i[2] = aimc.lssigma.plug_p.pin[2].i;
//   aimc.lssigma.i[3] = aimc.lssigma.plug_p.pin[3].i;
//   aimc.spacePhasorS.gnd.p.v = 0.0;
//   aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[1].v - aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[2].v - aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[3].v - aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = aimc.spacePhasorS.plug_p.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = aimc.spacePhasorS.plug_p.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = aimc.spacePhasorS.plug_p.pin[3].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = -aimc.spacePhasorS.plug_n.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = -aimc.spacePhasorS.plug_n.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = -aimc.spacePhasorS.plug_n.pin[3].i;
//   aimc.spacePhasorS.zero.v = 0.333333333333333 * (aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]));
//   aimc.spacePhasorS.spacePhasor.v_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.v[3]);
//   aimc.spacePhasorS.spacePhasor.v_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.v[3]);
//   -aimc.spacePhasorS.zero.i = 0.333333333333333 * (aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]));
//   -aimc.spacePhasorS.spacePhasor.i_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.i[3]);
//   -aimc.spacePhasorS.spacePhasor.i_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.i[3]);
//   aimc.airGapS.i_ms[1] = aimc.airGapS.i_ss[1] + aimc.airGapS.i_rs[1];
//   aimc.airGapS.i_ms[2] = aimc.airGapS.i_ss[2] + aimc.airGapS.i_rs[2];
//   aimc.airGapS.psi_ms[1] = aimc.airGapS.L[1,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[1,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_ms[2] = aimc.airGapS.L[2,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[2,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.gamma = Real(aimc.airGapS.p) * (aimc.airGapS.flange.phi - aimc.airGapS.support.phi);
//   aimc.airGapS.RotationMatrix[1,1] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[1,2] = -sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,1] = sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.i_ss[1] = aimc.airGapS.spacePhasor_s.i_[1];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.spacePhasor_s.i_[2];
//   aimc.airGapS.i_ss[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_rr[1] = aimc.airGapS.spacePhasor_r.i_[1];
//   aimc.airGapS.i_rr[2] = aimc.airGapS.spacePhasor_r.i_[2];
//   aimc.airGapS.i_rs[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.i_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.spacePhasor_s.v_[1] = der(aimc.airGapS.psi_ms[1]);
//   aimc.airGapS.spacePhasor_s.v_[2] = der(aimc.airGapS.psi_ms[2]);
//   aimc.airGapS.spacePhasor_r.v_[1] = der(aimc.airGapS.psi_mr[1]);
//   aimc.airGapS.spacePhasor_r.v_[2] = der(aimc.airGapS.psi_mr[2]);
//   aimc.airGapS.tauElectrical = Real(aimc.airGapS.m) * (Real(aimc.airGapS.p) * (aimc.airGapS.spacePhasor_s.i_[2] * aimc.airGapS.psi_ms[1] - aimc.airGapS.spacePhasor_s.i_[1] * aimc.airGapS.psi_ms[2]) / 2.0);
//   aimc.airGapS.flange.tau = -aimc.airGapS.tauElectrical;
//   aimc.airGapS.support.tau = aimc.airGapS.tauElectrical;
//   aimc.squirrelCageR.spacePhasor_r.v_[1] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[1] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[1]);
//   aimc.squirrelCageR.spacePhasor_r.v_[2] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[2] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[2]);
//   aimc.fixed.flange.phi = aimc.fixed.phi0;
//   assert(aimc.spacePhasorS.plug_n.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(aimc.lssigma.plug_n.m == aimc.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aimc.rs.plug_n.m == aimc.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aimc.plug_sp.m == aimc.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   booleanStep[1].y = if time >= booleanStep[1].startTime then  NOT booleanStep[1].startValue else booleanStep[1].startValue;
//   booleanStep[2].y = if time >= booleanStep[2].startTime then  NOT booleanStep[2].startValue else booleanStep[2].startValue;
//   booleanStep[3].y = if time >= booleanStep[3].startTime then  NOT booleanStep[3].startValue else booleanStep[3].startValue;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then idealCloser.idealClosingSwitch[1].Ron else 1.0);
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then 1.0 else idealCloser.idealClosingSwitch[1].Goff);
//   idealCloser.idealClosingSwitch[1].LossPower = idealCloser.idealClosingSwitch[1].v * idealCloser.idealClosingSwitch[1].i;
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].p.i;
//   0.0 = idealCloser.idealClosingSwitch[1].p.i + idealCloser.idealClosingSwitch[1].n.i;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].p.v - idealCloser.idealClosingSwitch[1].n.v;
//   idealCloser.idealClosingSwitch[1].T_heatPort = idealCloser.idealClosingSwitch[1].T;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then idealCloser.idealClosingSwitch[2].Ron else 1.0);
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then 1.0 else idealCloser.idealClosingSwitch[2].Goff);
//   idealCloser.idealClosingSwitch[2].LossPower = idealCloser.idealClosingSwitch[2].v * idealCloser.idealClosingSwitch[2].i;
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].p.i;
//   0.0 = idealCloser.idealClosingSwitch[2].p.i + idealCloser.idealClosingSwitch[2].n.i;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].p.v - idealCloser.idealClosingSwitch[2].n.v;
//   idealCloser.idealClosingSwitch[2].T_heatPort = idealCloser.idealClosingSwitch[2].T;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then idealCloser.idealClosingSwitch[3].Ron else 1.0);
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then 1.0 else idealCloser.idealClosingSwitch[3].Goff);
//   idealCloser.idealClosingSwitch[3].LossPower = idealCloser.idealClosingSwitch[3].v * idealCloser.idealClosingSwitch[3].i;
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].p.i;
//   0.0 = idealCloser.idealClosingSwitch[3].p.i + idealCloser.idealClosingSwitch[3].n.i;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].p.v - idealCloser.idealClosingSwitch[3].n.v;
//   idealCloser.idealClosingSwitch[3].T_heatPort = idealCloser.idealClosingSwitch[3].T;
//   idealCloser.v[1] = idealCloser.plug_p.pin[1].v - idealCloser.plug_n.pin[1].v;
//   idealCloser.v[2] = idealCloser.plug_p.pin[2].v - idealCloser.plug_n.pin[2].v;
//   idealCloser.v[3] = idealCloser.plug_p.pin[3].v - idealCloser.plug_n.pin[3].v;
//   idealCloser.i[1] = idealCloser.plug_p.pin[1].i;
//   idealCloser.i[2] = idealCloser.plug_p.pin[2].i;
//   idealCloser.i[3] = idealCloser.plug_p.pin[3].i;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(TerminalBox1.plug_sn.m == TerminalBox1.delta.plug_n.m,"automatically generated from connect");
//   assert(TerminalBox1.delta.plug_p.m == TerminalBox1.plug_sp.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sp.m == TerminalBox1.plugSupply.m,"automatically generated from connect");
//   assert(sineVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == idealCloser.plug_p.m,"automatically generated from connect");
//   assert(idealCloser.plug_n.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sn.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sp.m == aimc.plug_sp.m,"automatically generated from connect");
//   assert(TerminalBox1.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   aimc.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aimc.flange.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.flange.phi = loadInertia.flange_a.phi;
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   TerminalBox1.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.delta.plug_p.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.plugSupply.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.plug_sn.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.plug_sp.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[2].v = aimc.plug_sn.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[2].v = aimc.plug_sp.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[2].v = aimc.rs.plug_p.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[2].v = aimc.rs.resistor[3].p.v;
//   TerminalBox1.delta.plug_n.pin[2].v = aimc.spacePhasorS.plug_n.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[2].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   TerminalBox1.delta.plug_n.pin[2].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   TerminalBox1.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.delta.plug_p.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.plugSupply.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.plug_sn.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.plug_sp.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[1].v = aimc.plug_sn.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[1].v = aimc.plug_sp.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[1].v = aimc.rs.plug_p.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[1].v = aimc.rs.resistor[2].p.v;
//   TerminalBox1.delta.plug_n.pin[1].v = aimc.spacePhasorS.plug_n.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[1].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   TerminalBox1.delta.plug_n.pin[1].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   TerminalBox1.delta.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   TerminalBox1.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.delta.plug_p.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.plugSupply.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.plug_sn.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.plug_sp.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[3].v = aimc.plug_sn.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[3].v = aimc.plug_sp.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[3].v = aimc.rs.plug_p.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[3].v = aimc.rs.resistor[1].p.v;
//   TerminalBox1.delta.plug_n.pin[3].v = aimc.spacePhasorS.plug_n.pin[3].v;
//   TerminalBox1.delta.plug_n.pin[3].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   TerminalBox1.delta.plug_n.pin[3].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   TerminalBox1.delta.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   TerminalBox1.plug_sp.pin[3].i + aimc.plug_sp.pin[3].i = 0.0;
//   TerminalBox1.plug_sp.pin[2].i + aimc.plug_sp.pin[2].i = 0.0;
//   TerminalBox1.plug_sp.pin[1].i + aimc.plug_sp.pin[1].i = 0.0;
//   TerminalBox1.plug_sn.pin[3].i + aimc.plug_sn.pin[3].i = 0.0;
//   TerminalBox1.plug_sn.pin[2].i + aimc.plug_sn.pin[2].i = 0.0;
//   TerminalBox1.plug_sn.pin[1].i + aimc.plug_sn.pin[1].i = 0.0;
//   idealCloser.plug_n.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = idealCloser.idealClosingSwitch[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = idealCloser.plug_n.pin[3].v;
//   idealCloser.plug_n.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = idealCloser.idealClosingSwitch[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = idealCloser.plug_n.pin[2].v;
//   idealCloser.plug_n.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = idealCloser.idealClosingSwitch[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = idealCloser.plug_n.pin[1].v;
//   booleanStep[1].y = idealCloser.control[1];
//   booleanStep[1].y = idealCloser.idealClosingSwitch[1].control;
//   booleanStep[2].y = idealCloser.control[2];
//   booleanStep[2].y = idealCloser.idealClosingSwitch[2].control;
//   booleanStep[3].y = idealCloser.control[3];
//   booleanStep[3].y = idealCloser.idealClosingSwitch[3].control;
//   sineVoltage.plug_p.pin[3].i + idealCloser.plug_p.pin[3].i = 0.0;
//   idealCloser.idealClosingSwitch[3].p.v = idealCloser.plug_p.pin[3].v;
//   idealCloser.idealClosingSwitch[3].p.v = sineVoltage.plug_p.pin[3].v;
//   idealCloser.idealClosingSwitch[3].p.v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.plug_p.pin[2].i + idealCloser.plug_p.pin[2].i = 0.0;
//   idealCloser.idealClosingSwitch[2].p.v = idealCloser.plug_p.pin[2].v;
//   idealCloser.idealClosingSwitch[2].p.v = sineVoltage.plug_p.pin[2].v;
//   idealCloser.idealClosingSwitch[2].p.v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.plug_p.pin[1].i + idealCloser.plug_p.pin[1].i = 0.0;
//   idealCloser.idealClosingSwitch[1].p.v = idealCloser.plug_p.pin[1].v;
//   idealCloser.idealClosingSwitch[1].p.v = sineVoltage.plug_p.pin[1].v;
//   idealCloser.idealClosingSwitch[1].p.v = sineVoltage.sineVoltage[1].p.v;
//   sineVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   ground.p.v = sineVoltage.plug_n.pin[1].v;
//   ground.p.v = sineVoltage.plug_n.pin[2].v;
//   ground.p.v = sineVoltage.plug_n.pin[3].v;
//   ground.p.v = sineVoltage.sineVoltage[1].n.v;
//   ground.p.v = sineVoltage.sineVoltage[2].n.v;
//   ground.p.v = sineVoltage.sineVoltage[3].n.v;
//   ground.p.v = star.pin_n.v;
//   ground.p.v = star.plug_p.pin[1].v;
//   ground.p.v = star.plug_p.pin[2].v;
//   ground.p.v = star.plug_p.pin[3].v;
//   sineVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   star.pin_n.i + ground.p.i = 0.0;
//   TerminalBox1.delta.plug_p.pin[3].i + ((-TerminalBox1.plug_sp.pin[3].i) + (-TerminalBox1.plugSupply.pin[3].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[2].i + ((-TerminalBox1.plug_sp.pin[2].i) + (-TerminalBox1.plugSupply.pin[2].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[1].i + ((-TerminalBox1.plug_sp.pin[1].i) + (-TerminalBox1.plugSupply.pin[1].i)) = 0.0;
//   (-TerminalBox1.plug_sn.pin[3].i) + TerminalBox1.delta.plug_n.pin[3].i = 0.0;
//   (-TerminalBox1.plug_sn.pin[2].i) + TerminalBox1.delta.plug_n.pin[2].i = 0.0;
//   (-TerminalBox1.plug_sn.pin[1].i) + TerminalBox1.delta.plug_n.pin[1].i = 0.0;
//   (-TerminalBox1.delta.plug_n.pin[3].i) + (-TerminalBox1.delta.plug_p.pin[1].i) = 0.0;
//   (-TerminalBox1.delta.plug_n.pin[2].i) + (-TerminalBox1.delta.plug_p.pin[3].i) = 0.0;
//   (-TerminalBox1.delta.plug_n.pin[1].i) + (-TerminalBox1.delta.plug_p.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[3].n.i + (-idealCloser.plug_n.pin[3].i) = 0.0;
//   idealCloser.idealClosingSwitch[2].n.i + (-idealCloser.plug_n.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[1].n.i + (-idealCloser.plug_n.pin[1].i) = 0.0;
//   (-idealCloser.plug_p.pin[3].i) + idealCloser.idealClosingSwitch[3].p.i = 0.0;
//   (-idealCloser.plug_p.pin[2].i) + idealCloser.idealClosingSwitch[2].p.i = 0.0;
//   (-idealCloser.plug_p.pin[1].i) + idealCloser.idealClosingSwitch[1].p.i = 0.0;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   aimc.airGapS.support.tau + ((-aimc.internalSupport.tau) + aimc.fixed.flange.tau) = 0.0;
//   aimc.airGapS.support.phi = aimc.fixed.flange.phi;
//   aimc.airGapS.support.phi = aimc.internalSupport.phi;
//   aimc.inertiaRotor.flange_b.tau + (-aimc.flange.tau) = 0.0;
//   (-aimc.plug_sp.pin[3].i) + aimc.rs.plug_p.pin[3].i = 0.0;
//   (-aimc.plug_sp.pin[2].i) + aimc.rs.plug_p.pin[2].i = 0.0;
//   (-aimc.plug_sp.pin[1].i) + aimc.rs.plug_p.pin[1].i = 0.0;
//   aimc.rs.plug_n.pin[3].i + aimc.lssigma.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.inductor[3].p.v = aimc.lssigma.plug_p.pin[3].v;
//   aimc.lssigma.inductor[3].p.v = aimc.rs.plug_n.pin[3].v;
//   aimc.lssigma.inductor[3].p.v = aimc.rs.resistor[3].n.v;
//   aimc.rs.plug_n.pin[2].i + aimc.lssigma.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.inductor[2].p.v = aimc.lssigma.plug_p.pin[2].v;
//   aimc.lssigma.inductor[2].p.v = aimc.rs.plug_n.pin[2].v;
//   aimc.lssigma.inductor[2].p.v = aimc.rs.resistor[2].n.v;
//   aimc.rs.plug_n.pin[1].i + aimc.lssigma.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.inductor[1].p.v = aimc.lssigma.plug_p.pin[1].v;
//   aimc.lssigma.inductor[1].p.v = aimc.rs.plug_n.pin[1].v;
//   aimc.lssigma.inductor[1].p.v = aimc.rs.resistor[1].n.v;
//   aimc.lssigma.plug_n.pin[3].i + aimc.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.inductor[3].n.v = aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.inductor[3].n.v = aimc.spacePhasorS.plug_p.pin[3].v;
//   aimc.lssigma.plug_n.pin[2].i + aimc.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.inductor[2].n.v = aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.inductor[2].n.v = aimc.spacePhasorS.plug_p.pin[2].v;
//   aimc.lssigma.plug_n.pin[1].i + aimc.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.inductor[1].n.v = aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.inductor[1].n.v = aimc.spacePhasorS.plug_p.pin[1].v;
//   aimc.spacePhasorS.plug_n.pin[3].i + (-aimc.plug_sn.pin[3].i) = 0.0;
//   aimc.spacePhasorS.plug_n.pin[2].i + (-aimc.plug_sn.pin[2].i) = 0.0;
//   aimc.spacePhasorS.plug_n.pin[1].i + (-aimc.plug_sn.pin[1].i) = 0.0;
//   aimc.spacePhasorS.ground.i + aimc.spacePhasorS.zero.i = 0.0;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.ground.v;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.zero.v;
//   aimc.airGapS.flange.tau + aimc.inertiaRotor.flange_a.tau = 0.0;
//   aimc.airGapS.flange.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.spacePhasorS.spacePhasor.i_[1] + aimc.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aimc.spacePhasorS.spacePhasor.i_[2] + aimc.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_s.v_[1] = aimc.spacePhasorS.spacePhasor.v_[1];
//   aimc.airGapS.spacePhasor_s.v_[2] = aimc.spacePhasorS.spacePhasor.v_[2];
//   aimc.airGapS.spacePhasor_r.i_[1] + aimc.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   aimc.airGapS.spacePhasor_r.i_[2] + aimc.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_r.v_[1] = aimc.squirrelCageR.spacePhasor_r.v_[1];
//   aimc.airGapS.spacePhasor_r.v_[2] = aimc.squirrelCageR.spacePhasor_r.v_[2];
//   aimc.lssigma.inductor[3].n.i + (-aimc.lssigma.plug_n.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[2].n.i + (-aimc.lssigma.plug_n.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[1].n.i + (-aimc.lssigma.plug_n.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[3].p.i + (-aimc.lssigma.plug_p.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[2].p.i + (-aimc.lssigma.plug_p.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[1].p.i + (-aimc.lssigma.plug_p.pin[1].i) = 0.0;
//   aimc.rs.resistor[3].n.i + (-aimc.rs.plug_n.pin[3].i) = 0.0;
//   aimc.rs.resistor[2].n.i + (-aimc.rs.plug_n.pin[2].i) = 0.0;
//   aimc.rs.resistor[1].n.i + (-aimc.rs.plug_n.pin[1].i) = 0.0;
//   aimc.rs.resistor[3].p.i + (-aimc.rs.plug_p.pin[3].i) = 0.0;
//   aimc.rs.resistor[2].p.i + (-aimc.rs.plug_p.pin[2].i) = 0.0;
//   aimc.rs.resistor[1].p.i + (-aimc.rs.plug_p.pin[1].i) = 0.0;
//   aimc.spacePhasorS.gnd.p.i + (-aimc.spacePhasorS.ground.i) = 0.0;
//   aimc.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_DOL;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMC_DOL completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMC_DOL has 390 equation(s) and 390 variable(s).
// 277 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_YD
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "start time";
//   parameter Real tStart2(quantity = "Time", unit = "s") = 2.0 "2nd start time";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 150.843571262114 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aimc.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aimc.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aimc.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aimc.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aimc.Jr) "stator's moment of inertia";
//   output Real aimc.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aimc.flange.phi - aimc.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aimc.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aimc.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aimc.tauElectrical(quantity = "Torque", unit = "N.m") = aimc.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aimc.tauShaft(quantity = "Torque", unit = "N.m") = -aimc.flange.tau "shaft torque";
//   Real aimc.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aimc.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aimc.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aimc.m = 3 "number of phases";
//   parameter Integer aimc.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aimc.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aimc.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aimc.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aimc.vs[1](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[1].v - aimc.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aimc.vs[2](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[2].v - aimc.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aimc.vs[3](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[3].v - aimc.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aimc.is[1](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aimc.is[2](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aimc.is[3](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aimc.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aimc.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aimc.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aimc.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.m(min = 1) = 3 "number of phases";
//   Real aimc.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.rs.plug_p.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.plug_n.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.mh(min = 1) = aimc.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aimc.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aimc.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aimc.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[1].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Reference temperature";
//   parameter Real aimc.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[2].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Reference temperature";
//   parameter Real aimc.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[3].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Reference temperature";
//   parameter Real aimc.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aimc.lssigma.m(min = 1) = 3 "number of phases";
//   Real aimc.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.lssigma.plug_p.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.lssigma.plug_n.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   Real aimc.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[1] "Inductance";
//   Real aimc.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[2] "Inductance";
//   Real aimc.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[3] "Inductance";
//   constant Integer aimc.spacePhasorS.m = 3 "number of phases";
//   constant Real aimc.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aimc.spacePhasorS.turnsRatio = 1.0;
//   Real aimc.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aimc.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aimc.airGapS.m = 3 "number of phases";
//   parameter Integer aimc.airGapS.p(min = 1) = aimc.p "number of pole pairs";
//   output Real aimc.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aimc.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aimc.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.airGapS.Lm(quantity = "Inductance", unit = "H") = aimc.Lm "main field inductance";
//   Real aimc.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aimc.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   protected parameter Real aimc.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   parameter Real aimc.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aimc.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aimc.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "rotor stray inductance (equivalent three phase winding)";
//   parameter Real aimc.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance (equivalent three phase winding)";
//   parameter Real aimc.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = aimc.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real aimc.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = aimc.Rr "warm rotor resistance per phase translated to stator";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aimc.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real booleanStep[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[1].startValue = false "Output before startTime";
//   output Boolean booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real booleanStep[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[2].startValue = false "Output before startTime";
//   output Boolean booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real booleanStep[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[3].startValue = false "Output before startTime";
//   parameter Integer idealCloser.m(min = 1) = 3 "number of phases";
//   Real idealCloser.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer idealCloser.plug_p.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.plug_n.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.mh(min = 1) = idealCloser.m "Number of heatPorts=number of phases";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real idealCloser.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean idealCloser.control[1] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[2] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[3] "true => p--n connected, false => switch open";
//   Real idealCloser.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[1].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[1] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[1] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[1].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[2].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[2] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[2] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[2].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[3].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[3] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[3] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[3].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   constant Integer switchYD.m = 3 "number of phases";
//   parameter Integer switchYD.plugSupply.m(min = 1) = 3 "number of phases";
//   Real switchYD.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.plug_sp.m(min = 1) = 3 "number of phases";
//   Real switchYD.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.plug_sn.m(min = 1) = 3 "number of phases";
//   Real switchYD.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.star.m(min = 1) = 3 "number of phases";
//   parameter Integer switchYD.star.plug_p.m(min = 1) = switchYD.star.m "number of phases";
//   Real switchYD.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer switchYD.delta.plug_p.m(min = 1) = switchYD.delta.m "number of phases";
//   Real switchYD.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.delta.plug_n.m(min = 1) = switchYD.delta.m "number of phases";
//   Real switchYD.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.idealCommutingSwitch.mh(min = 1) = switchYD.idealCommutingSwitch.m "Number of heatPorts=number of phases";
//   parameter Boolean switchYD.idealCommutingSwitch.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real switchYD.idealCommutingSwitch.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchYD.idealCommutingSwitch.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchYD.idealCommutingSwitch.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Integer switchYD.idealCommutingSwitch.m(min = 1) = 3 "number of phases";
//   parameter Real switchYD.idealCommutingSwitch.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchYD.idealCommutingSwitch.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchYD.idealCommutingSwitch.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean switchYD.idealCommutingSwitch.control[1] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchYD.idealCommutingSwitch.control[2] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchYD.idealCommutingSwitch.control[3] "true => p--n2 connected, false => p--n1 connected";
//   parameter Integer switchYD.idealCommutingSwitch.plug_p.m(min = 1) = switchYD.idealCommutingSwitch.m "number of phases";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.idealCommutingSwitch.plug_n2.m(min = 1) = switchYD.idealCommutingSwitch.m "number of phases";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.idealCommutingSwitch.plug_n1.m(min = 1) = switchYD.idealCommutingSwitch.m "number of phases";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[1].useHeatPort = switchYD.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchYD.idealCommutingSwitch.Ron[1] "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchYD.idealCommutingSwitch.Goff[1] "Opened switch conductance";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s1(unit = "1");
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[2].useHeatPort = switchYD.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchYD.idealCommutingSwitch.Ron[2] "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchYD.idealCommutingSwitch.Goff[2] "Opened switch conductance";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s1(unit = "1");
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[3].useHeatPort = switchYD.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchYD.idealCommutingSwitch.Ron[3] "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchYD.idealCommutingSwitch.Goff[3] "Opened switch conductance";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s1(unit = "1");
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   input Boolean switchYD.control[1];
//   input Boolean switchYD.control[2];
//   input Boolean switchYD.control[3];
//   output Boolean booleanStepYD[1].y "Connector of Boolean output signal";
//   parameter Real booleanStepYD[1].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
//   parameter Boolean booleanStepYD[1].startValue = false "Output before startTime";
//   output Boolean booleanStepYD[2].y "Connector of Boolean output signal";
//   parameter Real booleanStepYD[2].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
//   parameter Boolean booleanStepYD[2].startValue = false "Output before startTime";
//   output Boolean booleanStepYD[3].y "Connector of Boolean output signal";
//   parameter Real booleanStepYD[3].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
//   parameter Boolean booleanStepYD[3].startValue = false "Output before startTime";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
// equation
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.inertiaRotor.w = der(aimc.inertiaRotor.phi);
//   aimc.inertiaRotor.a = der(aimc.inertiaRotor.w);
//   aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.inertiaRotor.flange_a.tau + aimc.inertiaRotor.flange_b.tau;
//   assert(1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[1].R_actual = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref));
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].i = aimc.rs.resistor[1].p.i;
//   0.0 = aimc.rs.resistor[1].p.i + aimc.rs.resistor[1].n.i;
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].p.v - aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[1].T_heatPort = aimc.rs.resistor[1].T;
//   assert(1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[2].R_actual = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref));
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].i = aimc.rs.resistor[2].p.i;
//   0.0 = aimc.rs.resistor[2].p.i + aimc.rs.resistor[2].n.i;
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].p.v - aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[2].T_heatPort = aimc.rs.resistor[2].T;
//   assert(1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[3].R_actual = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref));
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].i = aimc.rs.resistor[3].p.i;
//   0.0 = aimc.rs.resistor[3].p.i + aimc.rs.resistor[3].n.i;
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].p.v - aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[3].T_heatPort = aimc.rs.resistor[3].T;
//   aimc.rs.v[1] = aimc.rs.plug_p.pin[1].v - aimc.rs.plug_n.pin[1].v;
//   aimc.rs.v[2] = aimc.rs.plug_p.pin[2].v - aimc.rs.plug_n.pin[2].v;
//   aimc.rs.v[3] = aimc.rs.plug_p.pin[3].v - aimc.rs.plug_n.pin[3].v;
//   aimc.rs.i[1] = aimc.rs.plug_p.pin[1].i;
//   aimc.rs.i[2] = aimc.rs.plug_p.pin[2].i;
//   aimc.rs.i[3] = aimc.rs.plug_p.pin[3].i;
//   aimc.lssigma.inductor[1].L * der(aimc.lssigma.inductor[1].i) = aimc.lssigma.inductor[1].v;
//   aimc.lssigma.inductor[1].v = aimc.lssigma.inductor[1].p.v - aimc.lssigma.inductor[1].n.v;
//   0.0 = aimc.lssigma.inductor[1].p.i + aimc.lssigma.inductor[1].n.i;
//   aimc.lssigma.inductor[1].i = aimc.lssigma.inductor[1].p.i;
//   aimc.lssigma.inductor[2].L * der(aimc.lssigma.inductor[2].i) = aimc.lssigma.inductor[2].v;
//   aimc.lssigma.inductor[2].v = aimc.lssigma.inductor[2].p.v - aimc.lssigma.inductor[2].n.v;
//   0.0 = aimc.lssigma.inductor[2].p.i + aimc.lssigma.inductor[2].n.i;
//   aimc.lssigma.inductor[2].i = aimc.lssigma.inductor[2].p.i;
//   aimc.lssigma.inductor[3].L * der(aimc.lssigma.inductor[3].i) = aimc.lssigma.inductor[3].v;
//   aimc.lssigma.inductor[3].v = aimc.lssigma.inductor[3].p.v - aimc.lssigma.inductor[3].n.v;
//   0.0 = aimc.lssigma.inductor[3].p.i + aimc.lssigma.inductor[3].n.i;
//   aimc.lssigma.inductor[3].i = aimc.lssigma.inductor[3].p.i;
//   aimc.lssigma.v[1] = aimc.lssigma.plug_p.pin[1].v - aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.v[2] = aimc.lssigma.plug_p.pin[2].v - aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.v[3] = aimc.lssigma.plug_p.pin[3].v - aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.i[1] = aimc.lssigma.plug_p.pin[1].i;
//   aimc.lssigma.i[2] = aimc.lssigma.plug_p.pin[2].i;
//   aimc.lssigma.i[3] = aimc.lssigma.plug_p.pin[3].i;
//   aimc.spacePhasorS.gnd.p.v = 0.0;
//   aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[1].v - aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[2].v - aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[3].v - aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = aimc.spacePhasorS.plug_p.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = aimc.spacePhasorS.plug_p.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = aimc.spacePhasorS.plug_p.pin[3].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = -aimc.spacePhasorS.plug_n.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = -aimc.spacePhasorS.plug_n.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = -aimc.spacePhasorS.plug_n.pin[3].i;
//   aimc.spacePhasorS.zero.v = 0.333333333333333 * (aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]));
//   aimc.spacePhasorS.spacePhasor.v_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.v[3]);
//   aimc.spacePhasorS.spacePhasor.v_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.v[3]);
//   -aimc.spacePhasorS.zero.i = 0.333333333333333 * (aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]));
//   -aimc.spacePhasorS.spacePhasor.i_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.i[3]);
//   -aimc.spacePhasorS.spacePhasor.i_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.i[3]);
//   aimc.airGapS.i_ms[1] = aimc.airGapS.i_ss[1] + aimc.airGapS.i_rs[1];
//   aimc.airGapS.i_ms[2] = aimc.airGapS.i_ss[2] + aimc.airGapS.i_rs[2];
//   aimc.airGapS.psi_ms[1] = aimc.airGapS.L[1,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[1,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_ms[2] = aimc.airGapS.L[2,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[2,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.gamma = Real(aimc.airGapS.p) * (aimc.airGapS.flange.phi - aimc.airGapS.support.phi);
//   aimc.airGapS.RotationMatrix[1,1] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[1,2] = -sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,1] = sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.i_ss[1] = aimc.airGapS.spacePhasor_s.i_[1];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.spacePhasor_s.i_[2];
//   aimc.airGapS.i_ss[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_rr[1] = aimc.airGapS.spacePhasor_r.i_[1];
//   aimc.airGapS.i_rr[2] = aimc.airGapS.spacePhasor_r.i_[2];
//   aimc.airGapS.i_rs[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.i_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.spacePhasor_s.v_[1] = der(aimc.airGapS.psi_ms[1]);
//   aimc.airGapS.spacePhasor_s.v_[2] = der(aimc.airGapS.psi_ms[2]);
//   aimc.airGapS.spacePhasor_r.v_[1] = der(aimc.airGapS.psi_mr[1]);
//   aimc.airGapS.spacePhasor_r.v_[2] = der(aimc.airGapS.psi_mr[2]);
//   aimc.airGapS.tauElectrical = Real(aimc.airGapS.m) * (Real(aimc.airGapS.p) * (aimc.airGapS.spacePhasor_s.i_[2] * aimc.airGapS.psi_ms[1] - aimc.airGapS.spacePhasor_s.i_[1] * aimc.airGapS.psi_ms[2]) / 2.0);
//   aimc.airGapS.flange.tau = -aimc.airGapS.tauElectrical;
//   aimc.airGapS.support.tau = aimc.airGapS.tauElectrical;
//   aimc.squirrelCageR.spacePhasor_r.v_[1] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[1] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[1]);
//   aimc.squirrelCageR.spacePhasor_r.v_[2] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[2] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[2]);
//   aimc.fixed.flange.phi = aimc.fixed.phi0;
//   assert(aimc.spacePhasorS.plug_n.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(aimc.lssigma.plug_n.m == aimc.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aimc.rs.plug_n.m == aimc.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aimc.plug_sp.m == aimc.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   booleanStep[1].y = if time >= booleanStep[1].startTime then  NOT booleanStep[1].startValue else booleanStep[1].startValue;
//   booleanStep[2].y = if time >= booleanStep[2].startTime then  NOT booleanStep[2].startValue else booleanStep[2].startValue;
//   booleanStep[3].y = if time >= booleanStep[3].startTime then  NOT booleanStep[3].startValue else booleanStep[3].startValue;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then idealCloser.idealClosingSwitch[1].Ron else 1.0);
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then 1.0 else idealCloser.idealClosingSwitch[1].Goff);
//   idealCloser.idealClosingSwitch[1].LossPower = idealCloser.idealClosingSwitch[1].v * idealCloser.idealClosingSwitch[1].i;
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].p.i;
//   0.0 = idealCloser.idealClosingSwitch[1].p.i + idealCloser.idealClosingSwitch[1].n.i;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].p.v - idealCloser.idealClosingSwitch[1].n.v;
//   idealCloser.idealClosingSwitch[1].T_heatPort = idealCloser.idealClosingSwitch[1].T;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then idealCloser.idealClosingSwitch[2].Ron else 1.0);
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then 1.0 else idealCloser.idealClosingSwitch[2].Goff);
//   idealCloser.idealClosingSwitch[2].LossPower = idealCloser.idealClosingSwitch[2].v * idealCloser.idealClosingSwitch[2].i;
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].p.i;
//   0.0 = idealCloser.idealClosingSwitch[2].p.i + idealCloser.idealClosingSwitch[2].n.i;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].p.v - idealCloser.idealClosingSwitch[2].n.v;
//   idealCloser.idealClosingSwitch[2].T_heatPort = idealCloser.idealClosingSwitch[2].T;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then idealCloser.idealClosingSwitch[3].Ron else 1.0);
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then 1.0 else idealCloser.idealClosingSwitch[3].Goff);
//   idealCloser.idealClosingSwitch[3].LossPower = idealCloser.idealClosingSwitch[3].v * idealCloser.idealClosingSwitch[3].i;
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].p.i;
//   0.0 = idealCloser.idealClosingSwitch[3].p.i + idealCloser.idealClosingSwitch[3].n.i;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].p.v - idealCloser.idealClosingSwitch[3].n.v;
//   idealCloser.idealClosingSwitch[3].T_heatPort = idealCloser.idealClosingSwitch[3].T;
//   idealCloser.v[1] = idealCloser.plug_p.pin[1].v - idealCloser.plug_n.pin[1].v;
//   idealCloser.v[2] = idealCloser.plug_p.pin[2].v - idealCloser.plug_n.pin[2].v;
//   idealCloser.v[3] = idealCloser.plug_p.pin[3].v - idealCloser.plug_n.pin[3].v;
//   idealCloser.i[1] = idealCloser.plug_p.pin[1].i;
//   idealCloser.i[2] = idealCloser.plug_p.pin[2].i;
//   idealCloser.i[3] = idealCloser.plug_p.pin[3].i;
//   0.0 = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i + (switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s1 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Ron);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s1) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Goff else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s2 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Ron else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s2) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Goff);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].LossPower = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v + (switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v + switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T;
//   0.0 = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i + (switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s1 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Ron);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s1) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Goff else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s2 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Ron else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s2) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Goff);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].LossPower = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v + (switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v + switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T;
//   0.0 = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i + (switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s1 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Ron);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s1) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Goff else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s2 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Ron else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s2) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Goff);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].LossPower = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v + (switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v + switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T;
//   assert(switchYD.delta.plug_p.m == switchYD.plugSupply.m,"automatically generated from connect");
//   assert(switchYD.delta.plug_p.m == switchYD.plug_sp.m,"automatically generated from connect");
//   assert(switchYD.idealCommutingSwitch.plug_n2.m == switchYD.delta.plug_n.m,"automatically generated from connect");
//   assert(switchYD.idealCommutingSwitch.plug_n1.m == switchYD.star.plug_p.m,"automatically generated from connect");
//   assert(switchYD.idealCommutingSwitch.plug_p.m == switchYD.plug_sn.m,"automatically generated from connect");
//   booleanStepYD[1].y = if time >= booleanStepYD[1].startTime then  NOT booleanStepYD[1].startValue else booleanStepYD[1].startValue;
//   booleanStepYD[2].y = if time >= booleanStepYD[2].startTime then  NOT booleanStepYD[2].startValue else booleanStepYD[2].startValue;
//   booleanStepYD[3].y = if time >= booleanStepYD[3].startTime then  NOT booleanStepYD[3].startValue else booleanStepYD[3].startValue;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(sineVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == idealCloser.plug_p.m,"automatically generated from connect");
//   assert(idealCloser.plug_n.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(switchYD.plug_sn.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(switchYD.plug_sp.m == aimc.plug_sp.m,"automatically generated from connect");
//   assert(switchYD.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   aimc.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aimc.flange.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.flange.phi = loadInertia.flange_a.phi;
//   switchYD.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = aimc.rs.plug_p.pin[3].v;
//   aimc.plug_sp.pin[3].v = aimc.rs.resistor[3].p.v;
//   aimc.plug_sp.pin[3].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   aimc.plug_sp.pin[3].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   aimc.plug_sp.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   aimc.plug_sp.pin[3].v = switchYD.delta.plug_n.pin[2].v;
//   aimc.plug_sp.pin[3].v = switchYD.delta.plug_p.pin[3].v;
//   aimc.plug_sp.pin[3].v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v;
//   aimc.plug_sp.pin[3].v = switchYD.idealCommutingSwitch.plug_n2.pin[2].v;
//   aimc.plug_sp.pin[3].v = switchYD.plugSupply.pin[3].v;
//   aimc.plug_sp.pin[3].v = switchYD.plug_sp.pin[3].v;
//   switchYD.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = aimc.rs.plug_p.pin[2].v;
//   aimc.plug_sp.pin[2].v = aimc.rs.resistor[2].p.v;
//   aimc.plug_sp.pin[2].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   aimc.plug_sp.pin[2].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   aimc.plug_sp.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   aimc.plug_sp.pin[2].v = switchYD.delta.plug_n.pin[1].v;
//   aimc.plug_sp.pin[2].v = switchYD.delta.plug_p.pin[2].v;
//   aimc.plug_sp.pin[2].v = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v;
//   aimc.plug_sp.pin[2].v = switchYD.idealCommutingSwitch.plug_n2.pin[1].v;
//   aimc.plug_sp.pin[2].v = switchYD.plugSupply.pin[2].v;
//   aimc.plug_sp.pin[2].v = switchYD.plug_sp.pin[2].v;
//   switchYD.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = aimc.rs.plug_p.pin[1].v;
//   aimc.plug_sp.pin[1].v = aimc.rs.resistor[1].p.v;
//   aimc.plug_sp.pin[1].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   aimc.plug_sp.pin[1].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   aimc.plug_sp.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   aimc.plug_sp.pin[1].v = switchYD.delta.plug_n.pin[3].v;
//   aimc.plug_sp.pin[1].v = switchYD.delta.plug_p.pin[1].v;
//   aimc.plug_sp.pin[1].v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v;
//   aimc.plug_sp.pin[1].v = switchYD.idealCommutingSwitch.plug_n2.pin[3].v;
//   aimc.plug_sp.pin[1].v = switchYD.plugSupply.pin[1].v;
//   aimc.plug_sp.pin[1].v = switchYD.plug_sp.pin[1].v;
//   switchYD.plug_sp.pin[3].i + aimc.plug_sp.pin[3].i = 0.0;
//   switchYD.plug_sp.pin[2].i + aimc.plug_sp.pin[2].i = 0.0;
//   switchYD.plug_sp.pin[1].i + aimc.plug_sp.pin[1].i = 0.0;
//   switchYD.plug_sn.pin[3].i + aimc.plug_sn.pin[3].i = 0.0;
//   aimc.plug_sn.pin[3].v = aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.plug_sn.pin[3].v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v;
//   aimc.plug_sn.pin[3].v = switchYD.idealCommutingSwitch.plug_p.pin[3].v;
//   aimc.plug_sn.pin[3].v = switchYD.plug_sn.pin[3].v;
//   switchYD.plug_sn.pin[2].i + aimc.plug_sn.pin[2].i = 0.0;
//   aimc.plug_sn.pin[2].v = aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.plug_sn.pin[2].v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v;
//   aimc.plug_sn.pin[2].v = switchYD.idealCommutingSwitch.plug_p.pin[2].v;
//   aimc.plug_sn.pin[2].v = switchYD.plug_sn.pin[2].v;
//   switchYD.plug_sn.pin[1].i + aimc.plug_sn.pin[1].i = 0.0;
//   aimc.plug_sn.pin[1].v = aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.plug_sn.pin[1].v = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v;
//   aimc.plug_sn.pin[1].v = switchYD.idealCommutingSwitch.plug_p.pin[1].v;
//   aimc.plug_sn.pin[1].v = switchYD.plug_sn.pin[1].v;
//   idealCloser.plug_n.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = idealCloser.idealClosingSwitch[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = idealCloser.plug_n.pin[3].v;
//   idealCloser.plug_n.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = idealCloser.idealClosingSwitch[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = idealCloser.plug_n.pin[2].v;
//   idealCloser.plug_n.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = idealCloser.idealClosingSwitch[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = idealCloser.plug_n.pin[1].v;
//   booleanStepYD[1].y = switchYD.control[1];
//   booleanStepYD[1].y = switchYD.idealCommutingSwitch.control[1];
//   booleanStepYD[1].y = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control;
//   booleanStepYD[2].y = switchYD.control[2];
//   booleanStepYD[2].y = switchYD.idealCommutingSwitch.control[2];
//   booleanStepYD[2].y = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control;
//   booleanStepYD[3].y = switchYD.control[3];
//   booleanStepYD[3].y = switchYD.idealCommutingSwitch.control[3];
//   booleanStepYD[3].y = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control;
//   booleanStep[1].y = idealCloser.control[1];
//   booleanStep[1].y = idealCloser.idealClosingSwitch[1].control;
//   booleanStep[2].y = idealCloser.control[2];
//   booleanStep[2].y = idealCloser.idealClosingSwitch[2].control;
//   booleanStep[3].y = idealCloser.control[3];
//   booleanStep[3].y = idealCloser.idealClosingSwitch[3].control;
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   sineVoltage.plug_p.pin[3].i + idealCloser.plug_p.pin[3].i = 0.0;
//   idealCloser.idealClosingSwitch[3].p.v = idealCloser.plug_p.pin[3].v;
//   idealCloser.idealClosingSwitch[3].p.v = sineVoltage.plug_p.pin[3].v;
//   idealCloser.idealClosingSwitch[3].p.v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.plug_p.pin[2].i + idealCloser.plug_p.pin[2].i = 0.0;
//   idealCloser.idealClosingSwitch[2].p.v = idealCloser.plug_p.pin[2].v;
//   idealCloser.idealClosingSwitch[2].p.v = sineVoltage.plug_p.pin[2].v;
//   idealCloser.idealClosingSwitch[2].p.v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.plug_p.pin[1].i + idealCloser.plug_p.pin[1].i = 0.0;
//   idealCloser.idealClosingSwitch[1].p.v = idealCloser.plug_p.pin[1].v;
//   idealCloser.idealClosingSwitch[1].p.v = sineVoltage.plug_p.pin[1].v;
//   idealCloser.idealClosingSwitch[1].p.v = sineVoltage.sineVoltage[1].p.v;
//   sineVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   ground.p.v = sineVoltage.plug_n.pin[1].v;
//   ground.p.v = sineVoltage.plug_n.pin[2].v;
//   ground.p.v = sineVoltage.plug_n.pin[3].v;
//   ground.p.v = sineVoltage.sineVoltage[1].n.v;
//   ground.p.v = sineVoltage.sineVoltage[2].n.v;
//   ground.p.v = sineVoltage.sineVoltage[3].n.v;
//   ground.p.v = star.pin_n.v;
//   ground.p.v = star.plug_p.pin[1].v;
//   ground.p.v = star.plug_p.pin[2].v;
//   ground.p.v = star.plug_p.pin[3].v;
//   sineVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   star.pin_n.i + ground.p.i = 0.0;
//   switchYD.idealCommutingSwitch.plug_p.pin[3].i + (-switchYD.plug_sn.pin[3].i) = 0.0;
//   switchYD.idealCommutingSwitch.plug_p.pin[2].i + (-switchYD.plug_sn.pin[2].i) = 0.0;
//   switchYD.idealCommutingSwitch.plug_p.pin[1].i + (-switchYD.plug_sn.pin[1].i) = 0.0;
//   switchYD.idealCommutingSwitch.plug_n1.pin[3].i + switchYD.star.plug_p.pin[3].i = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.plug_n1.pin[1].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.plug_n1.pin[2].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.plug_n1.pin[3].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.star.pin_n.v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.star.plug_p.pin[1].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.star.plug_p.pin[2].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.star.plug_p.pin[3].v;
//   switchYD.idealCommutingSwitch.plug_n1.pin[2].i + switchYD.star.plug_p.pin[2].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n1.pin[1].i + switchYD.star.plug_p.pin[1].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n2.pin[3].i + switchYD.delta.plug_n.pin[3].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n2.pin[2].i + switchYD.delta.plug_n.pin[2].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n2.pin[1].i + switchYD.delta.plug_n.pin[1].i = 0.0;
//   switchYD.delta.plug_p.pin[3].i + ((-switchYD.plugSupply.pin[3].i) + (-switchYD.plug_sp.pin[3].i)) = 0.0;
//   switchYD.delta.plug_p.pin[2].i + ((-switchYD.plugSupply.pin[2].i) + (-switchYD.plug_sp.pin[2].i)) = 0.0;
//   switchYD.delta.plug_p.pin[1].i + ((-switchYD.plugSupply.pin[1].i) + (-switchYD.plug_sp.pin[1].i)) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i + (-switchYD.idealCommutingSwitch.plug_n1.pin[3].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i + (-switchYD.idealCommutingSwitch.plug_n1.pin[2].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i + (-switchYD.idealCommutingSwitch.plug_n1.pin[1].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + (-switchYD.idealCommutingSwitch.plug_n2.pin[3].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + (-switchYD.idealCommutingSwitch.plug_n2.pin[2].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + (-switchYD.idealCommutingSwitch.plug_n2.pin[1].i) = 0.0;
//   (-switchYD.idealCommutingSwitch.plug_p.pin[3].i) + switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i = 0.0;
//   (-switchYD.idealCommutingSwitch.plug_p.pin[2].i) + switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i = 0.0;
//   (-switchYD.idealCommutingSwitch.plug_p.pin[1].i) + switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i = 0.0;
//   (-switchYD.delta.plug_n.pin[3].i) + (-switchYD.delta.plug_p.pin[1].i) = 0.0;
//   (-switchYD.delta.plug_n.pin[2].i) + (-switchYD.delta.plug_p.pin[3].i) = 0.0;
//   (-switchYD.delta.plug_n.pin[1].i) + (-switchYD.delta.plug_p.pin[2].i) = 0.0;
//   (-switchYD.star.plug_p.pin[3].i) + ((-switchYD.star.plug_p.pin[2].i) + ((-switchYD.star.plug_p.pin[1].i) + (-switchYD.star.pin_n.i))) = 0.0;
//   switchYD.star.pin_n.i = 0.0;
//   idealCloser.idealClosingSwitch[3].n.i + (-idealCloser.plug_n.pin[3].i) = 0.0;
//   idealCloser.idealClosingSwitch[2].n.i + (-idealCloser.plug_n.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[1].n.i + (-idealCloser.plug_n.pin[1].i) = 0.0;
//   (-idealCloser.plug_p.pin[3].i) + idealCloser.idealClosingSwitch[3].p.i = 0.0;
//   (-idealCloser.plug_p.pin[2].i) + idealCloser.idealClosingSwitch[2].p.i = 0.0;
//   (-idealCloser.plug_p.pin[1].i) + idealCloser.idealClosingSwitch[1].p.i = 0.0;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   aimc.airGapS.support.tau + ((-aimc.internalSupport.tau) + aimc.fixed.flange.tau) = 0.0;
//   aimc.airGapS.support.phi = aimc.fixed.flange.phi;
//   aimc.airGapS.support.phi = aimc.internalSupport.phi;
//   aimc.inertiaRotor.flange_b.tau + (-aimc.flange.tau) = 0.0;
//   (-aimc.plug_sp.pin[3].i) + aimc.rs.plug_p.pin[3].i = 0.0;
//   (-aimc.plug_sp.pin[2].i) + aimc.rs.plug_p.pin[2].i = 0.0;
//   (-aimc.plug_sp.pin[1].i) + aimc.rs.plug_p.pin[1].i = 0.0;
//   aimc.rs.plug_n.pin[3].i + aimc.lssigma.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.inductor[3].p.v = aimc.lssigma.plug_p.pin[3].v;
//   aimc.lssigma.inductor[3].p.v = aimc.rs.plug_n.pin[3].v;
//   aimc.lssigma.inductor[3].p.v = aimc.rs.resistor[3].n.v;
//   aimc.rs.plug_n.pin[2].i + aimc.lssigma.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.inductor[2].p.v = aimc.lssigma.plug_p.pin[2].v;
//   aimc.lssigma.inductor[2].p.v = aimc.rs.plug_n.pin[2].v;
//   aimc.lssigma.inductor[2].p.v = aimc.rs.resistor[2].n.v;
//   aimc.rs.plug_n.pin[1].i + aimc.lssigma.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.inductor[1].p.v = aimc.lssigma.plug_p.pin[1].v;
//   aimc.lssigma.inductor[1].p.v = aimc.rs.plug_n.pin[1].v;
//   aimc.lssigma.inductor[1].p.v = aimc.rs.resistor[1].n.v;
//   aimc.lssigma.plug_n.pin[3].i + aimc.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.inductor[3].n.v = aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.inductor[3].n.v = aimc.spacePhasorS.plug_p.pin[3].v;
//   aimc.lssigma.plug_n.pin[2].i + aimc.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.inductor[2].n.v = aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.inductor[2].n.v = aimc.spacePhasorS.plug_p.pin[2].v;
//   aimc.lssigma.plug_n.pin[1].i + aimc.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.inductor[1].n.v = aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.inductor[1].n.v = aimc.spacePhasorS.plug_p.pin[1].v;
//   aimc.spacePhasorS.plug_n.pin[3].i + (-aimc.plug_sn.pin[3].i) = 0.0;
//   aimc.spacePhasorS.plug_n.pin[2].i + (-aimc.plug_sn.pin[2].i) = 0.0;
//   aimc.spacePhasorS.plug_n.pin[1].i + (-aimc.plug_sn.pin[1].i) = 0.0;
//   aimc.spacePhasorS.ground.i + aimc.spacePhasorS.zero.i = 0.0;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.ground.v;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.zero.v;
//   aimc.airGapS.flange.tau + aimc.inertiaRotor.flange_a.tau = 0.0;
//   aimc.airGapS.flange.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.spacePhasorS.spacePhasor.i_[1] + aimc.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aimc.spacePhasorS.spacePhasor.i_[2] + aimc.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_s.v_[1] = aimc.spacePhasorS.spacePhasor.v_[1];
//   aimc.airGapS.spacePhasor_s.v_[2] = aimc.spacePhasorS.spacePhasor.v_[2];
//   aimc.airGapS.spacePhasor_r.i_[1] + aimc.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   aimc.airGapS.spacePhasor_r.i_[2] + aimc.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_r.v_[1] = aimc.squirrelCageR.spacePhasor_r.v_[1];
//   aimc.airGapS.spacePhasor_r.v_[2] = aimc.squirrelCageR.spacePhasor_r.v_[2];
//   aimc.lssigma.inductor[3].n.i + (-aimc.lssigma.plug_n.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[2].n.i + (-aimc.lssigma.plug_n.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[1].n.i + (-aimc.lssigma.plug_n.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[3].p.i + (-aimc.lssigma.plug_p.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[2].p.i + (-aimc.lssigma.plug_p.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[1].p.i + (-aimc.lssigma.plug_p.pin[1].i) = 0.0;
//   aimc.rs.resistor[3].n.i + (-aimc.rs.plug_n.pin[3].i) = 0.0;
//   aimc.rs.resistor[2].n.i + (-aimc.rs.plug_n.pin[2].i) = 0.0;
//   aimc.rs.resistor[1].n.i + (-aimc.rs.plug_n.pin[1].i) = 0.0;
//   aimc.rs.resistor[3].p.i + (-aimc.rs.plug_p.pin[3].i) = 0.0;
//   aimc.rs.resistor[2].p.i + (-aimc.rs.plug_p.pin[2].i) = 0.0;
//   aimc.rs.resistor[1].p.i + (-aimc.rs.plug_p.pin[1].i) = 0.0;
//   aimc.spacePhasorS.gnd.p.i + (-aimc.spacePhasorS.ground.i) = 0.0;
//   aimc.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_YD;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMC_YD completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMC_YD has 458 equation(s) and 458 variable(s).
// 323 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMS_Start
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "1st start time";
//   parameter Real Rstart(quantity = "Resistance", unit = "Ohm") = 0.16 "starting resistance";
//   parameter Real tStart2(quantity = "Time", unit = "s") = 1.0 "2nd start time";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 150.843571262114 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aims.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aims.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aims.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aims.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aims.Jr) "stator's moment of inertia";
//   output Real aims.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aims.flange.phi - aims.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aims.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aims.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aims.tauElectrical(quantity = "Torque", unit = "N.m") = aims.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aims.tauShaft(quantity = "Torque", unit = "N.m") = -aims.flange.tau "shaft torque";
//   Real aims.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aims.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aims.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aims.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aims.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aims.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aims.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aims.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aims.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aims.m = 3 "number of phases";
//   parameter Integer aims.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aims.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aims.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aims.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aims.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aims.vs[1](quantity = "ElectricPotential", unit = "V") = aims.plug_sp.pin[1].v - aims.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aims.vs[2](quantity = "ElectricPotential", unit = "V") = aims.plug_sp.pin[2].v - aims.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aims.vs[3](quantity = "ElectricPotential", unit = "V") = aims.plug_sp.pin[3].v - aims.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aims.is[1](quantity = "ElectricCurrent", unit = "A") = aims.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aims.is[2](quantity = "ElectricCurrent", unit = "A") = aims.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aims.is[3](quantity = "ElectricCurrent", unit = "A") = aims.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aims.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aims.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aims.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aims.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aims.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aims.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aims.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aims.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aims.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aims.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aims.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aims.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rs.m(min = 1) = 3 "number of phases";
//   Real aims.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.rs.plug_p.m(min = 1) = aims.rs.m "number of phases";
//   Real aims.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rs.plug_n.m(min = 1) = aims.rs.m "number of phases";
//   Real aims.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rs.mh(min = 1) = aims.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aims.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aims.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aims.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rs.resistor[1].useHeatPort = aims.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aims.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aims.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[1] "Reference temperature";
//   parameter Real aims.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rs.resistor[2].useHeatPort = aims.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aims.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aims.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[2] "Reference temperature";
//   parameter Real aims.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rs.resistor[3].useHeatPort = aims.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aims.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aims.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[3] "Reference temperature";
//   parameter Real aims.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aims.lssigma.m(min = 1) = 3 "number of phases";
//   Real aims.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.lssigma.plug_p.m(min = 1) = aims.lssigma.m "number of phases";
//   Real aims.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.lssigma.plug_n.m(min = 1) = aims.lssigma.m "number of phases";
//   Real aims.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lssigma "Inductance";
//   parameter Real aims.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lssigma "Inductance";
//   parameter Real aims.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lssigma "Inductance";
//   Real aims.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lssigma.L[1] "Inductance";
//   Real aims.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lssigma.L[2] "Inductance";
//   Real aims.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lssigma.L[3] "Inductance";
//   constant Integer aims.spacePhasorS.m = 3 "number of phases";
//   constant Real aims.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aims.spacePhasorS.turnsRatio = 1.0;
//   Real aims.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aims.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aims.airGapS.m = 3 "number of phases";
//   parameter Integer aims.airGapS.p(min = 1) = aims.p "number of pole pairs";
//   output Real aims.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aims.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aims.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aims.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aims.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aims.airGapS.Lm(quantity = "Inductance", unit = "H") = aims.Lm "main field inductance";
//   Real aims.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aims.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aims.airGapS.Lm "inductance matrix";
//   protected parameter Real aims.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aims.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aims.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aims.airGapS.Lm "inductance matrix";
//   parameter Real aims.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aims.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aims.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aims.fsNominal / 6.28318530717959) "rotor stray inductance per phase";
//   parameter Real aims.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance per phase";
//   parameter Boolean aims.useTurnsRatio(start = true) "use turnsRatio or calculate from locked-rotor voltage?";
//   parameter Real aims.turnsRatio(min = 1e-60, start = 1.0) "Effective number of stator turns / effective number of rotor turns";
//   parameter Real aims.VsNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal stator voltage per phase";
//   parameter Real aims.VrLockedRotor(quantity = "ElectricPotential", unit = "V", start = 628.318530717959 * (aims.fsNominal * aims.Lm / sqrt(aims.Rs ^ 2.0 + 39.4784176043574 * (aims.fsNominal ^ 2.0 * (aims.Lm + aims.Lssigma) ^ 2.0)))) "locked-rotor voltage per phase";
//   output Real aims.i_0_r(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.spacePhasorR.zero.i "rotor zero-sequence current";
//   output Real aims.vr[1](quantity = "ElectricPotential", unit = "V") = aims.plug_rp.pin[1].v - aims.plug_rn.pin[1].v "rotor instantaneous voltages";
//   output Real aims.vr[2](quantity = "ElectricPotential", unit = "V") = aims.plug_rp.pin[2].v - aims.plug_rn.pin[2].v "rotor instantaneous voltages";
//   output Real aims.vr[3](quantity = "ElectricPotential", unit = "V") = aims.plug_rp.pin[3].v - aims.plug_rn.pin[3].v "rotor instantaneous voltages";
//   output Real aims.ir[1](quantity = "ElectricCurrent", unit = "A") = aims.plug_rp.pin[1].i "rotor instantaneous currents";
//   output Real aims.ir[2](quantity = "ElectricCurrent", unit = "A") = aims.plug_rp.pin[2].i "rotor instantaneous currents";
//   output Real aims.ir[3](quantity = "ElectricCurrent", unit = "A") = aims.plug_rp.pin[3].i "rotor instantaneous currents";
//   protected parameter Real aims.internalTurnsRatio = if aims.useTurnsRatio then aims.turnsRatio else 6.28318530717959 * (aims.VsNominal * (aims.fsNominal * (aims.Lm * 1.0 / sqrt(aims.Rs ^ 2.0 + 39.4784176043574 * (aims.fsNominal ^ 2.0 * (aims.Lm + aims.Lssigma) ^ 2.0)) / aims.VrLockedRotor)));
//   constant Integer aims.spacePhasorR.m = 3 "number of phases";
//   constant Real aims.spacePhasorR.pi = 3.14159265358979;
//   parameter Real aims.spacePhasorR.turnsRatio = aims.internalTurnsRatio;
//   Real aims.spacePhasorR.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorR.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorR.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorR.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorR.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorR.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aims.spacePhasorR.plug_p.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorR.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.spacePhasorR.plug_n.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorR.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorR.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorR.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.spacePhasorR.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aims.lrsigma.m(min = 1) = 3 "number of phases";
//   Real aims.lrsigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lrsigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lrsigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lrsigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lrsigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lrsigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.lrsigma.plug_p.m(min = 1) = aims.lrsigma.m "number of phases";
//   Real aims.lrsigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.lrsigma.plug_n.m(min = 1) = aims.lrsigma.m "number of phases";
//   Real aims.lrsigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lrsigma "Inductance";
//   parameter Real aims.lrsigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lrsigma "Inductance";
//   parameter Real aims.lrsigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lrsigma "Inductance";
//   Real aims.lrsigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lrsigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lrsigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lrsigma.L[1] "Inductance";
//   Real aims.lrsigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lrsigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lrsigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lrsigma.L[2] "Inductance";
//   Real aims.lrsigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lrsigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lrsigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lrsigma.L[3] "Inductance";
//   parameter Integer aims.rr.m(min = 1) = 3 "number of phases";
//   Real aims.rr.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rr.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rr.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rr.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rr.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rr.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.rr.plug_p.m(min = 1) = aims.rr.m "number of phases";
//   Real aims.rr.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rr.plug_n.m(min = 1) = aims.rr.m "number of phases";
//   Real aims.rr.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rr.mh(min = 1) = aims.rr.m "Number of heatPorts=number of phases";
//   parameter Boolean aims.rr.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aims.rr.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rr.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rr.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rr.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rr "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rr.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rr "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rr.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rr "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rr.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rr.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rr.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rr.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rr.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rr.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aims.rr.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rr.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rr.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rr.resistor[1].useHeatPort = aims.rr.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rr.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aims.rr.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rr.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rr.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rr.R[1] "Resistance at temperature T_ref";
//   parameter Real aims.rr.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[1] "Reference temperature";
//   parameter Real aims.rr.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rr.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rr.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rr.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rr.resistor[2].useHeatPort = aims.rr.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rr.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aims.rr.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rr.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rr.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rr.R[2] "Resistance at temperature T_ref";
//   parameter Real aims.rr.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[2] "Reference temperature";
//   parameter Real aims.rr.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rr.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rr.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rr.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rr.resistor[3].useHeatPort = aims.rr.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rr.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aims.rr.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rr.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rr.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rr.R[3] "Resistance at temperature T_ref";
//   parameter Real aims.rr.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[3] "Reference temperature";
//   parameter Real aims.rr.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rr.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aims.plug_rp.m(min = 1) = 3 "number of phases";
//   Real aims.plug_rp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.plug_rn.m(min = 1) = 3 "number of phases";
//   Real aims.plug_rn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aims.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real booleanStep[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[1].startValue = false "Output before startTime";
//   output Boolean booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real booleanStep[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[2].startValue = false "Output before startTime";
//   output Boolean booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real booleanStep[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[3].startValue = false "Output before startTime";
//   parameter Integer idealCloser.m(min = 1) = 3 "number of phases";
//   Real idealCloser.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer idealCloser.plug_p.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.plug_n.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.mh(min = 1) = idealCloser.m "Number of heatPorts=number of phases";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real idealCloser.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean idealCloser.control[1] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[2] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[3] "true => p--n connected, false => switch open";
//   Real idealCloser.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[1].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[1] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[1] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[1].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[2].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[2] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[2] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[2].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[3].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[3] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[3] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[3].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") = "D" "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer terminalBox.delta.plug_p.m(min = 1) = terminalBox.delta.m "number of phases";
//   Real terminalBox.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.delta.plug_n.m(min = 1) = terminalBox.delta.m "number of phases";
//   Real terminalBox.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer switchedRheostat.m = 3 "Number of phases";
//   parameter Integer switchedRheostat.plug_p.m(min = 1) = 3 "number of phases";
//   Real switchedRheostat.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.plug_n.m(min = 1) = 3 "number of phases";
//   Real switchedRheostat.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real switchedRheostat.RStart(quantity = "Resistance", unit = "Ohm") = Rstart "Starting resistance";
//   parameter Real switchedRheostat.tStart(quantity = "Time", unit = "s") = tStart2 "Duration of switching on the starting resistor";
//   parameter Integer switchedRheostat.star.m(min = 1) = 3 "number of phases";
//   parameter Integer switchedRheostat.star.plug_p.m(min = 1) = switchedRheostat.star.m "number of phases";
//   Real switchedRheostat.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.idealCommutingSwitch.mh(min = 1) = switchedRheostat.idealCommutingSwitch.m "Number of heatPorts=number of phases";
//   parameter Boolean switchedRheostat.idealCommutingSwitch.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.idealCommutingSwitch.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.idealCommutingSwitch.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Integer switchedRheostat.idealCommutingSwitch.m(min = 1) = 3 "number of phases";
//   parameter Real switchedRheostat.idealCommutingSwitch.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean switchedRheostat.idealCommutingSwitch.control[1] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchedRheostat.idealCommutingSwitch.control[2] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchedRheostat.idealCommutingSwitch.control[3] "true => p--n2 connected, false => p--n1 connected";
//   parameter Integer switchedRheostat.idealCommutingSwitch.plug_p.m(min = 1) = switchedRheostat.idealCommutingSwitch.m "number of phases";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.idealCommutingSwitch.plug_n2.m(min = 1) = switchedRheostat.idealCommutingSwitch.m "number of phases";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.idealCommutingSwitch.plug_n1.m(min = 1) = switchedRheostat.idealCommutingSwitch.m "number of phases";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].useHeatPort = switchedRheostat.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchedRheostat.idealCommutingSwitch.Ron[1] "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchedRheostat.idealCommutingSwitch.Goff[1] "Opened switch conductance";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s1(unit = "1");
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].useHeatPort = switchedRheostat.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchedRheostat.idealCommutingSwitch.Ron[2] "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchedRheostat.idealCommutingSwitch.Goff[2] "Opened switch conductance";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s1(unit = "1");
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].useHeatPort = switchedRheostat.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchedRheostat.idealCommutingSwitch.Ron[3] "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchedRheostat.idealCommutingSwitch.Goff[3] "Opened switch conductance";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s1(unit = "1");
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer switchedRheostat.rheostat.m(min = 1) = 3 "number of phases";
//   Real switchedRheostat.rheostat.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real switchedRheostat.rheostat.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real switchedRheostat.rheostat.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real switchedRheostat.rheostat.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real switchedRheostat.rheostat.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real switchedRheostat.rheostat.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer switchedRheostat.rheostat.plug_p.m(min = 1) = switchedRheostat.rheostat.m "number of phases";
//   Real switchedRheostat.rheostat.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.rheostat.plug_n.m(min = 1) = switchedRheostat.rheostat.m "number of phases";
//   Real switchedRheostat.rheostat.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.rheostat.mh(min = 1) = switchedRheostat.rheostat.m "Number of heatPorts=number of phases";
//   parameter Boolean switchedRheostat.rheostat.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real switchedRheostat.rheostat.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.rheostat.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.rheostat.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.rheostat.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.RStart "Resistances R_ref at temperatures T_ref";
//   parameter Real switchedRheostat.rheostat.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.RStart "Resistances R_ref at temperatures T_ref";
//   parameter Real switchedRheostat.rheostat.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.RStart "Resistances R_ref at temperatures T_ref";
//   parameter Real switchedRheostat.rheostat.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real switchedRheostat.rheostat.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real switchedRheostat.rheostat.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real switchedRheostat.rheostat.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real switchedRheostat.rheostat.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real switchedRheostat.rheostat.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real switchedRheostat.rheostat.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real switchedRheostat.rheostat.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real switchedRheostat.rheostat.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.rheostat.resistor[1].useHeatPort = switchedRheostat.rheostat.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.rheostat.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T[1] "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.rheostat.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.rheostat.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.rheostat.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.rheostat.R[1] "Resistance at temperature T_ref";
//   parameter Real switchedRheostat.rheostat.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[1] "Reference temperature";
//   parameter Real switchedRheostat.rheostat.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = switchedRheostat.rheostat.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real switchedRheostat.rheostat.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real switchedRheostat.rheostat.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.rheostat.resistor[2].useHeatPort = switchedRheostat.rheostat.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.rheostat.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T[2] "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.rheostat.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.rheostat.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.rheostat.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.rheostat.R[2] "Resistance at temperature T_ref";
//   parameter Real switchedRheostat.rheostat.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[2] "Reference temperature";
//   parameter Real switchedRheostat.rheostat.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = switchedRheostat.rheostat.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real switchedRheostat.rheostat.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real switchedRheostat.rheostat.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.rheostat.resistor[3].useHeatPort = switchedRheostat.rheostat.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.rheostat.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T[3] "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.rheostat.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.rheostat.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.rheostat.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.rheostat.R[3] "Resistance at temperature T_ref";
//   parameter Real switchedRheostat.rheostat.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[3] "Reference temperature";
//   parameter Real switchedRheostat.rheostat.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = switchedRheostat.rheostat.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer switchedRheostat.starRheostat.m(min = 1) = 3 "number of phases";
//   parameter Integer switchedRheostat.starRheostat.plug_p.m(min = 1) = switchedRheostat.starRheostat.m "number of phases";
//   Real switchedRheostat.starRheostat.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.starRheostat.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean switchedRheostat.booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real switchedRheostat.booleanStep[1].startTime(quantity = "Time", unit = "s") = switchedRheostat.tStart "Time instant of step start";
//   parameter Boolean switchedRheostat.booleanStep[1].startValue = false "Output before startTime";
//   output Boolean switchedRheostat.booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real switchedRheostat.booleanStep[2].startTime(quantity = "Time", unit = "s") = switchedRheostat.tStart "Time instant of step start";
//   parameter Boolean switchedRheostat.booleanStep[2].startValue = false "Output before startTime";
//   output Boolean switchedRheostat.booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real switchedRheostat.booleanStep[3].startTime(quantity = "Time", unit = "s") = switchedRheostat.tStart "Time instant of step start";
//   parameter Boolean switchedRheostat.booleanStep[3].startValue = false "Output before startTime";
// equation
//   aims.inertiaRotor.phi = aims.inertiaRotor.flange_a.phi;
//   aims.inertiaRotor.phi = aims.inertiaRotor.flange_b.phi;
//   aims.inertiaRotor.w = der(aims.inertiaRotor.phi);
//   aims.inertiaRotor.a = der(aims.inertiaRotor.w);
//   aims.inertiaRotor.J * aims.inertiaRotor.a = aims.inertiaRotor.flange_a.tau + aims.inertiaRotor.flange_b.tau;
//   assert(1.0 + aims.rs.resistor[1].alpha * (aims.rs.resistor[1].T_heatPort - aims.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rs.resistor[1].R_actual = aims.rs.resistor[1].R * (1.0 + aims.rs.resistor[1].alpha * (aims.rs.resistor[1].T_heatPort - aims.rs.resistor[1].T_ref));
//   aims.rs.resistor[1].v = aims.rs.resistor[1].R_actual * aims.rs.resistor[1].i;
//   aims.rs.resistor[1].LossPower = aims.rs.resistor[1].v * aims.rs.resistor[1].i;
//   aims.rs.resistor[1].i = aims.rs.resistor[1].p.i;
//   0.0 = aims.rs.resistor[1].p.i + aims.rs.resistor[1].n.i;
//   aims.rs.resistor[1].v = aims.rs.resistor[1].p.v - aims.rs.resistor[1].n.v;
//   aims.rs.resistor[1].T_heatPort = aims.rs.resistor[1].T;
//   assert(1.0 + aims.rs.resistor[2].alpha * (aims.rs.resistor[2].T_heatPort - aims.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rs.resistor[2].R_actual = aims.rs.resistor[2].R * (1.0 + aims.rs.resistor[2].alpha * (aims.rs.resistor[2].T_heatPort - aims.rs.resistor[2].T_ref));
//   aims.rs.resistor[2].v = aims.rs.resistor[2].R_actual * aims.rs.resistor[2].i;
//   aims.rs.resistor[2].LossPower = aims.rs.resistor[2].v * aims.rs.resistor[2].i;
//   aims.rs.resistor[2].i = aims.rs.resistor[2].p.i;
//   0.0 = aims.rs.resistor[2].p.i + aims.rs.resistor[2].n.i;
//   aims.rs.resistor[2].v = aims.rs.resistor[2].p.v - aims.rs.resistor[2].n.v;
//   aims.rs.resistor[2].T_heatPort = aims.rs.resistor[2].T;
//   assert(1.0 + aims.rs.resistor[3].alpha * (aims.rs.resistor[3].T_heatPort - aims.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rs.resistor[3].R_actual = aims.rs.resistor[3].R * (1.0 + aims.rs.resistor[3].alpha * (aims.rs.resistor[3].T_heatPort - aims.rs.resistor[3].T_ref));
//   aims.rs.resistor[3].v = aims.rs.resistor[3].R_actual * aims.rs.resistor[3].i;
//   aims.rs.resistor[3].LossPower = aims.rs.resistor[3].v * aims.rs.resistor[3].i;
//   aims.rs.resistor[3].i = aims.rs.resistor[3].p.i;
//   0.0 = aims.rs.resistor[3].p.i + aims.rs.resistor[3].n.i;
//   aims.rs.resistor[3].v = aims.rs.resistor[3].p.v - aims.rs.resistor[3].n.v;
//   aims.rs.resistor[3].T_heatPort = aims.rs.resistor[3].T;
//   aims.rs.v[1] = aims.rs.plug_p.pin[1].v - aims.rs.plug_n.pin[1].v;
//   aims.rs.v[2] = aims.rs.plug_p.pin[2].v - aims.rs.plug_n.pin[2].v;
//   aims.rs.v[3] = aims.rs.plug_p.pin[3].v - aims.rs.plug_n.pin[3].v;
//   aims.rs.i[1] = aims.rs.plug_p.pin[1].i;
//   aims.rs.i[2] = aims.rs.plug_p.pin[2].i;
//   aims.rs.i[3] = aims.rs.plug_p.pin[3].i;
//   aims.lssigma.inductor[1].L * der(aims.lssigma.inductor[1].i) = aims.lssigma.inductor[1].v;
//   aims.lssigma.inductor[1].v = aims.lssigma.inductor[1].p.v - aims.lssigma.inductor[1].n.v;
//   0.0 = aims.lssigma.inductor[1].p.i + aims.lssigma.inductor[1].n.i;
//   aims.lssigma.inductor[1].i = aims.lssigma.inductor[1].p.i;
//   aims.lssigma.inductor[2].L * der(aims.lssigma.inductor[2].i) = aims.lssigma.inductor[2].v;
//   aims.lssigma.inductor[2].v = aims.lssigma.inductor[2].p.v - aims.lssigma.inductor[2].n.v;
//   0.0 = aims.lssigma.inductor[2].p.i + aims.lssigma.inductor[2].n.i;
//   aims.lssigma.inductor[2].i = aims.lssigma.inductor[2].p.i;
//   aims.lssigma.inductor[3].L * der(aims.lssigma.inductor[3].i) = aims.lssigma.inductor[3].v;
//   aims.lssigma.inductor[3].v = aims.lssigma.inductor[3].p.v - aims.lssigma.inductor[3].n.v;
//   0.0 = aims.lssigma.inductor[3].p.i + aims.lssigma.inductor[3].n.i;
//   aims.lssigma.inductor[3].i = aims.lssigma.inductor[3].p.i;
//   aims.lssigma.v[1] = aims.lssigma.plug_p.pin[1].v - aims.lssigma.plug_n.pin[1].v;
//   aims.lssigma.v[2] = aims.lssigma.plug_p.pin[2].v - aims.lssigma.plug_n.pin[2].v;
//   aims.lssigma.v[3] = aims.lssigma.plug_p.pin[3].v - aims.lssigma.plug_n.pin[3].v;
//   aims.lssigma.i[1] = aims.lssigma.plug_p.pin[1].i;
//   aims.lssigma.i[2] = aims.lssigma.plug_p.pin[2].i;
//   aims.lssigma.i[3] = aims.lssigma.plug_p.pin[3].i;
//   aims.spacePhasorS.gnd.p.v = 0.0;
//   aims.spacePhasorS.v[1] / aims.spacePhasorS.turnsRatio = aims.spacePhasorS.plug_p.pin[1].v - aims.spacePhasorS.plug_n.pin[1].v;
//   aims.spacePhasorS.v[2] / aims.spacePhasorS.turnsRatio = aims.spacePhasorS.plug_p.pin[2].v - aims.spacePhasorS.plug_n.pin[2].v;
//   aims.spacePhasorS.v[3] / aims.spacePhasorS.turnsRatio = aims.spacePhasorS.plug_p.pin[3].v - aims.spacePhasorS.plug_n.pin[3].v;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[1] = aims.spacePhasorS.plug_p.pin[1].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[2] = aims.spacePhasorS.plug_p.pin[2].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[3] = aims.spacePhasorS.plug_p.pin[3].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[1] = -aims.spacePhasorS.plug_n.pin[1].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[2] = -aims.spacePhasorS.plug_n.pin[2].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[3] = -aims.spacePhasorS.plug_n.pin[3].i;
//   aims.spacePhasorS.zero.v = 0.333333333333333 * (aims.spacePhasorS.v[1] + (aims.spacePhasorS.v[2] + aims.spacePhasorS.v[3]));
//   aims.spacePhasorS.spacePhasor.v_[1] = aims.spacePhasorS.TransformationMatrix[1,1] * aims.spacePhasorS.v[1] + (aims.spacePhasorS.TransformationMatrix[1,2] * aims.spacePhasorS.v[2] + aims.spacePhasorS.TransformationMatrix[1,3] * aims.spacePhasorS.v[3]);
//   aims.spacePhasorS.spacePhasor.v_[2] = aims.spacePhasorS.TransformationMatrix[2,1] * aims.spacePhasorS.v[1] + (aims.spacePhasorS.TransformationMatrix[2,2] * aims.spacePhasorS.v[2] + aims.spacePhasorS.TransformationMatrix[2,3] * aims.spacePhasorS.v[3]);
//   -aims.spacePhasorS.zero.i = 0.333333333333333 * (aims.spacePhasorS.i[1] + (aims.spacePhasorS.i[2] + aims.spacePhasorS.i[3]));
//   -aims.spacePhasorS.spacePhasor.i_[1] = aims.spacePhasorS.TransformationMatrix[1,1] * aims.spacePhasorS.i[1] + (aims.spacePhasorS.TransformationMatrix[1,2] * aims.spacePhasorS.i[2] + aims.spacePhasorS.TransformationMatrix[1,3] * aims.spacePhasorS.i[3]);
//   -aims.spacePhasorS.spacePhasor.i_[2] = aims.spacePhasorS.TransformationMatrix[2,1] * aims.spacePhasorS.i[1] + (aims.spacePhasorS.TransformationMatrix[2,2] * aims.spacePhasorS.i[2] + aims.spacePhasorS.TransformationMatrix[2,3] * aims.spacePhasorS.i[3]);
//   aims.airGapS.i_ms[1] = aims.airGapS.i_ss[1] + aims.airGapS.i_rs[1];
//   aims.airGapS.i_ms[2] = aims.airGapS.i_ss[2] + aims.airGapS.i_rs[2];
//   aims.airGapS.psi_ms[1] = aims.airGapS.L[1,1] * aims.airGapS.i_ms[1] + aims.airGapS.L[1,2] * aims.airGapS.i_ms[2];
//   aims.airGapS.psi_ms[2] = aims.airGapS.L[2,1] * aims.airGapS.i_ms[1] + aims.airGapS.L[2,2] * aims.airGapS.i_ms[2];
//   aims.airGapS.psi_mr[1] = aims.airGapS.RotationMatrix[1,1] * aims.airGapS.psi_ms[1] + aims.airGapS.RotationMatrix[2,1] * aims.airGapS.psi_ms[2];
//   aims.airGapS.psi_mr[2] = aims.airGapS.RotationMatrix[1,2] * aims.airGapS.psi_ms[1] + aims.airGapS.RotationMatrix[2,2] * aims.airGapS.psi_ms[2];
//   aims.airGapS.gamma = Real(aims.airGapS.p) * (aims.airGapS.flange.phi - aims.airGapS.support.phi);
//   aims.airGapS.RotationMatrix[1,1] = cos(aims.airGapS.gamma);
//   aims.airGapS.RotationMatrix[1,2] = -sin(aims.airGapS.gamma);
//   aims.airGapS.RotationMatrix[2,1] = sin(aims.airGapS.gamma);
//   aims.airGapS.RotationMatrix[2,2] = cos(aims.airGapS.gamma);
//   aims.airGapS.i_ss[1] = aims.airGapS.spacePhasor_s.i_[1];
//   aims.airGapS.i_ss[2] = aims.airGapS.spacePhasor_s.i_[2];
//   aims.airGapS.i_ss[1] = aims.airGapS.RotationMatrix[1,1] * aims.airGapS.i_sr[1] + aims.airGapS.RotationMatrix[1,2] * aims.airGapS.i_sr[2];
//   aims.airGapS.i_ss[2] = aims.airGapS.RotationMatrix[2,1] * aims.airGapS.i_sr[1] + aims.airGapS.RotationMatrix[2,2] * aims.airGapS.i_sr[2];
//   aims.airGapS.i_rr[1] = aims.airGapS.spacePhasor_r.i_[1];
//   aims.airGapS.i_rr[2] = aims.airGapS.spacePhasor_r.i_[2];
//   aims.airGapS.i_rs[1] = aims.airGapS.RotationMatrix[1,1] * aims.airGapS.i_rr[1] + aims.airGapS.RotationMatrix[1,2] * aims.airGapS.i_rr[2];
//   aims.airGapS.i_rs[2] = aims.airGapS.RotationMatrix[2,1] * aims.airGapS.i_rr[1] + aims.airGapS.RotationMatrix[2,2] * aims.airGapS.i_rr[2];
//   aims.airGapS.spacePhasor_s.v_[1] = der(aims.airGapS.psi_ms[1]);
//   aims.airGapS.spacePhasor_s.v_[2] = der(aims.airGapS.psi_ms[2]);
//   aims.airGapS.spacePhasor_r.v_[1] = der(aims.airGapS.psi_mr[1]);
//   aims.airGapS.spacePhasor_r.v_[2] = der(aims.airGapS.psi_mr[2]);
//   aims.airGapS.tauElectrical = Real(aims.airGapS.m) * (Real(aims.airGapS.p) * (aims.airGapS.spacePhasor_s.i_[2] * aims.airGapS.psi_ms[1] - aims.airGapS.spacePhasor_s.i_[1] * aims.airGapS.psi_ms[2]) / 2.0);
//   aims.airGapS.flange.tau = -aims.airGapS.tauElectrical;
//   aims.airGapS.support.tau = aims.airGapS.tauElectrical;
//   aims.spacePhasorR.gnd.p.v = 0.0;
//   aims.spacePhasorR.v[1] / aims.spacePhasorR.turnsRatio = aims.spacePhasorR.plug_p.pin[1].v - aims.spacePhasorR.plug_n.pin[1].v;
//   aims.spacePhasorR.v[2] / aims.spacePhasorR.turnsRatio = aims.spacePhasorR.plug_p.pin[2].v - aims.spacePhasorR.plug_n.pin[2].v;
//   aims.spacePhasorR.v[3] / aims.spacePhasorR.turnsRatio = aims.spacePhasorR.plug_p.pin[3].v - aims.spacePhasorR.plug_n.pin[3].v;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[1] = aims.spacePhasorR.plug_p.pin[1].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[2] = aims.spacePhasorR.plug_p.pin[2].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[3] = aims.spacePhasorR.plug_p.pin[3].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[1] = -aims.spacePhasorR.plug_n.pin[1].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[2] = -aims.spacePhasorR.plug_n.pin[2].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[3] = -aims.spacePhasorR.plug_n.pin[3].i;
//   aims.spacePhasorR.zero.v = 0.333333333333333 * (aims.spacePhasorR.v[1] + (aims.spacePhasorR.v[2] + aims.spacePhasorR.v[3]));
//   aims.spacePhasorR.spacePhasor.v_[1] = aims.spacePhasorR.TransformationMatrix[1,1] * aims.spacePhasorR.v[1] + (aims.spacePhasorR.TransformationMatrix[1,2] * aims.spacePhasorR.v[2] + aims.spacePhasorR.TransformationMatrix[1,3] * aims.spacePhasorR.v[3]);
//   aims.spacePhasorR.spacePhasor.v_[2] = aims.spacePhasorR.TransformationMatrix[2,1] * aims.spacePhasorR.v[1] + (aims.spacePhasorR.TransformationMatrix[2,2] * aims.spacePhasorR.v[2] + aims.spacePhasorR.TransformationMatrix[2,3] * aims.spacePhasorR.v[3]);
//   -aims.spacePhasorR.zero.i = 0.333333333333333 * (aims.spacePhasorR.i[1] + (aims.spacePhasorR.i[2] + aims.spacePhasorR.i[3]));
//   -aims.spacePhasorR.spacePhasor.i_[1] = aims.spacePhasorR.TransformationMatrix[1,1] * aims.spacePhasorR.i[1] + (aims.spacePhasorR.TransformationMatrix[1,2] * aims.spacePhasorR.i[2] + aims.spacePhasorR.TransformationMatrix[1,3] * aims.spacePhasorR.i[3]);
//   -aims.spacePhasorR.spacePhasor.i_[2] = aims.spacePhasorR.TransformationMatrix[2,1] * aims.spacePhasorR.i[1] + (aims.spacePhasorR.TransformationMatrix[2,2] * aims.spacePhasorR.i[2] + aims.spacePhasorR.TransformationMatrix[2,3] * aims.spacePhasorR.i[3]);
//   aims.lrsigma.inductor[1].L * der(aims.lrsigma.inductor[1].i) = aims.lrsigma.inductor[1].v;
//   aims.lrsigma.inductor[1].v = aims.lrsigma.inductor[1].p.v - aims.lrsigma.inductor[1].n.v;
//   0.0 = aims.lrsigma.inductor[1].p.i + aims.lrsigma.inductor[1].n.i;
//   aims.lrsigma.inductor[1].i = aims.lrsigma.inductor[1].p.i;
//   aims.lrsigma.inductor[2].L * der(aims.lrsigma.inductor[2].i) = aims.lrsigma.inductor[2].v;
//   aims.lrsigma.inductor[2].v = aims.lrsigma.inductor[2].p.v - aims.lrsigma.inductor[2].n.v;
//   0.0 = aims.lrsigma.inductor[2].p.i + aims.lrsigma.inductor[2].n.i;
//   aims.lrsigma.inductor[2].i = aims.lrsigma.inductor[2].p.i;
//   aims.lrsigma.inductor[3].L * der(aims.lrsigma.inductor[3].i) = aims.lrsigma.inductor[3].v;
//   aims.lrsigma.inductor[3].v = aims.lrsigma.inductor[3].p.v - aims.lrsigma.inductor[3].n.v;
//   0.0 = aims.lrsigma.inductor[3].p.i + aims.lrsigma.inductor[3].n.i;
//   aims.lrsigma.inductor[3].i = aims.lrsigma.inductor[3].p.i;
//   aims.lrsigma.v[1] = aims.lrsigma.plug_p.pin[1].v - aims.lrsigma.plug_n.pin[1].v;
//   aims.lrsigma.v[2] = aims.lrsigma.plug_p.pin[2].v - aims.lrsigma.plug_n.pin[2].v;
//   aims.lrsigma.v[3] = aims.lrsigma.plug_p.pin[3].v - aims.lrsigma.plug_n.pin[3].v;
//   aims.lrsigma.i[1] = aims.lrsigma.plug_p.pin[1].i;
//   aims.lrsigma.i[2] = aims.lrsigma.plug_p.pin[2].i;
//   aims.lrsigma.i[3] = aims.lrsigma.plug_p.pin[3].i;
//   assert(1.0 + aims.rr.resistor[1].alpha * (aims.rr.resistor[1].T_heatPort - aims.rr.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rr.resistor[1].R_actual = aims.rr.resistor[1].R * (1.0 + aims.rr.resistor[1].alpha * (aims.rr.resistor[1].T_heatPort - aims.rr.resistor[1].T_ref));
//   aims.rr.resistor[1].v = aims.rr.resistor[1].R_actual * aims.rr.resistor[1].i;
//   aims.rr.resistor[1].LossPower = aims.rr.resistor[1].v * aims.rr.resistor[1].i;
//   aims.rr.resistor[1].i = aims.rr.resistor[1].p.i;
//   0.0 = aims.rr.resistor[1].p.i + aims.rr.resistor[1].n.i;
//   aims.rr.resistor[1].v = aims.rr.resistor[1].p.v - aims.rr.resistor[1].n.v;
//   aims.rr.resistor[1].T_heatPort = aims.rr.resistor[1].T;
//   assert(1.0 + aims.rr.resistor[2].alpha * (aims.rr.resistor[2].T_heatPort - aims.rr.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rr.resistor[2].R_actual = aims.rr.resistor[2].R * (1.0 + aims.rr.resistor[2].alpha * (aims.rr.resistor[2].T_heatPort - aims.rr.resistor[2].T_ref));
//   aims.rr.resistor[2].v = aims.rr.resistor[2].R_actual * aims.rr.resistor[2].i;
//   aims.rr.resistor[2].LossPower = aims.rr.resistor[2].v * aims.rr.resistor[2].i;
//   aims.rr.resistor[2].i = aims.rr.resistor[2].p.i;
//   0.0 = aims.rr.resistor[2].p.i + aims.rr.resistor[2].n.i;
//   aims.rr.resistor[2].v = aims.rr.resistor[2].p.v - aims.rr.resistor[2].n.v;
//   aims.rr.resistor[2].T_heatPort = aims.rr.resistor[2].T;
//   assert(1.0 + aims.rr.resistor[3].alpha * (aims.rr.resistor[3].T_heatPort - aims.rr.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rr.resistor[3].R_actual = aims.rr.resistor[3].R * (1.0 + aims.rr.resistor[3].alpha * (aims.rr.resistor[3].T_heatPort - aims.rr.resistor[3].T_ref));
//   aims.rr.resistor[3].v = aims.rr.resistor[3].R_actual * aims.rr.resistor[3].i;
//   aims.rr.resistor[3].LossPower = aims.rr.resistor[3].v * aims.rr.resistor[3].i;
//   aims.rr.resistor[3].i = aims.rr.resistor[3].p.i;
//   0.0 = aims.rr.resistor[3].p.i + aims.rr.resistor[3].n.i;
//   aims.rr.resistor[3].v = aims.rr.resistor[3].p.v - aims.rr.resistor[3].n.v;
//   aims.rr.resistor[3].T_heatPort = aims.rr.resistor[3].T;
//   aims.rr.v[1] = aims.rr.plug_p.pin[1].v - aims.rr.plug_n.pin[1].v;
//   aims.rr.v[2] = aims.rr.plug_p.pin[2].v - aims.rr.plug_n.pin[2].v;
//   aims.rr.v[3] = aims.rr.plug_p.pin[3].v - aims.rr.plug_n.pin[3].v;
//   aims.rr.i[1] = aims.rr.plug_p.pin[1].i;
//   aims.rr.i[2] = aims.rr.plug_p.pin[2].i;
//   aims.rr.i[3] = aims.rr.plug_p.pin[3].i;
//   aims.fixed.flange.phi = aims.fixed.phi0;
//   assert(aims.rr.plug_n.m == aims.lrsigma.plug_p.m,"automatically generated from connect");
//   assert(aims.rr.plug_p.m == aims.plug_rp.m,"automatically generated from connect");
//   assert(aims.lrsigma.plug_n.m == aims.spacePhasorR.plug_p.m,"automatically generated from connect");
//   assert(aims.spacePhasorR.plug_n.m == aims.plug_rn.m,"automatically generated from connect");
//   assert(aims.spacePhasorS.plug_n.m == aims.plug_sn.m,"automatically generated from connect");
//   assert(aims.lssigma.plug_n.m == aims.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aims.rs.plug_n.m == aims.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aims.plug_sp.m == aims.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   booleanStep[1].y = if time >= booleanStep[1].startTime then  NOT booleanStep[1].startValue else booleanStep[1].startValue;
//   booleanStep[2].y = if time >= booleanStep[2].startTime then  NOT booleanStep[2].startValue else booleanStep[2].startValue;
//   booleanStep[3].y = if time >= booleanStep[3].startTime then  NOT booleanStep[3].startValue else booleanStep[3].startValue;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then idealCloser.idealClosingSwitch[1].Ron else 1.0);
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then 1.0 else idealCloser.idealClosingSwitch[1].Goff);
//   idealCloser.idealClosingSwitch[1].LossPower = idealCloser.idealClosingSwitch[1].v * idealCloser.idealClosingSwitch[1].i;
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].p.i;
//   0.0 = idealCloser.idealClosingSwitch[1].p.i + idealCloser.idealClosingSwitch[1].n.i;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].p.v - idealCloser.idealClosingSwitch[1].n.v;
//   idealCloser.idealClosingSwitch[1].T_heatPort = idealCloser.idealClosingSwitch[1].T;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then idealCloser.idealClosingSwitch[2].Ron else 1.0);
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then 1.0 else idealCloser.idealClosingSwitch[2].Goff);
//   idealCloser.idealClosingSwitch[2].LossPower = idealCloser.idealClosingSwitch[2].v * idealCloser.idealClosingSwitch[2].i;
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].p.i;
//   0.0 = idealCloser.idealClosingSwitch[2].p.i + idealCloser.idealClosingSwitch[2].n.i;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].p.v - idealCloser.idealClosingSwitch[2].n.v;
//   idealCloser.idealClosingSwitch[2].T_heatPort = idealCloser.idealClosingSwitch[2].T;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then idealCloser.idealClosingSwitch[3].Ron else 1.0);
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then 1.0 else idealCloser.idealClosingSwitch[3].Goff);
//   idealCloser.idealClosingSwitch[3].LossPower = idealCloser.idealClosingSwitch[3].v * idealCloser.idealClosingSwitch[3].i;
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].p.i;
//   0.0 = idealCloser.idealClosingSwitch[3].p.i + idealCloser.idealClosingSwitch[3].n.i;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].p.v - idealCloser.idealClosingSwitch[3].n.v;
//   idealCloser.idealClosingSwitch[3].T_heatPort = idealCloser.idealClosingSwitch[3].T;
//   idealCloser.v[1] = idealCloser.plug_p.pin[1].v - idealCloser.plug_n.pin[1].v;
//   idealCloser.v[2] = idealCloser.plug_p.pin[2].v - idealCloser.plug_n.pin[2].v;
//   idealCloser.v[3] = idealCloser.plug_p.pin[3].v - idealCloser.plug_n.pin[3].v;
//   idealCloser.i[1] = idealCloser.plug_p.pin[1].i;
//   idealCloser.i[2] = idealCloser.plug_p.pin[2].i;
//   idealCloser.i[3] = idealCloser.plug_p.pin[3].i;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(terminalBox.plug_sn.m == terminalBox.delta.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.delta.plug_p.m == terminalBox.plug_sp.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   switchedRheostat.ground.p.v = 0.0;
//   0.0 = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s1 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Ron);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s1) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Goff else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s2 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Ron else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s2) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Goff);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].LossPower = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T;
//   0.0 = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s1 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Ron);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s1) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Goff else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s2 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Ron else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s2) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Goff);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].LossPower = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T;
//   0.0 = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s1 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Ron);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s1) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Goff else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s2 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Ron else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s2) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Goff);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].LossPower = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T;
//   assert(1.0 + switchedRheostat.rheostat.resistor[1].alpha * (switchedRheostat.rheostat.resistor[1].T_heatPort - switchedRheostat.rheostat.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   switchedRheostat.rheostat.resistor[1].R_actual = switchedRheostat.rheostat.resistor[1].R * (1.0 + switchedRheostat.rheostat.resistor[1].alpha * (switchedRheostat.rheostat.resistor[1].T_heatPort - switchedRheostat.rheostat.resistor[1].T_ref));
//   switchedRheostat.rheostat.resistor[1].v = switchedRheostat.rheostat.resistor[1].R_actual * switchedRheostat.rheostat.resistor[1].i;
//   switchedRheostat.rheostat.resistor[1].LossPower = switchedRheostat.rheostat.resistor[1].v * switchedRheostat.rheostat.resistor[1].i;
//   switchedRheostat.rheostat.resistor[1].i = switchedRheostat.rheostat.resistor[1].p.i;
//   0.0 = switchedRheostat.rheostat.resistor[1].p.i + switchedRheostat.rheostat.resistor[1].n.i;
//   switchedRheostat.rheostat.resistor[1].v = switchedRheostat.rheostat.resistor[1].p.v - switchedRheostat.rheostat.resistor[1].n.v;
//   switchedRheostat.rheostat.resistor[1].T_heatPort = switchedRheostat.rheostat.resistor[1].T;
//   assert(1.0 + switchedRheostat.rheostat.resistor[2].alpha * (switchedRheostat.rheostat.resistor[2].T_heatPort - switchedRheostat.rheostat.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   switchedRheostat.rheostat.resistor[2].R_actual = switchedRheostat.rheostat.resistor[2].R * (1.0 + switchedRheostat.rheostat.resistor[2].alpha * (switchedRheostat.rheostat.resistor[2].T_heatPort - switchedRheostat.rheostat.resistor[2].T_ref));
//   switchedRheostat.rheostat.resistor[2].v = switchedRheostat.rheostat.resistor[2].R_actual * switchedRheostat.rheostat.resistor[2].i;
//   switchedRheostat.rheostat.resistor[2].LossPower = switchedRheostat.rheostat.resistor[2].v * switchedRheostat.rheostat.resistor[2].i;
//   switchedRheostat.rheostat.resistor[2].i = switchedRheostat.rheostat.resistor[2].p.i;
//   0.0 = switchedRheostat.rheostat.resistor[2].p.i + switchedRheostat.rheostat.resistor[2].n.i;
//   switchedRheostat.rheostat.resistor[2].v = switchedRheostat.rheostat.resistor[2].p.v - switchedRheostat.rheostat.resistor[2].n.v;
//   switchedRheostat.rheostat.resistor[2].T_heatPort = switchedRheostat.rheostat.resistor[2].T;
//   assert(1.0 + switchedRheostat.rheostat.resistor[3].alpha * (switchedRheostat.rheostat.resistor[3].T_heatPort - switchedRheostat.rheostat.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   switchedRheostat.rheostat.resistor[3].R_actual = switchedRheostat.rheostat.resistor[3].R * (1.0 + switchedRheostat.rheostat.resistor[3].alpha * (switchedRheostat.rheostat.resistor[3].T_heatPort - switchedRheostat.rheostat.resistor[3].T_ref));
//   switchedRheostat.rheostat.resistor[3].v = switchedRheostat.rheostat.resistor[3].R_actual * switchedRheostat.rheostat.resistor[3].i;
//   switchedRheostat.rheostat.resistor[3].LossPower = switchedRheostat.rheostat.resistor[3].v * switchedRheostat.rheostat.resistor[3].i;
//   switchedRheostat.rheostat.resistor[3].i = switchedRheostat.rheostat.resistor[3].p.i;
//   0.0 = switchedRheostat.rheostat.resistor[3].p.i + switchedRheostat.rheostat.resistor[3].n.i;
//   switchedRheostat.rheostat.resistor[3].v = switchedRheostat.rheostat.resistor[3].p.v - switchedRheostat.rheostat.resistor[3].n.v;
//   switchedRheostat.rheostat.resistor[3].T_heatPort = switchedRheostat.rheostat.resistor[3].T;
//   switchedRheostat.rheostat.v[1] = switchedRheostat.rheostat.plug_p.pin[1].v - switchedRheostat.rheostat.plug_n.pin[1].v;
//   switchedRheostat.rheostat.v[2] = switchedRheostat.rheostat.plug_p.pin[2].v - switchedRheostat.rheostat.plug_n.pin[2].v;
//   switchedRheostat.rheostat.v[3] = switchedRheostat.rheostat.plug_p.pin[3].v - switchedRheostat.rheostat.plug_n.pin[3].v;
//   switchedRheostat.rheostat.i[1] = switchedRheostat.rheostat.plug_p.pin[1].i;
//   switchedRheostat.rheostat.i[2] = switchedRheostat.rheostat.plug_p.pin[2].i;
//   switchedRheostat.rheostat.i[3] = switchedRheostat.rheostat.plug_p.pin[3].i;
//   switchedRheostat.booleanStep[1].y = if time >= switchedRheostat.booleanStep[1].startTime then  NOT switchedRheostat.booleanStep[1].startValue else switchedRheostat.booleanStep[1].startValue;
//   switchedRheostat.booleanStep[2].y = if time >= switchedRheostat.booleanStep[2].startTime then  NOT switchedRheostat.booleanStep[2].startValue else switchedRheostat.booleanStep[2].startValue;
//   switchedRheostat.booleanStep[3].y = if time >= switchedRheostat.booleanStep[3].startTime then  NOT switchedRheostat.booleanStep[3].startValue else switchedRheostat.booleanStep[3].startValue;
//   assert(switchedRheostat.plug_p.m == switchedRheostat.idealCommutingSwitch.plug_p.m,"automatically generated from connect");
//   assert(switchedRheostat.idealCommutingSwitch.plug_n2.m == switchedRheostat.plug_n.m,"automatically generated from connect");
//   assert(switchedRheostat.rheostat.plug_p.m == switchedRheostat.idealCommutingSwitch.plug_n1.m,"automatically generated from connect");
//   assert(switchedRheostat.idealCommutingSwitch.plug_n2.m == switchedRheostat.star.plug_p.m,"automatically generated from connect");
//   assert(switchedRheostat.rheostat.plug_n.m == switchedRheostat.starRheostat.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == idealCloser.plug_p.m,"automatically generated from connect");
//   assert(idealCloser.plug_n.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == aims.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == aims.plug_sp.m,"automatically generated from connect");
//   assert(switchedRheostat.plug_p.m == aims.plug_rp.m,"automatically generated from connect");
//   assert(switchedRheostat.plug_n.m == aims.plug_rn.m,"automatically generated from connect");
//   switchedRheostat.plug_n.pin[3].i + aims.plug_rn.pin[3].i = 0.0;
//   aims.plug_rn.pin[1].v = aims.plug_rn.pin[2].v;
//   aims.plug_rn.pin[1].v = aims.plug_rn.pin[3].v;
//   aims.plug_rn.pin[1].v = aims.spacePhasorR.plug_n.pin[1].v;
//   aims.plug_rn.pin[1].v = aims.spacePhasorR.plug_n.pin[2].v;
//   aims.plug_rn.pin[1].v = aims.spacePhasorR.plug_n.pin[3].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.ground.p.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.plug_n.pin[1].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.plug_n.pin[2].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.plug_n.pin[3].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.rheostat.plug_n.pin[1].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.rheostat.plug_n.pin[2].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.rheostat.plug_n.pin[3].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.rheostat.resistor[1].n.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.rheostat.resistor[2].n.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.rheostat.resistor[3].n.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.star.pin_n.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.star.plug_p.pin[1].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.star.plug_p.pin[2].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.star.plug_p.pin[3].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.starRheostat.pin_n.v;
//   aims.plug_rn.pin[1].v = switchedRheostat.starRheostat.plug_p.pin[1].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.starRheostat.plug_p.pin[2].v;
//   aims.plug_rn.pin[1].v = switchedRheostat.starRheostat.plug_p.pin[3].v;
//   switchedRheostat.plug_n.pin[2].i + aims.plug_rn.pin[2].i = 0.0;
//   switchedRheostat.plug_n.pin[1].i + aims.plug_rn.pin[1].i = 0.0;
//   switchedRheostat.plug_p.pin[3].i + aims.plug_rp.pin[3].i = 0.0;
//   aims.plug_rp.pin[3].v = aims.rr.plug_p.pin[3].v;
//   aims.plug_rp.pin[3].v = aims.rr.resistor[3].p.v;
//   aims.plug_rp.pin[3].v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v;
//   aims.plug_rp.pin[3].v = switchedRheostat.idealCommutingSwitch.plug_p.pin[3].v;
//   aims.plug_rp.pin[3].v = switchedRheostat.plug_p.pin[3].v;
//   switchedRheostat.plug_p.pin[2].i + aims.plug_rp.pin[2].i = 0.0;
//   aims.plug_rp.pin[2].v = aims.rr.plug_p.pin[2].v;
//   aims.plug_rp.pin[2].v = aims.rr.resistor[2].p.v;
//   aims.plug_rp.pin[2].v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v;
//   aims.plug_rp.pin[2].v = switchedRheostat.idealCommutingSwitch.plug_p.pin[2].v;
//   aims.plug_rp.pin[2].v = switchedRheostat.plug_p.pin[2].v;
//   switchedRheostat.plug_p.pin[1].i + aims.plug_rp.pin[1].i = 0.0;
//   aims.plug_rp.pin[1].v = aims.rr.plug_p.pin[1].v;
//   aims.plug_rp.pin[1].v = aims.rr.resistor[1].p.v;
//   aims.plug_rp.pin[1].v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v;
//   aims.plug_rp.pin[1].v = switchedRheostat.idealCommutingSwitch.plug_p.pin[1].v;
//   aims.plug_rp.pin[1].v = switchedRheostat.plug_p.pin[1].v;
//   aims.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aims.flange.phi = aims.inertiaRotor.flange_b.phi;
//   aims.flange.phi = loadInertia.flange_a.phi;
//   terminalBox.plug_sp.pin[3].i + aims.plug_sp.pin[3].i = 0.0;
//   aims.plug_sn.pin[2].v = aims.plug_sp.pin[3].v;
//   aims.plug_sn.pin[2].v = aims.rs.plug_p.pin[3].v;
//   aims.plug_sn.pin[2].v = aims.rs.resistor[3].p.v;
//   aims.plug_sn.pin[2].v = aims.spacePhasorS.plug_n.pin[2].v;
//   aims.plug_sn.pin[2].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   aims.plug_sn.pin[2].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   aims.plug_sn.pin[2].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   aims.plug_sn.pin[2].v = terminalBox.delta.plug_n.pin[2].v;
//   aims.plug_sn.pin[2].v = terminalBox.delta.plug_p.pin[3].v;
//   aims.plug_sn.pin[2].v = terminalBox.plugSupply.pin[3].v;
//   aims.plug_sn.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   aims.plug_sn.pin[2].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + aims.plug_sp.pin[2].i = 0.0;
//   aims.plug_sn.pin[1].v = aims.plug_sp.pin[2].v;
//   aims.plug_sn.pin[1].v = aims.rs.plug_p.pin[2].v;
//   aims.plug_sn.pin[1].v = aims.rs.resistor[2].p.v;
//   aims.plug_sn.pin[1].v = aims.spacePhasorS.plug_n.pin[1].v;
//   aims.plug_sn.pin[1].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   aims.plug_sn.pin[1].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   aims.plug_sn.pin[1].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   aims.plug_sn.pin[1].v = terminalBox.delta.plug_n.pin[1].v;
//   aims.plug_sn.pin[1].v = terminalBox.delta.plug_p.pin[2].v;
//   aims.plug_sn.pin[1].v = terminalBox.plugSupply.pin[2].v;
//   aims.plug_sn.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   aims.plug_sn.pin[1].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + aims.plug_sp.pin[1].i = 0.0;
//   aims.plug_sn.pin[3].v = aims.plug_sp.pin[1].v;
//   aims.plug_sn.pin[3].v = aims.rs.plug_p.pin[1].v;
//   aims.plug_sn.pin[3].v = aims.rs.resistor[1].p.v;
//   aims.plug_sn.pin[3].v = aims.spacePhasorS.plug_n.pin[3].v;
//   aims.plug_sn.pin[3].v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   aims.plug_sn.pin[3].v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   aims.plug_sn.pin[3].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   aims.plug_sn.pin[3].v = terminalBox.delta.plug_n.pin[3].v;
//   aims.plug_sn.pin[3].v = terminalBox.delta.plug_p.pin[1].v;
//   aims.plug_sn.pin[3].v = terminalBox.plugSupply.pin[1].v;
//   aims.plug_sn.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   aims.plug_sn.pin[3].v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plug_sn.pin[3].i + aims.plug_sn.pin[3].i = 0.0;
//   terminalBox.plug_sn.pin[2].i + aims.plug_sn.pin[2].i = 0.0;
//   terminalBox.plug_sn.pin[1].i + aims.plug_sn.pin[1].i = 0.0;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   idealCloser.plug_n.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = idealCloser.idealClosingSwitch[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = idealCloser.plug_n.pin[3].v;
//   idealCloser.plug_n.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = idealCloser.idealClosingSwitch[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = idealCloser.plug_n.pin[2].v;
//   idealCloser.plug_n.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = idealCloser.idealClosingSwitch[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = idealCloser.plug_n.pin[1].v;
//   booleanStep[1].y = idealCloser.control[1];
//   booleanStep[1].y = idealCloser.idealClosingSwitch[1].control;
//   booleanStep[2].y = idealCloser.control[2];
//   booleanStep[2].y = idealCloser.idealClosingSwitch[2].control;
//   booleanStep[3].y = idealCloser.control[3];
//   booleanStep[3].y = idealCloser.idealClosingSwitch[3].control;
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   sineVoltage.plug_p.pin[3].i + idealCloser.plug_p.pin[3].i = 0.0;
//   idealCloser.idealClosingSwitch[3].p.v = idealCloser.plug_p.pin[3].v;
//   idealCloser.idealClosingSwitch[3].p.v = sineVoltage.plug_p.pin[3].v;
//   idealCloser.idealClosingSwitch[3].p.v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.plug_p.pin[2].i + idealCloser.plug_p.pin[2].i = 0.0;
//   idealCloser.idealClosingSwitch[2].p.v = idealCloser.plug_p.pin[2].v;
//   idealCloser.idealClosingSwitch[2].p.v = sineVoltage.plug_p.pin[2].v;
//   idealCloser.idealClosingSwitch[2].p.v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.plug_p.pin[1].i + idealCloser.plug_p.pin[1].i = 0.0;
//   idealCloser.idealClosingSwitch[1].p.v = idealCloser.plug_p.pin[1].v;
//   idealCloser.idealClosingSwitch[1].p.v = sineVoltage.plug_p.pin[1].v;
//   idealCloser.idealClosingSwitch[1].p.v = sineVoltage.sineVoltage[1].p.v;
//   sineVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   ground.p.v = sineVoltage.plug_n.pin[1].v;
//   ground.p.v = sineVoltage.plug_n.pin[2].v;
//   ground.p.v = sineVoltage.plug_n.pin[3].v;
//   ground.p.v = sineVoltage.sineVoltage[1].n.v;
//   ground.p.v = sineVoltage.sineVoltage[2].n.v;
//   ground.p.v = sineVoltage.sineVoltage[3].n.v;
//   ground.p.v = star.pin_n.v;
//   ground.p.v = star.plug_p.pin[1].v;
//   ground.p.v = star.plug_p.pin[2].v;
//   ground.p.v = star.plug_p.pin[3].v;
//   sineVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   star.pin_n.i + ground.p.i = 0.0;
//   switchedRheostat.booleanStep[1].y = switchedRheostat.idealCommutingSwitch.control[1];
//   switchedRheostat.booleanStep[1].y = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control;
//   switchedRheostat.booleanStep[2].y = switchedRheostat.idealCommutingSwitch.control[2];
//   switchedRheostat.booleanStep[2].y = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control;
//   switchedRheostat.booleanStep[3].y = switchedRheostat.idealCommutingSwitch.control[3];
//   switchedRheostat.booleanStep[3].y = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control;
//   switchedRheostat.starRheostat.pin_n.i + (switchedRheostat.star.pin_n.i + switchedRheostat.ground.p.i) = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[3].i + switchedRheostat.starRheostat.plug_p.pin[3].i = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[2].i + switchedRheostat.starRheostat.plug_p.pin[2].i = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[1].i + switchedRheostat.starRheostat.plug_p.pin[1].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].i + ((-switchedRheostat.plug_n.pin[3].i) + switchedRheostat.star.plug_p.pin[3].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].i + ((-switchedRheostat.plug_n.pin[2].i) + switchedRheostat.star.plug_p.pin[2].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].i + ((-switchedRheostat.plug_n.pin[1].i) + switchedRheostat.star.plug_p.pin[1].i) = 0.0;
//   switchedRheostat.rheostat.plug_p.pin[3].i + switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchedRheostat.rheostat.plug_p.pin[3].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchedRheostat.rheostat.resistor[3].p.v;
//   switchedRheostat.rheostat.plug_p.pin[2].i + switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchedRheostat.rheostat.plug_p.pin[2].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchedRheostat.rheostat.resistor[2].p.v;
//   switchedRheostat.rheostat.plug_p.pin[1].i + switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchedRheostat.rheostat.plug_p.pin[1].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchedRheostat.rheostat.resistor[1].p.v;
//   (-switchedRheostat.plug_p.pin[3].i) + switchedRheostat.idealCommutingSwitch.plug_p.pin[3].i = 0.0;
//   (-switchedRheostat.plug_p.pin[2].i) + switchedRheostat.idealCommutingSwitch.plug_p.pin[2].i = 0.0;
//   (-switchedRheostat.plug_p.pin[1].i) + switchedRheostat.idealCommutingSwitch.plug_p.pin[1].i = 0.0;
//   (-switchedRheostat.starRheostat.plug_p.pin[3].i) + ((-switchedRheostat.starRheostat.plug_p.pin[2].i) + ((-switchedRheostat.starRheostat.plug_p.pin[1].i) + (-switchedRheostat.starRheostat.pin_n.i))) = 0.0;
//   switchedRheostat.rheostat.resistor[3].n.i + (-switchedRheostat.rheostat.plug_n.pin[3].i) = 0.0;
//   switchedRheostat.rheostat.resistor[2].n.i + (-switchedRheostat.rheostat.plug_n.pin[2].i) = 0.0;
//   switchedRheostat.rheostat.resistor[1].n.i + (-switchedRheostat.rheostat.plug_n.pin[1].i) = 0.0;
//   switchedRheostat.rheostat.resistor[3].p.i + (-switchedRheostat.rheostat.plug_p.pin[3].i) = 0.0;
//   switchedRheostat.rheostat.resistor[2].p.i + (-switchedRheostat.rheostat.plug_p.pin[2].i) = 0.0;
//   switchedRheostat.rheostat.resistor[1].p.i + (-switchedRheostat.rheostat.plug_p.pin[1].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i + (-switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i + (-switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i + (-switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + (-switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + (-switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + (-switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].i) = 0.0;
//   (-switchedRheostat.idealCommutingSwitch.plug_p.pin[3].i) + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i = 0.0;
//   (-switchedRheostat.idealCommutingSwitch.plug_p.pin[2].i) + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i = 0.0;
//   (-switchedRheostat.idealCommutingSwitch.plug_p.pin[1].i) + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i = 0.0;
//   (-switchedRheostat.star.plug_p.pin[3].i) + ((-switchedRheostat.star.plug_p.pin[2].i) + ((-switchedRheostat.star.plug_p.pin[1].i) + (-switchedRheostat.star.pin_n.i))) = 0.0;
//   terminalBox.delta.plug_p.pin[3].i + ((-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i)) = 0.0;
//   terminalBox.delta.plug_p.pin[2].i + ((-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i)) = 0.0;
//   terminalBox.delta.plug_p.pin[1].i + ((-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i)) = 0.0;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.delta.plug_n.pin[3].i = 0.0;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.delta.plug_n.pin[2].i = 0.0;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.delta.plug_n.pin[1].i = 0.0;
//   (-terminalBox.delta.plug_n.pin[3].i) + (-terminalBox.delta.plug_p.pin[1].i) = 0.0;
//   (-terminalBox.delta.plug_n.pin[2].i) + (-terminalBox.delta.plug_p.pin[3].i) = 0.0;
//   (-terminalBox.delta.plug_n.pin[1].i) + (-terminalBox.delta.plug_p.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[3].n.i + (-idealCloser.plug_n.pin[3].i) = 0.0;
//   idealCloser.idealClosingSwitch[2].n.i + (-idealCloser.plug_n.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[1].n.i + (-idealCloser.plug_n.pin[1].i) = 0.0;
//   (-idealCloser.plug_p.pin[3].i) + idealCloser.idealClosingSwitch[3].p.i = 0.0;
//   (-idealCloser.plug_p.pin[2].i) + idealCloser.idealClosingSwitch[2].p.i = 0.0;
//   (-idealCloser.plug_p.pin[1].i) + idealCloser.idealClosingSwitch[1].p.i = 0.0;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   aims.airGapS.support.tau + ((-aims.internalSupport.tau) + aims.fixed.flange.tau) = 0.0;
//   aims.airGapS.support.phi = aims.fixed.flange.phi;
//   aims.airGapS.support.phi = aims.internalSupport.phi;
//   aims.inertiaRotor.flange_b.tau + (-aims.flange.tau) = 0.0;
//   (-aims.plug_sp.pin[3].i) + aims.rs.plug_p.pin[3].i = 0.0;
//   (-aims.plug_sp.pin[2].i) + aims.rs.plug_p.pin[2].i = 0.0;
//   (-aims.plug_sp.pin[1].i) + aims.rs.plug_p.pin[1].i = 0.0;
//   aims.rs.plug_n.pin[3].i + aims.lssigma.plug_p.pin[3].i = 0.0;
//   aims.lssigma.inductor[3].p.v = aims.lssigma.plug_p.pin[3].v;
//   aims.lssigma.inductor[3].p.v = aims.rs.plug_n.pin[3].v;
//   aims.lssigma.inductor[3].p.v = aims.rs.resistor[3].n.v;
//   aims.rs.plug_n.pin[2].i + aims.lssigma.plug_p.pin[2].i = 0.0;
//   aims.lssigma.inductor[2].p.v = aims.lssigma.plug_p.pin[2].v;
//   aims.lssigma.inductor[2].p.v = aims.rs.plug_n.pin[2].v;
//   aims.lssigma.inductor[2].p.v = aims.rs.resistor[2].n.v;
//   aims.rs.plug_n.pin[1].i + aims.lssigma.plug_p.pin[1].i = 0.0;
//   aims.lssigma.inductor[1].p.v = aims.lssigma.plug_p.pin[1].v;
//   aims.lssigma.inductor[1].p.v = aims.rs.plug_n.pin[1].v;
//   aims.lssigma.inductor[1].p.v = aims.rs.resistor[1].n.v;
//   aims.lssigma.plug_n.pin[3].i + aims.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aims.lssigma.inductor[3].n.v = aims.lssigma.plug_n.pin[3].v;
//   aims.lssigma.inductor[3].n.v = aims.spacePhasorS.plug_p.pin[3].v;
//   aims.lssigma.plug_n.pin[2].i + aims.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aims.lssigma.inductor[2].n.v = aims.lssigma.plug_n.pin[2].v;
//   aims.lssigma.inductor[2].n.v = aims.spacePhasorS.plug_p.pin[2].v;
//   aims.lssigma.plug_n.pin[1].i + aims.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aims.lssigma.inductor[1].n.v = aims.lssigma.plug_n.pin[1].v;
//   aims.lssigma.inductor[1].n.v = aims.spacePhasorS.plug_p.pin[1].v;
//   aims.spacePhasorS.plug_n.pin[3].i + (-aims.plug_sn.pin[3].i) = 0.0;
//   aims.spacePhasorS.plug_n.pin[2].i + (-aims.plug_sn.pin[2].i) = 0.0;
//   aims.spacePhasorS.plug_n.pin[1].i + (-aims.plug_sn.pin[1].i) = 0.0;
//   aims.spacePhasorS.ground.i + aims.spacePhasorS.zero.i = 0.0;
//   aims.spacePhasorS.gnd.p.v = aims.spacePhasorS.ground.v;
//   aims.spacePhasorS.gnd.p.v = aims.spacePhasorS.zero.v;
//   aims.spacePhasorR.plug_n.pin[3].i + (-aims.plug_rn.pin[3].i) = 0.0;
//   aims.spacePhasorR.plug_n.pin[2].i + (-aims.plug_rn.pin[2].i) = 0.0;
//   aims.spacePhasorR.plug_n.pin[1].i + (-aims.plug_rn.pin[1].i) = 0.0;
//   aims.lrsigma.plug_n.pin[3].i + aims.spacePhasorR.plug_p.pin[3].i = 0.0;
//   aims.lrsigma.inductor[3].n.v = aims.lrsigma.plug_n.pin[3].v;
//   aims.lrsigma.inductor[3].n.v = aims.spacePhasorR.plug_p.pin[3].v;
//   aims.lrsigma.plug_n.pin[2].i + aims.spacePhasorR.plug_p.pin[2].i = 0.0;
//   aims.lrsigma.inductor[2].n.v = aims.lrsigma.plug_n.pin[2].v;
//   aims.lrsigma.inductor[2].n.v = aims.spacePhasorR.plug_p.pin[2].v;
//   aims.lrsigma.plug_n.pin[1].i + aims.spacePhasorR.plug_p.pin[1].i = 0.0;
//   aims.lrsigma.inductor[1].n.v = aims.lrsigma.plug_n.pin[1].v;
//   aims.lrsigma.inductor[1].n.v = aims.spacePhasorR.plug_p.pin[1].v;
//   aims.airGapS.flange.tau + aims.inertiaRotor.flange_a.tau = 0.0;
//   aims.airGapS.flange.phi = aims.inertiaRotor.flange_a.phi;
//   aims.spacePhasorS.spacePhasor.i_[1] + aims.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aims.spacePhasorS.spacePhasor.i_[2] + aims.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aims.airGapS.spacePhasor_s.v_[1] = aims.spacePhasorS.spacePhasor.v_[1];
//   aims.airGapS.spacePhasor_s.v_[2] = aims.spacePhasorS.spacePhasor.v_[2];
//   aims.airGapS.spacePhasor_r.i_[1] + aims.spacePhasorR.spacePhasor.i_[1] = 0.0;
//   aims.airGapS.spacePhasor_r.i_[2] + aims.spacePhasorR.spacePhasor.i_[2] = 0.0;
//   aims.airGapS.spacePhasor_r.v_[1] = aims.spacePhasorR.spacePhasor.v_[1];
//   aims.airGapS.spacePhasor_r.v_[2] = aims.spacePhasorR.spacePhasor.v_[2];
//   aims.spacePhasorR.ground.i + aims.spacePhasorR.zero.i = 0.0;
//   aims.spacePhasorR.gnd.p.v = aims.spacePhasorR.ground.v;
//   aims.spacePhasorR.gnd.p.v = aims.spacePhasorR.zero.v;
//   aims.rr.plug_p.pin[3].i + (-aims.plug_rp.pin[3].i) = 0.0;
//   aims.rr.plug_p.pin[2].i + (-aims.plug_rp.pin[2].i) = 0.0;
//   aims.rr.plug_p.pin[1].i + (-aims.plug_rp.pin[1].i) = 0.0;
//   aims.rr.plug_n.pin[3].i + aims.lrsigma.plug_p.pin[3].i = 0.0;
//   aims.lrsigma.inductor[3].p.v = aims.lrsigma.plug_p.pin[3].v;
//   aims.lrsigma.inductor[3].p.v = aims.rr.plug_n.pin[3].v;
//   aims.lrsigma.inductor[3].p.v = aims.rr.resistor[3].n.v;
//   aims.rr.plug_n.pin[2].i + aims.lrsigma.plug_p.pin[2].i = 0.0;
//   aims.lrsigma.inductor[2].p.v = aims.lrsigma.plug_p.pin[2].v;
//   aims.lrsigma.inductor[2].p.v = aims.rr.plug_n.pin[2].v;
//   aims.lrsigma.inductor[2].p.v = aims.rr.resistor[2].n.v;
//   aims.rr.plug_n.pin[1].i + aims.lrsigma.plug_p.pin[1].i = 0.0;
//   aims.lrsigma.inductor[1].p.v = aims.lrsigma.plug_p.pin[1].v;
//   aims.lrsigma.inductor[1].p.v = aims.rr.plug_n.pin[1].v;
//   aims.lrsigma.inductor[1].p.v = aims.rr.resistor[1].n.v;
//   aims.rr.resistor[3].n.i + (-aims.rr.plug_n.pin[3].i) = 0.0;
//   aims.rr.resistor[2].n.i + (-aims.rr.plug_n.pin[2].i) = 0.0;
//   aims.rr.resistor[1].n.i + (-aims.rr.plug_n.pin[1].i) = 0.0;
//   aims.rr.resistor[3].p.i + (-aims.rr.plug_p.pin[3].i) = 0.0;
//   aims.rr.resistor[2].p.i + (-aims.rr.plug_p.pin[2].i) = 0.0;
//   aims.rr.resistor[1].p.i + (-aims.rr.plug_p.pin[1].i) = 0.0;
//   aims.lrsigma.inductor[3].n.i + (-aims.lrsigma.plug_n.pin[3].i) = 0.0;
//   aims.lrsigma.inductor[2].n.i + (-aims.lrsigma.plug_n.pin[2].i) = 0.0;
//   aims.lrsigma.inductor[1].n.i + (-aims.lrsigma.plug_n.pin[1].i) = 0.0;
//   aims.lrsigma.inductor[3].p.i + (-aims.lrsigma.plug_p.pin[3].i) = 0.0;
//   aims.lrsigma.inductor[2].p.i + (-aims.lrsigma.plug_p.pin[2].i) = 0.0;
//   aims.lrsigma.inductor[1].p.i + (-aims.lrsigma.plug_p.pin[1].i) = 0.0;
//   aims.spacePhasorR.gnd.p.i + (-aims.spacePhasorR.ground.i) = 0.0;
//   aims.lssigma.inductor[3].n.i + (-aims.lssigma.plug_n.pin[3].i) = 0.0;
//   aims.lssigma.inductor[2].n.i + (-aims.lssigma.plug_n.pin[2].i) = 0.0;
//   aims.lssigma.inductor[1].n.i + (-aims.lssigma.plug_n.pin[1].i) = 0.0;
//   aims.lssigma.inductor[3].p.i + (-aims.lssigma.plug_p.pin[3].i) = 0.0;
//   aims.lssigma.inductor[2].p.i + (-aims.lssigma.plug_p.pin[2].i) = 0.0;
//   aims.lssigma.inductor[1].p.i + (-aims.lssigma.plug_p.pin[1].i) = 0.0;
//   aims.rs.resistor[3].n.i + (-aims.rs.plug_n.pin[3].i) = 0.0;
//   aims.rs.resistor[2].n.i + (-aims.rs.plug_n.pin[2].i) = 0.0;
//   aims.rs.resistor[1].n.i + (-aims.rs.plug_n.pin[1].i) = 0.0;
//   aims.rs.resistor[3].p.i + (-aims.rs.plug_p.pin[3].i) = 0.0;
//   aims.rs.resistor[2].p.i + (-aims.rs.plug_p.pin[2].i) = 0.0;
//   aims.rs.resistor[1].p.i + (-aims.rs.plug_p.pin[1].i) = 0.0;
//   aims.spacePhasorS.gnd.p.i + (-aims.spacePhasorS.ground.i) = 0.0;
//   aims.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMS_Start;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMS_Start completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMS_Start has 646 equation(s) and 646 variable(s).
// 451 of these are trivial equation(s).
// "
// ""
// "function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
//   constant Integer m = 3 "number of phases";
//   constant Real pi = 3.14159265358979;
//   input Real[3] x;
//   output Real[2] y;
//   output Real y0;
// algorithm
//   y := {0.0,0.0};
//   for k in 1:3 loop
//     y := {y[1] + x[k] * 0.666666666666667 * cos(2.0943951023932 * /*REAL*/(k - 1)),y[2] + x[k] * 0.666666666666667 * sin(2.0943951023932 * /*REAL*/(k - 1))};
//   end for;
//   y0 := 0.333333333333333 * (x[1] + x[2] + x[3]);
// end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.SMEE_Generator
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real wActual(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 156.97491292437 "actual speed";
//   parameter Real Ie(quantity = "ElectricCurrent", unit = "A") = 19.0 "excitation current";
//   parameter Real Ie0(quantity = "ElectricCurrent", unit = "A") = 10.0 "initial excitation current";
//   parameter Real gamma0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "initial rotor displacement angle";
//   constant Real smee.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real smee.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean smee.useSupport = true "enable / disable (=fixed stator) support";
//   parameter Real smee.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = smee.Jr) "stator's moment of inertia";
//   output Real smee.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg", start = (-3.14159265358979 - gamma0) / Real(smee.p), fixed = true) = smee.flange.phi - smee.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real smee.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(smee.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real smee.tauElectrical(quantity = "Torque", unit = "N.m") = smee.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real smee.tauShaft(quantity = "Torque", unit = "N.m") = -smee.flange.tau "shaft torque";
//   Real smee.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smee.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = smee.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) smee.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real smee.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real smee.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real smee.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real smee.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real smee.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer smee.m = 3 "number of phases";
//   parameter Integer smee.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real smee.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real smee.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real smee.Lssigma(quantity = "Inductance", unit = "H", start = 0.1 * 1.0 / smee.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real smee.vs[1](quantity = "ElectricPotential", unit = "V") = smee.plug_sp.pin[1].v - smee.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real smee.vs[2](quantity = "ElectricPotential", unit = "V") = smee.plug_sp.pin[2].v - smee.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real smee.vs[3](quantity = "ElectricPotential", unit = "V") = smee.plug_sp.pin[3].v - smee.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real smee.is[1](quantity = "ElectricCurrent", unit = "A") = smee.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real smee.is[2](quantity = "ElectricCurrent", unit = "A") = smee.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real smee.is[3](quantity = "ElectricCurrent", unit = "A") = smee.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real smee.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real smee.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real smee.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real smee.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real smee.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real smee.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real smee.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real smee.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real smee.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer smee.plug_sp.m(min = 1) = 3 "number of phases";
//   Real smee.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.plug_sn.m(min = 1) = 3 "number of phases";
//   Real smee.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.rs.m(min = 1) = 3 "number of phases";
//   Real smee.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smee.rs.plug_p.m(min = 1) = smee.rs.m "number of phases";
//   Real smee.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.rs.plug_n.m(min = 1) = smee.rs.m "number of phases";
//   Real smee.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.rs.mh(min = 1) = smee.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean smee.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real smee.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smee.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smee.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smee.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smee.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smee.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smee.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smee.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smee.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smee.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smee.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smee.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real smee.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.rs.resistor[1].useHeatPort = smee.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smee.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real smee.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real smee.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[1] "Reference temperature";
//   parameter Real smee.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smee.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.rs.resistor[2].useHeatPort = smee.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smee.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real smee.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real smee.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[2] "Reference temperature";
//   parameter Real smee.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smee.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.rs.resistor[3].useHeatPort = smee.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smee.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real smee.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real smee.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[3] "Reference temperature";
//   parameter Real smee.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smee.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer smee.lssigma.m(min = 1) = 3 "number of phases";
//   Real smee.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smee.lssigma.plug_p.m(min = 1) = smee.lssigma.m "number of phases";
//   Real smee.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.lssigma.plug_n.m(min = 1) = smee.lssigma.m "number of phases";
//   Real smee.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = smee.Lssigma "Inductance";
//   parameter Real smee.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = smee.Lssigma "Inductance";
//   parameter Real smee.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = smee.Lssigma "Inductance";
//   Real smee.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = smee.lssigma.L[1] "Inductance";
//   Real smee.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = smee.lssigma.L[2] "Inductance";
//   Real smee.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = smee.lssigma.L[3] "Inductance";
//   constant Integer smee.spacePhasorS.m = 3 "number of phases";
//   constant Real smee.spacePhasorS.pi = 3.14159265358979;
//   parameter Real smee.spacePhasorS.turnsRatio = 1.0;
//   Real smee.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smee.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smee.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smee.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smee.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smee.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer smee.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real smee.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real smee.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer smee.airGapR.m = 3 "number of phases";
//   parameter Integer smee.airGapR.p(min = 1) = smee.p "number of pole pairs";
//   output Real smee.airGapR.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real smee.airGapR.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real smee.airGapR.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smee.airGapR.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smee.airGapR.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.airGapR.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.airGapR.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.airGapR.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.airGapR.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real smee.airGapR.Lmd(quantity = "Inductance", unit = "H") = smee.Lmd "main field inductance d-axis";
//   parameter Real smee.airGapR.Lmq(quantity = "Inductance", unit = "H") = smee.Lmq "main field inductance q-axis";
//   Real smee.airGapR.i_mr[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_mr[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   protected parameter Real smee.airGapR.L[1,1](quantity = "Inductance", unit = "H") = smee.airGapR.Lmd "inductance matrix";
//   protected parameter Real smee.airGapR.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smee.airGapR.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smee.airGapR.L[2,2](quantity = "Inductance", unit = "H") = smee.airGapR.Lmq "inductance matrix";
//   parameter Real smee.Lmd(quantity = "Inductance", unit = "H", start = 1.5 * 1.0 / smee.fsNominal / 6.28318530717959) "main field inductance in d-axis";
//   parameter Real smee.Lmq(quantity = "Inductance", unit = "H", start = 1.5 * 1.0 / smee.fsNominal / 6.28318530717959) "main field inductance in q-axis";
//   parameter Boolean smee.useDamperCage(start = true) "enable / disable damper cage";
//   parameter Real smee.Lrsigmad(quantity = "Inductance", unit = "H", start = 0.05 * 1.0 / smee.fsNominal / 6.28318530717959) "damper stray inductance in d-axis";
//   parameter Real smee.Lrsigmaq(quantity = "Inductance", unit = "H") = smee.Lrsigmad "damper stray inductance in q-axis";
//   parameter Real smee.Rrd(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm damper resistance in d-axis";
//   parameter Real smee.Rrq(quantity = "Resistance", unit = "Ohm") = smee.Rrd "warm damper resistance in q-axis";
//   parameter Real smee.VsNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal stator RMS voltage per phase";
//   parameter Real smee.IeOpenCircuit(quantity = "ElectricCurrent", unit = "A", start = 10.0) "open circuit excitation current @ nominal voltage and frequency";
//   parameter Real smee.Re(quantity = "Resistance", unit = "Ohm", start = 2.5) "warm excitation resistance";
//   parameter Real smee.sigmae(min = 0.0, max = 1.0, start = 0.025) "stray fraction of total excitation inductance";
//   output Real smee.ve(quantity = "ElectricPotential", unit = "V") = smee.pin_ep.v - smee.pin_en.v "excitation voltage";
//   output Real smee.ie(quantity = "ElectricCurrent", unit = "A") = smee.pin_ep.i "excitation current";
//   protected parameter Real smee.turnsRatio = 1.4142135623731 * (smee.VsNominal * 1.0 / smee.IeOpenCircuit / smee.Lmd / smee.fsNominal / 6.28318530717959) "stator current / excitation current";
//   protected parameter Real smee.Lesigma(quantity = "Inductance", unit = "H") = 1.5 * (smee.Lmd * (smee.turnsRatio ^ 2.0 * smee.sigmae / (1.0 - smee.sigmae)));
//   parameter Real smee.electricalExcitation.turnsRatio(start = 1.0) = smee.turnsRatio "stator current / excitation current";
//   Real smee.electricalExcitation.ie(quantity = "ElectricCurrent", unit = "A") "excitation current";
//   Real smee.electricalExcitation.ve(quantity = "ElectricPotential", unit = "V") "excitation voltage";
//   Real smee.electricalExcitation.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.electricalExcitation.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.electricalExcitation.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.electricalExcitation.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.re.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real smee.re.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.re.T_ref "Fixed device temperature if useHeatPort = false";
//   Real smee.re.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.re.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.re.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Re "Resistance at temperature T_ref";
//   parameter Real smee.re.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real smee.re.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.re.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.lesigma.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lesigma.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lesigma.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lesigma.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lesigma.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lesigma.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lesigma.L(quantity = "Inductance", unit = "H", start = 1.0) = smee.Lesigma "Inductance";
//   Real smee.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaStator.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaStator.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaStator.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaStator.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smee.inertiaStator.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = smee.Js "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) smee.inertiaStator.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real smee.inertiaStator.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real smee.inertiaStator.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real smee.inertiaStator.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   output Real smee.idq_dr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.damperCage.spacePhasor_r.i_[1] "damper space phasor current / rotor fixed frame";
//   output Real smee.idq_dr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.damperCage.spacePhasor_r.i_[2] "damper space phasor current / rotor fixed frame";
//   parameter Real smee.damperCage.Lrsigmad(quantity = "Inductance", unit = "H") = smee.Lrsigmad "stray inductance in d-axis per phase translated to stator";
//   parameter Real smee.damperCage.Lrsigmaq(quantity = "Inductance", unit = "H") = smee.Lrsigmaq "stray inductance in q-axis per phase translated to stator";
//   parameter Real smee.damperCage.Rrd(quantity = "Resistance", unit = "Ohm") = smee.Rrd "warm resistance in d-axis per phase translated to stator";
//   parameter Real smee.damperCage.Rrq(quantity = "Resistance", unit = "Ohm") = smee.Rrq "warm resistance in q-axis per phase translated to stator";
//   Real smee.damperCage.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.damperCage.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.damperCage.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.damperCage.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   constant Integer rotorDisplacementAngle.m = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.p(min = 1) = smee.p "number of pole pairs";
//   parameter Boolean rotorDisplacementAngle.useSupport = true "use support or fixed housing";
//   output Real rotorDisplacementAngle.rotorDisplacementAngle;
//   parameter Integer rotorDisplacementAngle.plug_p.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.plug_n.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_p.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_n.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nin = 3 "Number of inputs";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nout = 2 "Number of outputs";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[2] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[3] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[2] "Connector of Real output signals";
//   constant Integer rotorDisplacementAngle.ToSpacePhasorVS.m = 3 "number of phases";
//   constant Real rotorDisplacementAngle.ToSpacePhasorVS.pi = 3.14159265358979;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,2] = -0.866025403784438;
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.zero;
//   Real rotorDisplacementAngle.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real rotorDisplacementAngle.relativeAngleSensor.phi_rel "Relative angle between two flanges (= flange_b.phi - flange_a.phi)";
//   output Real rotorDisplacementAngle.constant_.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.constant_.k(start = 1.0) = 1.5707963267949 "Constant output value";
//   input Real rotorDisplacementAngle.add.u1 "Connector of Real input signal 1";
//   input Real rotorDisplacementAngle.add.u2 "Connector of Real input signal 2";
//   output Real rotorDisplacementAngle.add.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.add.k1 = Real(rotorDisplacementAngle.p) "Gain of upper input";
//   parameter Real rotorDisplacementAngle.add.k2 = 1.0 "Gain of lower input";
//   parameter Integer rotorDisplacementAngle.rotatorVS2R.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[2] "Connector of Real output signals";
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] = -sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] = sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   input Real rotorDisplacementAngle.rotatorVS2R.angle;
//   parameter Integer rotorDisplacementAngle.ToPolarVSR.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[2] "Connector of Real output signals";
//   constant Real rotorDisplacementAngle.ToPolarVSR.small = 1e-60;
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n1 = 1 "dimension of output signal connector 1";
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n2 = 1 "dimension of output signal connector 2";
//   input Real rotorDisplacementAngle.deMultiplex2.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.deMultiplex2.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.deMultiplex2.y1[1] "Connector of Real output signals 1";
//   output Real rotorDisplacementAngle.deMultiplex2.y2[1] "Connector of Real output signals 2";
//   Real rotorDisplacementAngle.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real groundExcitation.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundExcitation.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean constantSpeed.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real constantSpeed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real constantSpeed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real constantSpeed.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real constantSpeed.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   Real constantSpeed.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   parameter Real constantSpeed.w_fixed(quantity = "AngularVelocity", unit = "rad/s") = wActual "Fixed speed";
//   Real mechanicalPowerSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Boolean mechanicalPowerSensor.useSupport = true "use support or fixed housing";
//   output Real mechanicalPowerSensor.P;
//   Real mechanicalPowerSensor.torqueSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.torqueSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.torqueSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.torqueSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real mechanicalPowerSensor.torqueSensor.tau "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau)";
//   input Real mechanicalPowerSensor.product.u1 "Connector of Real input signal 1";
//   input Real mechanicalPowerSensor.product.u2 "Connector of Real input signal 2";
//   output Real mechanicalPowerSensor.product.y "Connector of Real output signal";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.relSpeedSensor.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg") "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//   output Real mechanicalPowerSensor.relSpeedSensor.w_rel "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi))";
//   Real mechanicalPowerSensor.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer electricalPowerSensor.m(min = 1) = 3 "Number of phases";
//   output Real electricalPowerSensor.P;
//   output Real electricalPowerSensor.Q;
//   parameter Integer electricalPowerSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensor.plug_ni.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensor.plug_ni.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_ni.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_ni.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_ni.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_ni.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_ni.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensor.plug_nv.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensor.plug_nv.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_nv.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_nv.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_nv.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_nv.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_nv.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected Real electricalPowerSensor.v_[1](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensor.v_[2](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensor.i_[1](quantity = "ElectricCurrent", unit = "A");
//   protected Real electricalPowerSensor.i_[2](quantity = "ElectricCurrent", unit = "A");
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rampCurrent.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real rampCurrent.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real rampCurrent.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rampCurrent.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rampCurrent.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rampCurrent.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real rampCurrent.offset(quantity = "ElectricCurrent", unit = "A") = Ie0 "Current offset";
//   parameter Real rampCurrent.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
//   output Real rampCurrent.signalSource.y "Connector of Real output signal";
//   parameter Real rampCurrent.signalSource.height = rampCurrent.I "Height of ramps";
//   parameter Real rampCurrent.signalSource.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = rampCurrent.duration "Durations of ramp";
//   parameter Real rampCurrent.signalSource.offset = rampCurrent.offset "Offset of output signal";
//   parameter Real rampCurrent.signalSource.startTime(quantity = "Time", unit = "s") = rampCurrent.startTime "Output = offset for time < startTime";
//   parameter Real rampCurrent.I(quantity = "ElectricCurrent", unit = "A", start = 1.0) = Ie - Ie0 "Height of ramp";
//   parameter Real rampCurrent.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = 0.1 "Duration of ramp";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.star.m(min = 1) = 3 "number of phases";
//   parameter Integer terminalBox.star.plug_p.m(min = 1) = terminalBox.star.m "number of phases";
//   Real terminalBox.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// equation
//   smee.inertiaRotor.phi = smee.inertiaRotor.flange_a.phi;
//   smee.inertiaRotor.phi = smee.inertiaRotor.flange_b.phi;
//   smee.inertiaRotor.w = der(smee.inertiaRotor.phi);
//   smee.inertiaRotor.a = der(smee.inertiaRotor.w);
//   smee.inertiaRotor.J * smee.inertiaRotor.a = smee.inertiaRotor.flange_a.tau + smee.inertiaRotor.flange_b.tau;
//   assert(1.0 + smee.rs.resistor[1].alpha * (smee.rs.resistor[1].T_heatPort - smee.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.rs.resistor[1].R_actual = smee.rs.resistor[1].R * (1.0 + smee.rs.resistor[1].alpha * (smee.rs.resistor[1].T_heatPort - smee.rs.resistor[1].T_ref));
//   smee.rs.resistor[1].v = smee.rs.resistor[1].R_actual * smee.rs.resistor[1].i;
//   smee.rs.resistor[1].LossPower = smee.rs.resistor[1].v * smee.rs.resistor[1].i;
//   smee.rs.resistor[1].i = smee.rs.resistor[1].p.i;
//   0.0 = smee.rs.resistor[1].p.i + smee.rs.resistor[1].n.i;
//   smee.rs.resistor[1].v = smee.rs.resistor[1].p.v - smee.rs.resistor[1].n.v;
//   smee.rs.resistor[1].T_heatPort = smee.rs.resistor[1].T;
//   assert(1.0 + smee.rs.resistor[2].alpha * (smee.rs.resistor[2].T_heatPort - smee.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.rs.resistor[2].R_actual = smee.rs.resistor[2].R * (1.0 + smee.rs.resistor[2].alpha * (smee.rs.resistor[2].T_heatPort - smee.rs.resistor[2].T_ref));
//   smee.rs.resistor[2].v = smee.rs.resistor[2].R_actual * smee.rs.resistor[2].i;
//   smee.rs.resistor[2].LossPower = smee.rs.resistor[2].v * smee.rs.resistor[2].i;
//   smee.rs.resistor[2].i = smee.rs.resistor[2].p.i;
//   0.0 = smee.rs.resistor[2].p.i + smee.rs.resistor[2].n.i;
//   smee.rs.resistor[2].v = smee.rs.resistor[2].p.v - smee.rs.resistor[2].n.v;
//   smee.rs.resistor[2].T_heatPort = smee.rs.resistor[2].T;
//   assert(1.0 + smee.rs.resistor[3].alpha * (smee.rs.resistor[3].T_heatPort - smee.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.rs.resistor[3].R_actual = smee.rs.resistor[3].R * (1.0 + smee.rs.resistor[3].alpha * (smee.rs.resistor[3].T_heatPort - smee.rs.resistor[3].T_ref));
//   smee.rs.resistor[3].v = smee.rs.resistor[3].R_actual * smee.rs.resistor[3].i;
//   smee.rs.resistor[3].LossPower = smee.rs.resistor[3].v * smee.rs.resistor[3].i;
//   smee.rs.resistor[3].i = smee.rs.resistor[3].p.i;
//   0.0 = smee.rs.resistor[3].p.i + smee.rs.resistor[3].n.i;
//   smee.rs.resistor[3].v = smee.rs.resistor[3].p.v - smee.rs.resistor[3].n.v;
//   smee.rs.resistor[3].T_heatPort = smee.rs.resistor[3].T;
//   smee.rs.v[1] = smee.rs.plug_p.pin[1].v - smee.rs.plug_n.pin[1].v;
//   smee.rs.v[2] = smee.rs.plug_p.pin[2].v - smee.rs.plug_n.pin[2].v;
//   smee.rs.v[3] = smee.rs.plug_p.pin[3].v - smee.rs.plug_n.pin[3].v;
//   smee.rs.i[1] = smee.rs.plug_p.pin[1].i;
//   smee.rs.i[2] = smee.rs.plug_p.pin[2].i;
//   smee.rs.i[3] = smee.rs.plug_p.pin[3].i;
//   smee.lssigma.inductor[1].L * der(smee.lssigma.inductor[1].i) = smee.lssigma.inductor[1].v;
//   smee.lssigma.inductor[1].v = smee.lssigma.inductor[1].p.v - smee.lssigma.inductor[1].n.v;
//   0.0 = smee.lssigma.inductor[1].p.i + smee.lssigma.inductor[1].n.i;
//   smee.lssigma.inductor[1].i = smee.lssigma.inductor[1].p.i;
//   smee.lssigma.inductor[2].L * der(smee.lssigma.inductor[2].i) = smee.lssigma.inductor[2].v;
//   smee.lssigma.inductor[2].v = smee.lssigma.inductor[2].p.v - smee.lssigma.inductor[2].n.v;
//   0.0 = smee.lssigma.inductor[2].p.i + smee.lssigma.inductor[2].n.i;
//   smee.lssigma.inductor[2].i = smee.lssigma.inductor[2].p.i;
//   smee.lssigma.inductor[3].L * der(smee.lssigma.inductor[3].i) = smee.lssigma.inductor[3].v;
//   smee.lssigma.inductor[3].v = smee.lssigma.inductor[3].p.v - smee.lssigma.inductor[3].n.v;
//   0.0 = smee.lssigma.inductor[3].p.i + smee.lssigma.inductor[3].n.i;
//   smee.lssigma.inductor[3].i = smee.lssigma.inductor[3].p.i;
//   smee.lssigma.v[1] = smee.lssigma.plug_p.pin[1].v - smee.lssigma.plug_n.pin[1].v;
//   smee.lssigma.v[2] = smee.lssigma.plug_p.pin[2].v - smee.lssigma.plug_n.pin[2].v;
//   smee.lssigma.v[3] = smee.lssigma.plug_p.pin[3].v - smee.lssigma.plug_n.pin[3].v;
//   smee.lssigma.i[1] = smee.lssigma.plug_p.pin[1].i;
//   smee.lssigma.i[2] = smee.lssigma.plug_p.pin[2].i;
//   smee.lssigma.i[3] = smee.lssigma.plug_p.pin[3].i;
//   smee.spacePhasorS.gnd.p.v = 0.0;
//   smee.spacePhasorS.v[1] / smee.spacePhasorS.turnsRatio = smee.spacePhasorS.plug_p.pin[1].v - smee.spacePhasorS.plug_n.pin[1].v;
//   smee.spacePhasorS.v[2] / smee.spacePhasorS.turnsRatio = smee.spacePhasorS.plug_p.pin[2].v - smee.spacePhasorS.plug_n.pin[2].v;
//   smee.spacePhasorS.v[3] / smee.spacePhasorS.turnsRatio = smee.spacePhasorS.plug_p.pin[3].v - smee.spacePhasorS.plug_n.pin[3].v;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[1] = smee.spacePhasorS.plug_p.pin[1].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[2] = smee.spacePhasorS.plug_p.pin[2].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[3] = smee.spacePhasorS.plug_p.pin[3].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[1] = -smee.spacePhasorS.plug_n.pin[1].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[2] = -smee.spacePhasorS.plug_n.pin[2].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[3] = -smee.spacePhasorS.plug_n.pin[3].i;
//   smee.spacePhasorS.zero.v = 0.333333333333333 * (smee.spacePhasorS.v[1] + (smee.spacePhasorS.v[2] + smee.spacePhasorS.v[3]));
//   smee.spacePhasorS.spacePhasor.v_[1] = smee.spacePhasorS.TransformationMatrix[1,1] * smee.spacePhasorS.v[1] + (smee.spacePhasorS.TransformationMatrix[1,2] * smee.spacePhasorS.v[2] + smee.spacePhasorS.TransformationMatrix[1,3] * smee.spacePhasorS.v[3]);
//   smee.spacePhasorS.spacePhasor.v_[2] = smee.spacePhasorS.TransformationMatrix[2,1] * smee.spacePhasorS.v[1] + (smee.spacePhasorS.TransformationMatrix[2,2] * smee.spacePhasorS.v[2] + smee.spacePhasorS.TransformationMatrix[2,3] * smee.spacePhasorS.v[3]);
//   -smee.spacePhasorS.zero.i = 0.333333333333333 * (smee.spacePhasorS.i[1] + (smee.spacePhasorS.i[2] + smee.spacePhasorS.i[3]));
//   -smee.spacePhasorS.spacePhasor.i_[1] = smee.spacePhasorS.TransformationMatrix[1,1] * smee.spacePhasorS.i[1] + (smee.spacePhasorS.TransformationMatrix[1,2] * smee.spacePhasorS.i[2] + smee.spacePhasorS.TransformationMatrix[1,3] * smee.spacePhasorS.i[3]);
//   -smee.spacePhasorS.spacePhasor.i_[2] = smee.spacePhasorS.TransformationMatrix[2,1] * smee.spacePhasorS.i[1] + (smee.spacePhasorS.TransformationMatrix[2,2] * smee.spacePhasorS.i[2] + smee.spacePhasorS.TransformationMatrix[2,3] * smee.spacePhasorS.i[3]);
//   smee.airGapR.i_mr[1] = smee.airGapR.i_sr[1] + smee.airGapR.i_rr[1];
//   smee.airGapR.i_mr[2] = smee.airGapR.i_sr[2] + smee.airGapR.i_rr[2];
//   smee.airGapR.psi_mr[1] = smee.airGapR.L[1,1] * smee.airGapR.i_mr[1] + smee.airGapR.L[1,2] * smee.airGapR.i_mr[2];
//   smee.airGapR.psi_mr[2] = smee.airGapR.L[2,1] * smee.airGapR.i_mr[1] + smee.airGapR.L[2,2] * smee.airGapR.i_mr[2];
//   smee.airGapR.psi_ms[1] = smee.airGapR.RotationMatrix[1,1] * smee.airGapR.psi_mr[1] + smee.airGapR.RotationMatrix[1,2] * smee.airGapR.psi_mr[2];
//   smee.airGapR.psi_ms[2] = smee.airGapR.RotationMatrix[2,1] * smee.airGapR.psi_mr[1] + smee.airGapR.RotationMatrix[2,2] * smee.airGapR.psi_mr[2];
//   smee.airGapR.gamma = Real(smee.airGapR.p) * (smee.airGapR.flange.phi - smee.airGapR.support.phi);
//   smee.airGapR.RotationMatrix[1,1] = cos(smee.airGapR.gamma);
//   smee.airGapR.RotationMatrix[1,2] = -sin(smee.airGapR.gamma);
//   smee.airGapR.RotationMatrix[2,1] = sin(smee.airGapR.gamma);
//   smee.airGapR.RotationMatrix[2,2] = cos(smee.airGapR.gamma);
//   smee.airGapR.i_ss[1] = smee.airGapR.spacePhasor_s.i_[1];
//   smee.airGapR.i_ss[2] = smee.airGapR.spacePhasor_s.i_[2];
//   smee.airGapR.i_ss[1] = smee.airGapR.RotationMatrix[1,1] * smee.airGapR.i_sr[1] + smee.airGapR.RotationMatrix[1,2] * smee.airGapR.i_sr[2];
//   smee.airGapR.i_ss[2] = smee.airGapR.RotationMatrix[2,1] * smee.airGapR.i_sr[1] + smee.airGapR.RotationMatrix[2,2] * smee.airGapR.i_sr[2];
//   smee.airGapR.i_rr[1] = smee.airGapR.spacePhasor_r.i_[1];
//   smee.airGapR.i_rr[2] = smee.airGapR.spacePhasor_r.i_[2];
//   smee.airGapR.i_rs[1] = smee.airGapR.RotationMatrix[1,1] * smee.airGapR.i_rr[1] + smee.airGapR.RotationMatrix[1,2] * smee.airGapR.i_rr[2];
//   smee.airGapR.i_rs[2] = smee.airGapR.RotationMatrix[2,1] * smee.airGapR.i_rr[1] + smee.airGapR.RotationMatrix[2,2] * smee.airGapR.i_rr[2];
//   smee.airGapR.spacePhasor_s.v_[1] = der(smee.airGapR.psi_ms[1]);
//   smee.airGapR.spacePhasor_s.v_[2] = der(smee.airGapR.psi_ms[2]);
//   smee.airGapR.spacePhasor_r.v_[1] = der(smee.airGapR.psi_mr[1]);
//   smee.airGapR.spacePhasor_r.v_[2] = der(smee.airGapR.psi_mr[2]);
//   smee.airGapR.tauElectrical = Real(smee.airGapR.m) * (Real(smee.airGapR.p) * (smee.airGapR.spacePhasor_s.i_[2] * smee.airGapR.psi_ms[1] - smee.airGapR.spacePhasor_s.i_[1] * smee.airGapR.psi_ms[2]) / 2.0);
//   smee.airGapR.flange.tau = -smee.airGapR.tauElectrical;
//   smee.airGapR.support.tau = smee.airGapR.tauElectrical;
//   smee.electricalExcitation.pin_ep.i + smee.electricalExcitation.pin_en.i = 0.0;
//   smee.electricalExcitation.ie = smee.electricalExcitation.pin_ep.i;
//   smee.electricalExcitation.ve = smee.electricalExcitation.pin_ep.v - smee.electricalExcitation.pin_en.v;
//   smee.electricalExcitation.spacePhasor_r.i_[1] = (-smee.electricalExcitation.ie) * smee.electricalExcitation.turnsRatio;
//   smee.electricalExcitation.spacePhasor_r.i_[2] = 0.0;
//   smee.electricalExcitation.ve = 1.5 * (smee.electricalExcitation.spacePhasor_r.v_[1] * smee.electricalExcitation.turnsRatio);
//   assert(1.0 + smee.re.alpha * (smee.re.T_heatPort - smee.re.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.re.R_actual = smee.re.R * (1.0 + smee.re.alpha * (smee.re.T_heatPort - smee.re.T_ref));
//   smee.re.v = smee.re.R_actual * smee.re.i;
//   smee.re.LossPower = smee.re.v * smee.re.i;
//   smee.re.i = smee.re.p.i;
//   0.0 = smee.re.p.i + smee.re.n.i;
//   smee.re.v = smee.re.p.v - smee.re.n.v;
//   smee.re.T_heatPort = smee.re.T;
//   smee.lesigma.L * der(smee.lesigma.i) = smee.lesigma.v;
//   smee.lesigma.v = smee.lesigma.p.v - smee.lesigma.n.v;
//   0.0 = smee.lesigma.p.i + smee.lesigma.n.i;
//   smee.lesigma.i = smee.lesigma.p.i;
//   smee.inertiaStator.phi = smee.inertiaStator.flange_a.phi;
//   smee.inertiaStator.phi = smee.inertiaStator.flange_b.phi;
//   smee.inertiaStator.w = der(smee.inertiaStator.phi);
//   smee.inertiaStator.a = der(smee.inertiaStator.w);
//   smee.inertiaStator.J * smee.inertiaStator.a = smee.inertiaStator.flange_a.tau + smee.inertiaStator.flange_b.tau;
//   smee.damperCage.spacePhasor_r.v_[1] = smee.damperCage.Rrd * smee.damperCage.spacePhasor_r.i_[1] + smee.damperCage.Lrsigmad * der(smee.damperCage.spacePhasor_r.i_[1]);
//   smee.damperCage.spacePhasor_r.v_[2] = smee.damperCage.Rrq * smee.damperCage.spacePhasor_r.i_[2] + smee.damperCage.Lrsigmaq * der(smee.damperCage.spacePhasor_r.i_[2]);
//   assert(smee.spacePhasorS.plug_n.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(smee.lssigma.plug_n.m == smee.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(smee.rs.plug_n.m == smee.lssigma.plug_p.m,"automatically generated from connect");
//   assert(smee.plug_sp.m == smee.rs.plug_p.m,"automatically generated from connect");
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.ToSpacePhasorVS.zero = 0.333333333333333 * (rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.u[3]));
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.relativeAngleSensor.phi_rel = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi - rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + rotorDisplacementAngle.relativeAngleSensor.flange_b.tau;
//   rotorDisplacementAngle.constant_.y = rotorDisplacementAngle.constant_.k;
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.add.k1 * rotorDisplacementAngle.add.u1 + rotorDisplacementAngle.add.k2 * rotorDisplacementAngle.add.u2;
//   rotorDisplacementAngle.rotatorVS2R.y[1] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.rotatorVS2R.y[2] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.ToPolarVSR.y[1] = sqrt(rotorDisplacementAngle.ToPolarVSR.u[1] ^ 2.0 + rotorDisplacementAngle.ToPolarVSR.u[2] ^ 2.0);
//   rotorDisplacementAngle.ToPolarVSR.y[2] = if noEvent(rotorDisplacementAngle.ToPolarVSR.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(rotorDisplacementAngle.ToPolarVSR.u[2],rotorDisplacementAngle.ToPolarVSR.u[1]);
//   rotorDisplacementAngle.deMultiplex2.u[1] = rotorDisplacementAngle.deMultiplex2.y1[1];
//   rotorDisplacementAngle.deMultiplex2.u[2] = rotorDisplacementAngle.deMultiplex2.y2[1];
//   assert(rotorDisplacementAngle.plug_p.m == rotorDisplacementAngle.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_n.m == rotorDisplacementAngle.VoltageSensor1.plug_n.m,"automatically generated from connect");
//   groundExcitation.p.v = 0.0;
//   constantSpeed.w = der(constantSpeed.phi);
//   constantSpeed.w = constantSpeed.w_fixed;
//   constantSpeed.phi = constantSpeed.flange.phi - constantSpeed.phi_support;
//   constantSpeed.phi_support = 0.0;
//   mechanicalPowerSensor.torqueSensor.flange_a.phi = mechanicalPowerSensor.torqueSensor.flange_b.phi;
//   mechanicalPowerSensor.torqueSensor.flange_a.tau = mechanicalPowerSensor.torqueSensor.tau;
//   0.0 = mechanicalPowerSensor.torqueSensor.flange_a.tau + mechanicalPowerSensor.torqueSensor.flange_b.tau;
//   mechanicalPowerSensor.product.y = mechanicalPowerSensor.product.u1 * mechanicalPowerSensor.product.u2;
//   mechanicalPowerSensor.relSpeedSensor.phi_rel = mechanicalPowerSensor.relSpeedSensor.flange_b.phi - mechanicalPowerSensor.relSpeedSensor.flange_a.phi;
//   mechanicalPowerSensor.relSpeedSensor.w_rel = der(mechanicalPowerSensor.relSpeedSensor.phi_rel);
//   0.0 = mechanicalPowerSensor.relSpeedSensor.flange_a.tau;
//   0.0 = mechanicalPowerSensor.relSpeedSensor.flange_a.tau + mechanicalPowerSensor.relSpeedSensor.flange_b.tau;
//   electricalPowerSensor.plug_p.pin[1].v = electricalPowerSensor.plug_ni.pin[1].v;
//   electricalPowerSensor.plug_p.pin[2].v = electricalPowerSensor.plug_ni.pin[2].v;
//   electricalPowerSensor.plug_p.pin[3].v = electricalPowerSensor.plug_ni.pin[3].v;
//   electricalPowerSensor.plug_p.pin[1].i + electricalPowerSensor.plug_ni.pin[1].i = 0.0;
//   electricalPowerSensor.plug_p.pin[2].i + electricalPowerSensor.plug_ni.pin[2].i = 0.0;
//   electricalPowerSensor.plug_p.pin[3].i + electricalPowerSensor.plug_ni.pin[3].i = 0.0;
//   electricalPowerSensor.plug_nv.pin[1].i = 0.0;
//   electricalPowerSensor.plug_nv.pin[2].i = 0.0;
//   electricalPowerSensor.plug_nv.pin[3].i = 0.0;
//   (electricalPowerSensor.v_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensor.plug_p.pin[1].v - electricalPowerSensor.plug_nv.pin[1].v,electricalPowerSensor.plug_p.pin[2].v - electricalPowerSensor.plug_nv.pin[2].v,electricalPowerSensor.plug_p.pin[3].v - electricalPowerSensor.plug_nv.pin[3].v});
//   (electricalPowerSensor.i_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensor.plug_p.pin[1].i,electricalPowerSensor.plug_p.pin[2].i,electricalPowerSensor.plug_p.pin[3].i});
//   0.666666666666667 * electricalPowerSensor.P = electricalPowerSensor.v_[1] * electricalPowerSensor.i_[1] + electricalPowerSensor.v_[2] * electricalPowerSensor.i_[2];
//   0.666666666666667 * electricalPowerSensor.Q = (-electricalPowerSensor.v_[1]) * electricalPowerSensor.i_[2] + electricalPowerSensor.v_[2] * electricalPowerSensor.i_[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   rampCurrent.signalSource.y = rampCurrent.signalSource.offset + (if time < rampCurrent.signalSource.startTime then 0.0 else if time < rampCurrent.signalSource.startTime + rampCurrent.signalSource.duration then ((time - rampCurrent.signalSource.startTime) * rampCurrent.signalSource.height) / rampCurrent.signalSource.duration else rampCurrent.signalSource.height);
//   rampCurrent.i = rampCurrent.signalSource.y;
//   rampCurrent.v = rampCurrent.p.v - rampCurrent.n.v;
//   0.0 = rampCurrent.p.i + rampCurrent.n.i;
//   rampCurrent.i = rampCurrent.p.i;
//   assert(terminalBox.plug_sn.m == terminalBox.star.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   fixed.flange.phi = fixed.phi0;
//   assert(rotorDisplacementAngle.plug_n.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_p.m == smee.plug_sp.m,"automatically generated from connect");
//   assert(star.plug_p.m == sineVoltage.plug_n.m,"automatically generated from connect");
//   assert(electricalPowerSensor.plug_ni.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == electricalPowerSensor.plug_p.m,"automatically generated from connect");
//   assert(electricalPowerSensor.plug_nv.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == smee.plug_sp.m,"automatically generated from connect");
//   smee.flange.tau + (rotorDisplacementAngle.flange.tau + mechanicalPowerSensor.flange_a.tau) = 0.0;
//   mechanicalPowerSensor.flange_a.phi = mechanicalPowerSensor.relSpeedSensor.flange_b.phi;
//   mechanicalPowerSensor.flange_a.phi = mechanicalPowerSensor.torqueSensor.flange_a.phi;
//   mechanicalPowerSensor.flange_a.phi = rotorDisplacementAngle.flange.phi;
//   mechanicalPowerSensor.flange_a.phi = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi;
//   mechanicalPowerSensor.flange_a.phi = smee.flange.phi;
//   mechanicalPowerSensor.flange_a.phi = smee.inertiaRotor.flange_b.phi;
//   rotorDisplacementAngle.support.tau + (smee.support.tau + (mechanicalPowerSensor.support.tau + fixed.flange.tau)) = 0.0;
//   fixed.flange.phi = mechanicalPowerSensor.relSpeedSensor.flange_a.phi;
//   fixed.flange.phi = mechanicalPowerSensor.support.phi;
//   fixed.flange.phi = rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   fixed.flange.phi = rotorDisplacementAngle.support.phi;
//   fixed.flange.phi = smee.inertiaStator.flange_b.phi;
//   fixed.flange.phi = smee.support.phi;
//   terminalBox.plug_sp.pin[3].i + (rotorDisplacementAngle.plug_p.pin[3].i + smee.plug_sp.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = rotorDisplacementAngle.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = smee.plug_sp.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = smee.rs.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = smee.rs.resistor[3].p.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = terminalBox.plugSupply.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + (rotorDisplacementAngle.plug_p.pin[2].i + smee.plug_sp.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = rotorDisplacementAngle.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = smee.plug_sp.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = smee.rs.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = smee.rs.resistor[2].p.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = terminalBox.plugSupply.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + (rotorDisplacementAngle.plug_p.pin[1].i + smee.plug_sp.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = rotorDisplacementAngle.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = smee.plug_sp.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = smee.rs.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = smee.rs.resistor[1].p.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = terminalBox.plugSupply.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plug_sn.pin[3].i + (electricalPowerSensor.plug_nv.pin[3].i + (rotorDisplacementAngle.plug_n.pin[3].i + smee.plug_sn.pin[3].i)) = 0.0;
//   electricalPowerSensor.plug_nv.pin[1].v = electricalPowerSensor.plug_nv.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = electricalPowerSensor.plug_nv.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.plug_n.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.plug_n.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.plug_n.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.plug_sn.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.plug_sn.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.plug_sn.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.spacePhasorS.plug_n.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.spacePhasorS.plug_n.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.spacePhasorS.plug_n.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.plug_sn.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.plug_sn.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.star.pin_n.v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.star.plug_p.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.star.plug_p.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.star.plug_p.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.starpoint.v;
//   terminalBox.plug_sn.pin[2].i + (electricalPowerSensor.plug_nv.pin[2].i + (rotorDisplacementAngle.plug_n.pin[2].i + smee.plug_sn.pin[2].i)) = 0.0;
//   terminalBox.plug_sn.pin[1].i + (electricalPowerSensor.plug_nv.pin[1].i + (rotorDisplacementAngle.plug_n.pin[1].i + smee.plug_sn.pin[1].i)) = 0.0;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   rampCurrent.n.i + smee.pin_ep.i = 0.0;
//   rampCurrent.n.v = smee.pin_ep.v;
//   rampCurrent.n.v = smee.re.p.v;
//   rampCurrent.p.i + (groundExcitation.p.i + smee.pin_en.i) = 0.0;
//   groundExcitation.p.v = rampCurrent.p.v;
//   groundExcitation.p.v = smee.electricalExcitation.pin_en.v;
//   groundExcitation.p.v = smee.pin_en.v;
//   sineVoltage.plug_p.pin[3].i + electricalPowerSensor.plug_p.pin[3].i = 0.0;
//   electricalPowerSensor.plug_p.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   electricalPowerSensor.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.plug_p.pin[2].i + electricalPowerSensor.plug_p.pin[2].i = 0.0;
//   electricalPowerSensor.plug_p.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   electricalPowerSensor.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.plug_p.pin[1].i + electricalPowerSensor.plug_p.pin[1].i = 0.0;
//   electricalPowerSensor.plug_p.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   electricalPowerSensor.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
//   mechanicalPowerSensor.flange_b.tau + constantSpeed.flange.tau = 0.0;
//   constantSpeed.flange.phi = mechanicalPowerSensor.flange_b.phi;
//   constantSpeed.flange.phi = mechanicalPowerSensor.torqueSensor.flange_b.phi;
//   electricalPowerSensor.plug_ni.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = electricalPowerSensor.plug_ni.pin[3].v;
//   electricalPowerSensor.plug_ni.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = electricalPowerSensor.plug_ni.pin[2].v;
//   electricalPowerSensor.plug_ni.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = electricalPowerSensor.plug_ni.pin[1].v;
//   star.plug_p.pin[3].i + sineVoltage.plug_n.pin[3].i = 0.0;
//   ground.p.v = sineVoltage.plug_n.pin[1].v;
//   ground.p.v = sineVoltage.plug_n.pin[2].v;
//   ground.p.v = sineVoltage.plug_n.pin[3].v;
//   ground.p.v = sineVoltage.sineVoltage[1].n.v;
//   ground.p.v = sineVoltage.sineVoltage[2].n.v;
//   ground.p.v = sineVoltage.sineVoltage[3].n.v;
//   ground.p.v = star.pin_n.v;
//   ground.p.v = star.plug_p.pin[1].v;
//   ground.p.v = star.plug_p.pin[2].v;
//   ground.p.v = star.plug_p.pin[3].v;
//   star.plug_p.pin[2].i + sineVoltage.plug_n.pin[2].i = 0.0;
//   star.plug_p.pin[1].i + sineVoltage.plug_n.pin[1].i = 0.0;
//   star.pin_n.i + ground.p.i = 0.0;
//   terminalBox.star.pin_n.i + (-terminalBox.starpoint.i) = 0.0;
//   (-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i) = 0.0;
//   (-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i) = 0.0;
//   (-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i) = 0.0;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.star.plug_p.pin[3].i = 0.0;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.star.plug_p.pin[2].i = 0.0;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.star.plug_p.pin[1].i = 0.0;
//   terminalBox.starpoint.i = 0.0;
//   (-terminalBox.star.plug_p.pin[3].i) + ((-terminalBox.star.plug_p.pin[2].i) + ((-terminalBox.star.plug_p.pin[1].i) + (-terminalBox.star.pin_n.i))) = 0.0;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   mechanicalPowerSensor.relSpeedSensor.flange_a.tau + (-mechanicalPowerSensor.support.tau) = 0.0;
//   mechanicalPowerSensor.product.u1 = mechanicalPowerSensor.relSpeedSensor.w_rel;
//   (-mechanicalPowerSensor.flange_a.tau) + (mechanicalPowerSensor.torqueSensor.flange_a.tau + mechanicalPowerSensor.relSpeedSensor.flange_b.tau) = 0.0;
//   mechanicalPowerSensor.product.u2 = mechanicalPowerSensor.torqueSensor.tau;
//   mechanicalPowerSensor.P = mechanicalPowerSensor.product.y;
//   mechanicalPowerSensor.torqueSensor.flange_b.tau + (-mechanicalPowerSensor.flange_b.tau) = 0.0;
//   rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + (-rotorDisplacementAngle.support.tau) = 0.0;
//   rotorDisplacementAngle.relativeAngleSensor.flange_b.tau + (-rotorDisplacementAngle.flange.tau) = 0.0;
//   rotorDisplacementAngle.add.u1 = rotorDisplacementAngle.relativeAngleSensor.phi_rel;
//   rotorDisplacementAngle.deMultiplex2.y2[1] = rotorDisplacementAngle.rotorDisplacementAngle;
//   rotorDisplacementAngle.ToSpacePhasorVS.u[1] = rotorDisplacementAngle.VoltageSensor1.v[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[1] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v;
//   rotorDisplacementAngle.ToSpacePhasorVS.u[2] = rotorDisplacementAngle.VoltageSensor1.v[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[2] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v;
//   rotorDisplacementAngle.ToSpacePhasorVS.u[3] = rotorDisplacementAngle.VoltageSensor1.v[3];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[3] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v;
//   (-rotorDisplacementAngle.plug_n.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i = 0.0;
//   (-rotorDisplacementAngle.plug_n.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i = 0.0;
//   (-rotorDisplacementAngle.plug_n.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i = 0.0;
//   (-rotorDisplacementAngle.plug_p.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   (-rotorDisplacementAngle.plug_p.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   (-rotorDisplacementAngle.plug_p.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   rotorDisplacementAngle.ToPolarVSR.y[1] = rotorDisplacementAngle.deMultiplex2.u[1];
//   rotorDisplacementAngle.ToPolarVSR.y[2] = rotorDisplacementAngle.deMultiplex2.u[2];
//   rotorDisplacementAngle.ToPolarVSR.u[1] = rotorDisplacementAngle.rotatorVS2R.y[1];
//   rotorDisplacementAngle.ToPolarVSR.u[2] = rotorDisplacementAngle.rotatorVS2R.y[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.rotatorVS2R.u[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.rotatorVS2R.angle;
//   rotorDisplacementAngle.add.u2 = rotorDisplacementAngle.constant_.y;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   smee.airGapR.support.tau + ((-smee.internalSupport.tau) + smee.inertiaStator.flange_a.tau) = 0.0;
//   smee.airGapR.support.phi = smee.inertiaStator.flange_a.phi;
//   smee.airGapR.support.phi = smee.internalSupport.phi;
//   smee.inertiaStator.flange_b.tau + (-smee.support.tau) = 0.0;
//   smee.inertiaRotor.flange_b.tau + (-smee.flange.tau) = 0.0;
//   (-smee.plug_sp.pin[3].i) + smee.rs.plug_p.pin[3].i = 0.0;
//   (-smee.plug_sp.pin[2].i) + smee.rs.plug_p.pin[2].i = 0.0;
//   (-smee.plug_sp.pin[1].i) + smee.rs.plug_p.pin[1].i = 0.0;
//   smee.rs.plug_n.pin[3].i + smee.lssigma.plug_p.pin[3].i = 0.0;
//   smee.lssigma.inductor[3].p.v = smee.lssigma.plug_p.pin[3].v;
//   smee.lssigma.inductor[3].p.v = smee.rs.plug_n.pin[3].v;
//   smee.lssigma.inductor[3].p.v = smee.rs.resistor[3].n.v;
//   smee.rs.plug_n.pin[2].i + smee.lssigma.plug_p.pin[2].i = 0.0;
//   smee.lssigma.inductor[2].p.v = smee.lssigma.plug_p.pin[2].v;
//   smee.lssigma.inductor[2].p.v = smee.rs.plug_n.pin[2].v;
//   smee.lssigma.inductor[2].p.v = smee.rs.resistor[2].n.v;
//   smee.rs.plug_n.pin[1].i + smee.lssigma.plug_p.pin[1].i = 0.0;
//   smee.lssigma.inductor[1].p.v = smee.lssigma.plug_p.pin[1].v;
//   smee.lssigma.inductor[1].p.v = smee.rs.plug_n.pin[1].v;
//   smee.lssigma.inductor[1].p.v = smee.rs.resistor[1].n.v;
//   smee.lssigma.plug_n.pin[3].i + smee.spacePhasorS.plug_p.pin[3].i = 0.0;
//   smee.lssigma.inductor[3].n.v = smee.lssigma.plug_n.pin[3].v;
//   smee.lssigma.inductor[3].n.v = smee.spacePhasorS.plug_p.pin[3].v;
//   smee.lssigma.plug_n.pin[2].i + smee.spacePhasorS.plug_p.pin[2].i = 0.0;
//   smee.lssigma.inductor[2].n.v = smee.lssigma.plug_n.pin[2].v;
//   smee.lssigma.inductor[2].n.v = smee.spacePhasorS.plug_p.pin[2].v;
//   smee.lssigma.plug_n.pin[1].i + smee.spacePhasorS.plug_p.pin[1].i = 0.0;
//   smee.lssigma.inductor[1].n.v = smee.lssigma.plug_n.pin[1].v;
//   smee.lssigma.inductor[1].n.v = smee.spacePhasorS.plug_p.pin[1].v;
//   smee.spacePhasorS.plug_n.pin[3].i + (-smee.plug_sn.pin[3].i) = 0.0;
//   smee.spacePhasorS.plug_n.pin[2].i + (-smee.plug_sn.pin[2].i) = 0.0;
//   smee.spacePhasorS.plug_n.pin[1].i + (-smee.plug_sn.pin[1].i) = 0.0;
//   smee.spacePhasorS.ground.i + smee.spacePhasorS.zero.i = 0.0;
//   smee.spacePhasorS.gnd.p.v = smee.spacePhasorS.ground.v;
//   smee.spacePhasorS.gnd.p.v = smee.spacePhasorS.zero.v;
//   smee.airGapR.flange.tau + smee.inertiaRotor.flange_a.tau = 0.0;
//   smee.airGapR.flange.phi = smee.inertiaRotor.flange_a.phi;
//   smee.spacePhasorS.spacePhasor.i_[1] + smee.airGapR.spacePhasor_s.i_[1] = 0.0;
//   smee.spacePhasorS.spacePhasor.i_[2] + smee.airGapR.spacePhasor_s.i_[2] = 0.0;
//   smee.airGapR.spacePhasor_s.v_[1] = smee.spacePhasorS.spacePhasor.v_[1];
//   smee.airGapR.spacePhasor_s.v_[2] = smee.spacePhasorS.spacePhasor.v_[2];
//   smee.airGapR.spacePhasor_r.i_[1] + (smee.damperCage.spacePhasor_r.i_[1] + smee.electricalExcitation.spacePhasor_r.i_[1]) = 0.0;
//   smee.airGapR.spacePhasor_r.i_[2] + (smee.damperCage.spacePhasor_r.i_[2] + smee.electricalExcitation.spacePhasor_r.i_[2]) = 0.0;
//   smee.airGapR.spacePhasor_r.v_[1] = smee.damperCage.spacePhasor_r.v_[1];
//   smee.airGapR.spacePhasor_r.v_[1] = smee.electricalExcitation.spacePhasor_r.v_[1];
//   smee.airGapR.spacePhasor_r.v_[2] = smee.damperCage.spacePhasor_r.v_[2];
//   smee.airGapR.spacePhasor_r.v_[2] = smee.electricalExcitation.spacePhasor_r.v_[2];
//   smee.lesigma.n.i + smee.electricalExcitation.pin_ep.i = 0.0;
//   smee.electricalExcitation.pin_ep.v = smee.lesigma.n.v;
//   smee.lesigma.p.i + smee.re.n.i = 0.0;
//   smee.lesigma.p.v = smee.re.n.v;
//   (-smee.pin_ep.i) + smee.re.p.i = 0.0;
//   smee.electricalExcitation.pin_en.i + (-smee.pin_en.i) = 0.0;
//   smee.lssigma.inductor[3].n.i + (-smee.lssigma.plug_n.pin[3].i) = 0.0;
//   smee.lssigma.inductor[2].n.i + (-smee.lssigma.plug_n.pin[2].i) = 0.0;
//   smee.lssigma.inductor[1].n.i + (-smee.lssigma.plug_n.pin[1].i) = 0.0;
//   smee.lssigma.inductor[3].p.i + (-smee.lssigma.plug_p.pin[3].i) = 0.0;
//   smee.lssigma.inductor[2].p.i + (-smee.lssigma.plug_p.pin[2].i) = 0.0;
//   smee.lssigma.inductor[1].p.i + (-smee.lssigma.plug_p.pin[1].i) = 0.0;
//   smee.rs.resistor[3].n.i + (-smee.rs.plug_n.pin[3].i) = 0.0;
//   smee.rs.resistor[2].n.i + (-smee.rs.plug_n.pin[2].i) = 0.0;
//   smee.rs.resistor[1].n.i + (-smee.rs.plug_n.pin[1].i) = 0.0;
//   smee.rs.resistor[3].p.i + (-smee.rs.plug_p.pin[3].i) = 0.0;
//   smee.rs.resistor[2].p.i + (-smee.rs.plug_p.pin[2].i) = 0.0;
//   smee.rs.resistor[1].p.i + (-smee.rs.plug_p.pin[1].i) = 0.0;
//   smee.spacePhasorS.gnd.p.i + (-smee.spacePhasorS.ground.i) = 0.0;
//   smee.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.SMEE_Generator;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.SMEE_Generator completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.SMEE_Generator has 503 equation(s) and 501 variable(s).
// 358 of these are trivial equation(s).
// "
// ""
// endResult
