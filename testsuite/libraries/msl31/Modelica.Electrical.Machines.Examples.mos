//name:        Modelica.Electrical.Machines.Examples [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Electrical.Machines.Examples
//status:      correct
//env: OPENMODELICALIBRARY=../../../libraries/msl31/
//
// instantiate example
//

loadModel(Modelica); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_DOL); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMC_DOL); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_YD); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMC_YD); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMS_Start); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMS_Start); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_Inverter); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.AIMC_Inverter); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.SMR_Inverter); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.SMR_Inverter); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.SMPM_Inverter); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.SMPM_Inverter); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.SMEE_Generator); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.SMEE_Generator); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.DCPM_Start); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.DCPM_Start); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.DCEE_Start); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.DCEE_Start); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.DCSE_Start); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.DCSE_Start); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.TransformerTestbench); getErrorString();
checkModel(Modelica.Electrical.Machines.Examples.TransformerTestbench); getErrorString();

instantiateModel(Modelica.Electrical.Machines.Examples.Rectifier6pulse); getErroString();
checkModel(Modelica.Electrical.Machines.Examples.Rectifier6pulse); getErroString();

instantiateModel(Modelica.Electrical.Machines.Examples.Rectifier12pulse); getErroString();
checkModel(Modelica.Electrical.Machines.Examples.Rectifier12pulse); getErroString();

instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_Steinmetz); getErroString();
checkModel(Modelica.Electrical.Machines.Examples.AIMC_Steinmetz); getErroString();

// Result:
// true
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_DOL
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "start time";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 150.843571262114 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aimc.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aimc.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aimc.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aimc.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aimc.Jr) "stator's moment of inertia";
//   output Real aimc.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aimc.flange.phi - aimc.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aimc.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aimc.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aimc.tauElectrical(quantity = "Torque", unit = "N.m") = aimc.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aimc.tauShaft(quantity = "Torque", unit = "N.m") = -aimc.flange.tau "shaft torque";
//   Real aimc.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aimc.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aimc.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aimc.m = 3 "number of phases";
//   parameter Integer aimc.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aimc.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aimc.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aimc.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aimc.vs[1](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[1].v - aimc.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aimc.vs[2](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[2].v - aimc.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aimc.vs[3](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[3].v - aimc.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aimc.is[1](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aimc.is[2](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aimc.is[3](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aimc.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aimc.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aimc.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aimc.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.m(min = 1) = 3 "number of phases";
//   Real aimc.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.rs.plug_p.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.plug_n.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.mh(min = 1) = aimc.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aimc.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aimc.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aimc.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[1].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Reference temperature";
//   parameter Real aimc.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[2].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Reference temperature";
//   parameter Real aimc.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[3].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Reference temperature";
//   parameter Real aimc.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aimc.lssigma.m(min = 1) = 3 "number of phases";
//   Real aimc.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.lssigma.plug_p.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.lssigma.plug_n.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   Real aimc.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[1] "Inductance";
//   Real aimc.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[2] "Inductance";
//   Real aimc.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[3] "Inductance";
//   constant Integer aimc.spacePhasorS.m = 3 "number of phases";
//   constant Real aimc.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aimc.spacePhasorS.turnsRatio = 1.0;
//   Real aimc.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aimc.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aimc.airGapS.m = 3 "number of phases";
//   parameter Integer aimc.airGapS.p(min = 1) = aimc.p "number of pole pairs";
//   output Real aimc.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aimc.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aimc.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.airGapS.Lm(quantity = "Inductance", unit = "H") = aimc.Lm "main field inductance";
//   Real aimc.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aimc.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   protected parameter Real aimc.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   parameter Real aimc.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aimc.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aimc.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "rotor stray inductance (equivalent three phase winding)";
//   parameter Real aimc.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance (equivalent three phase winding)";
//   parameter Real aimc.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = aimc.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real aimc.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = aimc.Rr "warm rotor resistance per phase translated to stator";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aimc.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real booleanStep[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[1].startValue = false "Output before startTime";
//   output Boolean booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real booleanStep[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[2].startValue = false "Output before startTime";
//   output Boolean booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real booleanStep[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[3].startValue = false "Output before startTime";
//   parameter Integer idealCloser.m(min = 1) = 3 "number of phases";
//   Real idealCloser.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer idealCloser.plug_p.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.plug_n.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.mh(min = 1) = idealCloser.m "Number of heatPorts=number of phases";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real idealCloser.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean idealCloser.control[1] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[2] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[3] "true => p--n connected, false => switch open";
//   Real idealCloser.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[1].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[1] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[1] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[1].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[2].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[2] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[2] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[2].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[3].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[3] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[3] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[3].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer TerminalBox1.m = 3 "number of phases";
//   parameter String TerminalBox1.terminalConnection(start = "Y") = "D" "choose Y=star/D=delta";
//   parameter Integer TerminalBox1.plug_sp.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plug_sn.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plugSupply.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer TerminalBox1.delta.plug_p.m(min = 1) = TerminalBox1.delta.m "number of phases";
//   Real TerminalBox1.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.delta.plug_n.m(min = 1) = TerminalBox1.delta.m "number of phases";
//   Real TerminalBox1.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.inertiaRotor.w = der(aimc.inertiaRotor.phi);
//   aimc.inertiaRotor.a = der(aimc.inertiaRotor.w);
//   aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.inertiaRotor.flange_a.tau + aimc.inertiaRotor.flange_b.tau;
//   assert(1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[1].R_actual = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref));
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].i = aimc.rs.resistor[1].p.i;
//   0.0 = aimc.rs.resistor[1].p.i + aimc.rs.resistor[1].n.i;
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].p.v - aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[1].T_heatPort = aimc.rs.resistor[1].T;
//   assert(1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[2].R_actual = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref));
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].i = aimc.rs.resistor[2].p.i;
//   0.0 = aimc.rs.resistor[2].p.i + aimc.rs.resistor[2].n.i;
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].p.v - aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[2].T_heatPort = aimc.rs.resistor[2].T;
//   assert(1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[3].R_actual = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref));
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].i = aimc.rs.resistor[3].p.i;
//   0.0 = aimc.rs.resistor[3].p.i + aimc.rs.resistor[3].n.i;
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].p.v - aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[3].T_heatPort = aimc.rs.resistor[3].T;
//   aimc.rs.v[1] = aimc.rs.plug_p.pin[1].v - aimc.rs.plug_n.pin[1].v;
//   aimc.rs.v[2] = aimc.rs.plug_p.pin[2].v - aimc.rs.plug_n.pin[2].v;
//   aimc.rs.v[3] = aimc.rs.plug_p.pin[3].v - aimc.rs.plug_n.pin[3].v;
//   aimc.rs.i[1] = aimc.rs.plug_p.pin[1].i;
//   aimc.rs.i[2] = aimc.rs.plug_p.pin[2].i;
//   aimc.rs.i[3] = aimc.rs.plug_p.pin[3].i;
//   aimc.lssigma.inductor[1].L * der(aimc.lssigma.inductor[1].i) = aimc.lssigma.inductor[1].v;
//   aimc.lssigma.inductor[1].v = aimc.lssigma.inductor[1].p.v - aimc.lssigma.inductor[1].n.v;
//   0.0 = aimc.lssigma.inductor[1].p.i + aimc.lssigma.inductor[1].n.i;
//   aimc.lssigma.inductor[1].i = aimc.lssigma.inductor[1].p.i;
//   aimc.lssigma.inductor[2].L * der(aimc.lssigma.inductor[2].i) = aimc.lssigma.inductor[2].v;
//   aimc.lssigma.inductor[2].v = aimc.lssigma.inductor[2].p.v - aimc.lssigma.inductor[2].n.v;
//   0.0 = aimc.lssigma.inductor[2].p.i + aimc.lssigma.inductor[2].n.i;
//   aimc.lssigma.inductor[2].i = aimc.lssigma.inductor[2].p.i;
//   aimc.lssigma.inductor[3].L * der(aimc.lssigma.inductor[3].i) = aimc.lssigma.inductor[3].v;
//   aimc.lssigma.inductor[3].v = aimc.lssigma.inductor[3].p.v - aimc.lssigma.inductor[3].n.v;
//   0.0 = aimc.lssigma.inductor[3].p.i + aimc.lssigma.inductor[3].n.i;
//   aimc.lssigma.inductor[3].i = aimc.lssigma.inductor[3].p.i;
//   aimc.lssigma.v[1] = aimc.lssigma.plug_p.pin[1].v - aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.v[2] = aimc.lssigma.plug_p.pin[2].v - aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.v[3] = aimc.lssigma.plug_p.pin[3].v - aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.i[1] = aimc.lssigma.plug_p.pin[1].i;
//   aimc.lssigma.i[2] = aimc.lssigma.plug_p.pin[2].i;
//   aimc.lssigma.i[3] = aimc.lssigma.plug_p.pin[3].i;
//   aimc.spacePhasorS.gnd.p.v = 0.0;
//   aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[1].v - aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[2].v - aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[3].v - aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = aimc.spacePhasorS.plug_p.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = aimc.spacePhasorS.plug_p.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = aimc.spacePhasorS.plug_p.pin[3].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = -aimc.spacePhasorS.plug_n.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = -aimc.spacePhasorS.plug_n.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = -aimc.spacePhasorS.plug_n.pin[3].i;
//   aimc.spacePhasorS.zero.v = 0.333333333333333 * (aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]));
//   aimc.spacePhasorS.spacePhasor.v_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.v[3]);
//   aimc.spacePhasorS.spacePhasor.v_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.v[3]);
//   -aimc.spacePhasorS.zero.i = 0.333333333333333 * (aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]));
//   -aimc.spacePhasorS.spacePhasor.i_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.i[3]);
//   -aimc.spacePhasorS.spacePhasor.i_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.i[3]);
//   aimc.airGapS.i_ms[1] = aimc.airGapS.i_ss[1] + aimc.airGapS.i_rs[1];
//   aimc.airGapS.i_ms[2] = aimc.airGapS.i_ss[2] + aimc.airGapS.i_rs[2];
//   aimc.airGapS.psi_ms[1] = aimc.airGapS.L[1,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[1,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_ms[2] = aimc.airGapS.L[2,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[2,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.gamma = Real(aimc.airGapS.p) * (aimc.airGapS.flange.phi - aimc.airGapS.support.phi);
//   aimc.airGapS.RotationMatrix[1,1] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[1,2] = -sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,1] = sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.i_ss[1] = aimc.airGapS.spacePhasor_s.i_[1];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.spacePhasor_s.i_[2];
//   aimc.airGapS.i_ss[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_rr[1] = aimc.airGapS.spacePhasor_r.i_[1];
//   aimc.airGapS.i_rr[2] = aimc.airGapS.spacePhasor_r.i_[2];
//   aimc.airGapS.i_rs[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.i_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.spacePhasor_s.v_[1] = der(aimc.airGapS.psi_ms[1]);
//   aimc.airGapS.spacePhasor_s.v_[2] = der(aimc.airGapS.psi_ms[2]);
//   aimc.airGapS.spacePhasor_r.v_[1] = der(aimc.airGapS.psi_mr[1]);
//   aimc.airGapS.spacePhasor_r.v_[2] = der(aimc.airGapS.psi_mr[2]);
//   aimc.airGapS.tauElectrical = Real(aimc.airGapS.m) * (Real(aimc.airGapS.p) * (aimc.airGapS.spacePhasor_s.i_[2] * aimc.airGapS.psi_ms[1] - aimc.airGapS.spacePhasor_s.i_[1] * aimc.airGapS.psi_ms[2]) / 2.0);
//   aimc.airGapS.flange.tau = -aimc.airGapS.tauElectrical;
//   aimc.airGapS.support.tau = aimc.airGapS.tauElectrical;
//   aimc.squirrelCageR.spacePhasor_r.v_[1] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[1] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[1]);
//   aimc.squirrelCageR.spacePhasor_r.v_[2] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[2] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[2]);
//   aimc.fixed.flange.phi = aimc.fixed.phi0;
//   assert(aimc.spacePhasorS.plug_n.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(aimc.lssigma.plug_n.m == aimc.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aimc.rs.plug_n.m == aimc.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aimc.plug_sp.m == aimc.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   booleanStep[1].y = if time >= booleanStep[1].startTime then  NOT booleanStep[1].startValue else booleanStep[1].startValue;
//   booleanStep[2].y = if time >= booleanStep[2].startTime then  NOT booleanStep[2].startValue else booleanStep[2].startValue;
//   booleanStep[3].y = if time >= booleanStep[3].startTime then  NOT booleanStep[3].startValue else booleanStep[3].startValue;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then idealCloser.idealClosingSwitch[1].Ron else 1.0);
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then 1.0 else idealCloser.idealClosingSwitch[1].Goff);
//   idealCloser.idealClosingSwitch[1].LossPower = idealCloser.idealClosingSwitch[1].v * idealCloser.idealClosingSwitch[1].i;
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].p.i;
//   0.0 = idealCloser.idealClosingSwitch[1].p.i + idealCloser.idealClosingSwitch[1].n.i;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].p.v - idealCloser.idealClosingSwitch[1].n.v;
//   idealCloser.idealClosingSwitch[1].T_heatPort = idealCloser.idealClosingSwitch[1].T;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then idealCloser.idealClosingSwitch[2].Ron else 1.0);
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then 1.0 else idealCloser.idealClosingSwitch[2].Goff);
//   idealCloser.idealClosingSwitch[2].LossPower = idealCloser.idealClosingSwitch[2].v * idealCloser.idealClosingSwitch[2].i;
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].p.i;
//   0.0 = idealCloser.idealClosingSwitch[2].p.i + idealCloser.idealClosingSwitch[2].n.i;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].p.v - idealCloser.idealClosingSwitch[2].n.v;
//   idealCloser.idealClosingSwitch[2].T_heatPort = idealCloser.idealClosingSwitch[2].T;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then idealCloser.idealClosingSwitch[3].Ron else 1.0);
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then 1.0 else idealCloser.idealClosingSwitch[3].Goff);
//   idealCloser.idealClosingSwitch[3].LossPower = idealCloser.idealClosingSwitch[3].v * idealCloser.idealClosingSwitch[3].i;
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].p.i;
//   0.0 = idealCloser.idealClosingSwitch[3].p.i + idealCloser.idealClosingSwitch[3].n.i;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].p.v - idealCloser.idealClosingSwitch[3].n.v;
//   idealCloser.idealClosingSwitch[3].T_heatPort = idealCloser.idealClosingSwitch[3].T;
//   idealCloser.v[1] = idealCloser.plug_p.pin[1].v - idealCloser.plug_n.pin[1].v;
//   idealCloser.v[2] = idealCloser.plug_p.pin[2].v - idealCloser.plug_n.pin[2].v;
//   idealCloser.v[3] = idealCloser.plug_p.pin[3].v - idealCloser.plug_n.pin[3].v;
//   idealCloser.i[1] = idealCloser.plug_p.pin[1].i;
//   idealCloser.i[2] = idealCloser.plug_p.pin[2].i;
//   idealCloser.i[3] = idealCloser.plug_p.pin[3].i;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(TerminalBox1.plug_sn.m == TerminalBox1.delta.plug_n.m,"automatically generated from connect");
//   assert(TerminalBox1.delta.plug_p.m == TerminalBox1.plug_sp.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sp.m == TerminalBox1.plugSupply.m,"automatically generated from connect");
//   assert(sineVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == idealCloser.plug_p.m,"automatically generated from connect");
//   assert(idealCloser.plug_n.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sn.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sp.m == aimc.plug_sp.m,"automatically generated from connect");
//   assert(TerminalBox1.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   aimc.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aimc.flange.phi = loadInertia.flange_a.phi;
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   TerminalBox1.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   TerminalBox1.plugSupply.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   TerminalBox1.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   TerminalBox1.plugSupply.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   TerminalBox1.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   TerminalBox1.plugSupply.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   TerminalBox1.plug_sp.pin[3].i + aimc.plug_sp.pin[3].i = 0.0;
//   TerminalBox1.plug_sp.pin[3].v = aimc.plug_sp.pin[3].v;
//   TerminalBox1.plug_sp.pin[2].i + aimc.plug_sp.pin[2].i = 0.0;
//   TerminalBox1.plug_sp.pin[2].v = aimc.plug_sp.pin[2].v;
//   TerminalBox1.plug_sp.pin[1].i + aimc.plug_sp.pin[1].i = 0.0;
//   TerminalBox1.plug_sp.pin[1].v = aimc.plug_sp.pin[1].v;
//   TerminalBox1.plug_sn.pin[3].i + aimc.plug_sn.pin[3].i = 0.0;
//   TerminalBox1.plug_sn.pin[3].v = aimc.plug_sn.pin[3].v;
//   TerminalBox1.plug_sn.pin[2].i + aimc.plug_sn.pin[2].i = 0.0;
//   TerminalBox1.plug_sn.pin[2].v = aimc.plug_sn.pin[2].v;
//   TerminalBox1.plug_sn.pin[1].i + aimc.plug_sn.pin[1].i = 0.0;
//   TerminalBox1.plug_sn.pin[1].v = aimc.plug_sn.pin[1].v;
//   idealCloser.plug_n.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = idealCloser.plug_n.pin[3].v;
//   idealCloser.plug_n.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = idealCloser.plug_n.pin[2].v;
//   idealCloser.plug_n.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = idealCloser.plug_n.pin[1].v;
//   booleanStep[1].y = idealCloser.control[1];
//   booleanStep[2].y = idealCloser.control[2];
//   booleanStep[3].y = idealCloser.control[3];
//   sineVoltage.plug_p.pin[3].i + idealCloser.plug_p.pin[3].i = 0.0;
//   idealCloser.plug_p.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + idealCloser.plug_p.pin[2].i = 0.0;
//   idealCloser.plug_p.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + idealCloser.plug_p.pin[1].i = 0.0;
//   idealCloser.plug_p.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   sineVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   sineVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   sineVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   TerminalBox1.delta.plug_p.pin[3].i + ((-TerminalBox1.plug_sp.pin[3].i) + (-TerminalBox1.plugSupply.pin[3].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[3].v = TerminalBox1.plugSupply.pin[3].v;
//   TerminalBox1.delta.plug_p.pin[3].v = TerminalBox1.plug_sp.pin[3].v;
//   TerminalBox1.delta.plug_p.pin[2].i + ((-TerminalBox1.plug_sp.pin[2].i) + (-TerminalBox1.plugSupply.pin[2].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[2].v = TerminalBox1.plugSupply.pin[2].v;
//   TerminalBox1.delta.plug_p.pin[2].v = TerminalBox1.plug_sp.pin[2].v;
//   TerminalBox1.delta.plug_p.pin[1].i + ((-TerminalBox1.plug_sp.pin[1].i) + (-TerminalBox1.plugSupply.pin[1].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[1].v = TerminalBox1.plugSupply.pin[1].v;
//   TerminalBox1.delta.plug_p.pin[1].v = TerminalBox1.plug_sp.pin[1].v;
//   (-TerminalBox1.plug_sn.pin[3].i) + TerminalBox1.delta.plug_n.pin[3].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.plug_sn.pin[3].v;
//   (-TerminalBox1.plug_sn.pin[2].i) + TerminalBox1.delta.plug_n.pin[2].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.plug_sn.pin[2].v;
//   (-TerminalBox1.plug_sn.pin[1].i) + TerminalBox1.delta.plug_n.pin[1].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.plug_sn.pin[1].v;
//   (-TerminalBox1.delta.plug_n.pin[3].i) + (-TerminalBox1.delta.plug_p.pin[1].i) = 0.0;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.delta.plug_p.pin[1].v;
//   (-TerminalBox1.delta.plug_n.pin[2].i) + (-TerminalBox1.delta.plug_p.pin[3].i) = 0.0;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.delta.plug_p.pin[3].v;
//   (-TerminalBox1.delta.plug_n.pin[1].i) + (-TerminalBox1.delta.plug_p.pin[2].i) = 0.0;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.delta.plug_p.pin[2].v;
//   idealCloser.control[1] = idealCloser.idealClosingSwitch[1].control;
//   idealCloser.control[2] = idealCloser.idealClosingSwitch[2].control;
//   idealCloser.control[3] = idealCloser.idealClosingSwitch[3].control;
//   idealCloser.idealClosingSwitch[3].n.i + (-idealCloser.plug_n.pin[3].i) = 0.0;
//   idealCloser.idealClosingSwitch[3].n.v = idealCloser.plug_n.pin[3].v;
//   idealCloser.idealClosingSwitch[2].n.i + (-idealCloser.plug_n.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[2].n.v = idealCloser.plug_n.pin[2].v;
//   idealCloser.idealClosingSwitch[1].n.i + (-idealCloser.plug_n.pin[1].i) = 0.0;
//   idealCloser.idealClosingSwitch[1].n.v = idealCloser.plug_n.pin[1].v;
//   (-idealCloser.plug_p.pin[3].i) + idealCloser.idealClosingSwitch[3].p.i = 0.0;
//   idealCloser.idealClosingSwitch[3].p.v = idealCloser.plug_p.pin[3].v;
//   (-idealCloser.plug_p.pin[2].i) + idealCloser.idealClosingSwitch[2].p.i = 0.0;
//   idealCloser.idealClosingSwitch[2].p.v = idealCloser.plug_p.pin[2].v;
//   (-idealCloser.plug_p.pin[1].i) + idealCloser.idealClosingSwitch[1].p.i = 0.0;
//   idealCloser.idealClosingSwitch[1].p.v = idealCloser.plug_p.pin[1].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   aimc.airGapS.support.tau + ((-aimc.internalSupport.tau) + aimc.fixed.flange.tau) = 0.0;
//   aimc.airGapS.support.phi = aimc.fixed.flange.phi;
//   aimc.airGapS.support.phi = aimc.internalSupport.phi;
//   aimc.inertiaRotor.flange_b.tau + (-aimc.flange.tau) = 0.0;
//   aimc.flange.phi = aimc.inertiaRotor.flange_b.phi;
//   (-aimc.plug_sp.pin[3].i) + aimc.rs.plug_p.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = aimc.rs.plug_p.pin[3].v;
//   (-aimc.plug_sp.pin[2].i) + aimc.rs.plug_p.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = aimc.rs.plug_p.pin[2].v;
//   (-aimc.plug_sp.pin[1].i) + aimc.rs.plug_p.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = aimc.rs.plug_p.pin[1].v;
//   aimc.rs.plug_n.pin[3].i + aimc.lssigma.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_p.pin[3].v = aimc.rs.plug_n.pin[3].v;
//   aimc.rs.plug_n.pin[2].i + aimc.lssigma.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_p.pin[2].v = aimc.rs.plug_n.pin[2].v;
//   aimc.rs.plug_n.pin[1].i + aimc.lssigma.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_p.pin[1].v = aimc.rs.plug_n.pin[1].v;
//   aimc.lssigma.plug_n.pin[3].i + aimc.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_n.pin[3].v = aimc.spacePhasorS.plug_p.pin[3].v;
//   aimc.lssigma.plug_n.pin[2].i + aimc.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_n.pin[2].v = aimc.spacePhasorS.plug_p.pin[2].v;
//   aimc.lssigma.plug_n.pin[1].i + aimc.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_n.pin[1].v = aimc.spacePhasorS.plug_p.pin[1].v;
//   aimc.spacePhasorS.plug_n.pin[3].i + (-aimc.plug_sn.pin[3].i) = 0.0;
//   aimc.plug_sn.pin[3].v = aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.plug_n.pin[2].i + (-aimc.plug_sn.pin[2].i) = 0.0;
//   aimc.plug_sn.pin[2].v = aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.plug_n.pin[1].i + (-aimc.plug_sn.pin[1].i) = 0.0;
//   aimc.plug_sn.pin[1].v = aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.ground.i + aimc.spacePhasorS.zero.i = 0.0;
//   aimc.spacePhasorS.ground.v = aimc.spacePhasorS.zero.v;
//   aimc.airGapS.flange.tau + aimc.inertiaRotor.flange_a.tau = 0.0;
//   aimc.airGapS.flange.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.spacePhasorS.spacePhasor.i_[1] + aimc.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aimc.spacePhasorS.spacePhasor.i_[2] + aimc.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_s.v_[1] = aimc.spacePhasorS.spacePhasor.v_[1];
//   aimc.airGapS.spacePhasor_s.v_[2] = aimc.spacePhasorS.spacePhasor.v_[2];
//   aimc.airGapS.spacePhasor_r.i_[1] + aimc.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   aimc.airGapS.spacePhasor_r.i_[2] + aimc.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_r.v_[1] = aimc.squirrelCageR.spacePhasor_r.v_[1];
//   aimc.airGapS.spacePhasor_r.v_[2] = aimc.squirrelCageR.spacePhasor_r.v_[2];
//   aimc.spacePhasorS.gnd.p.i + (-aimc.spacePhasorS.ground.i) = 0.0;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.ground.v;
//   aimc.lssigma.inductor[3].n.i + (-aimc.lssigma.plug_n.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].n.v = aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.inductor[2].n.i + (-aimc.lssigma.plug_n.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].n.v = aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.inductor[1].n.i + (-aimc.lssigma.plug_n.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].n.v = aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.inductor[3].p.i + (-aimc.lssigma.plug_p.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].p.v = aimc.lssigma.plug_p.pin[3].v;
//   aimc.lssigma.inductor[2].p.i + (-aimc.lssigma.plug_p.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].p.v = aimc.lssigma.plug_p.pin[2].v;
//   aimc.lssigma.inductor[1].p.i + (-aimc.lssigma.plug_p.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].p.v = aimc.lssigma.plug_p.pin[1].v;
//   aimc.rs.resistor[3].n.i + (-aimc.rs.plug_n.pin[3].i) = 0.0;
//   aimc.rs.plug_n.pin[3].v = aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[2].n.i + (-aimc.rs.plug_n.pin[2].i) = 0.0;
//   aimc.rs.plug_n.pin[2].v = aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[1].n.i + (-aimc.rs.plug_n.pin[1].i) = 0.0;
//   aimc.rs.plug_n.pin[1].v = aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[3].p.i + (-aimc.rs.plug_p.pin[3].i) = 0.0;
//   aimc.rs.plug_p.pin[3].v = aimc.rs.resistor[3].p.v;
//   aimc.rs.resistor[2].p.i + (-aimc.rs.plug_p.pin[2].i) = 0.0;
//   aimc.rs.plug_p.pin[2].v = aimc.rs.resistor[2].p.v;
//   aimc.rs.resistor[1].p.i + (-aimc.rs.plug_p.pin[1].i) = 0.0;
//   aimc.rs.plug_p.pin[1].v = aimc.rs.resistor[1].p.v;
//   aimc.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_DOL;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMC_DOL completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMC_DOL has 390 equation(s) and 390 variable(s).
// 277 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_YD
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "start time";
//   parameter Real tStart2(quantity = "Time", unit = "s") = 2.0 "2nd start time";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 150.843571262114 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aimc.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aimc.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aimc.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aimc.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aimc.Jr) "stator's moment of inertia";
//   output Real aimc.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aimc.flange.phi - aimc.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aimc.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aimc.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aimc.tauElectrical(quantity = "Torque", unit = "N.m") = aimc.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aimc.tauShaft(quantity = "Torque", unit = "N.m") = -aimc.flange.tau "shaft torque";
//   Real aimc.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aimc.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aimc.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aimc.m = 3 "number of phases";
//   parameter Integer aimc.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aimc.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aimc.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aimc.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aimc.vs[1](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[1].v - aimc.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aimc.vs[2](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[2].v - aimc.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aimc.vs[3](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[3].v - aimc.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aimc.is[1](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aimc.is[2](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aimc.is[3](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aimc.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aimc.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aimc.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aimc.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.m(min = 1) = 3 "number of phases";
//   Real aimc.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.rs.plug_p.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.plug_n.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.mh(min = 1) = aimc.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aimc.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aimc.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aimc.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[1].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Reference temperature";
//   parameter Real aimc.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[2].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Reference temperature";
//   parameter Real aimc.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[3].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Reference temperature";
//   parameter Real aimc.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aimc.lssigma.m(min = 1) = 3 "number of phases";
//   Real aimc.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.lssigma.plug_p.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.lssigma.plug_n.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   Real aimc.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[1] "Inductance";
//   Real aimc.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[2] "Inductance";
//   Real aimc.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[3] "Inductance";
//   constant Integer aimc.spacePhasorS.m = 3 "number of phases";
//   constant Real aimc.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aimc.spacePhasorS.turnsRatio = 1.0;
//   Real aimc.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aimc.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aimc.airGapS.m = 3 "number of phases";
//   parameter Integer aimc.airGapS.p(min = 1) = aimc.p "number of pole pairs";
//   output Real aimc.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aimc.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aimc.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.airGapS.Lm(quantity = "Inductance", unit = "H") = aimc.Lm "main field inductance";
//   Real aimc.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aimc.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   protected parameter Real aimc.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   parameter Real aimc.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aimc.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aimc.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "rotor stray inductance (equivalent three phase winding)";
//   parameter Real aimc.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance (equivalent three phase winding)";
//   parameter Real aimc.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = aimc.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real aimc.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = aimc.Rr "warm rotor resistance per phase translated to stator";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aimc.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real booleanStep[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[1].startValue = false "Output before startTime";
//   output Boolean booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real booleanStep[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[2].startValue = false "Output before startTime";
//   output Boolean booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real booleanStep[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[3].startValue = false "Output before startTime";
//   parameter Integer idealCloser.m(min = 1) = 3 "number of phases";
//   Real idealCloser.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer idealCloser.plug_p.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.plug_n.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.mh(min = 1) = idealCloser.m "Number of heatPorts=number of phases";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real idealCloser.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean idealCloser.control[1] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[2] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[3] "true => p--n connected, false => switch open";
//   Real idealCloser.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[1].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[1] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[1] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[1].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[2].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[2] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[2] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[2].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[3].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[3] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[3] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[3].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   constant Integer switchYD.m = 3 "number of phases";
//   parameter Integer switchYD.plugSupply.m(min = 1) = 3 "number of phases";
//   Real switchYD.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.plug_sp.m(min = 1) = 3 "number of phases";
//   Real switchYD.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.plug_sn.m(min = 1) = 3 "number of phases";
//   Real switchYD.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.star.m(min = 1) = 3 "number of phases";
//   parameter Integer switchYD.star.plug_p.m(min = 1) = switchYD.star.m "number of phases";
//   Real switchYD.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer switchYD.delta.plug_p.m(min = 1) = switchYD.delta.m "number of phases";
//   Real switchYD.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.delta.plug_n.m(min = 1) = switchYD.delta.m "number of phases";
//   Real switchYD.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.idealCommutingSwitch.mh(min = 1) = switchYD.idealCommutingSwitch.m "Number of heatPorts=number of phases";
//   parameter Boolean switchYD.idealCommutingSwitch.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real switchYD.idealCommutingSwitch.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchYD.idealCommutingSwitch.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchYD.idealCommutingSwitch.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Integer switchYD.idealCommutingSwitch.m(min = 1) = 3 "number of phases";
//   parameter Real switchYD.idealCommutingSwitch.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchYD.idealCommutingSwitch.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchYD.idealCommutingSwitch.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean switchYD.idealCommutingSwitch.control[1] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchYD.idealCommutingSwitch.control[2] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchYD.idealCommutingSwitch.control[3] "true => p--n2 connected, false => p--n1 connected";
//   parameter Integer switchYD.idealCommutingSwitch.plug_p.m(min = 1) = switchYD.idealCommutingSwitch.m "number of phases";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.idealCommutingSwitch.plug_n2.m(min = 1) = switchYD.idealCommutingSwitch.m "number of phases";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchYD.idealCommutingSwitch.plug_n1.m(min = 1) = switchYD.idealCommutingSwitch.m "number of phases";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[1].useHeatPort = switchYD.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchYD.idealCommutingSwitch.Ron[1] "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchYD.idealCommutingSwitch.Goff[1] "Opened switch conductance";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s1(unit = "1");
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[2].useHeatPort = switchYD.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchYD.idealCommutingSwitch.Ron[2] "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchYD.idealCommutingSwitch.Goff[2] "Opened switch conductance";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s1(unit = "1");
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[3].useHeatPort = switchYD.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchYD.idealCommutingSwitch.Ron[3] "Closed switch resistance";
//   parameter Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchYD.idealCommutingSwitch.Goff[3] "Opened switch conductance";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s1(unit = "1");
//   protected Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchYD.idealCommutingSwitch.idealCommutingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   input Boolean switchYD.control[1];
//   input Boolean switchYD.control[2];
//   input Boolean switchYD.control[3];
//   output Boolean booleanStepYD[1].y "Connector of Boolean output signal";
//   parameter Real booleanStepYD[1].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
//   parameter Boolean booleanStepYD[1].startValue = false "Output before startTime";
//   output Boolean booleanStepYD[2].y "Connector of Boolean output signal";
//   parameter Real booleanStepYD[2].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
//   parameter Boolean booleanStepYD[2].startValue = false "Output before startTime";
//   output Boolean booleanStepYD[3].y "Connector of Boolean output signal";
//   parameter Real booleanStepYD[3].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
//   parameter Boolean booleanStepYD[3].startValue = false "Output before startTime";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
// equation
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.inertiaRotor.w = der(aimc.inertiaRotor.phi);
//   aimc.inertiaRotor.a = der(aimc.inertiaRotor.w);
//   aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.inertiaRotor.flange_a.tau + aimc.inertiaRotor.flange_b.tau;
//   assert(1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[1].R_actual = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref));
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].i = aimc.rs.resistor[1].p.i;
//   0.0 = aimc.rs.resistor[1].p.i + aimc.rs.resistor[1].n.i;
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].p.v - aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[1].T_heatPort = aimc.rs.resistor[1].T;
//   assert(1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[2].R_actual = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref));
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].i = aimc.rs.resistor[2].p.i;
//   0.0 = aimc.rs.resistor[2].p.i + aimc.rs.resistor[2].n.i;
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].p.v - aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[2].T_heatPort = aimc.rs.resistor[2].T;
//   assert(1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[3].R_actual = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref));
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].i = aimc.rs.resistor[3].p.i;
//   0.0 = aimc.rs.resistor[3].p.i + aimc.rs.resistor[3].n.i;
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].p.v - aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[3].T_heatPort = aimc.rs.resistor[3].T;
//   aimc.rs.v[1] = aimc.rs.plug_p.pin[1].v - aimc.rs.plug_n.pin[1].v;
//   aimc.rs.v[2] = aimc.rs.plug_p.pin[2].v - aimc.rs.plug_n.pin[2].v;
//   aimc.rs.v[3] = aimc.rs.plug_p.pin[3].v - aimc.rs.plug_n.pin[3].v;
//   aimc.rs.i[1] = aimc.rs.plug_p.pin[1].i;
//   aimc.rs.i[2] = aimc.rs.plug_p.pin[2].i;
//   aimc.rs.i[3] = aimc.rs.plug_p.pin[3].i;
//   aimc.lssigma.inductor[1].L * der(aimc.lssigma.inductor[1].i) = aimc.lssigma.inductor[1].v;
//   aimc.lssigma.inductor[1].v = aimc.lssigma.inductor[1].p.v - aimc.lssigma.inductor[1].n.v;
//   0.0 = aimc.lssigma.inductor[1].p.i + aimc.lssigma.inductor[1].n.i;
//   aimc.lssigma.inductor[1].i = aimc.lssigma.inductor[1].p.i;
//   aimc.lssigma.inductor[2].L * der(aimc.lssigma.inductor[2].i) = aimc.lssigma.inductor[2].v;
//   aimc.lssigma.inductor[2].v = aimc.lssigma.inductor[2].p.v - aimc.lssigma.inductor[2].n.v;
//   0.0 = aimc.lssigma.inductor[2].p.i + aimc.lssigma.inductor[2].n.i;
//   aimc.lssigma.inductor[2].i = aimc.lssigma.inductor[2].p.i;
//   aimc.lssigma.inductor[3].L * der(aimc.lssigma.inductor[3].i) = aimc.lssigma.inductor[3].v;
//   aimc.lssigma.inductor[3].v = aimc.lssigma.inductor[3].p.v - aimc.lssigma.inductor[3].n.v;
//   0.0 = aimc.lssigma.inductor[3].p.i + aimc.lssigma.inductor[3].n.i;
//   aimc.lssigma.inductor[3].i = aimc.lssigma.inductor[3].p.i;
//   aimc.lssigma.v[1] = aimc.lssigma.plug_p.pin[1].v - aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.v[2] = aimc.lssigma.plug_p.pin[2].v - aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.v[3] = aimc.lssigma.plug_p.pin[3].v - aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.i[1] = aimc.lssigma.plug_p.pin[1].i;
//   aimc.lssigma.i[2] = aimc.lssigma.plug_p.pin[2].i;
//   aimc.lssigma.i[3] = aimc.lssigma.plug_p.pin[3].i;
//   aimc.spacePhasorS.gnd.p.v = 0.0;
//   aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[1].v - aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[2].v - aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[3].v - aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = aimc.spacePhasorS.plug_p.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = aimc.spacePhasorS.plug_p.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = aimc.spacePhasorS.plug_p.pin[3].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = -aimc.spacePhasorS.plug_n.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = -aimc.spacePhasorS.plug_n.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = -aimc.spacePhasorS.plug_n.pin[3].i;
//   aimc.spacePhasorS.zero.v = 0.333333333333333 * (aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]));
//   aimc.spacePhasorS.spacePhasor.v_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.v[3]);
//   aimc.spacePhasorS.spacePhasor.v_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.v[3]);
//   -aimc.spacePhasorS.zero.i = 0.333333333333333 * (aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]));
//   -aimc.spacePhasorS.spacePhasor.i_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.i[3]);
//   -aimc.spacePhasorS.spacePhasor.i_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.i[3]);
//   aimc.airGapS.i_ms[1] = aimc.airGapS.i_ss[1] + aimc.airGapS.i_rs[1];
//   aimc.airGapS.i_ms[2] = aimc.airGapS.i_ss[2] + aimc.airGapS.i_rs[2];
//   aimc.airGapS.psi_ms[1] = aimc.airGapS.L[1,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[1,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_ms[2] = aimc.airGapS.L[2,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[2,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.gamma = Real(aimc.airGapS.p) * (aimc.airGapS.flange.phi - aimc.airGapS.support.phi);
//   aimc.airGapS.RotationMatrix[1,1] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[1,2] = -sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,1] = sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.i_ss[1] = aimc.airGapS.spacePhasor_s.i_[1];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.spacePhasor_s.i_[2];
//   aimc.airGapS.i_ss[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_rr[1] = aimc.airGapS.spacePhasor_r.i_[1];
//   aimc.airGapS.i_rr[2] = aimc.airGapS.spacePhasor_r.i_[2];
//   aimc.airGapS.i_rs[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.i_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.spacePhasor_s.v_[1] = der(aimc.airGapS.psi_ms[1]);
//   aimc.airGapS.spacePhasor_s.v_[2] = der(aimc.airGapS.psi_ms[2]);
//   aimc.airGapS.spacePhasor_r.v_[1] = der(aimc.airGapS.psi_mr[1]);
//   aimc.airGapS.spacePhasor_r.v_[2] = der(aimc.airGapS.psi_mr[2]);
//   aimc.airGapS.tauElectrical = Real(aimc.airGapS.m) * (Real(aimc.airGapS.p) * (aimc.airGapS.spacePhasor_s.i_[2] * aimc.airGapS.psi_ms[1] - aimc.airGapS.spacePhasor_s.i_[1] * aimc.airGapS.psi_ms[2]) / 2.0);
//   aimc.airGapS.flange.tau = -aimc.airGapS.tauElectrical;
//   aimc.airGapS.support.tau = aimc.airGapS.tauElectrical;
//   aimc.squirrelCageR.spacePhasor_r.v_[1] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[1] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[1]);
//   aimc.squirrelCageR.spacePhasor_r.v_[2] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[2] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[2]);
//   aimc.fixed.flange.phi = aimc.fixed.phi0;
//   assert(aimc.spacePhasorS.plug_n.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(aimc.lssigma.plug_n.m == aimc.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aimc.rs.plug_n.m == aimc.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aimc.plug_sp.m == aimc.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   booleanStep[1].y = if time >= booleanStep[1].startTime then  NOT booleanStep[1].startValue else booleanStep[1].startValue;
//   booleanStep[2].y = if time >= booleanStep[2].startTime then  NOT booleanStep[2].startValue else booleanStep[2].startValue;
//   booleanStep[3].y = if time >= booleanStep[3].startTime then  NOT booleanStep[3].startValue else booleanStep[3].startValue;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then idealCloser.idealClosingSwitch[1].Ron else 1.0);
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then 1.0 else idealCloser.idealClosingSwitch[1].Goff);
//   idealCloser.idealClosingSwitch[1].LossPower = idealCloser.idealClosingSwitch[1].v * idealCloser.idealClosingSwitch[1].i;
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].p.i;
//   0.0 = idealCloser.idealClosingSwitch[1].p.i + idealCloser.idealClosingSwitch[1].n.i;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].p.v - idealCloser.idealClosingSwitch[1].n.v;
//   idealCloser.idealClosingSwitch[1].T_heatPort = idealCloser.idealClosingSwitch[1].T;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then idealCloser.idealClosingSwitch[2].Ron else 1.0);
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then 1.0 else idealCloser.idealClosingSwitch[2].Goff);
//   idealCloser.idealClosingSwitch[2].LossPower = idealCloser.idealClosingSwitch[2].v * idealCloser.idealClosingSwitch[2].i;
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].p.i;
//   0.0 = idealCloser.idealClosingSwitch[2].p.i + idealCloser.idealClosingSwitch[2].n.i;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].p.v - idealCloser.idealClosingSwitch[2].n.v;
//   idealCloser.idealClosingSwitch[2].T_heatPort = idealCloser.idealClosingSwitch[2].T;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then idealCloser.idealClosingSwitch[3].Ron else 1.0);
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then 1.0 else idealCloser.idealClosingSwitch[3].Goff);
//   idealCloser.idealClosingSwitch[3].LossPower = idealCloser.idealClosingSwitch[3].v * idealCloser.idealClosingSwitch[3].i;
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].p.i;
//   0.0 = idealCloser.idealClosingSwitch[3].p.i + idealCloser.idealClosingSwitch[3].n.i;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].p.v - idealCloser.idealClosingSwitch[3].n.v;
//   idealCloser.idealClosingSwitch[3].T_heatPort = idealCloser.idealClosingSwitch[3].T;
//   idealCloser.v[1] = idealCloser.plug_p.pin[1].v - idealCloser.plug_n.pin[1].v;
//   idealCloser.v[2] = idealCloser.plug_p.pin[2].v - idealCloser.plug_n.pin[2].v;
//   idealCloser.v[3] = idealCloser.plug_p.pin[3].v - idealCloser.plug_n.pin[3].v;
//   idealCloser.i[1] = idealCloser.plug_p.pin[1].i;
//   idealCloser.i[2] = idealCloser.plug_p.pin[2].i;
//   idealCloser.i[3] = idealCloser.plug_p.pin[3].i;
//   0.0 = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i + (switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s1 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Ron);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s1) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Goff else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s2 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Ron else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[1].s2) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[1].Goff);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].LossPower = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v + (switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v + switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].T;
//   0.0 = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i + (switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s1 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Ron);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s1) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Goff else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s2 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Ron else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[2].s2) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[2].Goff);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].LossPower = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v + (switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v + switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].T;
//   0.0 = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i + (switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s1 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Ron);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s1) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Goff else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s2 * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Ron else 1.0);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i = (-switchYD.idealCommutingSwitch.idealCommutingSwitch[3].s2) * (if switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchYD.idealCommutingSwitch.idealCommutingSwitch[3].Goff);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].LossPower = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v + (switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v + switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i * switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v);
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].T;
//   assert(switchYD.delta.plug_p.m == switchYD.plugSupply.m,"automatically generated from connect");
//   assert(switchYD.delta.plug_p.m == switchYD.plug_sp.m,"automatically generated from connect");
//   assert(switchYD.idealCommutingSwitch.plug_n2.m == switchYD.delta.plug_n.m,"automatically generated from connect");
//   assert(switchYD.idealCommutingSwitch.plug_n1.m == switchYD.star.plug_p.m,"automatically generated from connect");
//   assert(switchYD.idealCommutingSwitch.plug_p.m == switchYD.plug_sn.m,"automatically generated from connect");
//   booleanStepYD[1].y = if time >= booleanStepYD[1].startTime then  NOT booleanStepYD[1].startValue else booleanStepYD[1].startValue;
//   booleanStepYD[2].y = if time >= booleanStepYD[2].startTime then  NOT booleanStepYD[2].startValue else booleanStepYD[2].startValue;
//   booleanStepYD[3].y = if time >= booleanStepYD[3].startTime then  NOT booleanStepYD[3].startValue else booleanStepYD[3].startValue;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(sineVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == idealCloser.plug_p.m,"automatically generated from connect");
//   assert(idealCloser.plug_n.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(switchYD.plug_sn.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(switchYD.plug_sp.m == aimc.plug_sp.m,"automatically generated from connect");
//   assert(switchYD.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   aimc.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aimc.flange.phi = loadInertia.flange_a.phi;
//   switchYD.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = switchYD.plugSupply.pin[3].v;
//   switchYD.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = switchYD.plugSupply.pin[2].v;
//   switchYD.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = switchYD.plugSupply.pin[1].v;
//   switchYD.plug_sp.pin[3].i + aimc.plug_sp.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = switchYD.plug_sp.pin[3].v;
//   switchYD.plug_sp.pin[2].i + aimc.plug_sp.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = switchYD.plug_sp.pin[2].v;
//   switchYD.plug_sp.pin[1].i + aimc.plug_sp.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = switchYD.plug_sp.pin[1].v;
//   switchYD.plug_sn.pin[3].i + aimc.plug_sn.pin[3].i = 0.0;
//   aimc.plug_sn.pin[3].v = switchYD.plug_sn.pin[3].v;
//   switchYD.plug_sn.pin[2].i + aimc.plug_sn.pin[2].i = 0.0;
//   aimc.plug_sn.pin[2].v = switchYD.plug_sn.pin[2].v;
//   switchYD.plug_sn.pin[1].i + aimc.plug_sn.pin[1].i = 0.0;
//   aimc.plug_sn.pin[1].v = switchYD.plug_sn.pin[1].v;
//   idealCloser.plug_n.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = idealCloser.plug_n.pin[3].v;
//   idealCloser.plug_n.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = idealCloser.plug_n.pin[2].v;
//   idealCloser.plug_n.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = idealCloser.plug_n.pin[1].v;
//   booleanStepYD[1].y = switchYD.control[1];
//   booleanStepYD[2].y = switchYD.control[2];
//   booleanStepYD[3].y = switchYD.control[3];
//   booleanStep[1].y = idealCloser.control[1];
//   booleanStep[2].y = idealCloser.control[2];
//   booleanStep[3].y = idealCloser.control[3];
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   sineVoltage.plug_p.pin[3].i + idealCloser.plug_p.pin[3].i = 0.0;
//   idealCloser.plug_p.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + idealCloser.plug_p.pin[2].i = 0.0;
//   idealCloser.plug_p.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + idealCloser.plug_p.pin[1].i = 0.0;
//   idealCloser.plug_p.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   sineVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   sineVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   sineVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   switchYD.control[1] = switchYD.idealCommutingSwitch.control[1];
//   switchYD.control[2] = switchYD.idealCommutingSwitch.control[2];
//   switchYD.control[3] = switchYD.idealCommutingSwitch.control[3];
//   switchYD.idealCommutingSwitch.plug_p.pin[3].i + (-switchYD.plug_sn.pin[3].i) = 0.0;
//   switchYD.idealCommutingSwitch.plug_p.pin[3].v = switchYD.plug_sn.pin[3].v;
//   switchYD.idealCommutingSwitch.plug_p.pin[2].i + (-switchYD.plug_sn.pin[2].i) = 0.0;
//   switchYD.idealCommutingSwitch.plug_p.pin[2].v = switchYD.plug_sn.pin[2].v;
//   switchYD.idealCommutingSwitch.plug_p.pin[1].i + (-switchYD.plug_sn.pin[1].i) = 0.0;
//   switchYD.idealCommutingSwitch.plug_p.pin[1].v = switchYD.plug_sn.pin[1].v;
//   switchYD.idealCommutingSwitch.plug_n1.pin[3].i + switchYD.star.plug_p.pin[3].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n1.pin[3].v = switchYD.star.plug_p.pin[3].v;
//   switchYD.idealCommutingSwitch.plug_n1.pin[2].i + switchYD.star.plug_p.pin[2].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n1.pin[2].v = switchYD.star.plug_p.pin[2].v;
//   switchYD.idealCommutingSwitch.plug_n1.pin[1].i + switchYD.star.plug_p.pin[1].i = 0.0;
//   switchYD.idealCommutingSwitch.plug_n1.pin[1].v = switchYD.star.plug_p.pin[1].v;
//   switchYD.idealCommutingSwitch.plug_n2.pin[3].i + switchYD.delta.plug_n.pin[3].i = 0.0;
//   switchYD.delta.plug_n.pin[3].v = switchYD.idealCommutingSwitch.plug_n2.pin[3].v;
//   switchYD.idealCommutingSwitch.plug_n2.pin[2].i + switchYD.delta.plug_n.pin[2].i = 0.0;
//   switchYD.delta.plug_n.pin[2].v = switchYD.idealCommutingSwitch.plug_n2.pin[2].v;
//   switchYD.idealCommutingSwitch.plug_n2.pin[1].i + switchYD.delta.plug_n.pin[1].i = 0.0;
//   switchYD.delta.plug_n.pin[1].v = switchYD.idealCommutingSwitch.plug_n2.pin[1].v;
//   switchYD.delta.plug_p.pin[3].i + ((-switchYD.plugSupply.pin[3].i) + (-switchYD.plug_sp.pin[3].i)) = 0.0;
//   switchYD.delta.plug_p.pin[3].v = switchYD.plugSupply.pin[3].v;
//   switchYD.delta.plug_p.pin[3].v = switchYD.plug_sp.pin[3].v;
//   switchYD.delta.plug_p.pin[2].i + ((-switchYD.plugSupply.pin[2].i) + (-switchYD.plug_sp.pin[2].i)) = 0.0;
//   switchYD.delta.plug_p.pin[2].v = switchYD.plugSupply.pin[2].v;
//   switchYD.delta.plug_p.pin[2].v = switchYD.plug_sp.pin[2].v;
//   switchYD.delta.plug_p.pin[1].i + ((-switchYD.plugSupply.pin[1].i) + (-switchYD.plug_sp.pin[1].i)) = 0.0;
//   switchYD.delta.plug_p.pin[1].v = switchYD.plugSupply.pin[1].v;
//   switchYD.delta.plug_p.pin[1].v = switchYD.plug_sp.pin[1].v;
//   switchYD.idealCommutingSwitch.control[1] = switchYD.idealCommutingSwitch.idealCommutingSwitch[1].control;
//   switchYD.idealCommutingSwitch.control[2] = switchYD.idealCommutingSwitch.idealCommutingSwitch[2].control;
//   switchYD.idealCommutingSwitch.control[3] = switchYD.idealCommutingSwitch.idealCommutingSwitch[3].control;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.i + (-switchYD.idealCommutingSwitch.plug_n1.pin[3].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchYD.idealCommutingSwitch.plug_n1.pin[3].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.i + (-switchYD.idealCommutingSwitch.plug_n1.pin[2].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchYD.idealCommutingSwitch.plug_n1.pin[2].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.i + (-switchYD.idealCommutingSwitch.plug_n1.pin[1].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchYD.idealCommutingSwitch.plug_n1.pin[1].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + (-switchYD.idealCommutingSwitch.plug_n2.pin[3].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].n2.v = switchYD.idealCommutingSwitch.plug_n2.pin[3].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + (-switchYD.idealCommutingSwitch.plug_n2.pin[2].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].n2.v = switchYD.idealCommutingSwitch.plug_n2.pin[2].v;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + (-switchYD.idealCommutingSwitch.plug_n2.pin[1].i) = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].n2.v = switchYD.idealCommutingSwitch.plug_n2.pin[1].v;
//   (-switchYD.idealCommutingSwitch.plug_p.pin[3].i) + switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.i = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[3].p.v = switchYD.idealCommutingSwitch.plug_p.pin[3].v;
//   (-switchYD.idealCommutingSwitch.plug_p.pin[2].i) + switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.i = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[2].p.v = switchYD.idealCommutingSwitch.plug_p.pin[2].v;
//   (-switchYD.idealCommutingSwitch.plug_p.pin[1].i) + switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.i = 0.0;
//   switchYD.idealCommutingSwitch.idealCommutingSwitch[1].p.v = switchYD.idealCommutingSwitch.plug_p.pin[1].v;
//   (-switchYD.delta.plug_n.pin[3].i) + (-switchYD.delta.plug_p.pin[1].i) = 0.0;
//   switchYD.delta.plug_n.pin[3].v = switchYD.delta.plug_p.pin[1].v;
//   (-switchYD.delta.plug_n.pin[2].i) + (-switchYD.delta.plug_p.pin[3].i) = 0.0;
//   switchYD.delta.plug_n.pin[2].v = switchYD.delta.plug_p.pin[3].v;
//   (-switchYD.delta.plug_n.pin[1].i) + (-switchYD.delta.plug_p.pin[2].i) = 0.0;
//   switchYD.delta.plug_n.pin[1].v = switchYD.delta.plug_p.pin[2].v;
//   (-switchYD.star.plug_p.pin[3].i) + ((-switchYD.star.plug_p.pin[2].i) + ((-switchYD.star.plug_p.pin[1].i) + (-switchYD.star.pin_n.i))) = 0.0;
//   switchYD.star.pin_n.v = switchYD.star.plug_p.pin[1].v;
//   switchYD.star.pin_n.v = switchYD.star.plug_p.pin[2].v;
//   switchYD.star.pin_n.v = switchYD.star.plug_p.pin[3].v;
//   switchYD.star.pin_n.i = 0.0;
//   idealCloser.control[1] = idealCloser.idealClosingSwitch[1].control;
//   idealCloser.control[2] = idealCloser.idealClosingSwitch[2].control;
//   idealCloser.control[3] = idealCloser.idealClosingSwitch[3].control;
//   idealCloser.idealClosingSwitch[3].n.i + (-idealCloser.plug_n.pin[3].i) = 0.0;
//   idealCloser.idealClosingSwitch[3].n.v = idealCloser.plug_n.pin[3].v;
//   idealCloser.idealClosingSwitch[2].n.i + (-idealCloser.plug_n.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[2].n.v = idealCloser.plug_n.pin[2].v;
//   idealCloser.idealClosingSwitch[1].n.i + (-idealCloser.plug_n.pin[1].i) = 0.0;
//   idealCloser.idealClosingSwitch[1].n.v = idealCloser.plug_n.pin[1].v;
//   (-idealCloser.plug_p.pin[3].i) + idealCloser.idealClosingSwitch[3].p.i = 0.0;
//   idealCloser.idealClosingSwitch[3].p.v = idealCloser.plug_p.pin[3].v;
//   (-idealCloser.plug_p.pin[2].i) + idealCloser.idealClosingSwitch[2].p.i = 0.0;
//   idealCloser.idealClosingSwitch[2].p.v = idealCloser.plug_p.pin[2].v;
//   (-idealCloser.plug_p.pin[1].i) + idealCloser.idealClosingSwitch[1].p.i = 0.0;
//   idealCloser.idealClosingSwitch[1].p.v = idealCloser.plug_p.pin[1].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   aimc.airGapS.support.tau + ((-aimc.internalSupport.tau) + aimc.fixed.flange.tau) = 0.0;
//   aimc.airGapS.support.phi = aimc.fixed.flange.phi;
//   aimc.airGapS.support.phi = aimc.internalSupport.phi;
//   aimc.inertiaRotor.flange_b.tau + (-aimc.flange.tau) = 0.0;
//   aimc.flange.phi = aimc.inertiaRotor.flange_b.phi;
//   (-aimc.plug_sp.pin[3].i) + aimc.rs.plug_p.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = aimc.rs.plug_p.pin[3].v;
//   (-aimc.plug_sp.pin[2].i) + aimc.rs.plug_p.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = aimc.rs.plug_p.pin[2].v;
//   (-aimc.plug_sp.pin[1].i) + aimc.rs.plug_p.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = aimc.rs.plug_p.pin[1].v;
//   aimc.rs.plug_n.pin[3].i + aimc.lssigma.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_p.pin[3].v = aimc.rs.plug_n.pin[3].v;
//   aimc.rs.plug_n.pin[2].i + aimc.lssigma.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_p.pin[2].v = aimc.rs.plug_n.pin[2].v;
//   aimc.rs.plug_n.pin[1].i + aimc.lssigma.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_p.pin[1].v = aimc.rs.plug_n.pin[1].v;
//   aimc.lssigma.plug_n.pin[3].i + aimc.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_n.pin[3].v = aimc.spacePhasorS.plug_p.pin[3].v;
//   aimc.lssigma.plug_n.pin[2].i + aimc.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_n.pin[2].v = aimc.spacePhasorS.plug_p.pin[2].v;
//   aimc.lssigma.plug_n.pin[1].i + aimc.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_n.pin[1].v = aimc.spacePhasorS.plug_p.pin[1].v;
//   aimc.spacePhasorS.plug_n.pin[3].i + (-aimc.plug_sn.pin[3].i) = 0.0;
//   aimc.plug_sn.pin[3].v = aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.plug_n.pin[2].i + (-aimc.plug_sn.pin[2].i) = 0.0;
//   aimc.plug_sn.pin[2].v = aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.plug_n.pin[1].i + (-aimc.plug_sn.pin[1].i) = 0.0;
//   aimc.plug_sn.pin[1].v = aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.ground.i + aimc.spacePhasorS.zero.i = 0.0;
//   aimc.spacePhasorS.ground.v = aimc.spacePhasorS.zero.v;
//   aimc.airGapS.flange.tau + aimc.inertiaRotor.flange_a.tau = 0.0;
//   aimc.airGapS.flange.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.spacePhasorS.spacePhasor.i_[1] + aimc.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aimc.spacePhasorS.spacePhasor.i_[2] + aimc.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_s.v_[1] = aimc.spacePhasorS.spacePhasor.v_[1];
//   aimc.airGapS.spacePhasor_s.v_[2] = aimc.spacePhasorS.spacePhasor.v_[2];
//   aimc.airGapS.spacePhasor_r.i_[1] + aimc.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   aimc.airGapS.spacePhasor_r.i_[2] + aimc.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_r.v_[1] = aimc.squirrelCageR.spacePhasor_r.v_[1];
//   aimc.airGapS.spacePhasor_r.v_[2] = aimc.squirrelCageR.spacePhasor_r.v_[2];
//   aimc.spacePhasorS.gnd.p.i + (-aimc.spacePhasorS.ground.i) = 0.0;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.ground.v;
//   aimc.lssigma.inductor[3].n.i + (-aimc.lssigma.plug_n.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].n.v = aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.inductor[2].n.i + (-aimc.lssigma.plug_n.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].n.v = aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.inductor[1].n.i + (-aimc.lssigma.plug_n.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].n.v = aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.inductor[3].p.i + (-aimc.lssigma.plug_p.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].p.v = aimc.lssigma.plug_p.pin[3].v;
//   aimc.lssigma.inductor[2].p.i + (-aimc.lssigma.plug_p.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].p.v = aimc.lssigma.plug_p.pin[2].v;
//   aimc.lssigma.inductor[1].p.i + (-aimc.lssigma.plug_p.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].p.v = aimc.lssigma.plug_p.pin[1].v;
//   aimc.rs.resistor[3].n.i + (-aimc.rs.plug_n.pin[3].i) = 0.0;
//   aimc.rs.plug_n.pin[3].v = aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[2].n.i + (-aimc.rs.plug_n.pin[2].i) = 0.0;
//   aimc.rs.plug_n.pin[2].v = aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[1].n.i + (-aimc.rs.plug_n.pin[1].i) = 0.0;
//   aimc.rs.plug_n.pin[1].v = aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[3].p.i + (-aimc.rs.plug_p.pin[3].i) = 0.0;
//   aimc.rs.plug_p.pin[3].v = aimc.rs.resistor[3].p.v;
//   aimc.rs.resistor[2].p.i + (-aimc.rs.plug_p.pin[2].i) = 0.0;
//   aimc.rs.plug_p.pin[2].v = aimc.rs.resistor[2].p.v;
//   aimc.rs.resistor[1].p.i + (-aimc.rs.plug_p.pin[1].i) = 0.0;
//   aimc.rs.plug_p.pin[1].v = aimc.rs.resistor[1].p.v;
//   aimc.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_YD;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMC_YD completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMC_YD has 458 equation(s) and 458 variable(s).
// 323 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMS_Start
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "1st start time";
//   parameter Real Rstart(quantity = "Resistance", unit = "Ohm") = 0.16 "starting resistance";
//   parameter Real tStart2(quantity = "Time", unit = "s") = 1.0 "2nd start time";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 150.843571262114 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aims.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aims.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aims.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aims.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aims.Jr) "stator's moment of inertia";
//   output Real aims.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aims.flange.phi - aims.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aims.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aims.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aims.tauElectrical(quantity = "Torque", unit = "N.m") = aims.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aims.tauShaft(quantity = "Torque", unit = "N.m") = -aims.flange.tau "shaft torque";
//   Real aims.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aims.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aims.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aims.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aims.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aims.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aims.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aims.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aims.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aims.m = 3 "number of phases";
//   parameter Integer aims.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aims.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aims.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aims.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aims.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aims.vs[1](quantity = "ElectricPotential", unit = "V") = aims.plug_sp.pin[1].v - aims.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aims.vs[2](quantity = "ElectricPotential", unit = "V") = aims.plug_sp.pin[2].v - aims.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aims.vs[3](quantity = "ElectricPotential", unit = "V") = aims.plug_sp.pin[3].v - aims.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aims.is[1](quantity = "ElectricCurrent", unit = "A") = aims.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aims.is[2](quantity = "ElectricCurrent", unit = "A") = aims.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aims.is[3](quantity = "ElectricCurrent", unit = "A") = aims.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aims.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aims.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aims.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aims.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aims.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aims.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aims.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aims.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aims.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aims.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aims.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aims.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aims.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rs.m(min = 1) = 3 "number of phases";
//   Real aims.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.rs.plug_p.m(min = 1) = aims.rs.m "number of phases";
//   Real aims.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rs.plug_n.m(min = 1) = aims.rs.m "number of phases";
//   Real aims.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rs.mh(min = 1) = aims.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aims.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aims.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aims.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rs.resistor[1].useHeatPort = aims.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aims.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aims.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[1] "Reference temperature";
//   parameter Real aims.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rs.resistor[2].useHeatPort = aims.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aims.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aims.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[2] "Reference temperature";
//   parameter Real aims.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rs.resistor[3].useHeatPort = aims.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aims.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aims.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rs.T_ref[3] "Reference temperature";
//   parameter Real aims.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aims.lssigma.m(min = 1) = 3 "number of phases";
//   Real aims.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.lssigma.plug_p.m(min = 1) = aims.lssigma.m "number of phases";
//   Real aims.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.lssigma.plug_n.m(min = 1) = aims.lssigma.m "number of phases";
//   Real aims.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lssigma "Inductance";
//   parameter Real aims.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lssigma "Inductance";
//   parameter Real aims.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lssigma "Inductance";
//   Real aims.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lssigma.L[1] "Inductance";
//   Real aims.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lssigma.L[2] "Inductance";
//   Real aims.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lssigma.L[3] "Inductance";
//   constant Integer aims.spacePhasorS.m = 3 "number of phases";
//   constant Real aims.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aims.spacePhasorS.turnsRatio = 1.0;
//   Real aims.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aims.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aims.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aims.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aims.airGapS.m = 3 "number of phases";
//   parameter Integer aims.airGapS.p(min = 1) = aims.p "number of pole pairs";
//   output Real aims.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aims.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aims.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aims.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aims.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aims.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aims.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aims.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aims.airGapS.Lm(quantity = "Inductance", unit = "H") = aims.Lm "main field inductance";
//   Real aims.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aims.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aims.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aims.airGapS.Lm "inductance matrix";
//   protected parameter Real aims.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aims.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aims.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aims.airGapS.Lm "inductance matrix";
//   parameter Real aims.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aims.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aims.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aims.fsNominal / 6.28318530717959) "rotor stray inductance per phase";
//   parameter Real aims.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance per phase";
//   parameter Boolean aims.useTurnsRatio(start = true) "use turnsRatio or calculate from locked-rotor voltage?";
//   parameter Real aims.turnsRatio(min = 1e-60, start = 1.0) "Effective number of stator turns / effective number of rotor turns";
//   parameter Real aims.VsNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal stator voltage per phase";
//   parameter Real aims.VrLockedRotor(quantity = "ElectricPotential", unit = "V", start = 628.318530717959 * (aims.fsNominal * aims.Lm / sqrt(aims.Rs ^ 2.0 + 39.4784176043574 * (aims.fsNominal ^ 2.0 * (aims.Lm + aims.Lssigma) ^ 2.0)))) "locked-rotor voltage per phase";
//   output Real aims.i_0_r(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aims.spacePhasorR.zero.i "rotor zero-sequence current";
//   output Real aims.vr[1](quantity = "ElectricPotential", unit = "V") = aims.plug_rp.pin[1].v - aims.plug_rn.pin[1].v "rotor instantaneous voltages";
//   output Real aims.vr[2](quantity = "ElectricPotential", unit = "V") = aims.plug_rp.pin[2].v - aims.plug_rn.pin[2].v "rotor instantaneous voltages";
//   output Real aims.vr[3](quantity = "ElectricPotential", unit = "V") = aims.plug_rp.pin[3].v - aims.plug_rn.pin[3].v "rotor instantaneous voltages";
//   output Real aims.ir[1](quantity = "ElectricCurrent", unit = "A") = aims.plug_rp.pin[1].i "rotor instantaneous currents";
//   output Real aims.ir[2](quantity = "ElectricCurrent", unit = "A") = aims.plug_rp.pin[2].i "rotor instantaneous currents";
//   output Real aims.ir[3](quantity = "ElectricCurrent", unit = "A") = aims.plug_rp.pin[3].i "rotor instantaneous currents";
//   protected parameter Real aims.internalTurnsRatio = if aims.useTurnsRatio then aims.turnsRatio else 6.28318530717959 * (aims.VsNominal * (aims.fsNominal * (aims.Lm * 1.0 / sqrt(aims.Rs ^ 2.0 + 39.4784176043574 * (aims.fsNominal ^ 2.0 * (aims.Lm + aims.Lssigma) ^ 2.0)) / aims.VrLockedRotor)));
//   constant Integer aims.spacePhasorR.m = 3 "number of phases";
//   constant Real aims.spacePhasorR.pi = 3.14159265358979;
//   parameter Real aims.spacePhasorR.turnsRatio = aims.internalTurnsRatio;
//   Real aims.spacePhasorR.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorR.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorR.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aims.spacePhasorR.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorR.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aims.spacePhasorR.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aims.spacePhasorR.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aims.spacePhasorR.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aims.spacePhasorR.plug_p.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorR.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.spacePhasorR.plug_n.m(min = 1) = 3 "number of phases";
//   Real aims.spacePhasorR.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.spacePhasorR.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.spacePhasorR.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorR.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aims.spacePhasorR.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aims.spacePhasorR.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aims.lrsigma.m(min = 1) = 3 "number of phases";
//   Real aims.lrsigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lrsigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lrsigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.lrsigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lrsigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.lrsigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.lrsigma.plug_p.m(min = 1) = aims.lrsigma.m "number of phases";
//   Real aims.lrsigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.lrsigma.plug_n.m(min = 1) = aims.lrsigma.m "number of phases";
//   Real aims.lrsigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lrsigma "Inductance";
//   parameter Real aims.lrsigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lrsigma "Inductance";
//   parameter Real aims.lrsigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aims.Lrsigma "Inductance";
//   Real aims.lrsigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lrsigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lrsigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lrsigma.L[1] "Inductance";
//   Real aims.lrsigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lrsigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lrsigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lrsigma.L[2] "Inductance";
//   Real aims.lrsigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.lrsigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.lrsigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.lrsigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.lrsigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.lrsigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aims.lrsigma.L[3] "Inductance";
//   parameter Integer aims.rr.m(min = 1) = 3 "number of phases";
//   Real aims.rr.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rr.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rr.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aims.rr.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rr.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aims.rr.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aims.rr.plug_p.m(min = 1) = aims.rr.m "number of phases";
//   Real aims.rr.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rr.plug_n.m(min = 1) = aims.rr.m "number of phases";
//   Real aims.rr.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.rr.mh(min = 1) = aims.rr.m "Number of heatPorts=number of phases";
//   parameter Boolean aims.rr.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aims.rr.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rr.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rr.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aims.rr.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rr "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rr.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rr "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rr.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.Rr "Resistances R_ref at temperatures T_ref";
//   parameter Real aims.rr.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rr.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rr.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aims.rr.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rr.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aims.rr.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aims.rr.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rr.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rr.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rr.resistor[1].useHeatPort = aims.rr.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rr.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aims.rr.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rr.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rr.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rr.R[1] "Resistance at temperature T_ref";
//   parameter Real aims.rr.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[1] "Reference temperature";
//   parameter Real aims.rr.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rr.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rr.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rr.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rr.resistor[2].useHeatPort = aims.rr.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rr.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aims.rr.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rr.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rr.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rr.R[2] "Resistance at temperature T_ref";
//   parameter Real aims.rr.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[2] "Reference temperature";
//   parameter Real aims.rr.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rr.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aims.rr.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aims.rr.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.rr.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.rr.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aims.rr.resistor[3].useHeatPort = aims.rr.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aims.rr.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aims.rr.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aims.rr.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aims.rr.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aims.rr.R[3] "Resistance at temperature T_ref";
//   parameter Real aims.rr.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aims.rr.T_ref[3] "Reference temperature";
//   parameter Real aims.rr.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aims.rr.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aims.rr.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aims.plug_rp.m(min = 1) = 3 "number of phases";
//   Real aims.plug_rp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aims.plug_rn.m(min = 1) = 3 "number of phases";
//   Real aims.plug_rn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aims.plug_rn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aims.plug_rn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aims.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aims.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aims.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 0.816496580927726 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real booleanStep[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[1].startValue = false "Output before startTime";
//   output Boolean booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real booleanStep[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[2].startValue = false "Output before startTime";
//   output Boolean booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real booleanStep[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep[3].startValue = false "Output before startTime";
//   parameter Integer idealCloser.m(min = 1) = 3 "number of phases";
//   Real idealCloser.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real idealCloser.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real idealCloser.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer idealCloser.plug_p.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.plug_n.m(min = 1) = idealCloser.m "number of phases";
//   Real idealCloser.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer idealCloser.mh(min = 1) = idealCloser.m "Number of heatPorts=number of phases";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real idealCloser.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real idealCloser.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real idealCloser.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real idealCloser.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean idealCloser.control[1] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[2] "true => p--n connected, false => switch open";
//   input Boolean idealCloser.control[3] "true => p--n connected, false => switch open";
//   Real idealCloser.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[1].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[1] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[1] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[1].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[2].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[2] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[2] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[2].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real idealCloser.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.idealClosingSwitch[3].useHeatPort = idealCloser.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real idealCloser.idealClosingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.idealClosingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.idealClosingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = idealCloser.Ron[3] "Closed switch resistance";
//   parameter Real idealCloser.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = idealCloser.Goff[3] "Opened switch conductance";
//   input Boolean idealCloser.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
//   protected Real idealCloser.idealClosingSwitch[3].s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") = "D" "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer terminalBox.delta.plug_p.m(min = 1) = terminalBox.delta.m "number of phases";
//   Real terminalBox.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.delta.plug_n.m(min = 1) = terminalBox.delta.m "number of phases";
//   Real terminalBox.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer switchedRheostat.m = 3 "Number of phases";
//   parameter Integer switchedRheostat.plug_p.m(min = 1) = 3 "number of phases";
//   Real switchedRheostat.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.plug_n.m(min = 1) = 3 "number of phases";
//   Real switchedRheostat.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real switchedRheostat.RStart(quantity = "Resistance", unit = "Ohm") = Rstart "Starting resistance";
//   parameter Real switchedRheostat.tStart(quantity = "Time", unit = "s") = tStart2 "Duration of switching on the starting resistor";
//   parameter Integer switchedRheostat.star.m(min = 1) = 3 "number of phases";
//   parameter Integer switchedRheostat.star.plug_p.m(min = 1) = switchedRheostat.star.m "number of phases";
//   Real switchedRheostat.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.idealCommutingSwitch.mh(min = 1) = switchedRheostat.idealCommutingSwitch.m "Number of heatPorts=number of phases";
//   parameter Boolean switchedRheostat.idealCommutingSwitch.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.idealCommutingSwitch.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.idealCommutingSwitch.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Integer switchedRheostat.idealCommutingSwitch.m(min = 1) = 3 "number of phases";
//   parameter Real switchedRheostat.idealCommutingSwitch.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   parameter Real switchedRheostat.idealCommutingSwitch.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened switch conductance";
//   input Boolean switchedRheostat.idealCommutingSwitch.control[1] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchedRheostat.idealCommutingSwitch.control[2] "true => p--n2 connected, false => p--n1 connected";
//   input Boolean switchedRheostat.idealCommutingSwitch.control[3] "true => p--n2 connected, false => p--n1 connected";
//   parameter Integer switchedRheostat.idealCommutingSwitch.plug_p.m(min = 1) = switchedRheostat.idealCommutingSwitch.m "number of phases";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.idealCommutingSwitch.plug_n2.m(min = 1) = switchedRheostat.idealCommutingSwitch.m "number of phases";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.idealCommutingSwitch.plug_n1.m(min = 1) = switchedRheostat.idealCommutingSwitch.m "number of phases";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].useHeatPort = switchedRheostat.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchedRheostat.idealCommutingSwitch.Ron[1] "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchedRheostat.idealCommutingSwitch.Goff[1] "Opened switch conductance";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s1(unit = "1");
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].useHeatPort = switchedRheostat.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchedRheostat.idealCommutingSwitch.Ron[2] "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchedRheostat.idealCommutingSwitch.Goff[2] "Opened switch conductance";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s1(unit = "1");
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].useHeatPort = switchedRheostat.idealCommutingSwitch.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = switchedRheostat.idealCommutingSwitch.Ron[3] "Closed switch resistance";
//   parameter Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = switchedRheostat.idealCommutingSwitch.Goff[3] "Opened switch conductance";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Boolean switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control "true => p--n2 connected, false => p--n1 connected";
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s1(unit = "1");
//   protected Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s2(unit = "1") "Auxiliary variables";
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer switchedRheostat.rheostat.m(min = 1) = 3 "number of phases";
//   Real switchedRheostat.rheostat.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real switchedRheostat.rheostat.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real switchedRheostat.rheostat.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real switchedRheostat.rheostat.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real switchedRheostat.rheostat.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real switchedRheostat.rheostat.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer switchedRheostat.rheostat.plug_p.m(min = 1) = switchedRheostat.rheostat.m "number of phases";
//   Real switchedRheostat.rheostat.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.rheostat.plug_n.m(min = 1) = switchedRheostat.rheostat.m "number of phases";
//   Real switchedRheostat.rheostat.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer switchedRheostat.rheostat.mh(min = 1) = switchedRheostat.rheostat.m "Number of heatPorts=number of phases";
//   parameter Boolean switchedRheostat.rheostat.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real switchedRheostat.rheostat.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.rheostat.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.rheostat.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real switchedRheostat.rheostat.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.RStart "Resistances R_ref at temperatures T_ref";
//   parameter Real switchedRheostat.rheostat.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.RStart "Resistances R_ref at temperatures T_ref";
//   parameter Real switchedRheostat.rheostat.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.RStart "Resistances R_ref at temperatures T_ref";
//   parameter Real switchedRheostat.rheostat.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real switchedRheostat.rheostat.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real switchedRheostat.rheostat.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real switchedRheostat.rheostat.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real switchedRheostat.rheostat.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real switchedRheostat.rheostat.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real switchedRheostat.rheostat.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real switchedRheostat.rheostat.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real switchedRheostat.rheostat.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.rheostat.resistor[1].useHeatPort = switchedRheostat.rheostat.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.rheostat.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T[1] "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.rheostat.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.rheostat.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.rheostat.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.rheostat.R[1] "Resistance at temperature T_ref";
//   parameter Real switchedRheostat.rheostat.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[1] "Reference temperature";
//   parameter Real switchedRheostat.rheostat.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = switchedRheostat.rheostat.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real switchedRheostat.rheostat.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real switchedRheostat.rheostat.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.rheostat.resistor[2].useHeatPort = switchedRheostat.rheostat.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.rheostat.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T[2] "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.rheostat.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.rheostat.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.rheostat.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.rheostat.R[2] "Resistance at temperature T_ref";
//   parameter Real switchedRheostat.rheostat.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[2] "Reference temperature";
//   parameter Real switchedRheostat.rheostat.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = switchedRheostat.rheostat.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real switchedRheostat.rheostat.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real switchedRheostat.rheostat.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.rheostat.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.rheostat.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean switchedRheostat.rheostat.resistor[3].useHeatPort = switchedRheostat.rheostat.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real switchedRheostat.rheostat.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T[3] "Fixed device temperature if useHeatPort = false";
//   Real switchedRheostat.rheostat.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real switchedRheostat.rheostat.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real switchedRheostat.rheostat.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = switchedRheostat.rheostat.R[3] "Resistance at temperature T_ref";
//   parameter Real switchedRheostat.rheostat.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = switchedRheostat.rheostat.T_ref[3] "Reference temperature";
//   parameter Real switchedRheostat.rheostat.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = switchedRheostat.rheostat.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real switchedRheostat.rheostat.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer switchedRheostat.starRheostat.m(min = 1) = 3 "number of phases";
//   parameter Integer switchedRheostat.starRheostat.plug_p.m(min = 1) = switchedRheostat.starRheostat.m "number of phases";
//   Real switchedRheostat.starRheostat.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real switchedRheostat.starRheostat.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real switchedRheostat.starRheostat.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean switchedRheostat.booleanStep[1].y "Connector of Boolean output signal";
//   parameter Real switchedRheostat.booleanStep[1].startTime(quantity = "Time", unit = "s") = switchedRheostat.tStart "Time instant of step start";
//   parameter Boolean switchedRheostat.booleanStep[1].startValue = false "Output before startTime";
//   output Boolean switchedRheostat.booleanStep[2].y "Connector of Boolean output signal";
//   parameter Real switchedRheostat.booleanStep[2].startTime(quantity = "Time", unit = "s") = switchedRheostat.tStart "Time instant of step start";
//   parameter Boolean switchedRheostat.booleanStep[2].startValue = false "Output before startTime";
//   output Boolean switchedRheostat.booleanStep[3].y "Connector of Boolean output signal";
//   parameter Real switchedRheostat.booleanStep[3].startTime(quantity = "Time", unit = "s") = switchedRheostat.tStart "Time instant of step start";
//   parameter Boolean switchedRheostat.booleanStep[3].startValue = false "Output before startTime";
// equation
//   aims.inertiaRotor.phi = aims.inertiaRotor.flange_a.phi;
//   aims.inertiaRotor.phi = aims.inertiaRotor.flange_b.phi;
//   aims.inertiaRotor.w = der(aims.inertiaRotor.phi);
//   aims.inertiaRotor.a = der(aims.inertiaRotor.w);
//   aims.inertiaRotor.J * aims.inertiaRotor.a = aims.inertiaRotor.flange_a.tau + aims.inertiaRotor.flange_b.tau;
//   assert(1.0 + aims.rs.resistor[1].alpha * (aims.rs.resistor[1].T_heatPort - aims.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rs.resistor[1].R_actual = aims.rs.resistor[1].R * (1.0 + aims.rs.resistor[1].alpha * (aims.rs.resistor[1].T_heatPort - aims.rs.resistor[1].T_ref));
//   aims.rs.resistor[1].v = aims.rs.resistor[1].R_actual * aims.rs.resistor[1].i;
//   aims.rs.resistor[1].LossPower = aims.rs.resistor[1].v * aims.rs.resistor[1].i;
//   aims.rs.resistor[1].i = aims.rs.resistor[1].p.i;
//   0.0 = aims.rs.resistor[1].p.i + aims.rs.resistor[1].n.i;
//   aims.rs.resistor[1].v = aims.rs.resistor[1].p.v - aims.rs.resistor[1].n.v;
//   aims.rs.resistor[1].T_heatPort = aims.rs.resistor[1].T;
//   assert(1.0 + aims.rs.resistor[2].alpha * (aims.rs.resistor[2].T_heatPort - aims.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rs.resistor[2].R_actual = aims.rs.resistor[2].R * (1.0 + aims.rs.resistor[2].alpha * (aims.rs.resistor[2].T_heatPort - aims.rs.resistor[2].T_ref));
//   aims.rs.resistor[2].v = aims.rs.resistor[2].R_actual * aims.rs.resistor[2].i;
//   aims.rs.resistor[2].LossPower = aims.rs.resistor[2].v * aims.rs.resistor[2].i;
//   aims.rs.resistor[2].i = aims.rs.resistor[2].p.i;
//   0.0 = aims.rs.resistor[2].p.i + aims.rs.resistor[2].n.i;
//   aims.rs.resistor[2].v = aims.rs.resistor[2].p.v - aims.rs.resistor[2].n.v;
//   aims.rs.resistor[2].T_heatPort = aims.rs.resistor[2].T;
//   assert(1.0 + aims.rs.resistor[3].alpha * (aims.rs.resistor[3].T_heatPort - aims.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rs.resistor[3].R_actual = aims.rs.resistor[3].R * (1.0 + aims.rs.resistor[3].alpha * (aims.rs.resistor[3].T_heatPort - aims.rs.resistor[3].T_ref));
//   aims.rs.resistor[3].v = aims.rs.resistor[3].R_actual * aims.rs.resistor[3].i;
//   aims.rs.resistor[3].LossPower = aims.rs.resistor[3].v * aims.rs.resistor[3].i;
//   aims.rs.resistor[3].i = aims.rs.resistor[3].p.i;
//   0.0 = aims.rs.resistor[3].p.i + aims.rs.resistor[3].n.i;
//   aims.rs.resistor[3].v = aims.rs.resistor[3].p.v - aims.rs.resistor[3].n.v;
//   aims.rs.resistor[3].T_heatPort = aims.rs.resistor[3].T;
//   aims.rs.v[1] = aims.rs.plug_p.pin[1].v - aims.rs.plug_n.pin[1].v;
//   aims.rs.v[2] = aims.rs.plug_p.pin[2].v - aims.rs.plug_n.pin[2].v;
//   aims.rs.v[3] = aims.rs.plug_p.pin[3].v - aims.rs.plug_n.pin[3].v;
//   aims.rs.i[1] = aims.rs.plug_p.pin[1].i;
//   aims.rs.i[2] = aims.rs.plug_p.pin[2].i;
//   aims.rs.i[3] = aims.rs.plug_p.pin[3].i;
//   aims.lssigma.inductor[1].L * der(aims.lssigma.inductor[1].i) = aims.lssigma.inductor[1].v;
//   aims.lssigma.inductor[1].v = aims.lssigma.inductor[1].p.v - aims.lssigma.inductor[1].n.v;
//   0.0 = aims.lssigma.inductor[1].p.i + aims.lssigma.inductor[1].n.i;
//   aims.lssigma.inductor[1].i = aims.lssigma.inductor[1].p.i;
//   aims.lssigma.inductor[2].L * der(aims.lssigma.inductor[2].i) = aims.lssigma.inductor[2].v;
//   aims.lssigma.inductor[2].v = aims.lssigma.inductor[2].p.v - aims.lssigma.inductor[2].n.v;
//   0.0 = aims.lssigma.inductor[2].p.i + aims.lssigma.inductor[2].n.i;
//   aims.lssigma.inductor[2].i = aims.lssigma.inductor[2].p.i;
//   aims.lssigma.inductor[3].L * der(aims.lssigma.inductor[3].i) = aims.lssigma.inductor[3].v;
//   aims.lssigma.inductor[3].v = aims.lssigma.inductor[3].p.v - aims.lssigma.inductor[3].n.v;
//   0.0 = aims.lssigma.inductor[3].p.i + aims.lssigma.inductor[3].n.i;
//   aims.lssigma.inductor[3].i = aims.lssigma.inductor[3].p.i;
//   aims.lssigma.v[1] = aims.lssigma.plug_p.pin[1].v - aims.lssigma.plug_n.pin[1].v;
//   aims.lssigma.v[2] = aims.lssigma.plug_p.pin[2].v - aims.lssigma.plug_n.pin[2].v;
//   aims.lssigma.v[3] = aims.lssigma.plug_p.pin[3].v - aims.lssigma.plug_n.pin[3].v;
//   aims.lssigma.i[1] = aims.lssigma.plug_p.pin[1].i;
//   aims.lssigma.i[2] = aims.lssigma.plug_p.pin[2].i;
//   aims.lssigma.i[3] = aims.lssigma.plug_p.pin[3].i;
//   aims.spacePhasorS.gnd.p.v = 0.0;
//   aims.spacePhasorS.v[1] / aims.spacePhasorS.turnsRatio = aims.spacePhasorS.plug_p.pin[1].v - aims.spacePhasorS.plug_n.pin[1].v;
//   aims.spacePhasorS.v[2] / aims.spacePhasorS.turnsRatio = aims.spacePhasorS.plug_p.pin[2].v - aims.spacePhasorS.plug_n.pin[2].v;
//   aims.spacePhasorS.v[3] / aims.spacePhasorS.turnsRatio = aims.spacePhasorS.plug_p.pin[3].v - aims.spacePhasorS.plug_n.pin[3].v;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[1] = aims.spacePhasorS.plug_p.pin[1].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[2] = aims.spacePhasorS.plug_p.pin[2].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[3] = aims.spacePhasorS.plug_p.pin[3].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[1] = -aims.spacePhasorS.plug_n.pin[1].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[2] = -aims.spacePhasorS.plug_n.pin[2].i;
//   aims.spacePhasorS.turnsRatio * aims.spacePhasorS.i[3] = -aims.spacePhasorS.plug_n.pin[3].i;
//   aims.spacePhasorS.zero.v = 0.333333333333333 * (aims.spacePhasorS.v[1] + (aims.spacePhasorS.v[2] + aims.spacePhasorS.v[3]));
//   aims.spacePhasorS.spacePhasor.v_[1] = aims.spacePhasorS.TransformationMatrix[1,1] * aims.spacePhasorS.v[1] + (aims.spacePhasorS.TransformationMatrix[1,2] * aims.spacePhasorS.v[2] + aims.spacePhasorS.TransformationMatrix[1,3] * aims.spacePhasorS.v[3]);
//   aims.spacePhasorS.spacePhasor.v_[2] = aims.spacePhasorS.TransformationMatrix[2,1] * aims.spacePhasorS.v[1] + (aims.spacePhasorS.TransformationMatrix[2,2] * aims.spacePhasorS.v[2] + aims.spacePhasorS.TransformationMatrix[2,3] * aims.spacePhasorS.v[3]);
//   -aims.spacePhasorS.zero.i = 0.333333333333333 * (aims.spacePhasorS.i[1] + (aims.spacePhasorS.i[2] + aims.spacePhasorS.i[3]));
//   -aims.spacePhasorS.spacePhasor.i_[1] = aims.spacePhasorS.TransformationMatrix[1,1] * aims.spacePhasorS.i[1] + (aims.spacePhasorS.TransformationMatrix[1,2] * aims.spacePhasorS.i[2] + aims.spacePhasorS.TransformationMatrix[1,3] * aims.spacePhasorS.i[3]);
//   -aims.spacePhasorS.spacePhasor.i_[2] = aims.spacePhasorS.TransformationMatrix[2,1] * aims.spacePhasorS.i[1] + (aims.spacePhasorS.TransformationMatrix[2,2] * aims.spacePhasorS.i[2] + aims.spacePhasorS.TransformationMatrix[2,3] * aims.spacePhasorS.i[3]);
//   aims.airGapS.i_ms[1] = aims.airGapS.i_ss[1] + aims.airGapS.i_rs[1];
//   aims.airGapS.i_ms[2] = aims.airGapS.i_ss[2] + aims.airGapS.i_rs[2];
//   aims.airGapS.psi_ms[1] = aims.airGapS.L[1,1] * aims.airGapS.i_ms[1] + aims.airGapS.L[1,2] * aims.airGapS.i_ms[2];
//   aims.airGapS.psi_ms[2] = aims.airGapS.L[2,1] * aims.airGapS.i_ms[1] + aims.airGapS.L[2,2] * aims.airGapS.i_ms[2];
//   aims.airGapS.psi_mr[1] = aims.airGapS.RotationMatrix[1,1] * aims.airGapS.psi_ms[1] + aims.airGapS.RotationMatrix[2,1] * aims.airGapS.psi_ms[2];
//   aims.airGapS.psi_mr[2] = aims.airGapS.RotationMatrix[1,2] * aims.airGapS.psi_ms[1] + aims.airGapS.RotationMatrix[2,2] * aims.airGapS.psi_ms[2];
//   aims.airGapS.gamma = Real(aims.airGapS.p) * (aims.airGapS.flange.phi - aims.airGapS.support.phi);
//   aims.airGapS.RotationMatrix[1,1] = cos(aims.airGapS.gamma);
//   aims.airGapS.RotationMatrix[1,2] = -sin(aims.airGapS.gamma);
//   aims.airGapS.RotationMatrix[2,1] = sin(aims.airGapS.gamma);
//   aims.airGapS.RotationMatrix[2,2] = cos(aims.airGapS.gamma);
//   aims.airGapS.i_ss[1] = aims.airGapS.spacePhasor_s.i_[1];
//   aims.airGapS.i_ss[2] = aims.airGapS.spacePhasor_s.i_[2];
//   aims.airGapS.i_ss[1] = aims.airGapS.RotationMatrix[1,1] * aims.airGapS.i_sr[1] + aims.airGapS.RotationMatrix[1,2] * aims.airGapS.i_sr[2];
//   aims.airGapS.i_ss[2] = aims.airGapS.RotationMatrix[2,1] * aims.airGapS.i_sr[1] + aims.airGapS.RotationMatrix[2,2] * aims.airGapS.i_sr[2];
//   aims.airGapS.i_rr[1] = aims.airGapS.spacePhasor_r.i_[1];
//   aims.airGapS.i_rr[2] = aims.airGapS.spacePhasor_r.i_[2];
//   aims.airGapS.i_rs[1] = aims.airGapS.RotationMatrix[1,1] * aims.airGapS.i_rr[1] + aims.airGapS.RotationMatrix[1,2] * aims.airGapS.i_rr[2];
//   aims.airGapS.i_rs[2] = aims.airGapS.RotationMatrix[2,1] * aims.airGapS.i_rr[1] + aims.airGapS.RotationMatrix[2,2] * aims.airGapS.i_rr[2];
//   aims.airGapS.spacePhasor_s.v_[1] = der(aims.airGapS.psi_ms[1]);
//   aims.airGapS.spacePhasor_s.v_[2] = der(aims.airGapS.psi_ms[2]);
//   aims.airGapS.spacePhasor_r.v_[1] = der(aims.airGapS.psi_mr[1]);
//   aims.airGapS.spacePhasor_r.v_[2] = der(aims.airGapS.psi_mr[2]);
//   aims.airGapS.tauElectrical = Real(aims.airGapS.m) * (Real(aims.airGapS.p) * (aims.airGapS.spacePhasor_s.i_[2] * aims.airGapS.psi_ms[1] - aims.airGapS.spacePhasor_s.i_[1] * aims.airGapS.psi_ms[2]) / 2.0);
//   aims.airGapS.flange.tau = -aims.airGapS.tauElectrical;
//   aims.airGapS.support.tau = aims.airGapS.tauElectrical;
//   aims.spacePhasorR.gnd.p.v = 0.0;
//   aims.spacePhasorR.v[1] / aims.spacePhasorR.turnsRatio = aims.spacePhasorR.plug_p.pin[1].v - aims.spacePhasorR.plug_n.pin[1].v;
//   aims.spacePhasorR.v[2] / aims.spacePhasorR.turnsRatio = aims.spacePhasorR.plug_p.pin[2].v - aims.spacePhasorR.plug_n.pin[2].v;
//   aims.spacePhasorR.v[3] / aims.spacePhasorR.turnsRatio = aims.spacePhasorR.plug_p.pin[3].v - aims.spacePhasorR.plug_n.pin[3].v;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[1] = aims.spacePhasorR.plug_p.pin[1].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[2] = aims.spacePhasorR.plug_p.pin[2].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[3] = aims.spacePhasorR.plug_p.pin[3].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[1] = -aims.spacePhasorR.plug_n.pin[1].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[2] = -aims.spacePhasorR.plug_n.pin[2].i;
//   aims.spacePhasorR.turnsRatio * aims.spacePhasorR.i[3] = -aims.spacePhasorR.plug_n.pin[3].i;
//   aims.spacePhasorR.zero.v = 0.333333333333333 * (aims.spacePhasorR.v[1] + (aims.spacePhasorR.v[2] + aims.spacePhasorR.v[3]));
//   aims.spacePhasorR.spacePhasor.v_[1] = aims.spacePhasorR.TransformationMatrix[1,1] * aims.spacePhasorR.v[1] + (aims.spacePhasorR.TransformationMatrix[1,2] * aims.spacePhasorR.v[2] + aims.spacePhasorR.TransformationMatrix[1,3] * aims.spacePhasorR.v[3]);
//   aims.spacePhasorR.spacePhasor.v_[2] = aims.spacePhasorR.TransformationMatrix[2,1] * aims.spacePhasorR.v[1] + (aims.spacePhasorR.TransformationMatrix[2,2] * aims.spacePhasorR.v[2] + aims.spacePhasorR.TransformationMatrix[2,3] * aims.spacePhasorR.v[3]);
//   -aims.spacePhasorR.zero.i = 0.333333333333333 * (aims.spacePhasorR.i[1] + (aims.spacePhasorR.i[2] + aims.spacePhasorR.i[3]));
//   -aims.spacePhasorR.spacePhasor.i_[1] = aims.spacePhasorR.TransformationMatrix[1,1] * aims.spacePhasorR.i[1] + (aims.spacePhasorR.TransformationMatrix[1,2] * aims.spacePhasorR.i[2] + aims.spacePhasorR.TransformationMatrix[1,3] * aims.spacePhasorR.i[3]);
//   -aims.spacePhasorR.spacePhasor.i_[2] = aims.spacePhasorR.TransformationMatrix[2,1] * aims.spacePhasorR.i[1] + (aims.spacePhasorR.TransformationMatrix[2,2] * aims.spacePhasorR.i[2] + aims.spacePhasorR.TransformationMatrix[2,3] * aims.spacePhasorR.i[3]);
//   aims.lrsigma.inductor[1].L * der(aims.lrsigma.inductor[1].i) = aims.lrsigma.inductor[1].v;
//   aims.lrsigma.inductor[1].v = aims.lrsigma.inductor[1].p.v - aims.lrsigma.inductor[1].n.v;
//   0.0 = aims.lrsigma.inductor[1].p.i + aims.lrsigma.inductor[1].n.i;
//   aims.lrsigma.inductor[1].i = aims.lrsigma.inductor[1].p.i;
//   aims.lrsigma.inductor[2].L * der(aims.lrsigma.inductor[2].i) = aims.lrsigma.inductor[2].v;
//   aims.lrsigma.inductor[2].v = aims.lrsigma.inductor[2].p.v - aims.lrsigma.inductor[2].n.v;
//   0.0 = aims.lrsigma.inductor[2].p.i + aims.lrsigma.inductor[2].n.i;
//   aims.lrsigma.inductor[2].i = aims.lrsigma.inductor[2].p.i;
//   aims.lrsigma.inductor[3].L * der(aims.lrsigma.inductor[3].i) = aims.lrsigma.inductor[3].v;
//   aims.lrsigma.inductor[3].v = aims.lrsigma.inductor[3].p.v - aims.lrsigma.inductor[3].n.v;
//   0.0 = aims.lrsigma.inductor[3].p.i + aims.lrsigma.inductor[3].n.i;
//   aims.lrsigma.inductor[3].i = aims.lrsigma.inductor[3].p.i;
//   aims.lrsigma.v[1] = aims.lrsigma.plug_p.pin[1].v - aims.lrsigma.plug_n.pin[1].v;
//   aims.lrsigma.v[2] = aims.lrsigma.plug_p.pin[2].v - aims.lrsigma.plug_n.pin[2].v;
//   aims.lrsigma.v[3] = aims.lrsigma.plug_p.pin[3].v - aims.lrsigma.plug_n.pin[3].v;
//   aims.lrsigma.i[1] = aims.lrsigma.plug_p.pin[1].i;
//   aims.lrsigma.i[2] = aims.lrsigma.plug_p.pin[2].i;
//   aims.lrsigma.i[3] = aims.lrsigma.plug_p.pin[3].i;
//   assert(1.0 + aims.rr.resistor[1].alpha * (aims.rr.resistor[1].T_heatPort - aims.rr.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rr.resistor[1].R_actual = aims.rr.resistor[1].R * (1.0 + aims.rr.resistor[1].alpha * (aims.rr.resistor[1].T_heatPort - aims.rr.resistor[1].T_ref));
//   aims.rr.resistor[1].v = aims.rr.resistor[1].R_actual * aims.rr.resistor[1].i;
//   aims.rr.resistor[1].LossPower = aims.rr.resistor[1].v * aims.rr.resistor[1].i;
//   aims.rr.resistor[1].i = aims.rr.resistor[1].p.i;
//   0.0 = aims.rr.resistor[1].p.i + aims.rr.resistor[1].n.i;
//   aims.rr.resistor[1].v = aims.rr.resistor[1].p.v - aims.rr.resistor[1].n.v;
//   aims.rr.resistor[1].T_heatPort = aims.rr.resistor[1].T;
//   assert(1.0 + aims.rr.resistor[2].alpha * (aims.rr.resistor[2].T_heatPort - aims.rr.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rr.resistor[2].R_actual = aims.rr.resistor[2].R * (1.0 + aims.rr.resistor[2].alpha * (aims.rr.resistor[2].T_heatPort - aims.rr.resistor[2].T_ref));
//   aims.rr.resistor[2].v = aims.rr.resistor[2].R_actual * aims.rr.resistor[2].i;
//   aims.rr.resistor[2].LossPower = aims.rr.resistor[2].v * aims.rr.resistor[2].i;
//   aims.rr.resistor[2].i = aims.rr.resistor[2].p.i;
//   0.0 = aims.rr.resistor[2].p.i + aims.rr.resistor[2].n.i;
//   aims.rr.resistor[2].v = aims.rr.resistor[2].p.v - aims.rr.resistor[2].n.v;
//   aims.rr.resistor[2].T_heatPort = aims.rr.resistor[2].T;
//   assert(1.0 + aims.rr.resistor[3].alpha * (aims.rr.resistor[3].T_heatPort - aims.rr.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aims.rr.resistor[3].R_actual = aims.rr.resistor[3].R * (1.0 + aims.rr.resistor[3].alpha * (aims.rr.resistor[3].T_heatPort - aims.rr.resistor[3].T_ref));
//   aims.rr.resistor[3].v = aims.rr.resistor[3].R_actual * aims.rr.resistor[3].i;
//   aims.rr.resistor[3].LossPower = aims.rr.resistor[3].v * aims.rr.resistor[3].i;
//   aims.rr.resistor[3].i = aims.rr.resistor[3].p.i;
//   0.0 = aims.rr.resistor[3].p.i + aims.rr.resistor[3].n.i;
//   aims.rr.resistor[3].v = aims.rr.resistor[3].p.v - aims.rr.resistor[3].n.v;
//   aims.rr.resistor[3].T_heatPort = aims.rr.resistor[3].T;
//   aims.rr.v[1] = aims.rr.plug_p.pin[1].v - aims.rr.plug_n.pin[1].v;
//   aims.rr.v[2] = aims.rr.plug_p.pin[2].v - aims.rr.plug_n.pin[2].v;
//   aims.rr.v[3] = aims.rr.plug_p.pin[3].v - aims.rr.plug_n.pin[3].v;
//   aims.rr.i[1] = aims.rr.plug_p.pin[1].i;
//   aims.rr.i[2] = aims.rr.plug_p.pin[2].i;
//   aims.rr.i[3] = aims.rr.plug_p.pin[3].i;
//   aims.fixed.flange.phi = aims.fixed.phi0;
//   assert(aims.rr.plug_n.m == aims.lrsigma.plug_p.m,"automatically generated from connect");
//   assert(aims.rr.plug_p.m == aims.plug_rp.m,"automatically generated from connect");
//   assert(aims.lrsigma.plug_n.m == aims.spacePhasorR.plug_p.m,"automatically generated from connect");
//   assert(aims.spacePhasorR.plug_n.m == aims.plug_rn.m,"automatically generated from connect");
//   assert(aims.spacePhasorS.plug_n.m == aims.plug_sn.m,"automatically generated from connect");
//   assert(aims.lssigma.plug_n.m == aims.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aims.rs.plug_n.m == aims.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aims.plug_sp.m == aims.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   booleanStep[1].y = if time >= booleanStep[1].startTime then  NOT booleanStep[1].startValue else booleanStep[1].startValue;
//   booleanStep[2].y = if time >= booleanStep[2].startTime then  NOT booleanStep[2].startValue else booleanStep[2].startValue;
//   booleanStep[3].y = if time >= booleanStep[3].startTime then  NOT booleanStep[3].startValue else booleanStep[3].startValue;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then idealCloser.idealClosingSwitch[1].Ron else 1.0);
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].s * (if idealCloser.idealClosingSwitch[1].control then 1.0 else idealCloser.idealClosingSwitch[1].Goff);
//   idealCloser.idealClosingSwitch[1].LossPower = idealCloser.idealClosingSwitch[1].v * idealCloser.idealClosingSwitch[1].i;
//   idealCloser.idealClosingSwitch[1].i = idealCloser.idealClosingSwitch[1].p.i;
//   0.0 = idealCloser.idealClosingSwitch[1].p.i + idealCloser.idealClosingSwitch[1].n.i;
//   idealCloser.idealClosingSwitch[1].v = idealCloser.idealClosingSwitch[1].p.v - idealCloser.idealClosingSwitch[1].n.v;
//   idealCloser.idealClosingSwitch[1].T_heatPort = idealCloser.idealClosingSwitch[1].T;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then idealCloser.idealClosingSwitch[2].Ron else 1.0);
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].s * (if idealCloser.idealClosingSwitch[2].control then 1.0 else idealCloser.idealClosingSwitch[2].Goff);
//   idealCloser.idealClosingSwitch[2].LossPower = idealCloser.idealClosingSwitch[2].v * idealCloser.idealClosingSwitch[2].i;
//   idealCloser.idealClosingSwitch[2].i = idealCloser.idealClosingSwitch[2].p.i;
//   0.0 = idealCloser.idealClosingSwitch[2].p.i + idealCloser.idealClosingSwitch[2].n.i;
//   idealCloser.idealClosingSwitch[2].v = idealCloser.idealClosingSwitch[2].p.v - idealCloser.idealClosingSwitch[2].n.v;
//   idealCloser.idealClosingSwitch[2].T_heatPort = idealCloser.idealClosingSwitch[2].T;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then idealCloser.idealClosingSwitch[3].Ron else 1.0);
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].s * (if idealCloser.idealClosingSwitch[3].control then 1.0 else idealCloser.idealClosingSwitch[3].Goff);
//   idealCloser.idealClosingSwitch[3].LossPower = idealCloser.idealClosingSwitch[3].v * idealCloser.idealClosingSwitch[3].i;
//   idealCloser.idealClosingSwitch[3].i = idealCloser.idealClosingSwitch[3].p.i;
//   0.0 = idealCloser.idealClosingSwitch[3].p.i + idealCloser.idealClosingSwitch[3].n.i;
//   idealCloser.idealClosingSwitch[3].v = idealCloser.idealClosingSwitch[3].p.v - idealCloser.idealClosingSwitch[3].n.v;
//   idealCloser.idealClosingSwitch[3].T_heatPort = idealCloser.idealClosingSwitch[3].T;
//   idealCloser.v[1] = idealCloser.plug_p.pin[1].v - idealCloser.plug_n.pin[1].v;
//   idealCloser.v[2] = idealCloser.plug_p.pin[2].v - idealCloser.plug_n.pin[2].v;
//   idealCloser.v[3] = idealCloser.plug_p.pin[3].v - idealCloser.plug_n.pin[3].v;
//   idealCloser.i[1] = idealCloser.plug_p.pin[1].i;
//   idealCloser.i[2] = idealCloser.plug_p.pin[2].i;
//   idealCloser.i[3] = idealCloser.plug_p.pin[3].i;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(terminalBox.plug_sn.m == terminalBox.delta.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.delta.plug_p.m == terminalBox.plug_sp.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   switchedRheostat.ground.p.v = 0.0;
//   0.0 = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s1 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Ron);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s1) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Goff else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s2 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Ron else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].s2) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].Goff);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].LossPower = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T_heatPort = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].T;
//   0.0 = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s1 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Ron);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s1) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Goff else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s2 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Ron else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].s2) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].Goff);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].LossPower = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T_heatPort = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].T;
//   0.0 = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s1 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Ron);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s1) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Goff else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v - switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s2 * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Ron else 1.0);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i = (-switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].s2) * (if switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control then 1.0 else switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].Goff);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].LossPower = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v + (switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i * switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v);
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T_heatPort = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].T;
//   assert(1.0 + switchedRheostat.rheostat.resistor[1].alpha * (switchedRheostat.rheostat.resistor[1].T_heatPort - switchedRheostat.rheostat.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   switchedRheostat.rheostat.resistor[1].R_actual = switchedRheostat.rheostat.resistor[1].R * (1.0 + switchedRheostat.rheostat.resistor[1].alpha * (switchedRheostat.rheostat.resistor[1].T_heatPort - switchedRheostat.rheostat.resistor[1].T_ref));
//   switchedRheostat.rheostat.resistor[1].v = switchedRheostat.rheostat.resistor[1].R_actual * switchedRheostat.rheostat.resistor[1].i;
//   switchedRheostat.rheostat.resistor[1].LossPower = switchedRheostat.rheostat.resistor[1].v * switchedRheostat.rheostat.resistor[1].i;
//   switchedRheostat.rheostat.resistor[1].i = switchedRheostat.rheostat.resistor[1].p.i;
//   0.0 = switchedRheostat.rheostat.resistor[1].p.i + switchedRheostat.rheostat.resistor[1].n.i;
//   switchedRheostat.rheostat.resistor[1].v = switchedRheostat.rheostat.resistor[1].p.v - switchedRheostat.rheostat.resistor[1].n.v;
//   switchedRheostat.rheostat.resistor[1].T_heatPort = switchedRheostat.rheostat.resistor[1].T;
//   assert(1.0 + switchedRheostat.rheostat.resistor[2].alpha * (switchedRheostat.rheostat.resistor[2].T_heatPort - switchedRheostat.rheostat.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   switchedRheostat.rheostat.resistor[2].R_actual = switchedRheostat.rheostat.resistor[2].R * (1.0 + switchedRheostat.rheostat.resistor[2].alpha * (switchedRheostat.rheostat.resistor[2].T_heatPort - switchedRheostat.rheostat.resistor[2].T_ref));
//   switchedRheostat.rheostat.resistor[2].v = switchedRheostat.rheostat.resistor[2].R_actual * switchedRheostat.rheostat.resistor[2].i;
//   switchedRheostat.rheostat.resistor[2].LossPower = switchedRheostat.rheostat.resistor[2].v * switchedRheostat.rheostat.resistor[2].i;
//   switchedRheostat.rheostat.resistor[2].i = switchedRheostat.rheostat.resistor[2].p.i;
//   0.0 = switchedRheostat.rheostat.resistor[2].p.i + switchedRheostat.rheostat.resistor[2].n.i;
//   switchedRheostat.rheostat.resistor[2].v = switchedRheostat.rheostat.resistor[2].p.v - switchedRheostat.rheostat.resistor[2].n.v;
//   switchedRheostat.rheostat.resistor[2].T_heatPort = switchedRheostat.rheostat.resistor[2].T;
//   assert(1.0 + switchedRheostat.rheostat.resistor[3].alpha * (switchedRheostat.rheostat.resistor[3].T_heatPort - switchedRheostat.rheostat.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   switchedRheostat.rheostat.resistor[3].R_actual = switchedRheostat.rheostat.resistor[3].R * (1.0 + switchedRheostat.rheostat.resistor[3].alpha * (switchedRheostat.rheostat.resistor[3].T_heatPort - switchedRheostat.rheostat.resistor[3].T_ref));
//   switchedRheostat.rheostat.resistor[3].v = switchedRheostat.rheostat.resistor[3].R_actual * switchedRheostat.rheostat.resistor[3].i;
//   switchedRheostat.rheostat.resistor[3].LossPower = switchedRheostat.rheostat.resistor[3].v * switchedRheostat.rheostat.resistor[3].i;
//   switchedRheostat.rheostat.resistor[3].i = switchedRheostat.rheostat.resistor[3].p.i;
//   0.0 = switchedRheostat.rheostat.resistor[3].p.i + switchedRheostat.rheostat.resistor[3].n.i;
//   switchedRheostat.rheostat.resistor[3].v = switchedRheostat.rheostat.resistor[3].p.v - switchedRheostat.rheostat.resistor[3].n.v;
//   switchedRheostat.rheostat.resistor[3].T_heatPort = switchedRheostat.rheostat.resistor[3].T;
//   switchedRheostat.rheostat.v[1] = switchedRheostat.rheostat.plug_p.pin[1].v - switchedRheostat.rheostat.plug_n.pin[1].v;
//   switchedRheostat.rheostat.v[2] = switchedRheostat.rheostat.plug_p.pin[2].v - switchedRheostat.rheostat.plug_n.pin[2].v;
//   switchedRheostat.rheostat.v[3] = switchedRheostat.rheostat.plug_p.pin[3].v - switchedRheostat.rheostat.plug_n.pin[3].v;
//   switchedRheostat.rheostat.i[1] = switchedRheostat.rheostat.plug_p.pin[1].i;
//   switchedRheostat.rheostat.i[2] = switchedRheostat.rheostat.plug_p.pin[2].i;
//   switchedRheostat.rheostat.i[3] = switchedRheostat.rheostat.plug_p.pin[3].i;
//   switchedRheostat.booleanStep[1].y = if time >= switchedRheostat.booleanStep[1].startTime then  NOT switchedRheostat.booleanStep[1].startValue else switchedRheostat.booleanStep[1].startValue;
//   switchedRheostat.booleanStep[2].y = if time >= switchedRheostat.booleanStep[2].startTime then  NOT switchedRheostat.booleanStep[2].startValue else switchedRheostat.booleanStep[2].startValue;
//   switchedRheostat.booleanStep[3].y = if time >= switchedRheostat.booleanStep[3].startTime then  NOT switchedRheostat.booleanStep[3].startValue else switchedRheostat.booleanStep[3].startValue;
//   assert(switchedRheostat.plug_p.m == switchedRheostat.idealCommutingSwitch.plug_p.m,"automatically generated from connect");
//   assert(switchedRheostat.idealCommutingSwitch.plug_n2.m == switchedRheostat.plug_n.m,"automatically generated from connect");
//   assert(switchedRheostat.rheostat.plug_p.m == switchedRheostat.idealCommutingSwitch.plug_n1.m,"automatically generated from connect");
//   assert(switchedRheostat.idealCommutingSwitch.plug_n2.m == switchedRheostat.star.plug_p.m,"automatically generated from connect");
//   assert(switchedRheostat.rheostat.plug_n.m == switchedRheostat.starRheostat.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == idealCloser.plug_p.m,"automatically generated from connect");
//   assert(idealCloser.plug_n.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == aims.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == aims.plug_sp.m,"automatically generated from connect");
//   assert(switchedRheostat.plug_p.m == aims.plug_rp.m,"automatically generated from connect");
//   assert(switchedRheostat.plug_n.m == aims.plug_rn.m,"automatically generated from connect");
//   switchedRheostat.plug_n.pin[3].i + aims.plug_rn.pin[3].i = 0.0;
//   aims.plug_rn.pin[3].v = switchedRheostat.plug_n.pin[3].v;
//   switchedRheostat.plug_n.pin[2].i + aims.plug_rn.pin[2].i = 0.0;
//   aims.plug_rn.pin[2].v = switchedRheostat.plug_n.pin[2].v;
//   switchedRheostat.plug_n.pin[1].i + aims.plug_rn.pin[1].i = 0.0;
//   aims.plug_rn.pin[1].v = switchedRheostat.plug_n.pin[1].v;
//   switchedRheostat.plug_p.pin[3].i + aims.plug_rp.pin[3].i = 0.0;
//   aims.plug_rp.pin[3].v = switchedRheostat.plug_p.pin[3].v;
//   switchedRheostat.plug_p.pin[2].i + aims.plug_rp.pin[2].i = 0.0;
//   aims.plug_rp.pin[2].v = switchedRheostat.plug_p.pin[2].v;
//   switchedRheostat.plug_p.pin[1].i + aims.plug_rp.pin[1].i = 0.0;
//   aims.plug_rp.pin[1].v = switchedRheostat.plug_p.pin[1].v;
//   aims.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aims.flange.phi = loadInertia.flange_a.phi;
//   terminalBox.plug_sp.pin[3].i + aims.plug_sp.pin[3].i = 0.0;
//   aims.plug_sp.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + aims.plug_sp.pin[2].i = 0.0;
//   aims.plug_sp.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + aims.plug_sp.pin[1].i = 0.0;
//   aims.plug_sp.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plug_sn.pin[3].i + aims.plug_sn.pin[3].i = 0.0;
//   aims.plug_sn.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   terminalBox.plug_sn.pin[2].i + aims.plug_sn.pin[2].i = 0.0;
//   aims.plug_sn.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   terminalBox.plug_sn.pin[1].i + aims.plug_sn.pin[1].i = 0.0;
//   aims.plug_sn.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = terminalBox.plugSupply.pin[3].v;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = terminalBox.plugSupply.pin[2].v;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = terminalBox.plugSupply.pin[1].v;
//   idealCloser.plug_n.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = idealCloser.plug_n.pin[3].v;
//   idealCloser.plug_n.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = idealCloser.plug_n.pin[2].v;
//   idealCloser.plug_n.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = idealCloser.plug_n.pin[1].v;
//   booleanStep[1].y = idealCloser.control[1];
//   booleanStep[2].y = idealCloser.control[2];
//   booleanStep[3].y = idealCloser.control[3];
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   sineVoltage.plug_p.pin[3].i + idealCloser.plug_p.pin[3].i = 0.0;
//   idealCloser.plug_p.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + idealCloser.plug_p.pin[2].i = 0.0;
//   idealCloser.plug_p.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + idealCloser.plug_p.pin[1].i = 0.0;
//   idealCloser.plug_p.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   sineVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   sineVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   sineVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   switchedRheostat.booleanStep[1].y = switchedRheostat.idealCommutingSwitch.control[1];
//   switchedRheostat.booleanStep[2].y = switchedRheostat.idealCommutingSwitch.control[2];
//   switchedRheostat.booleanStep[3].y = switchedRheostat.idealCommutingSwitch.control[3];
//   switchedRheostat.starRheostat.pin_n.i + (switchedRheostat.star.pin_n.i + switchedRheostat.ground.p.i) = 0.0;
//   switchedRheostat.ground.p.v = switchedRheostat.star.pin_n.v;
//   switchedRheostat.ground.p.v = switchedRheostat.starRheostat.pin_n.v;
//   switchedRheostat.rheostat.plug_n.pin[3].i + switchedRheostat.starRheostat.plug_p.pin[3].i = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[3].v = switchedRheostat.starRheostat.plug_p.pin[3].v;
//   switchedRheostat.rheostat.plug_n.pin[2].i + switchedRheostat.starRheostat.plug_p.pin[2].i = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[2].v = switchedRheostat.starRheostat.plug_p.pin[2].v;
//   switchedRheostat.rheostat.plug_n.pin[1].i + switchedRheostat.starRheostat.plug_p.pin[1].i = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[1].v = switchedRheostat.starRheostat.plug_p.pin[1].v;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].i + ((-switchedRheostat.plug_n.pin[3].i) + switchedRheostat.star.plug_p.pin[3].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].v = switchedRheostat.plug_n.pin[3].v;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].v = switchedRheostat.star.plug_p.pin[3].v;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].i + ((-switchedRheostat.plug_n.pin[2].i) + switchedRheostat.star.plug_p.pin[2].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].v = switchedRheostat.plug_n.pin[2].v;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].v = switchedRheostat.star.plug_p.pin[2].v;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].i + ((-switchedRheostat.plug_n.pin[1].i) + switchedRheostat.star.plug_p.pin[1].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].v = switchedRheostat.plug_n.pin[1].v;
//   switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].v = switchedRheostat.star.plug_p.pin[1].v;
//   switchedRheostat.rheostat.plug_p.pin[3].i + switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].v = switchedRheostat.rheostat.plug_p.pin[3].v;
//   switchedRheostat.rheostat.plug_p.pin[2].i + switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].v = switchedRheostat.rheostat.plug_p.pin[2].v;
//   switchedRheostat.rheostat.plug_p.pin[1].i + switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].v = switchedRheostat.rheostat.plug_p.pin[1].v;
//   (-switchedRheostat.plug_p.pin[3].i) + switchedRheostat.idealCommutingSwitch.plug_p.pin[3].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_p.pin[3].v = switchedRheostat.plug_p.pin[3].v;
//   (-switchedRheostat.plug_p.pin[2].i) + switchedRheostat.idealCommutingSwitch.plug_p.pin[2].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_p.pin[2].v = switchedRheostat.plug_p.pin[2].v;
//   (-switchedRheostat.plug_p.pin[1].i) + switchedRheostat.idealCommutingSwitch.plug_p.pin[1].i = 0.0;
//   switchedRheostat.idealCommutingSwitch.plug_p.pin[1].v = switchedRheostat.plug_p.pin[1].v;
//   (-switchedRheostat.starRheostat.plug_p.pin[3].i) + ((-switchedRheostat.starRheostat.plug_p.pin[2].i) + ((-switchedRheostat.starRheostat.plug_p.pin[1].i) + (-switchedRheostat.starRheostat.pin_n.i))) = 0.0;
//   switchedRheostat.starRheostat.pin_n.v = switchedRheostat.starRheostat.plug_p.pin[1].v;
//   switchedRheostat.starRheostat.pin_n.v = switchedRheostat.starRheostat.plug_p.pin[2].v;
//   switchedRheostat.starRheostat.pin_n.v = switchedRheostat.starRheostat.plug_p.pin[3].v;
//   switchedRheostat.rheostat.resistor[3].n.i + (-switchedRheostat.rheostat.plug_n.pin[3].i) = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[3].v = switchedRheostat.rheostat.resistor[3].n.v;
//   switchedRheostat.rheostat.resistor[2].n.i + (-switchedRheostat.rheostat.plug_n.pin[2].i) = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[2].v = switchedRheostat.rheostat.resistor[2].n.v;
//   switchedRheostat.rheostat.resistor[1].n.i + (-switchedRheostat.rheostat.plug_n.pin[1].i) = 0.0;
//   switchedRheostat.rheostat.plug_n.pin[1].v = switchedRheostat.rheostat.resistor[1].n.v;
//   switchedRheostat.rheostat.resistor[3].p.i + (-switchedRheostat.rheostat.plug_p.pin[3].i) = 0.0;
//   switchedRheostat.rheostat.plug_p.pin[3].v = switchedRheostat.rheostat.resistor[3].p.v;
//   switchedRheostat.rheostat.resistor[2].p.i + (-switchedRheostat.rheostat.plug_p.pin[2].i) = 0.0;
//   switchedRheostat.rheostat.plug_p.pin[2].v = switchedRheostat.rheostat.resistor[2].p.v;
//   switchedRheostat.rheostat.resistor[1].p.i + (-switchedRheostat.rheostat.plug_p.pin[1].i) = 0.0;
//   switchedRheostat.rheostat.plug_p.pin[1].v = switchedRheostat.rheostat.resistor[1].p.v;
//   switchedRheostat.idealCommutingSwitch.control[1] = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].control;
//   switchedRheostat.idealCommutingSwitch.control[2] = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].control;
//   switchedRheostat.idealCommutingSwitch.control[3] = switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].control;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.i + (-switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n1.v = switchedRheostat.idealCommutingSwitch.plug_n1.pin[3].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.i + (-switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n1.v = switchedRheostat.idealCommutingSwitch.plug_n1.pin[2].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.i + (-switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n1.v = switchedRheostat.idealCommutingSwitch.plug_n1.pin[1].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.i + (-switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].n2.v = switchedRheostat.idealCommutingSwitch.plug_n2.pin[3].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.i + (-switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].n2.v = switchedRheostat.idealCommutingSwitch.plug_n2.pin[2].v;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.i + (-switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].i) = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].n2.v = switchedRheostat.idealCommutingSwitch.plug_n2.pin[1].v;
//   (-switchedRheostat.idealCommutingSwitch.plug_p.pin[3].i) + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.i = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[3].p.v = switchedRheostat.idealCommutingSwitch.plug_p.pin[3].v;
//   (-switchedRheostat.idealCommutingSwitch.plug_p.pin[2].i) + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.i = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[2].p.v = switchedRheostat.idealCommutingSwitch.plug_p.pin[2].v;
//   (-switchedRheostat.idealCommutingSwitch.plug_p.pin[1].i) + switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.i = 0.0;
//   switchedRheostat.idealCommutingSwitch.idealCommutingSwitch[1].p.v = switchedRheostat.idealCommutingSwitch.plug_p.pin[1].v;
//   (-switchedRheostat.star.plug_p.pin[3].i) + ((-switchedRheostat.star.plug_p.pin[2].i) + ((-switchedRheostat.star.plug_p.pin[1].i) + (-switchedRheostat.star.pin_n.i))) = 0.0;
//   switchedRheostat.star.pin_n.v = switchedRheostat.star.plug_p.pin[1].v;
//   switchedRheostat.star.pin_n.v = switchedRheostat.star.plug_p.pin[2].v;
//   switchedRheostat.star.pin_n.v = switchedRheostat.star.plug_p.pin[3].v;
//   terminalBox.delta.plug_p.pin[3].i + ((-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i)) = 0.0;
//   terminalBox.delta.plug_p.pin[3].v = terminalBox.plugSupply.pin[3].v;
//   terminalBox.delta.plug_p.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.delta.plug_p.pin[2].i + ((-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i)) = 0.0;
//   terminalBox.delta.plug_p.pin[2].v = terminalBox.plugSupply.pin[2].v;
//   terminalBox.delta.plug_p.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.delta.plug_p.pin[1].i + ((-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i)) = 0.0;
//   terminalBox.delta.plug_p.pin[1].v = terminalBox.plugSupply.pin[1].v;
//   terminalBox.delta.plug_p.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.delta.plug_n.pin[3].i = 0.0;
//   terminalBox.delta.plug_n.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.delta.plug_n.pin[2].i = 0.0;
//   terminalBox.delta.plug_n.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.delta.plug_n.pin[1].i = 0.0;
//   terminalBox.delta.plug_n.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   (-terminalBox.delta.plug_n.pin[3].i) + (-terminalBox.delta.plug_p.pin[1].i) = 0.0;
//   terminalBox.delta.plug_n.pin[3].v = terminalBox.delta.plug_p.pin[1].v;
//   (-terminalBox.delta.plug_n.pin[2].i) + (-terminalBox.delta.plug_p.pin[3].i) = 0.0;
//   terminalBox.delta.plug_n.pin[2].v = terminalBox.delta.plug_p.pin[3].v;
//   (-terminalBox.delta.plug_n.pin[1].i) + (-terminalBox.delta.plug_p.pin[2].i) = 0.0;
//   terminalBox.delta.plug_n.pin[1].v = terminalBox.delta.plug_p.pin[2].v;
//   idealCloser.control[1] = idealCloser.idealClosingSwitch[1].control;
//   idealCloser.control[2] = idealCloser.idealClosingSwitch[2].control;
//   idealCloser.control[3] = idealCloser.idealClosingSwitch[3].control;
//   idealCloser.idealClosingSwitch[3].n.i + (-idealCloser.plug_n.pin[3].i) = 0.0;
//   idealCloser.idealClosingSwitch[3].n.v = idealCloser.plug_n.pin[3].v;
//   idealCloser.idealClosingSwitch[2].n.i + (-idealCloser.plug_n.pin[2].i) = 0.0;
//   idealCloser.idealClosingSwitch[2].n.v = idealCloser.plug_n.pin[2].v;
//   idealCloser.idealClosingSwitch[1].n.i + (-idealCloser.plug_n.pin[1].i) = 0.0;
//   idealCloser.idealClosingSwitch[1].n.v = idealCloser.plug_n.pin[1].v;
//   (-idealCloser.plug_p.pin[3].i) + idealCloser.idealClosingSwitch[3].p.i = 0.0;
//   idealCloser.idealClosingSwitch[3].p.v = idealCloser.plug_p.pin[3].v;
//   (-idealCloser.plug_p.pin[2].i) + idealCloser.idealClosingSwitch[2].p.i = 0.0;
//   idealCloser.idealClosingSwitch[2].p.v = idealCloser.plug_p.pin[2].v;
//   (-idealCloser.plug_p.pin[1].i) + idealCloser.idealClosingSwitch[1].p.i = 0.0;
//   idealCloser.idealClosingSwitch[1].p.v = idealCloser.plug_p.pin[1].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   aims.airGapS.support.tau + ((-aims.internalSupport.tau) + aims.fixed.flange.tau) = 0.0;
//   aims.airGapS.support.phi = aims.fixed.flange.phi;
//   aims.airGapS.support.phi = aims.internalSupport.phi;
//   aims.inertiaRotor.flange_b.tau + (-aims.flange.tau) = 0.0;
//   aims.flange.phi = aims.inertiaRotor.flange_b.phi;
//   (-aims.plug_sp.pin[3].i) + aims.rs.plug_p.pin[3].i = 0.0;
//   aims.plug_sp.pin[3].v = aims.rs.plug_p.pin[3].v;
//   (-aims.plug_sp.pin[2].i) + aims.rs.plug_p.pin[2].i = 0.0;
//   aims.plug_sp.pin[2].v = aims.rs.plug_p.pin[2].v;
//   (-aims.plug_sp.pin[1].i) + aims.rs.plug_p.pin[1].i = 0.0;
//   aims.plug_sp.pin[1].v = aims.rs.plug_p.pin[1].v;
//   aims.rs.plug_n.pin[3].i + aims.lssigma.plug_p.pin[3].i = 0.0;
//   aims.lssigma.plug_p.pin[3].v = aims.rs.plug_n.pin[3].v;
//   aims.rs.plug_n.pin[2].i + aims.lssigma.plug_p.pin[2].i = 0.0;
//   aims.lssigma.plug_p.pin[2].v = aims.rs.plug_n.pin[2].v;
//   aims.rs.plug_n.pin[1].i + aims.lssigma.plug_p.pin[1].i = 0.0;
//   aims.lssigma.plug_p.pin[1].v = aims.rs.plug_n.pin[1].v;
//   aims.lssigma.plug_n.pin[3].i + aims.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aims.lssigma.plug_n.pin[3].v = aims.spacePhasorS.plug_p.pin[3].v;
//   aims.lssigma.plug_n.pin[2].i + aims.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aims.lssigma.plug_n.pin[2].v = aims.spacePhasorS.plug_p.pin[2].v;
//   aims.lssigma.plug_n.pin[1].i + aims.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aims.lssigma.plug_n.pin[1].v = aims.spacePhasorS.plug_p.pin[1].v;
//   aims.spacePhasorS.plug_n.pin[3].i + (-aims.plug_sn.pin[3].i) = 0.0;
//   aims.plug_sn.pin[3].v = aims.spacePhasorS.plug_n.pin[3].v;
//   aims.spacePhasorS.plug_n.pin[2].i + (-aims.plug_sn.pin[2].i) = 0.0;
//   aims.plug_sn.pin[2].v = aims.spacePhasorS.plug_n.pin[2].v;
//   aims.spacePhasorS.plug_n.pin[1].i + (-aims.plug_sn.pin[1].i) = 0.0;
//   aims.plug_sn.pin[1].v = aims.spacePhasorS.plug_n.pin[1].v;
//   aims.spacePhasorS.ground.i + aims.spacePhasorS.zero.i = 0.0;
//   aims.spacePhasorS.ground.v = aims.spacePhasorS.zero.v;
//   aims.spacePhasorR.plug_n.pin[3].i + (-aims.plug_rn.pin[3].i) = 0.0;
//   aims.plug_rn.pin[3].v = aims.spacePhasorR.plug_n.pin[3].v;
//   aims.spacePhasorR.plug_n.pin[2].i + (-aims.plug_rn.pin[2].i) = 0.0;
//   aims.plug_rn.pin[2].v = aims.spacePhasorR.plug_n.pin[2].v;
//   aims.spacePhasorR.plug_n.pin[1].i + (-aims.plug_rn.pin[1].i) = 0.0;
//   aims.plug_rn.pin[1].v = aims.spacePhasorR.plug_n.pin[1].v;
//   aims.lrsigma.plug_n.pin[3].i + aims.spacePhasorR.plug_p.pin[3].i = 0.0;
//   aims.lrsigma.plug_n.pin[3].v = aims.spacePhasorR.plug_p.pin[3].v;
//   aims.lrsigma.plug_n.pin[2].i + aims.spacePhasorR.plug_p.pin[2].i = 0.0;
//   aims.lrsigma.plug_n.pin[2].v = aims.spacePhasorR.plug_p.pin[2].v;
//   aims.lrsigma.plug_n.pin[1].i + aims.spacePhasorR.plug_p.pin[1].i = 0.0;
//   aims.lrsigma.plug_n.pin[1].v = aims.spacePhasorR.plug_p.pin[1].v;
//   aims.airGapS.flange.tau + aims.inertiaRotor.flange_a.tau = 0.0;
//   aims.airGapS.flange.phi = aims.inertiaRotor.flange_a.phi;
//   aims.spacePhasorS.spacePhasor.i_[1] + aims.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aims.spacePhasorS.spacePhasor.i_[2] + aims.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aims.airGapS.spacePhasor_s.v_[1] = aims.spacePhasorS.spacePhasor.v_[1];
//   aims.airGapS.spacePhasor_s.v_[2] = aims.spacePhasorS.spacePhasor.v_[2];
//   aims.airGapS.spacePhasor_r.i_[1] + aims.spacePhasorR.spacePhasor.i_[1] = 0.0;
//   aims.airGapS.spacePhasor_r.i_[2] + aims.spacePhasorR.spacePhasor.i_[2] = 0.0;
//   aims.airGapS.spacePhasor_r.v_[1] = aims.spacePhasorR.spacePhasor.v_[1];
//   aims.airGapS.spacePhasor_r.v_[2] = aims.spacePhasorR.spacePhasor.v_[2];
//   aims.spacePhasorR.ground.i + aims.spacePhasorR.zero.i = 0.0;
//   aims.spacePhasorR.ground.v = aims.spacePhasorR.zero.v;
//   aims.rr.plug_p.pin[3].i + (-aims.plug_rp.pin[3].i) = 0.0;
//   aims.plug_rp.pin[3].v = aims.rr.plug_p.pin[3].v;
//   aims.rr.plug_p.pin[2].i + (-aims.plug_rp.pin[2].i) = 0.0;
//   aims.plug_rp.pin[2].v = aims.rr.plug_p.pin[2].v;
//   aims.rr.plug_p.pin[1].i + (-aims.plug_rp.pin[1].i) = 0.0;
//   aims.plug_rp.pin[1].v = aims.rr.plug_p.pin[1].v;
//   aims.rr.plug_n.pin[3].i + aims.lrsigma.plug_p.pin[3].i = 0.0;
//   aims.lrsigma.plug_p.pin[3].v = aims.rr.plug_n.pin[3].v;
//   aims.rr.plug_n.pin[2].i + aims.lrsigma.plug_p.pin[2].i = 0.0;
//   aims.lrsigma.plug_p.pin[2].v = aims.rr.plug_n.pin[2].v;
//   aims.rr.plug_n.pin[1].i + aims.lrsigma.plug_p.pin[1].i = 0.0;
//   aims.lrsigma.plug_p.pin[1].v = aims.rr.plug_n.pin[1].v;
//   aims.rr.resistor[3].n.i + (-aims.rr.plug_n.pin[3].i) = 0.0;
//   aims.rr.plug_n.pin[3].v = aims.rr.resistor[3].n.v;
//   aims.rr.resistor[2].n.i + (-aims.rr.plug_n.pin[2].i) = 0.0;
//   aims.rr.plug_n.pin[2].v = aims.rr.resistor[2].n.v;
//   aims.rr.resistor[1].n.i + (-aims.rr.plug_n.pin[1].i) = 0.0;
//   aims.rr.plug_n.pin[1].v = aims.rr.resistor[1].n.v;
//   aims.rr.resistor[3].p.i + (-aims.rr.plug_p.pin[3].i) = 0.0;
//   aims.rr.plug_p.pin[3].v = aims.rr.resistor[3].p.v;
//   aims.rr.resistor[2].p.i + (-aims.rr.plug_p.pin[2].i) = 0.0;
//   aims.rr.plug_p.pin[2].v = aims.rr.resistor[2].p.v;
//   aims.rr.resistor[1].p.i + (-aims.rr.plug_p.pin[1].i) = 0.0;
//   aims.rr.plug_p.pin[1].v = aims.rr.resistor[1].p.v;
//   aims.lrsigma.inductor[3].n.i + (-aims.lrsigma.plug_n.pin[3].i) = 0.0;
//   aims.lrsigma.inductor[3].n.v = aims.lrsigma.plug_n.pin[3].v;
//   aims.lrsigma.inductor[2].n.i + (-aims.lrsigma.plug_n.pin[2].i) = 0.0;
//   aims.lrsigma.inductor[2].n.v = aims.lrsigma.plug_n.pin[2].v;
//   aims.lrsigma.inductor[1].n.i + (-aims.lrsigma.plug_n.pin[1].i) = 0.0;
//   aims.lrsigma.inductor[1].n.v = aims.lrsigma.plug_n.pin[1].v;
//   aims.lrsigma.inductor[3].p.i + (-aims.lrsigma.plug_p.pin[3].i) = 0.0;
//   aims.lrsigma.inductor[3].p.v = aims.lrsigma.plug_p.pin[3].v;
//   aims.lrsigma.inductor[2].p.i + (-aims.lrsigma.plug_p.pin[2].i) = 0.0;
//   aims.lrsigma.inductor[2].p.v = aims.lrsigma.plug_p.pin[2].v;
//   aims.lrsigma.inductor[1].p.i + (-aims.lrsigma.plug_p.pin[1].i) = 0.0;
//   aims.lrsigma.inductor[1].p.v = aims.lrsigma.plug_p.pin[1].v;
//   aims.spacePhasorR.gnd.p.i + (-aims.spacePhasorR.ground.i) = 0.0;
//   aims.spacePhasorR.gnd.p.v = aims.spacePhasorR.ground.v;
//   aims.spacePhasorS.gnd.p.i + (-aims.spacePhasorS.ground.i) = 0.0;
//   aims.spacePhasorS.gnd.p.v = aims.spacePhasorS.ground.v;
//   aims.lssigma.inductor[3].n.i + (-aims.lssigma.plug_n.pin[3].i) = 0.0;
//   aims.lssigma.inductor[3].n.v = aims.lssigma.plug_n.pin[3].v;
//   aims.lssigma.inductor[2].n.i + (-aims.lssigma.plug_n.pin[2].i) = 0.0;
//   aims.lssigma.inductor[2].n.v = aims.lssigma.plug_n.pin[2].v;
//   aims.lssigma.inductor[1].n.i + (-aims.lssigma.plug_n.pin[1].i) = 0.0;
//   aims.lssigma.inductor[1].n.v = aims.lssigma.plug_n.pin[1].v;
//   aims.lssigma.inductor[3].p.i + (-aims.lssigma.plug_p.pin[3].i) = 0.0;
//   aims.lssigma.inductor[3].p.v = aims.lssigma.plug_p.pin[3].v;
//   aims.lssigma.inductor[2].p.i + (-aims.lssigma.plug_p.pin[2].i) = 0.0;
//   aims.lssigma.inductor[2].p.v = aims.lssigma.plug_p.pin[2].v;
//   aims.lssigma.inductor[1].p.i + (-aims.lssigma.plug_p.pin[1].i) = 0.0;
//   aims.lssigma.inductor[1].p.v = aims.lssigma.plug_p.pin[1].v;
//   aims.rs.resistor[3].n.i + (-aims.rs.plug_n.pin[3].i) = 0.0;
//   aims.rs.plug_n.pin[3].v = aims.rs.resistor[3].n.v;
//   aims.rs.resistor[2].n.i + (-aims.rs.plug_n.pin[2].i) = 0.0;
//   aims.rs.plug_n.pin[2].v = aims.rs.resistor[2].n.v;
//   aims.rs.resistor[1].n.i + (-aims.rs.plug_n.pin[1].i) = 0.0;
//   aims.rs.plug_n.pin[1].v = aims.rs.resistor[1].n.v;
//   aims.rs.resistor[3].p.i + (-aims.rs.plug_p.pin[3].i) = 0.0;
//   aims.rs.plug_p.pin[3].v = aims.rs.resistor[3].p.v;
//   aims.rs.resistor[2].p.i + (-aims.rs.plug_p.pin[2].i) = 0.0;
//   aims.rs.plug_p.pin[2].v = aims.rs.resistor[2].p.v;
//   aims.rs.resistor[1].p.i + (-aims.rs.plug_p.pin[1].i) = 0.0;
//   aims.rs.plug_p.pin[1].v = aims.rs.resistor[1].p.v;
//   aims.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMS_Start;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMS_Start completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMS_Start has 646 equation(s) and 646 variable(s).
// 451 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_Inverter
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real f(quantity = "Frequency", unit = "Hz") = 50.0 "actual frequency";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 1.0 "frequency ramp";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.2 "time of load torque step";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aimc.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aimc.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aimc.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real aimc.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aimc.Jr) "stator's moment of inertia";
//   output Real aimc.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aimc.flange.phi - aimc.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aimc.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aimc.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aimc.tauElectrical(quantity = "Torque", unit = "N.m") = aimc.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aimc.tauShaft(quantity = "Torque", unit = "N.m") = -aimc.flange.tau "shaft torque";
//   Real aimc.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aimc.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aimc.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aimc.m = 3 "number of phases";
//   parameter Integer aimc.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aimc.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aimc.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aimc.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aimc.vs[1](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[1].v - aimc.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aimc.vs[2](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[2].v - aimc.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aimc.vs[3](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[3].v - aimc.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aimc.is[1](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aimc.is[2](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aimc.is[3](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aimc.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aimc.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aimc.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aimc.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.m(min = 1) = 3 "number of phases";
//   Real aimc.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.rs.plug_p.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.plug_n.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.mh(min = 1) = aimc.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aimc.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aimc.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aimc.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[1].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Reference temperature";
//   parameter Real aimc.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[2].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Reference temperature";
//   parameter Real aimc.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[3].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Reference temperature";
//   parameter Real aimc.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aimc.lssigma.m(min = 1) = 3 "number of phases";
//   Real aimc.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.lssigma.plug_p.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.lssigma.plug_n.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   Real aimc.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[1] "Inductance";
//   Real aimc.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[2] "Inductance";
//   Real aimc.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[3] "Inductance";
//   constant Integer aimc.spacePhasorS.m = 3 "number of phases";
//   constant Real aimc.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aimc.spacePhasorS.turnsRatio = 1.0;
//   Real aimc.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aimc.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aimc.airGapS.m = 3 "number of phases";
//   parameter Integer aimc.airGapS.p(min = 1) = aimc.p "number of pole pairs";
//   output Real aimc.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aimc.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aimc.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.airGapS.Lm(quantity = "Inductance", unit = "H") = aimc.Lm "main field inductance";
//   Real aimc.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aimc.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   protected parameter Real aimc.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   parameter Real aimc.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aimc.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aimc.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "rotor stray inductance (equivalent three phase winding)";
//   parameter Real aimc.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance (equivalent three phase winding)";
//   parameter Real aimc.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = aimc.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real aimc.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = aimc.Rr "warm rotor resistance per phase translated to stator";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real aimc.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   output Real ramp.y "Connector of Real output signal";
//   parameter Real ramp.height = f "Height of ramps";
//   parameter Real ramp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = tRamp "Durations of ramp";
//   parameter Real ramp.offset = 0.0 "Offset of output signal";
//   parameter Real ramp.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
//   parameter Integer vfController.nout = vfController.m "Number of outputs";
//   input Real vfController.u "Connector of Real input signal";
//   output Real vfController.y[1] "Connector of Real output signals";
//   output Real vfController.y[2] "Connector of Real output signals";
//   output Real vfController.y[3] "Connector of Real output signals";
//   constant Real vfController.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Integer vfController.m = 3 "number of phases";
//   parameter Real vfController.VNominal(quantity = "ElectricPotential", unit = "V") = VNominal "nominal RMS voltage per phase";
//   parameter Real vfController.fNominal(quantity = "Frequency", unit = "Hz") = fNominal "nominal frequency";
//   parameter Real vfController.BasePhase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "common phase shift";
//   output Real vfController.x(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true) "integrator state";
//   output Real vfController.amplitude(quantity = "ElectricPotential", unit = "V");
//   parameter Integer signalVoltage.m(min = 1) = 3 "number of phases";
//   Real signalVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real signalVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real signalVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer signalVoltage.plug_p.m(min = 1) = signalVoltage.m "number of phases";
//   Real signalVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer signalVoltage.plug_n.m(min = 1) = signalVoltage.m "number of phases";
//   Real signalVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.v[1] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real signalVoltage.v[2] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real signalVoltage.v[3] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[1].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real signalVoltage.signalVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[2].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real signalVoltage.signalVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[3].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean loadTorqueStep.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real loadTorqueStep.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorqueStep.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real loadTorqueStep.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real loadTorqueStep.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real loadTorqueStep.stepTorque(quantity = "Torque", unit = "N.m", start = 1.0) = -TLoad "Height of torque step (if negative, torque is acting as load)";
//   parameter Real loadTorqueStep.offsetTorque(quantity = "Torque", unit = "N.m", start = 0.0) "Offset of torque";
//   parameter Real loadTorqueStep.startTime(quantity = "Time", unit = "s") = tStep "Torque = offset for time < startTime";
//   Real loadTorqueStep.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.star.m(min = 1) = 3 "number of phases";
//   parameter Integer terminalBox.star.plug_p.m(min = 1) = terminalBox.star.m "number of phases";
//   Real terminalBox.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.inertiaRotor.w = der(aimc.inertiaRotor.phi);
//   aimc.inertiaRotor.a = der(aimc.inertiaRotor.w);
//   aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.inertiaRotor.flange_a.tau + aimc.inertiaRotor.flange_b.tau;
//   assert(1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[1].R_actual = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref));
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].i = aimc.rs.resistor[1].p.i;
//   0.0 = aimc.rs.resistor[1].p.i + aimc.rs.resistor[1].n.i;
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].p.v - aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[1].T_heatPort = aimc.rs.resistor[1].T;
//   assert(1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[2].R_actual = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref));
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].i = aimc.rs.resistor[2].p.i;
//   0.0 = aimc.rs.resistor[2].p.i + aimc.rs.resistor[2].n.i;
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].p.v - aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[2].T_heatPort = aimc.rs.resistor[2].T;
//   assert(1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[3].R_actual = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref));
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].i = aimc.rs.resistor[3].p.i;
//   0.0 = aimc.rs.resistor[3].p.i + aimc.rs.resistor[3].n.i;
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].p.v - aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[3].T_heatPort = aimc.rs.resistor[3].T;
//   aimc.rs.v[1] = aimc.rs.plug_p.pin[1].v - aimc.rs.plug_n.pin[1].v;
//   aimc.rs.v[2] = aimc.rs.plug_p.pin[2].v - aimc.rs.plug_n.pin[2].v;
//   aimc.rs.v[3] = aimc.rs.plug_p.pin[3].v - aimc.rs.plug_n.pin[3].v;
//   aimc.rs.i[1] = aimc.rs.plug_p.pin[1].i;
//   aimc.rs.i[2] = aimc.rs.plug_p.pin[2].i;
//   aimc.rs.i[3] = aimc.rs.plug_p.pin[3].i;
//   aimc.lssigma.inductor[1].L * der(aimc.lssigma.inductor[1].i) = aimc.lssigma.inductor[1].v;
//   aimc.lssigma.inductor[1].v = aimc.lssigma.inductor[1].p.v - aimc.lssigma.inductor[1].n.v;
//   0.0 = aimc.lssigma.inductor[1].p.i + aimc.lssigma.inductor[1].n.i;
//   aimc.lssigma.inductor[1].i = aimc.lssigma.inductor[1].p.i;
//   aimc.lssigma.inductor[2].L * der(aimc.lssigma.inductor[2].i) = aimc.lssigma.inductor[2].v;
//   aimc.lssigma.inductor[2].v = aimc.lssigma.inductor[2].p.v - aimc.lssigma.inductor[2].n.v;
//   0.0 = aimc.lssigma.inductor[2].p.i + aimc.lssigma.inductor[2].n.i;
//   aimc.lssigma.inductor[2].i = aimc.lssigma.inductor[2].p.i;
//   aimc.lssigma.inductor[3].L * der(aimc.lssigma.inductor[3].i) = aimc.lssigma.inductor[3].v;
//   aimc.lssigma.inductor[3].v = aimc.lssigma.inductor[3].p.v - aimc.lssigma.inductor[3].n.v;
//   0.0 = aimc.lssigma.inductor[3].p.i + aimc.lssigma.inductor[3].n.i;
//   aimc.lssigma.inductor[3].i = aimc.lssigma.inductor[3].p.i;
//   aimc.lssigma.v[1] = aimc.lssigma.plug_p.pin[1].v - aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.v[2] = aimc.lssigma.plug_p.pin[2].v - aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.v[3] = aimc.lssigma.plug_p.pin[3].v - aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.i[1] = aimc.lssigma.plug_p.pin[1].i;
//   aimc.lssigma.i[2] = aimc.lssigma.plug_p.pin[2].i;
//   aimc.lssigma.i[3] = aimc.lssigma.plug_p.pin[3].i;
//   aimc.spacePhasorS.gnd.p.v = 0.0;
//   aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[1].v - aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[2].v - aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[3].v - aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = aimc.spacePhasorS.plug_p.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = aimc.spacePhasorS.plug_p.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = aimc.spacePhasorS.plug_p.pin[3].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = -aimc.spacePhasorS.plug_n.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = -aimc.spacePhasorS.plug_n.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = -aimc.spacePhasorS.plug_n.pin[3].i;
//   aimc.spacePhasorS.zero.v = 0.333333333333333 * (aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]));
//   aimc.spacePhasorS.spacePhasor.v_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.v[3]);
//   aimc.spacePhasorS.spacePhasor.v_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.v[3]);
//   -aimc.spacePhasorS.zero.i = 0.333333333333333 * (aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]));
//   -aimc.spacePhasorS.spacePhasor.i_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.i[3]);
//   -aimc.spacePhasorS.spacePhasor.i_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.i[3]);
//   aimc.airGapS.i_ms[1] = aimc.airGapS.i_ss[1] + aimc.airGapS.i_rs[1];
//   aimc.airGapS.i_ms[2] = aimc.airGapS.i_ss[2] + aimc.airGapS.i_rs[2];
//   aimc.airGapS.psi_ms[1] = aimc.airGapS.L[1,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[1,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_ms[2] = aimc.airGapS.L[2,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[2,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.gamma = Real(aimc.airGapS.p) * (aimc.airGapS.flange.phi - aimc.airGapS.support.phi);
//   aimc.airGapS.RotationMatrix[1,1] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[1,2] = -sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,1] = sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.i_ss[1] = aimc.airGapS.spacePhasor_s.i_[1];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.spacePhasor_s.i_[2];
//   aimc.airGapS.i_ss[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_rr[1] = aimc.airGapS.spacePhasor_r.i_[1];
//   aimc.airGapS.i_rr[2] = aimc.airGapS.spacePhasor_r.i_[2];
//   aimc.airGapS.i_rs[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.i_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.spacePhasor_s.v_[1] = der(aimc.airGapS.psi_ms[1]);
//   aimc.airGapS.spacePhasor_s.v_[2] = der(aimc.airGapS.psi_ms[2]);
//   aimc.airGapS.spacePhasor_r.v_[1] = der(aimc.airGapS.psi_mr[1]);
//   aimc.airGapS.spacePhasor_r.v_[2] = der(aimc.airGapS.psi_mr[2]);
//   aimc.airGapS.tauElectrical = Real(aimc.airGapS.m) * (Real(aimc.airGapS.p) * (aimc.airGapS.spacePhasor_s.i_[2] * aimc.airGapS.psi_ms[1] - aimc.airGapS.spacePhasor_s.i_[1] * aimc.airGapS.psi_ms[2]) / 2.0);
//   aimc.airGapS.flange.tau = -aimc.airGapS.tauElectrical;
//   aimc.airGapS.support.tau = aimc.airGapS.tauElectrical;
//   aimc.squirrelCageR.spacePhasor_r.v_[1] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[1] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[1]);
//   aimc.squirrelCageR.spacePhasor_r.v_[2] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[2] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[2]);
//   aimc.fixed.flange.phi = aimc.fixed.phi0;
//   assert(aimc.spacePhasorS.plug_n.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(aimc.lssigma.plug_n.m == aimc.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aimc.rs.plug_n.m == aimc.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aimc.plug_sp.m == aimc.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   vfController.amplitude = 1.4142135623731 * (vfController.VNominal * (if abs(vfController.u) < vfController.fNominal then abs(vfController.u) / vfController.fNominal else 1.0));
//   der(vfController.x) = 6.28318530717959 * vfController.u;
//   vfController.y[1] = vfController.amplitude * sin(vfController.x + vfController.BasePhase);
//   vfController.y[2] = vfController.amplitude * sin(vfController.x + vfController.BasePhase - 6.28318530717959 / Real(vfController.m));
//   vfController.y[3] = vfController.amplitude * sin(vfController.x + vfController.BasePhase - 12.5663706143592 / Real(vfController.m));
//   signalVoltage.signalVoltage[1].v = signalVoltage.signalVoltage[1].p.v - signalVoltage.signalVoltage[1].n.v;
//   0.0 = signalVoltage.signalVoltage[1].p.i + signalVoltage.signalVoltage[1].n.i;
//   signalVoltage.signalVoltage[1].i = signalVoltage.signalVoltage[1].p.i;
//   signalVoltage.signalVoltage[2].v = signalVoltage.signalVoltage[2].p.v - signalVoltage.signalVoltage[2].n.v;
//   0.0 = signalVoltage.signalVoltage[2].p.i + signalVoltage.signalVoltage[2].n.i;
//   signalVoltage.signalVoltage[2].i = signalVoltage.signalVoltage[2].p.i;
//   signalVoltage.signalVoltage[3].v = signalVoltage.signalVoltage[3].p.v - signalVoltage.signalVoltage[3].n.v;
//   0.0 = signalVoltage.signalVoltage[3].p.i + signalVoltage.signalVoltage[3].n.i;
//   signalVoltage.signalVoltage[3].i = signalVoltage.signalVoltage[3].p.i;
//   signalVoltage.i[1] = signalVoltage.plug_p.pin[1].i;
//   signalVoltage.i[2] = signalVoltage.plug_p.pin[2].i;
//   signalVoltage.i[3] = signalVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   loadTorqueStep.tau = -loadTorqueStep.flange.tau;
//   loadTorqueStep.tau = loadTorqueStep.offsetTorque + (if time < loadTorqueStep.startTime then 0.0 else loadTorqueStep.stepTorque);
//   loadTorqueStep.phi = loadTorqueStep.flange.phi - loadTorqueStep.phi_support;
//   loadTorqueStep.phi_support = 0.0;
//   assert(terminalBox.plug_sn.m == terminalBox.star.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   assert(signalVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(signalVoltage.plug_p.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == aimc.plug_sp.m,"automatically generated from connect");
//   aimc.flange.tau + loadInertia.flange_a.tau = 0.0;
//   aimc.flange.phi = loadInertia.flange_a.phi;
//   terminalBox.plug_sp.pin[3].i + aimc.plug_sp.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + aimc.plug_sp.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + aimc.plug_sp.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plug_sn.pin[3].i + aimc.plug_sn.pin[3].i = 0.0;
//   aimc.plug_sn.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   terminalBox.plug_sn.pin[2].i + aimc.plug_sn.pin[2].i = 0.0;
//   aimc.plug_sn.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   terminalBox.plug_sn.pin[1].i + aimc.plug_sn.pin[1].i = 0.0;
//   aimc.plug_sn.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = terminalBox.plugSupply.pin[3].v;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = terminalBox.plugSupply.pin[2].v;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = terminalBox.plugSupply.pin[1].v;
//   signalVoltage.plug_p.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = signalVoltage.plug_p.pin[3].v;
//   signalVoltage.plug_p.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = signalVoltage.plug_p.pin[2].v;
//   signalVoltage.plug_p.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = signalVoltage.plug_p.pin[1].v;
//   loadTorqueStep.flange.tau + loadInertia.flange_b.tau = 0.0;
//   loadInertia.flange_b.phi = loadTorqueStep.flange.phi;
//   signalVoltage.v[1] = vfController.y[1];
//   signalVoltage.v[2] = vfController.y[2];
//   signalVoltage.v[3] = vfController.y[3];
//   ramp.y = vfController.u;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   signalVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   signalVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   signalVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   signalVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   signalVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   signalVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.i + (-terminalBox.starpoint.i) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.starpoint.v;
//   (-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i) = 0.0;
//   terminalBox.plugSupply.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   (-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i) = 0.0;
//   terminalBox.plugSupply.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   (-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i) = 0.0;
//   terminalBox.plugSupply.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.star.plug_p.pin[3].i = 0.0;
//   terminalBox.plug_sn.pin[3].v = terminalBox.star.plug_p.pin[3].v;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.star.plug_p.pin[2].i = 0.0;
//   terminalBox.plug_sn.pin[2].v = terminalBox.star.plug_p.pin[2].v;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.star.plug_p.pin[1].i = 0.0;
//   terminalBox.plug_sn.pin[1].v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.starpoint.i = 0.0;
//   (-terminalBox.star.plug_p.pin[3].i) + ((-terminalBox.star.plug_p.pin[2].i) + ((-terminalBox.star.plug_p.pin[1].i) + (-terminalBox.star.pin_n.i))) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[2].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[3].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   signalVoltage.signalVoltage[1].v = signalVoltage.v[1];
//   signalVoltage.signalVoltage[2].v = signalVoltage.v[2];
//   signalVoltage.signalVoltage[3].v = signalVoltage.v[3];
//   signalVoltage.signalVoltage[3].n.i + (-signalVoltage.plug_n.pin[3].i) = 0.0;
//   signalVoltage.plug_n.pin[3].v = signalVoltage.signalVoltage[3].n.v;
//   signalVoltage.signalVoltage[2].n.i + (-signalVoltage.plug_n.pin[2].i) = 0.0;
//   signalVoltage.plug_n.pin[2].v = signalVoltage.signalVoltage[2].n.v;
//   signalVoltage.signalVoltage[1].n.i + (-signalVoltage.plug_n.pin[1].i) = 0.0;
//   signalVoltage.plug_n.pin[1].v = signalVoltage.signalVoltage[1].n.v;
//   signalVoltage.signalVoltage[3].p.i + (-signalVoltage.plug_p.pin[3].i) = 0.0;
//   signalVoltage.plug_p.pin[3].v = signalVoltage.signalVoltage[3].p.v;
//   signalVoltage.signalVoltage[2].p.i + (-signalVoltage.plug_p.pin[2].i) = 0.0;
//   signalVoltage.plug_p.pin[2].v = signalVoltage.signalVoltage[2].p.v;
//   signalVoltage.signalVoltage[1].p.i + (-signalVoltage.plug_p.pin[1].i) = 0.0;
//   signalVoltage.plug_p.pin[1].v = signalVoltage.signalVoltage[1].p.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   aimc.airGapS.support.tau + ((-aimc.internalSupport.tau) + aimc.fixed.flange.tau) = 0.0;
//   aimc.airGapS.support.phi = aimc.fixed.flange.phi;
//   aimc.airGapS.support.phi = aimc.internalSupport.phi;
//   aimc.inertiaRotor.flange_b.tau + (-aimc.flange.tau) = 0.0;
//   aimc.flange.phi = aimc.inertiaRotor.flange_b.phi;
//   (-aimc.plug_sp.pin[3].i) + aimc.rs.plug_p.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = aimc.rs.plug_p.pin[3].v;
//   (-aimc.plug_sp.pin[2].i) + aimc.rs.plug_p.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = aimc.rs.plug_p.pin[2].v;
//   (-aimc.plug_sp.pin[1].i) + aimc.rs.plug_p.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = aimc.rs.plug_p.pin[1].v;
//   aimc.rs.plug_n.pin[3].i + aimc.lssigma.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_p.pin[3].v = aimc.rs.plug_n.pin[3].v;
//   aimc.rs.plug_n.pin[2].i + aimc.lssigma.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_p.pin[2].v = aimc.rs.plug_n.pin[2].v;
//   aimc.rs.plug_n.pin[1].i + aimc.lssigma.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_p.pin[1].v = aimc.rs.plug_n.pin[1].v;
//   aimc.lssigma.plug_n.pin[3].i + aimc.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_n.pin[3].v = aimc.spacePhasorS.plug_p.pin[3].v;
//   aimc.lssigma.plug_n.pin[2].i + aimc.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_n.pin[2].v = aimc.spacePhasorS.plug_p.pin[2].v;
//   aimc.lssigma.plug_n.pin[1].i + aimc.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_n.pin[1].v = aimc.spacePhasorS.plug_p.pin[1].v;
//   aimc.spacePhasorS.plug_n.pin[3].i + (-aimc.plug_sn.pin[3].i) = 0.0;
//   aimc.plug_sn.pin[3].v = aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.plug_n.pin[2].i + (-aimc.plug_sn.pin[2].i) = 0.0;
//   aimc.plug_sn.pin[2].v = aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.plug_n.pin[1].i + (-aimc.plug_sn.pin[1].i) = 0.0;
//   aimc.plug_sn.pin[1].v = aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.ground.i + aimc.spacePhasorS.zero.i = 0.0;
//   aimc.spacePhasorS.ground.v = aimc.spacePhasorS.zero.v;
//   aimc.airGapS.flange.tau + aimc.inertiaRotor.flange_a.tau = 0.0;
//   aimc.airGapS.flange.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.spacePhasorS.spacePhasor.i_[1] + aimc.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aimc.spacePhasorS.spacePhasor.i_[2] + aimc.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_s.v_[1] = aimc.spacePhasorS.spacePhasor.v_[1];
//   aimc.airGapS.spacePhasor_s.v_[2] = aimc.spacePhasorS.spacePhasor.v_[2];
//   aimc.airGapS.spacePhasor_r.i_[1] + aimc.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   aimc.airGapS.spacePhasor_r.i_[2] + aimc.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_r.v_[1] = aimc.squirrelCageR.spacePhasor_r.v_[1];
//   aimc.airGapS.spacePhasor_r.v_[2] = aimc.squirrelCageR.spacePhasor_r.v_[2];
//   aimc.spacePhasorS.gnd.p.i + (-aimc.spacePhasorS.ground.i) = 0.0;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.ground.v;
//   aimc.lssigma.inductor[3].n.i + (-aimc.lssigma.plug_n.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].n.v = aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.inductor[2].n.i + (-aimc.lssigma.plug_n.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].n.v = aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.inductor[1].n.i + (-aimc.lssigma.plug_n.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].n.v = aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.inductor[3].p.i + (-aimc.lssigma.plug_p.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].p.v = aimc.lssigma.plug_p.pin[3].v;
//   aimc.lssigma.inductor[2].p.i + (-aimc.lssigma.plug_p.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].p.v = aimc.lssigma.plug_p.pin[2].v;
//   aimc.lssigma.inductor[1].p.i + (-aimc.lssigma.plug_p.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].p.v = aimc.lssigma.plug_p.pin[1].v;
//   aimc.rs.resistor[3].n.i + (-aimc.rs.plug_n.pin[3].i) = 0.0;
//   aimc.rs.plug_n.pin[3].v = aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[2].n.i + (-aimc.rs.plug_n.pin[2].i) = 0.0;
//   aimc.rs.plug_n.pin[2].v = aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[1].n.i + (-aimc.rs.plug_n.pin[1].i) = 0.0;
//   aimc.rs.plug_n.pin[1].v = aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[3].p.i + (-aimc.rs.plug_p.pin[3].i) = 0.0;
//   aimc.rs.plug_p.pin[3].v = aimc.rs.resistor[3].p.v;
//   aimc.rs.resistor[2].p.i + (-aimc.rs.plug_p.pin[2].i) = 0.0;
//   aimc.rs.plug_p.pin[2].v = aimc.rs.resistor[2].p.v;
//   aimc.rs.resistor[1].p.i + (-aimc.rs.plug_p.pin[1].i) = 0.0;
//   aimc.rs.plug_p.pin[1].v = aimc.rs.resistor[1].p.v;
//   aimc.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_Inverter;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.AIMC_Inverter completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMC_Inverter has 337 equation(s) and 337 variable(s).
// 245 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// class Modelica.Electrical.Machines.Examples.SMR_Inverter
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real f(quantity = "Frequency", unit = "Hz") = 50.0 "actual frequency";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 1.0 "frequency ramp";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 46.0 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.2 "time of load torque step";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real smr.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real smr.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean smr.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real smr.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = smr.Jr) "stator's moment of inertia";
//   output Real smr.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = smr.flange.phi - smr.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real smr.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(smr.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real smr.tauElectrical(quantity = "Torque", unit = "N.m") = smr.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real smr.tauShaft(quantity = "Torque", unit = "N.m") = -smr.flange.tau "shaft torque";
//   Real smr.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smr.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smr.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smr.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smr.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smr.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smr.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = smr.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) smr.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real smr.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real smr.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real smr.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real smr.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real smr.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer smr.m = 3 "number of phases";
//   parameter Integer smr.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real smr.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real smr.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real smr.Lssigma(quantity = "Inductance", unit = "H", start = 0.1 * 1.0 / smr.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real smr.vs[1](quantity = "ElectricPotential", unit = "V") = smr.plug_sp.pin[1].v - smr.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real smr.vs[2](quantity = "ElectricPotential", unit = "V") = smr.plug_sp.pin[2].v - smr.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real smr.vs[3](quantity = "ElectricPotential", unit = "V") = smr.plug_sp.pin[3].v - smr.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real smr.is[1](quantity = "ElectricCurrent", unit = "A") = smr.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real smr.is[2](quantity = "ElectricCurrent", unit = "A") = smr.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real smr.is[3](quantity = "ElectricCurrent", unit = "A") = smr.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real smr.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smr.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real smr.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = smr.airGapR.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real smr.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = smr.airGapR.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real smr.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smr.airGapR.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real smr.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smr.airGapR.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real smr.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = smr.airGapR.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real smr.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = smr.airGapR.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real smr.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smr.airGapR.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real smr.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smr.airGapR.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer smr.plug_sp.m(min = 1) = 3 "number of phases";
//   Real smr.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smr.plug_sn.m(min = 1) = 3 "number of phases";
//   Real smr.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smr.rs.m(min = 1) = 3 "number of phases";
//   Real smr.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smr.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smr.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smr.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smr.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smr.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smr.rs.plug_p.m(min = 1) = smr.rs.m "number of phases";
//   Real smr.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smr.rs.plug_n.m(min = 1) = smr.rs.m "number of phases";
//   Real smr.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smr.rs.mh(min = 1) = smr.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean smr.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real smr.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smr.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smr.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smr.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = smr.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smr.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = smr.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smr.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = smr.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smr.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smr.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smr.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smr.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smr.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smr.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real smr.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smr.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smr.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smr.rs.resistor[1].useHeatPort = smr.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smr.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real smr.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smr.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smr.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smr.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real smr.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T_ref[1] "Reference temperature";
//   parameter Real smr.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smr.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smr.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smr.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smr.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smr.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smr.rs.resistor[2].useHeatPort = smr.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smr.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real smr.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smr.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smr.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smr.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real smr.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T_ref[2] "Reference temperature";
//   parameter Real smr.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smr.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smr.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smr.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smr.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smr.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smr.rs.resistor[3].useHeatPort = smr.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smr.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real smr.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smr.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smr.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smr.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real smr.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smr.rs.T_ref[3] "Reference temperature";
//   parameter Real smr.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smr.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smr.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer smr.lssigma.m(min = 1) = 3 "number of phases";
//   Real smr.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smr.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smr.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smr.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smr.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smr.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smr.lssigma.plug_p.m(min = 1) = smr.lssigma.m "number of phases";
//   Real smr.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smr.lssigma.plug_n.m(min = 1) = smr.lssigma.m "number of phases";
//   Real smr.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smr.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = smr.Lssigma "Inductance";
//   parameter Real smr.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = smr.Lssigma "Inductance";
//   parameter Real smr.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = smr.Lssigma "Inductance";
//   Real smr.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smr.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smr.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smr.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = smr.lssigma.L[1] "Inductance";
//   Real smr.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smr.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smr.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smr.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = smr.lssigma.L[2] "Inductance";
//   Real smr.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smr.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smr.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smr.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = smr.lssigma.L[3] "Inductance";
//   constant Integer smr.spacePhasorS.m = 3 "number of phases";
//   constant Real smr.spacePhasorS.pi = 3.14159265358979;
//   parameter Real smr.spacePhasorS.turnsRatio = 1.0;
//   Real smr.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smr.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smr.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smr.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smr.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smr.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real smr.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real smr.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real smr.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real smr.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real smr.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real smr.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real smr.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real smr.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real smr.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real smr.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real smr.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real smr.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer smr.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real smr.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smr.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real smr.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smr.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smr.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smr.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer smr.airGapR.m = 3 "number of phases";
//   parameter Integer smr.airGapR.p(min = 1) = smr.p "number of pole pairs";
//   output Real smr.airGapR.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real smr.airGapR.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real smr.airGapR.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smr.airGapR.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smr.airGapR.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smr.airGapR.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smr.airGapR.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smr.airGapR.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smr.airGapR.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real smr.airGapR.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real smr.airGapR.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real smr.airGapR.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real smr.airGapR.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smr.airGapR.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smr.airGapR.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smr.airGapR.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smr.airGapR.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smr.airGapR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real smr.airGapR.Lmd(quantity = "Inductance", unit = "H") = smr.Lmd "main field inductance d-axis";
//   parameter Real smr.airGapR.Lmq(quantity = "Inductance", unit = "H") = smr.Lmq "main field inductance q-axis";
//   Real smr.airGapR.i_mr[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   Real smr.airGapR.i_mr[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   protected parameter Real smr.airGapR.L[1,1](quantity = "Inductance", unit = "H") = smr.airGapR.Lmd "inductance matrix";
//   protected parameter Real smr.airGapR.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smr.airGapR.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smr.airGapR.L[2,2](quantity = "Inductance", unit = "H") = smr.airGapR.Lmq "inductance matrix";
//   parameter Real smr.Lmd(quantity = "Inductance", unit = "H", start = 2.9 * 1.0 / smr.fsNominal / 6.28318530717959) "main field inductance in d-axis";
//   parameter Real smr.Lmq(quantity = "Inductance", unit = "H", start = 0.9 * 1.0 / smr.fsNominal / 6.28318530717959) "main field inductance in q-axis";
//   parameter Boolean smr.useDamperCage(start = true) "enable / disable damper cage";
//   parameter Real smr.Lrsigmad(quantity = "Inductance", unit = "H", start = 0.05 * 1.0 / smr.fsNominal / 6.28318530717959) "damper stray inductance in d-axis";
//   parameter Real smr.Lrsigmaq(quantity = "Inductance", unit = "H") = smr.Lrsigmad "damper stray inductance in q-axis";
//   parameter Real smr.Rrd(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm damper resistance in d-axis";
//   parameter Real smr.Rrq(quantity = "Resistance", unit = "Ohm") = smr.Rrd "warm damper resistance in q-axis";
//   parameter Real smr.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real smr.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smr.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smr.damperCage.Lrsigmad(quantity = "Inductance", unit = "H") = smr.Lrsigmad "stray inductance in d-axis per phase translated to stator";
//   parameter Real smr.damperCage.Lrsigmaq(quantity = "Inductance", unit = "H") = smr.Lrsigmaq "stray inductance in q-axis per phase translated to stator";
//   parameter Real smr.damperCage.Rrd(quantity = "Resistance", unit = "Ohm") = smr.Rrd "warm resistance in d-axis per phase translated to stator";
//   parameter Real smr.damperCage.Rrq(quantity = "Resistance", unit = "Ohm") = smr.Rrq "warm resistance in q-axis per phase translated to stator";
//   Real smr.damperCage.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.damperCage.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smr.damperCage.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smr.damperCage.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   constant Integer rotorDisplacementAngle.m = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.p(min = 1) = smr.p "number of pole pairs";
//   parameter Boolean rotorDisplacementAngle.useSupport = false "use support or fixed housing";
//   output Real rotorDisplacementAngle.rotorDisplacementAngle;
//   parameter Integer rotorDisplacementAngle.plug_p.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.plug_n.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_p.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_n.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nin = 3 "Number of inputs";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nout = 2 "Number of outputs";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[2] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[3] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[2] "Connector of Real output signals";
//   constant Integer rotorDisplacementAngle.ToSpacePhasorVS.m = 3 "number of phases";
//   constant Real rotorDisplacementAngle.ToSpacePhasorVS.pi = 3.14159265358979;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,2] = -0.866025403784438;
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.zero;
//   Real rotorDisplacementAngle.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real rotorDisplacementAngle.relativeAngleSensor.phi_rel "Relative angle between two flanges (= flange_b.phi - flange_a.phi)";
//   output Real rotorDisplacementAngle.constant_.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.constant_.k(start = 1.0) = 1.5707963267949 "Constant output value";
//   input Real rotorDisplacementAngle.add.u1 "Connector of Real input signal 1";
//   input Real rotorDisplacementAngle.add.u2 "Connector of Real input signal 2";
//   output Real rotorDisplacementAngle.add.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.add.k1 = Real(rotorDisplacementAngle.p) "Gain of upper input";
//   parameter Real rotorDisplacementAngle.add.k2 = 1.0 "Gain of lower input";
//   parameter Integer rotorDisplacementAngle.rotatorVS2R.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[2] "Connector of Real output signals";
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] = -sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] = sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   input Real rotorDisplacementAngle.rotatorVS2R.angle;
//   parameter Integer rotorDisplacementAngle.ToPolarVSR.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[2] "Connector of Real output signals";
//   constant Real rotorDisplacementAngle.ToPolarVSR.small = 1e-60;
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n1 = 1 "dimension of output signal connector 1";
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n2 = 1 "dimension of output signal connector 2";
//   input Real rotorDisplacementAngle.deMultiplex2.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.deMultiplex2.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.deMultiplex2.y1[1] "Connector of Real output signals 1";
//   output Real rotorDisplacementAngle.deMultiplex2.y2[1] "Connector of Real output signals 2";
//   parameter Real rotorDisplacementAngle.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real rotorDisplacementAngle.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real ramp.y "Connector of Real output signal";
//   parameter Real ramp.height = f "Height of ramps";
//   parameter Real ramp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = tRamp "Durations of ramp";
//   parameter Real ramp.offset = 0.0 "Offset of output signal";
//   parameter Real ramp.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
//   parameter Integer vfController.nout = vfController.m "Number of outputs";
//   input Real vfController.u "Connector of Real input signal";
//   output Real vfController.y[1] "Connector of Real output signals";
//   output Real vfController.y[2] "Connector of Real output signals";
//   output Real vfController.y[3] "Connector of Real output signals";
//   constant Real vfController.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Integer vfController.m = 3 "number of phases";
//   parameter Real vfController.VNominal(quantity = "ElectricPotential", unit = "V") = VNominal "nominal RMS voltage per phase";
//   parameter Real vfController.fNominal(quantity = "Frequency", unit = "Hz") = fNominal "nominal frequency";
//   parameter Real vfController.BasePhase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "common phase shift";
//   output Real vfController.x(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true) "integrator state";
//   output Real vfController.amplitude(quantity = "ElectricPotential", unit = "V");
//   parameter Integer signalVoltage.m(min = 1) = 3 "number of phases";
//   Real signalVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real signalVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real signalVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer signalVoltage.plug_p.m(min = 1) = signalVoltage.m "number of phases";
//   Real signalVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer signalVoltage.plug_n.m(min = 1) = signalVoltage.m "number of phases";
//   Real signalVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.v[1] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real signalVoltage.v[2] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real signalVoltage.v[3] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[1].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real signalVoltage.signalVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[2].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real signalVoltage.signalVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[3].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean loadTorqueStep.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real loadTorqueStep.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorqueStep.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real loadTorqueStep.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real loadTorqueStep.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real loadTorqueStep.stepTorque(quantity = "Torque", unit = "N.m", start = 1.0) = -TLoad "Height of torque step (if negative, torque is acting as load)";
//   parameter Real loadTorqueStep.offsetTorque(quantity = "Torque", unit = "N.m", start = 0.0) "Offset of torque";
//   parameter Real loadTorqueStep.startTime(quantity = "Time", unit = "s") = tStep "Torque = offset for time < startTime";
//   Real loadTorqueStep.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.star.m(min = 1) = 3 "number of phases";
//   parameter Integer terminalBox.star.plug_p.m(min = 1) = terminalBox.star.m "number of phases";
//   Real terminalBox.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   smr.inertiaRotor.phi = smr.inertiaRotor.flange_a.phi;
//   smr.inertiaRotor.phi = smr.inertiaRotor.flange_b.phi;
//   smr.inertiaRotor.w = der(smr.inertiaRotor.phi);
//   smr.inertiaRotor.a = der(smr.inertiaRotor.w);
//   smr.inertiaRotor.J * smr.inertiaRotor.a = smr.inertiaRotor.flange_a.tau + smr.inertiaRotor.flange_b.tau;
//   assert(1.0 + smr.rs.resistor[1].alpha * (smr.rs.resistor[1].T_heatPort - smr.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smr.rs.resistor[1].R_actual = smr.rs.resistor[1].R * (1.0 + smr.rs.resistor[1].alpha * (smr.rs.resistor[1].T_heatPort - smr.rs.resistor[1].T_ref));
//   smr.rs.resistor[1].v = smr.rs.resistor[1].R_actual * smr.rs.resistor[1].i;
//   smr.rs.resistor[1].LossPower = smr.rs.resistor[1].v * smr.rs.resistor[1].i;
//   smr.rs.resistor[1].i = smr.rs.resistor[1].p.i;
//   0.0 = smr.rs.resistor[1].p.i + smr.rs.resistor[1].n.i;
//   smr.rs.resistor[1].v = smr.rs.resistor[1].p.v - smr.rs.resistor[1].n.v;
//   smr.rs.resistor[1].T_heatPort = smr.rs.resistor[1].T;
//   assert(1.0 + smr.rs.resistor[2].alpha * (smr.rs.resistor[2].T_heatPort - smr.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smr.rs.resistor[2].R_actual = smr.rs.resistor[2].R * (1.0 + smr.rs.resistor[2].alpha * (smr.rs.resistor[2].T_heatPort - smr.rs.resistor[2].T_ref));
//   smr.rs.resistor[2].v = smr.rs.resistor[2].R_actual * smr.rs.resistor[2].i;
//   smr.rs.resistor[2].LossPower = smr.rs.resistor[2].v * smr.rs.resistor[2].i;
//   smr.rs.resistor[2].i = smr.rs.resistor[2].p.i;
//   0.0 = smr.rs.resistor[2].p.i + smr.rs.resistor[2].n.i;
//   smr.rs.resistor[2].v = smr.rs.resistor[2].p.v - smr.rs.resistor[2].n.v;
//   smr.rs.resistor[2].T_heatPort = smr.rs.resistor[2].T;
//   assert(1.0 + smr.rs.resistor[3].alpha * (smr.rs.resistor[3].T_heatPort - smr.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smr.rs.resistor[3].R_actual = smr.rs.resistor[3].R * (1.0 + smr.rs.resistor[3].alpha * (smr.rs.resistor[3].T_heatPort - smr.rs.resistor[3].T_ref));
//   smr.rs.resistor[3].v = smr.rs.resistor[3].R_actual * smr.rs.resistor[3].i;
//   smr.rs.resistor[3].LossPower = smr.rs.resistor[3].v * smr.rs.resistor[3].i;
//   smr.rs.resistor[3].i = smr.rs.resistor[3].p.i;
//   0.0 = smr.rs.resistor[3].p.i + smr.rs.resistor[3].n.i;
//   smr.rs.resistor[3].v = smr.rs.resistor[3].p.v - smr.rs.resistor[3].n.v;
//   smr.rs.resistor[3].T_heatPort = smr.rs.resistor[3].T;
//   smr.rs.v[1] = smr.rs.plug_p.pin[1].v - smr.rs.plug_n.pin[1].v;
//   smr.rs.v[2] = smr.rs.plug_p.pin[2].v - smr.rs.plug_n.pin[2].v;
//   smr.rs.v[3] = smr.rs.plug_p.pin[3].v - smr.rs.plug_n.pin[3].v;
//   smr.rs.i[1] = smr.rs.plug_p.pin[1].i;
//   smr.rs.i[2] = smr.rs.plug_p.pin[2].i;
//   smr.rs.i[3] = smr.rs.plug_p.pin[3].i;
//   smr.lssigma.inductor[1].L * der(smr.lssigma.inductor[1].i) = smr.lssigma.inductor[1].v;
//   smr.lssigma.inductor[1].v = smr.lssigma.inductor[1].p.v - smr.lssigma.inductor[1].n.v;
//   0.0 = smr.lssigma.inductor[1].p.i + smr.lssigma.inductor[1].n.i;
//   smr.lssigma.inductor[1].i = smr.lssigma.inductor[1].p.i;
//   smr.lssigma.inductor[2].L * der(smr.lssigma.inductor[2].i) = smr.lssigma.inductor[2].v;
//   smr.lssigma.inductor[2].v = smr.lssigma.inductor[2].p.v - smr.lssigma.inductor[2].n.v;
//   0.0 = smr.lssigma.inductor[2].p.i + smr.lssigma.inductor[2].n.i;
//   smr.lssigma.inductor[2].i = smr.lssigma.inductor[2].p.i;
//   smr.lssigma.inductor[3].L * der(smr.lssigma.inductor[3].i) = smr.lssigma.inductor[3].v;
//   smr.lssigma.inductor[3].v = smr.lssigma.inductor[3].p.v - smr.lssigma.inductor[3].n.v;
//   0.0 = smr.lssigma.inductor[3].p.i + smr.lssigma.inductor[3].n.i;
//   smr.lssigma.inductor[3].i = smr.lssigma.inductor[3].p.i;
//   smr.lssigma.v[1] = smr.lssigma.plug_p.pin[1].v - smr.lssigma.plug_n.pin[1].v;
//   smr.lssigma.v[2] = smr.lssigma.plug_p.pin[2].v - smr.lssigma.plug_n.pin[2].v;
//   smr.lssigma.v[3] = smr.lssigma.plug_p.pin[3].v - smr.lssigma.plug_n.pin[3].v;
//   smr.lssigma.i[1] = smr.lssigma.plug_p.pin[1].i;
//   smr.lssigma.i[2] = smr.lssigma.plug_p.pin[2].i;
//   smr.lssigma.i[3] = smr.lssigma.plug_p.pin[3].i;
//   smr.spacePhasorS.gnd.p.v = 0.0;
//   smr.spacePhasorS.v[1] / smr.spacePhasorS.turnsRatio = smr.spacePhasorS.plug_p.pin[1].v - smr.spacePhasorS.plug_n.pin[1].v;
//   smr.spacePhasorS.v[2] / smr.spacePhasorS.turnsRatio = smr.spacePhasorS.plug_p.pin[2].v - smr.spacePhasorS.plug_n.pin[2].v;
//   smr.spacePhasorS.v[3] / smr.spacePhasorS.turnsRatio = smr.spacePhasorS.plug_p.pin[3].v - smr.spacePhasorS.plug_n.pin[3].v;
//   smr.spacePhasorS.turnsRatio * smr.spacePhasorS.i[1] = smr.spacePhasorS.plug_p.pin[1].i;
//   smr.spacePhasorS.turnsRatio * smr.spacePhasorS.i[2] = smr.spacePhasorS.plug_p.pin[2].i;
//   smr.spacePhasorS.turnsRatio * smr.spacePhasorS.i[3] = smr.spacePhasorS.plug_p.pin[3].i;
//   smr.spacePhasorS.turnsRatio * smr.spacePhasorS.i[1] = -smr.spacePhasorS.plug_n.pin[1].i;
//   smr.spacePhasorS.turnsRatio * smr.spacePhasorS.i[2] = -smr.spacePhasorS.plug_n.pin[2].i;
//   smr.spacePhasorS.turnsRatio * smr.spacePhasorS.i[3] = -smr.spacePhasorS.plug_n.pin[3].i;
//   smr.spacePhasorS.zero.v = 0.333333333333333 * (smr.spacePhasorS.v[1] + (smr.spacePhasorS.v[2] + smr.spacePhasorS.v[3]));
//   smr.spacePhasorS.spacePhasor.v_[1] = smr.spacePhasorS.TransformationMatrix[1,1] * smr.spacePhasorS.v[1] + (smr.spacePhasorS.TransformationMatrix[1,2] * smr.spacePhasorS.v[2] + smr.spacePhasorS.TransformationMatrix[1,3] * smr.spacePhasorS.v[3]);
//   smr.spacePhasorS.spacePhasor.v_[2] = smr.spacePhasorS.TransformationMatrix[2,1] * smr.spacePhasorS.v[1] + (smr.spacePhasorS.TransformationMatrix[2,2] * smr.spacePhasorS.v[2] + smr.spacePhasorS.TransformationMatrix[2,3] * smr.spacePhasorS.v[3]);
//   -smr.spacePhasorS.zero.i = 0.333333333333333 * (smr.spacePhasorS.i[1] + (smr.spacePhasorS.i[2] + smr.spacePhasorS.i[3]));
//   -smr.spacePhasorS.spacePhasor.i_[1] = smr.spacePhasorS.TransformationMatrix[1,1] * smr.spacePhasorS.i[1] + (smr.spacePhasorS.TransformationMatrix[1,2] * smr.spacePhasorS.i[2] + smr.spacePhasorS.TransformationMatrix[1,3] * smr.spacePhasorS.i[3]);
//   -smr.spacePhasorS.spacePhasor.i_[2] = smr.spacePhasorS.TransformationMatrix[2,1] * smr.spacePhasorS.i[1] + (smr.spacePhasorS.TransformationMatrix[2,2] * smr.spacePhasorS.i[2] + smr.spacePhasorS.TransformationMatrix[2,3] * smr.spacePhasorS.i[3]);
//   smr.airGapR.i_mr[1] = smr.airGapR.i_sr[1] + smr.airGapR.i_rr[1];
//   smr.airGapR.i_mr[2] = smr.airGapR.i_sr[2] + smr.airGapR.i_rr[2];
//   smr.airGapR.psi_mr[1] = smr.airGapR.L[1,1] * smr.airGapR.i_mr[1] + smr.airGapR.L[1,2] * smr.airGapR.i_mr[2];
//   smr.airGapR.psi_mr[2] = smr.airGapR.L[2,1] * smr.airGapR.i_mr[1] + smr.airGapR.L[2,2] * smr.airGapR.i_mr[2];
//   smr.airGapR.psi_ms[1] = smr.airGapR.RotationMatrix[1,1] * smr.airGapR.psi_mr[1] + smr.airGapR.RotationMatrix[1,2] * smr.airGapR.psi_mr[2];
//   smr.airGapR.psi_ms[2] = smr.airGapR.RotationMatrix[2,1] * smr.airGapR.psi_mr[1] + smr.airGapR.RotationMatrix[2,2] * smr.airGapR.psi_mr[2];
//   smr.airGapR.gamma = Real(smr.airGapR.p) * (smr.airGapR.flange.phi - smr.airGapR.support.phi);
//   smr.airGapR.RotationMatrix[1,1] = cos(smr.airGapR.gamma);
//   smr.airGapR.RotationMatrix[1,2] = -sin(smr.airGapR.gamma);
//   smr.airGapR.RotationMatrix[2,1] = sin(smr.airGapR.gamma);
//   smr.airGapR.RotationMatrix[2,2] = cos(smr.airGapR.gamma);
//   smr.airGapR.i_ss[1] = smr.airGapR.spacePhasor_s.i_[1];
//   smr.airGapR.i_ss[2] = smr.airGapR.spacePhasor_s.i_[2];
//   smr.airGapR.i_ss[1] = smr.airGapR.RotationMatrix[1,1] * smr.airGapR.i_sr[1] + smr.airGapR.RotationMatrix[1,2] * smr.airGapR.i_sr[2];
//   smr.airGapR.i_ss[2] = smr.airGapR.RotationMatrix[2,1] * smr.airGapR.i_sr[1] + smr.airGapR.RotationMatrix[2,2] * smr.airGapR.i_sr[2];
//   smr.airGapR.i_rr[1] = smr.airGapR.spacePhasor_r.i_[1];
//   smr.airGapR.i_rr[2] = smr.airGapR.spacePhasor_r.i_[2];
//   smr.airGapR.i_rs[1] = smr.airGapR.RotationMatrix[1,1] * smr.airGapR.i_rr[1] + smr.airGapR.RotationMatrix[1,2] * smr.airGapR.i_rr[2];
//   smr.airGapR.i_rs[2] = smr.airGapR.RotationMatrix[2,1] * smr.airGapR.i_rr[1] + smr.airGapR.RotationMatrix[2,2] * smr.airGapR.i_rr[2];
//   smr.airGapR.spacePhasor_s.v_[1] = der(smr.airGapR.psi_ms[1]);
//   smr.airGapR.spacePhasor_s.v_[2] = der(smr.airGapR.psi_ms[2]);
//   smr.airGapR.spacePhasor_r.v_[1] = der(smr.airGapR.psi_mr[1]);
//   smr.airGapR.spacePhasor_r.v_[2] = der(smr.airGapR.psi_mr[2]);
//   smr.airGapR.tauElectrical = Real(smr.airGapR.m) * (Real(smr.airGapR.p) * (smr.airGapR.spacePhasor_s.i_[2] * smr.airGapR.psi_ms[1] - smr.airGapR.spacePhasor_s.i_[1] * smr.airGapR.psi_ms[2]) / 2.0);
//   smr.airGapR.flange.tau = -smr.airGapR.tauElectrical;
//   smr.airGapR.support.tau = smr.airGapR.tauElectrical;
//   smr.fixed.flange.phi = smr.fixed.phi0;
//   smr.damperCage.spacePhasor_r.v_[1] = smr.damperCage.Rrd * smr.damperCage.spacePhasor_r.i_[1] + smr.damperCage.Lrsigmad * der(smr.damperCage.spacePhasor_r.i_[1]);
//   smr.damperCage.spacePhasor_r.v_[2] = smr.damperCage.Rrq * smr.damperCage.spacePhasor_r.i_[2] + smr.damperCage.Lrsigmaq * der(smr.damperCage.spacePhasor_r.i_[2]);
//   assert(smr.spacePhasorS.plug_n.m == smr.plug_sn.m,"automatically generated from connect");
//   assert(smr.lssigma.plug_n.m == smr.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(smr.rs.plug_n.m == smr.lssigma.plug_p.m,"automatically generated from connect");
//   assert(smr.plug_sp.m == smr.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.ToSpacePhasorVS.zero = 0.333333333333333 * (rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.u[3]));
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.relativeAngleSensor.phi_rel = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi - rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + rotorDisplacementAngle.relativeAngleSensor.flange_b.tau;
//   rotorDisplacementAngle.constant_.y = rotorDisplacementAngle.constant_.k;
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.add.k1 * rotorDisplacementAngle.add.u1 + rotorDisplacementAngle.add.k2 * rotorDisplacementAngle.add.u2;
//   rotorDisplacementAngle.rotatorVS2R.y[1] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.rotatorVS2R.y[2] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.ToPolarVSR.y[1] = sqrt(rotorDisplacementAngle.ToPolarVSR.u[1] ^ 2.0 + rotorDisplacementAngle.ToPolarVSR.u[2] ^ 2.0);
//   rotorDisplacementAngle.ToPolarVSR.y[2] = if noEvent(rotorDisplacementAngle.ToPolarVSR.y[1] <= 1e-60) then 0.0 else atan2(rotorDisplacementAngle.ToPolarVSR.u[2],rotorDisplacementAngle.ToPolarVSR.u[1]);
//   rotorDisplacementAngle.deMultiplex2.u[1] = rotorDisplacementAngle.deMultiplex2.y1[1];
//   rotorDisplacementAngle.deMultiplex2.u[2] = rotorDisplacementAngle.deMultiplex2.y2[1];
//   rotorDisplacementAngle.fixed.flange.phi = rotorDisplacementAngle.fixed.phi0;
//   assert(rotorDisplacementAngle.plug_p.m == rotorDisplacementAngle.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_n.m == rotorDisplacementAngle.VoltageSensor1.plug_n.m,"automatically generated from connect");
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   vfController.amplitude = 1.4142135623731 * (vfController.VNominal * (if abs(vfController.u) < vfController.fNominal then abs(vfController.u) / vfController.fNominal else 1.0));
//   der(vfController.x) = 6.28318530717959 * vfController.u;
//   vfController.y[1] = vfController.amplitude * sin(vfController.x + vfController.BasePhase);
//   vfController.y[2] = vfController.amplitude * sin(vfController.x + vfController.BasePhase - 6.28318530717959 / Real(vfController.m));
//   vfController.y[3] = vfController.amplitude * sin(vfController.x + vfController.BasePhase - 12.5663706143592 / Real(vfController.m));
//   signalVoltage.signalVoltage[1].v = signalVoltage.signalVoltage[1].p.v - signalVoltage.signalVoltage[1].n.v;
//   0.0 = signalVoltage.signalVoltage[1].p.i + signalVoltage.signalVoltage[1].n.i;
//   signalVoltage.signalVoltage[1].i = signalVoltage.signalVoltage[1].p.i;
//   signalVoltage.signalVoltage[2].v = signalVoltage.signalVoltage[2].p.v - signalVoltage.signalVoltage[2].n.v;
//   0.0 = signalVoltage.signalVoltage[2].p.i + signalVoltage.signalVoltage[2].n.i;
//   signalVoltage.signalVoltage[2].i = signalVoltage.signalVoltage[2].p.i;
//   signalVoltage.signalVoltage[3].v = signalVoltage.signalVoltage[3].p.v - signalVoltage.signalVoltage[3].n.v;
//   0.0 = signalVoltage.signalVoltage[3].p.i + signalVoltage.signalVoltage[3].n.i;
//   signalVoltage.signalVoltage[3].i = signalVoltage.signalVoltage[3].p.i;
//   signalVoltage.i[1] = signalVoltage.plug_p.pin[1].i;
//   signalVoltage.i[2] = signalVoltage.plug_p.pin[2].i;
//   signalVoltage.i[3] = signalVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   loadTorqueStep.tau = -loadTorqueStep.flange.tau;
//   loadTorqueStep.tau = loadTorqueStep.offsetTorque + (if time < loadTorqueStep.startTime then 0.0 else loadTorqueStep.stepTorque);
//   loadTorqueStep.phi = loadTorqueStep.flange.phi - loadTorqueStep.phi_support;
//   loadTorqueStep.phi_support = 0.0;
//   assert(terminalBox.plug_sn.m == terminalBox.star.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   assert(signalVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.plug_p.m == signalVoltage.plug_p.m,"automatically generated from connect");
//   assert(smr.plug_sn.m == rotorDisplacementAngle.plug_n.m,"automatically generated from connect");
//   assert(smr.plug_sp.m == rotorDisplacementAngle.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == smr.plug_sp.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == smr.plug_sn.m,"automatically generated from connect");
//   smr.flange.tau + (rotorDisplacementAngle.flange.tau + loadInertia.flange_a.tau) = 0.0;
//   loadInertia.flange_a.phi = rotorDisplacementAngle.flange.phi;
//   loadInertia.flange_a.phi = smr.flange.phi;
//   terminalBox.plug_sn.pin[3].i + (smr.plug_sn.pin[3].i + rotorDisplacementAngle.plug_n.pin[3].i) = 0.0;
//   rotorDisplacementAngle.plug_n.pin[3].v = smr.plug_sn.pin[3].v;
//   rotorDisplacementAngle.plug_n.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   terminalBox.plug_sn.pin[2].i + (smr.plug_sn.pin[2].i + rotorDisplacementAngle.plug_n.pin[2].i) = 0.0;
//   rotorDisplacementAngle.plug_n.pin[2].v = smr.plug_sn.pin[2].v;
//   rotorDisplacementAngle.plug_n.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   terminalBox.plug_sn.pin[1].i + (smr.plug_sn.pin[1].i + rotorDisplacementAngle.plug_n.pin[1].i) = 0.0;
//   rotorDisplacementAngle.plug_n.pin[1].v = smr.plug_sn.pin[1].v;
//   rotorDisplacementAngle.plug_n.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   terminalBox.plug_sp.pin[3].i + (smr.plug_sp.pin[3].i + rotorDisplacementAngle.plug_p.pin[3].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[3].v = smr.plug_sp.pin[3].v;
//   rotorDisplacementAngle.plug_p.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + (smr.plug_sp.pin[2].i + rotorDisplacementAngle.plug_p.pin[2].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[2].v = smr.plug_sp.pin[2].v;
//   rotorDisplacementAngle.plug_p.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + (smr.plug_sp.pin[1].i + rotorDisplacementAngle.plug_p.pin[1].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[1].v = smr.plug_sp.pin[1].v;
//   rotorDisplacementAngle.plug_p.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = terminalBox.plugSupply.pin[3].v;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = terminalBox.plugSupply.pin[2].v;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = terminalBox.plugSupply.pin[1].v;
//   currentQuasiRMSSensor.plug_p.pin[3].i + signalVoltage.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = signalVoltage.plug_p.pin[3].v;
//   currentQuasiRMSSensor.plug_p.pin[2].i + signalVoltage.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = signalVoltage.plug_p.pin[2].v;
//   currentQuasiRMSSensor.plug_p.pin[1].i + signalVoltage.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = signalVoltage.plug_p.pin[1].v;
//   loadInertia.flange_b.tau + loadTorqueStep.flange.tau = 0.0;
//   loadInertia.flange_b.phi = loadTorqueStep.flange.phi;
//   signalVoltage.v[1] = vfController.y[1];
//   signalVoltage.v[2] = vfController.y[2];
//   signalVoltage.v[3] = vfController.y[3];
//   ramp.y = vfController.u;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   signalVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   signalVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   signalVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   signalVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   signalVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   signalVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.i + (-terminalBox.starpoint.i) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.starpoint.v;
//   (-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i) = 0.0;
//   terminalBox.plugSupply.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   (-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i) = 0.0;
//   terminalBox.plugSupply.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   (-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i) = 0.0;
//   terminalBox.plugSupply.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.star.plug_p.pin[3].i = 0.0;
//   terminalBox.plug_sn.pin[3].v = terminalBox.star.plug_p.pin[3].v;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.star.plug_p.pin[2].i = 0.0;
//   terminalBox.plug_sn.pin[2].v = terminalBox.star.plug_p.pin[2].v;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.star.plug_p.pin[1].i = 0.0;
//   terminalBox.plug_sn.pin[1].v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.starpoint.i = 0.0;
//   (-terminalBox.star.plug_p.pin[3].i) + ((-terminalBox.star.plug_p.pin[2].i) + ((-terminalBox.star.plug_p.pin[1].i) + (-terminalBox.star.pin_n.i))) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[2].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[3].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   signalVoltage.signalVoltage[1].v = signalVoltage.v[1];
//   signalVoltage.signalVoltage[2].v = signalVoltage.v[2];
//   signalVoltage.signalVoltage[3].v = signalVoltage.v[3];
//   signalVoltage.signalVoltage[3].n.i + (-signalVoltage.plug_n.pin[3].i) = 0.0;
//   signalVoltage.plug_n.pin[3].v = signalVoltage.signalVoltage[3].n.v;
//   signalVoltage.signalVoltage[2].n.i + (-signalVoltage.plug_n.pin[2].i) = 0.0;
//   signalVoltage.plug_n.pin[2].v = signalVoltage.signalVoltage[2].n.v;
//   signalVoltage.signalVoltage[1].n.i + (-signalVoltage.plug_n.pin[1].i) = 0.0;
//   signalVoltage.plug_n.pin[1].v = signalVoltage.signalVoltage[1].n.v;
//   signalVoltage.signalVoltage[3].p.i + (-signalVoltage.plug_p.pin[3].i) = 0.0;
//   signalVoltage.plug_p.pin[3].v = signalVoltage.signalVoltage[3].p.v;
//   signalVoltage.signalVoltage[2].p.i + (-signalVoltage.plug_p.pin[2].i) = 0.0;
//   signalVoltage.plug_p.pin[2].v = signalVoltage.signalVoltage[2].p.v;
//   signalVoltage.signalVoltage[1].p.i + (-signalVoltage.plug_p.pin[1].i) = 0.0;
//   signalVoltage.plug_p.pin[1].v = signalVoltage.signalVoltage[1].p.v;
//   rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + rotorDisplacementAngle.fixed.flange.tau = 0.0;
//   rotorDisplacementAngle.fixed.flange.phi = rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   rotorDisplacementAngle.relativeAngleSensor.flange_b.tau + (-rotorDisplacementAngle.flange.tau) = 0.0;
//   rotorDisplacementAngle.flange.phi = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi;
//   rotorDisplacementAngle.add.u1 = rotorDisplacementAngle.relativeAngleSensor.phi_rel;
//   rotorDisplacementAngle.deMultiplex2.y2[1] = rotorDisplacementAngle.rotorDisplacementAngle;
//   rotorDisplacementAngle.ToSpacePhasorVS.u[1] = rotorDisplacementAngle.VoltageSensor1.v[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[2] = rotorDisplacementAngle.VoltageSensor1.v[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[3] = rotorDisplacementAngle.VoltageSensor1.v[3];
//   (-rotorDisplacementAngle.plug_n.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v = rotorDisplacementAngle.plug_n.pin[3].v;
//   (-rotorDisplacementAngle.plug_n.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v = rotorDisplacementAngle.plug_n.pin[2].v;
//   (-rotorDisplacementAngle.plug_n.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v = rotorDisplacementAngle.plug_n.pin[1].v;
//   (-rotorDisplacementAngle.plug_p.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v = rotorDisplacementAngle.plug_p.pin[3].v;
//   (-rotorDisplacementAngle.plug_p.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v = rotorDisplacementAngle.plug_p.pin[2].v;
//   (-rotorDisplacementAngle.plug_p.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v = rotorDisplacementAngle.plug_p.pin[1].v;
//   rotorDisplacementAngle.ToPolarVSR.y[1] = rotorDisplacementAngle.deMultiplex2.u[1];
//   rotorDisplacementAngle.ToPolarVSR.y[2] = rotorDisplacementAngle.deMultiplex2.u[2];
//   rotorDisplacementAngle.ToPolarVSR.u[1] = rotorDisplacementAngle.rotatorVS2R.y[1];
//   rotorDisplacementAngle.ToPolarVSR.u[2] = rotorDisplacementAngle.rotatorVS2R.y[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.rotatorVS2R.u[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.rotatorVS2R.angle;
//   rotorDisplacementAngle.add.u2 = rotorDisplacementAngle.constant_.y;
//   rotorDisplacementAngle.VoltageSensor1.v[1] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v;
//   rotorDisplacementAngle.VoltageSensor1.v[2] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v;
//   rotorDisplacementAngle.VoltageSensor1.v[3] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   smr.airGapR.support.tau + ((-smr.internalSupport.tau) + smr.fixed.flange.tau) = 0.0;
//   smr.airGapR.support.phi = smr.fixed.flange.phi;
//   smr.airGapR.support.phi = smr.internalSupport.phi;
//   smr.inertiaRotor.flange_b.tau + (-smr.flange.tau) = 0.0;
//   smr.flange.phi = smr.inertiaRotor.flange_b.phi;
//   (-smr.plug_sp.pin[3].i) + smr.rs.plug_p.pin[3].i = 0.0;
//   smr.plug_sp.pin[3].v = smr.rs.plug_p.pin[3].v;
//   (-smr.plug_sp.pin[2].i) + smr.rs.plug_p.pin[2].i = 0.0;
//   smr.plug_sp.pin[2].v = smr.rs.plug_p.pin[2].v;
//   (-smr.plug_sp.pin[1].i) + smr.rs.plug_p.pin[1].i = 0.0;
//   smr.plug_sp.pin[1].v = smr.rs.plug_p.pin[1].v;
//   smr.rs.plug_n.pin[3].i + smr.lssigma.plug_p.pin[3].i = 0.0;
//   smr.lssigma.plug_p.pin[3].v = smr.rs.plug_n.pin[3].v;
//   smr.rs.plug_n.pin[2].i + smr.lssigma.plug_p.pin[2].i = 0.0;
//   smr.lssigma.plug_p.pin[2].v = smr.rs.plug_n.pin[2].v;
//   smr.rs.plug_n.pin[1].i + smr.lssigma.plug_p.pin[1].i = 0.0;
//   smr.lssigma.plug_p.pin[1].v = smr.rs.plug_n.pin[1].v;
//   smr.lssigma.plug_n.pin[3].i + smr.spacePhasorS.plug_p.pin[3].i = 0.0;
//   smr.lssigma.plug_n.pin[3].v = smr.spacePhasorS.plug_p.pin[3].v;
//   smr.lssigma.plug_n.pin[2].i + smr.spacePhasorS.plug_p.pin[2].i = 0.0;
//   smr.lssigma.plug_n.pin[2].v = smr.spacePhasorS.plug_p.pin[2].v;
//   smr.lssigma.plug_n.pin[1].i + smr.spacePhasorS.plug_p.pin[1].i = 0.0;
//   smr.lssigma.plug_n.pin[1].v = smr.spacePhasorS.plug_p.pin[1].v;
//   smr.spacePhasorS.plug_n.pin[3].i + (-smr.plug_sn.pin[3].i) = 0.0;
//   smr.plug_sn.pin[3].v = smr.spacePhasorS.plug_n.pin[3].v;
//   smr.spacePhasorS.plug_n.pin[2].i + (-smr.plug_sn.pin[2].i) = 0.0;
//   smr.plug_sn.pin[2].v = smr.spacePhasorS.plug_n.pin[2].v;
//   smr.spacePhasorS.plug_n.pin[1].i + (-smr.plug_sn.pin[1].i) = 0.0;
//   smr.plug_sn.pin[1].v = smr.spacePhasorS.plug_n.pin[1].v;
//   smr.spacePhasorS.ground.i + smr.spacePhasorS.zero.i = 0.0;
//   smr.spacePhasorS.ground.v = smr.spacePhasorS.zero.v;
//   smr.airGapR.flange.tau + smr.inertiaRotor.flange_a.tau = 0.0;
//   smr.airGapR.flange.phi = smr.inertiaRotor.flange_a.phi;
//   smr.spacePhasorS.spacePhasor.i_[1] + smr.airGapR.spacePhasor_s.i_[1] = 0.0;
//   smr.spacePhasorS.spacePhasor.i_[2] + smr.airGapR.spacePhasor_s.i_[2] = 0.0;
//   smr.airGapR.spacePhasor_s.v_[1] = smr.spacePhasorS.spacePhasor.v_[1];
//   smr.airGapR.spacePhasor_s.v_[2] = smr.spacePhasorS.spacePhasor.v_[2];
//   smr.airGapR.spacePhasor_r.i_[1] + smr.damperCage.spacePhasor_r.i_[1] = 0.0;
//   smr.airGapR.spacePhasor_r.i_[2] + smr.damperCage.spacePhasor_r.i_[2] = 0.0;
//   smr.airGapR.spacePhasor_r.v_[1] = smr.damperCage.spacePhasor_r.v_[1];
//   smr.airGapR.spacePhasor_r.v_[2] = smr.damperCage.spacePhasor_r.v_[2];
//   smr.spacePhasorS.gnd.p.i + (-smr.spacePhasorS.ground.i) = 0.0;
//   smr.spacePhasorS.gnd.p.v = smr.spacePhasorS.ground.v;
//   smr.lssigma.inductor[3].n.i + (-smr.lssigma.plug_n.pin[3].i) = 0.0;
//   smr.lssigma.inductor[3].n.v = smr.lssigma.plug_n.pin[3].v;
//   smr.lssigma.inductor[2].n.i + (-smr.lssigma.plug_n.pin[2].i) = 0.0;
//   smr.lssigma.inductor[2].n.v = smr.lssigma.plug_n.pin[2].v;
//   smr.lssigma.inductor[1].n.i + (-smr.lssigma.plug_n.pin[1].i) = 0.0;
//   smr.lssigma.inductor[1].n.v = smr.lssigma.plug_n.pin[1].v;
//   smr.lssigma.inductor[3].p.i + (-smr.lssigma.plug_p.pin[3].i) = 0.0;
//   smr.lssigma.inductor[3].p.v = smr.lssigma.plug_p.pin[3].v;
//   smr.lssigma.inductor[2].p.i + (-smr.lssigma.plug_p.pin[2].i) = 0.0;
//   smr.lssigma.inductor[2].p.v = smr.lssigma.plug_p.pin[2].v;
//   smr.lssigma.inductor[1].p.i + (-smr.lssigma.plug_p.pin[1].i) = 0.0;
//   smr.lssigma.inductor[1].p.v = smr.lssigma.plug_p.pin[1].v;
//   smr.rs.resistor[3].n.i + (-smr.rs.plug_n.pin[3].i) = 0.0;
//   smr.rs.plug_n.pin[3].v = smr.rs.resistor[3].n.v;
//   smr.rs.resistor[2].n.i + (-smr.rs.plug_n.pin[2].i) = 0.0;
//   smr.rs.plug_n.pin[2].v = smr.rs.resistor[2].n.v;
//   smr.rs.resistor[1].n.i + (-smr.rs.plug_n.pin[1].i) = 0.0;
//   smr.rs.plug_n.pin[1].v = smr.rs.resistor[1].n.v;
//   smr.rs.resistor[3].p.i + (-smr.rs.plug_p.pin[3].i) = 0.0;
//   smr.rs.plug_p.pin[3].v = smr.rs.resistor[3].p.v;
//   smr.rs.resistor[2].p.i + (-smr.rs.plug_p.pin[2].i) = 0.0;
//   smr.rs.plug_p.pin[2].v = smr.rs.resistor[2].p.v;
//   smr.rs.resistor[1].p.i + (-smr.rs.plug_p.pin[1].i) = 0.0;
//   smr.rs.plug_p.pin[1].v = smr.rs.resistor[1].p.v;
//   smr.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.SMR_Inverter;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.SMR_Inverter completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.SMR_Inverter has 416 equation(s) and 416 variable(s).
// 300 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// class Modelica.Electrical.Machines.Examples.SMPM_Inverter
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real f(quantity = "Frequency", unit = "Hz") = 50.0 "actual frequency";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 1.0 "frequency ramp";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 181.4 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.2 "time of load torque step";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real smpm.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real smpm.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean smpm.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real smpm.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = smpm.Jr) "stator's moment of inertia";
//   output Real smpm.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = smpm.flange.phi - smpm.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real smpm.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(smpm.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real smpm.tauElectrical(quantity = "Torque", unit = "N.m") = smpm.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real smpm.tauShaft(quantity = "Torque", unit = "N.m") = -smpm.flange.tau "shaft torque";
//   Real smpm.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smpm.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smpm.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smpm.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smpm.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smpm.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smpm.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = smpm.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) smpm.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real smpm.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real smpm.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real smpm.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real smpm.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real smpm.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer smpm.m = 3 "number of phases";
//   parameter Integer smpm.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real smpm.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real smpm.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real smpm.Lssigma(quantity = "Inductance", unit = "H", start = 0.1 * 1.0 / smpm.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real smpm.vs[1](quantity = "ElectricPotential", unit = "V") = smpm.plug_sp.pin[1].v - smpm.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real smpm.vs[2](quantity = "ElectricPotential", unit = "V") = smpm.plug_sp.pin[2].v - smpm.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real smpm.vs[3](quantity = "ElectricPotential", unit = "V") = smpm.plug_sp.pin[3].v - smpm.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real smpm.is[1](quantity = "ElectricCurrent", unit = "A") = smpm.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real smpm.is[2](quantity = "ElectricCurrent", unit = "A") = smpm.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real smpm.is[3](quantity = "ElectricCurrent", unit = "A") = smpm.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real smpm.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real smpm.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = smpm.airGapR.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real smpm.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = smpm.airGapR.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real smpm.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.airGapR.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real smpm.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.airGapR.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real smpm.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = smpm.airGapR.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real smpm.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = smpm.airGapR.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real smpm.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.airGapR.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real smpm.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.airGapR.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer smpm.plug_sp.m(min = 1) = 3 "number of phases";
//   Real smpm.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smpm.plug_sn.m(min = 1) = 3 "number of phases";
//   Real smpm.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smpm.rs.m(min = 1) = 3 "number of phases";
//   Real smpm.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smpm.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smpm.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smpm.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smpm.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smpm.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smpm.rs.plug_p.m(min = 1) = smpm.rs.m "number of phases";
//   Real smpm.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smpm.rs.plug_n.m(min = 1) = smpm.rs.m "number of phases";
//   Real smpm.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smpm.rs.mh(min = 1) = smpm.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean smpm.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real smpm.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smpm.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smpm.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smpm.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = smpm.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smpm.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = smpm.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smpm.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = smpm.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smpm.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smpm.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smpm.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smpm.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smpm.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smpm.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real smpm.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smpm.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smpm.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smpm.rs.resistor[1].useHeatPort = smpm.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smpm.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real smpm.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smpm.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smpm.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smpm.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real smpm.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T_ref[1] "Reference temperature";
//   parameter Real smpm.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smpm.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smpm.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smpm.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smpm.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smpm.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smpm.rs.resistor[2].useHeatPort = smpm.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smpm.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real smpm.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smpm.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smpm.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smpm.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real smpm.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T_ref[2] "Reference temperature";
//   parameter Real smpm.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smpm.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smpm.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smpm.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smpm.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smpm.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smpm.rs.resistor[3].useHeatPort = smpm.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smpm.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real smpm.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smpm.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smpm.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smpm.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real smpm.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smpm.rs.T_ref[3] "Reference temperature";
//   parameter Real smpm.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smpm.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smpm.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer smpm.lssigma.m(min = 1) = 3 "number of phases";
//   Real smpm.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smpm.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smpm.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smpm.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smpm.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smpm.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smpm.lssigma.plug_p.m(min = 1) = smpm.lssigma.m "number of phases";
//   Real smpm.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smpm.lssigma.plug_n.m(min = 1) = smpm.lssigma.m "number of phases";
//   Real smpm.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smpm.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = smpm.Lssigma "Inductance";
//   parameter Real smpm.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = smpm.Lssigma "Inductance";
//   parameter Real smpm.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = smpm.Lssigma "Inductance";
//   Real smpm.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smpm.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smpm.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smpm.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = smpm.lssigma.L[1] "Inductance";
//   Real smpm.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smpm.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smpm.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smpm.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = smpm.lssigma.L[2] "Inductance";
//   Real smpm.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smpm.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smpm.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smpm.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = smpm.lssigma.L[3] "Inductance";
//   constant Integer smpm.spacePhasorS.m = 3 "number of phases";
//   constant Real smpm.spacePhasorS.pi = 3.14159265358979;
//   parameter Real smpm.spacePhasorS.turnsRatio = 1.0;
//   Real smpm.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smpm.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smpm.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smpm.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smpm.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smpm.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real smpm.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real smpm.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real smpm.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real smpm.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real smpm.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real smpm.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real smpm.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real smpm.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real smpm.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real smpm.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real smpm.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real smpm.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer smpm.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real smpm.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smpm.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real smpm.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smpm.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smpm.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smpm.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer smpm.airGapR.m = 3 "number of phases";
//   parameter Integer smpm.airGapR.p(min = 1) = smpm.p "number of pole pairs";
//   output Real smpm.airGapR.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real smpm.airGapR.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real smpm.airGapR.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smpm.airGapR.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smpm.airGapR.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smpm.airGapR.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smpm.airGapR.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smpm.airGapR.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smpm.airGapR.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real smpm.airGapR.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real smpm.airGapR.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real smpm.airGapR.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real smpm.airGapR.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smpm.airGapR.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smpm.airGapR.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smpm.airGapR.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smpm.airGapR.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smpm.airGapR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real smpm.airGapR.Lmd(quantity = "Inductance", unit = "H") = smpm.Lmd "main field inductance d-axis";
//   parameter Real smpm.airGapR.Lmq(quantity = "Inductance", unit = "H") = smpm.Lmq "main field inductance q-axis";
//   Real smpm.airGapR.i_mr[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   Real smpm.airGapR.i_mr[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   protected parameter Real smpm.airGapR.L[1,1](quantity = "Inductance", unit = "H") = smpm.airGapR.Lmd "inductance matrix";
//   protected parameter Real smpm.airGapR.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smpm.airGapR.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smpm.airGapR.L[2,2](quantity = "Inductance", unit = "H") = smpm.airGapR.Lmq "inductance matrix";
//   parameter Real smpm.VsOpenCircuit(quantity = "ElectricPotential", unit = "V", start = 112.3) "open circuit RMS voltage per phase @ fNominal";
//   parameter Real smpm.Lmd(quantity = "Inductance", unit = "H", start = 0.3 * 1.0 / smpm.fsNominal / 6.28318530717959) "main field inductance in d-axis";
//   parameter Real smpm.Lmq(quantity = "Inductance", unit = "H", start = 0.3 * 1.0 / smpm.fsNominal / 6.28318530717959) "main field inductance in q-axis";
//   parameter Boolean smpm.useDamperCage(start = true) "enable / disable damper cage";
//   parameter Real smpm.Lrsigmad(quantity = "Inductance", unit = "H", start = 0.05 * 1.0 / smpm.fsNominal / 6.28318530717959) "damper stray inductance in d-axis";
//   parameter Real smpm.Lrsigmaq(quantity = "Inductance", unit = "H") = smpm.Lrsigmad "damper stray inductance in q-axis";
//   parameter Real smpm.Rrd(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm damper resistance in d-axis";
//   parameter Real smpm.Rrq(quantity = "Resistance", unit = "Ohm") = smpm.Rrd "warm damper resistance in q-axis";
//   protected parameter Real smpm.Ie(quantity = "ElectricCurrent", unit = "A") = 1.4142135623731 * (smpm.VsOpenCircuit * 1.0 / smpm.fsNominal / smpm.Lmd / 6.28318530717959) "equivalent excitation current";
//   parameter Real smpm.permanentMagnet.Ie(quantity = "ElectricCurrent", unit = "A") = smpm.Ie "equivalent excitation current";
//   Real smpm.permanentMagnet.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.permanentMagnet.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.permanentMagnet.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smpm.permanentMagnet.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real smpm.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real smpm.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smpm.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real smpm.idq_dr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.damperCage.spacePhasor_r.i_[1] "damper space phasor current / rotor fixed frame";
//   output Real smpm.idq_dr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smpm.damperCage.spacePhasor_r.i_[2] "damper space phasor current / rotor fixed frame";
//   parameter Real smpm.damperCage.Lrsigmad(quantity = "Inductance", unit = "H") = smpm.Lrsigmad "stray inductance in d-axis per phase translated to stator";
//   parameter Real smpm.damperCage.Lrsigmaq(quantity = "Inductance", unit = "H") = smpm.Lrsigmaq "stray inductance in q-axis per phase translated to stator";
//   parameter Real smpm.damperCage.Rrd(quantity = "Resistance", unit = "Ohm") = smpm.Rrd "warm resistance in d-axis per phase translated to stator";
//   parameter Real smpm.damperCage.Rrq(quantity = "Resistance", unit = "Ohm") = smpm.Rrq "warm resistance in q-axis per phase translated to stator";
//   Real smpm.damperCage.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.damperCage.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smpm.damperCage.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smpm.damperCage.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   constant Integer rotorDisplacementAngle.m = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.p(min = 1) = smpm.p "number of pole pairs";
//   parameter Boolean rotorDisplacementAngle.useSupport = false "use support or fixed housing";
//   output Real rotorDisplacementAngle.rotorDisplacementAngle;
//   parameter Integer rotorDisplacementAngle.plug_p.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.plug_n.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_p.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_n.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nin = 3 "Number of inputs";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nout = 2 "Number of outputs";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[2] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[3] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[2] "Connector of Real output signals";
//   constant Integer rotorDisplacementAngle.ToSpacePhasorVS.m = 3 "number of phases";
//   constant Real rotorDisplacementAngle.ToSpacePhasorVS.pi = 3.14159265358979;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,2] = -0.866025403784438;
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.zero;
//   Real rotorDisplacementAngle.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real rotorDisplacementAngle.relativeAngleSensor.phi_rel "Relative angle between two flanges (= flange_b.phi - flange_a.phi)";
//   output Real rotorDisplacementAngle.constant_.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.constant_.k(start = 1.0) = 1.5707963267949 "Constant output value";
//   input Real rotorDisplacementAngle.add.u1 "Connector of Real input signal 1";
//   input Real rotorDisplacementAngle.add.u2 "Connector of Real input signal 2";
//   output Real rotorDisplacementAngle.add.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.add.k1 = Real(rotorDisplacementAngle.p) "Gain of upper input";
//   parameter Real rotorDisplacementAngle.add.k2 = 1.0 "Gain of lower input";
//   parameter Integer rotorDisplacementAngle.rotatorVS2R.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[2] "Connector of Real output signals";
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] = -sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] = sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   input Real rotorDisplacementAngle.rotatorVS2R.angle;
//   parameter Integer rotorDisplacementAngle.ToPolarVSR.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[2] "Connector of Real output signals";
//   constant Real rotorDisplacementAngle.ToPolarVSR.small = 1e-60;
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n1 = 1 "dimension of output signal connector 1";
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n2 = 1 "dimension of output signal connector 2";
//   input Real rotorDisplacementAngle.deMultiplex2.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.deMultiplex2.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.deMultiplex2.y1[1] "Connector of Real output signals 1";
//   output Real rotorDisplacementAngle.deMultiplex2.y2[1] "Connector of Real output signals 2";
//   parameter Real rotorDisplacementAngle.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real rotorDisplacementAngle.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real ramp.y "Connector of Real output signal";
//   parameter Real ramp.height = f "Height of ramps";
//   parameter Real ramp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = tRamp "Durations of ramp";
//   parameter Real ramp.offset = 0.0 "Offset of output signal";
//   parameter Real ramp.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
//   parameter Integer vfController.nout = vfController.m "Number of outputs";
//   input Real vfController.u "Connector of Real input signal";
//   output Real vfController.y[1] "Connector of Real output signals";
//   output Real vfController.y[2] "Connector of Real output signals";
//   output Real vfController.y[3] "Connector of Real output signals";
//   constant Real vfController.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Integer vfController.m = 3 "number of phases";
//   parameter Real vfController.VNominal(quantity = "ElectricPotential", unit = "V") = VNominal "nominal RMS voltage per phase";
//   parameter Real vfController.fNominal(quantity = "Frequency", unit = "Hz") = fNominal "nominal frequency";
//   parameter Real vfController.BasePhase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 1.5707963267949 "common phase shift";
//   output Real vfController.x(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true) "integrator state";
//   output Real vfController.amplitude(quantity = "ElectricPotential", unit = "V");
//   parameter Integer signalVoltage.m(min = 1) = 3 "number of phases";
//   Real signalVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real signalVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real signalVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer signalVoltage.plug_p.m(min = 1) = signalVoltage.m "number of phases";
//   Real signalVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer signalVoltage.plug_n.m(min = 1) = signalVoltage.m "number of phases";
//   Real signalVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.v[1] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real signalVoltage.v[2] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real signalVoltage.v[3] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[1].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real signalVoltage.signalVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[2].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real signalVoltage.signalVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.signalVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.signalVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.signalVoltage[3].v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.signalVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean loadTorqueStep.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real loadTorqueStep.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorqueStep.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real loadTorqueStep.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real loadTorqueStep.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real loadTorqueStep.stepTorque(quantity = "Torque", unit = "N.m", start = 1.0) = -TLoad "Height of torque step (if negative, torque is acting as load)";
//   parameter Real loadTorqueStep.offsetTorque(quantity = "Torque", unit = "N.m", start = 0.0) "Offset of torque";
//   parameter Real loadTorqueStep.startTime(quantity = "Time", unit = "s") = tStep "Torque = offset for time < startTime";
//   Real loadTorqueStep.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.star.m(min = 1) = 3 "number of phases";
//   parameter Integer terminalBox.star.plug_p.m(min = 1) = terminalBox.star.m "number of phases";
//   Real terminalBox.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   smpm.inertiaRotor.phi = smpm.inertiaRotor.flange_a.phi;
//   smpm.inertiaRotor.phi = smpm.inertiaRotor.flange_b.phi;
//   smpm.inertiaRotor.w = der(smpm.inertiaRotor.phi);
//   smpm.inertiaRotor.a = der(smpm.inertiaRotor.w);
//   smpm.inertiaRotor.J * smpm.inertiaRotor.a = smpm.inertiaRotor.flange_a.tau + smpm.inertiaRotor.flange_b.tau;
//   assert(1.0 + smpm.rs.resistor[1].alpha * (smpm.rs.resistor[1].T_heatPort - smpm.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smpm.rs.resistor[1].R_actual = smpm.rs.resistor[1].R * (1.0 + smpm.rs.resistor[1].alpha * (smpm.rs.resistor[1].T_heatPort - smpm.rs.resistor[1].T_ref));
//   smpm.rs.resistor[1].v = smpm.rs.resistor[1].R_actual * smpm.rs.resistor[1].i;
//   smpm.rs.resistor[1].LossPower = smpm.rs.resistor[1].v * smpm.rs.resistor[1].i;
//   smpm.rs.resistor[1].i = smpm.rs.resistor[1].p.i;
//   0.0 = smpm.rs.resistor[1].p.i + smpm.rs.resistor[1].n.i;
//   smpm.rs.resistor[1].v = smpm.rs.resistor[1].p.v - smpm.rs.resistor[1].n.v;
//   smpm.rs.resistor[1].T_heatPort = smpm.rs.resistor[1].T;
//   assert(1.0 + smpm.rs.resistor[2].alpha * (smpm.rs.resistor[2].T_heatPort - smpm.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smpm.rs.resistor[2].R_actual = smpm.rs.resistor[2].R * (1.0 + smpm.rs.resistor[2].alpha * (smpm.rs.resistor[2].T_heatPort - smpm.rs.resistor[2].T_ref));
//   smpm.rs.resistor[2].v = smpm.rs.resistor[2].R_actual * smpm.rs.resistor[2].i;
//   smpm.rs.resistor[2].LossPower = smpm.rs.resistor[2].v * smpm.rs.resistor[2].i;
//   smpm.rs.resistor[2].i = smpm.rs.resistor[2].p.i;
//   0.0 = smpm.rs.resistor[2].p.i + smpm.rs.resistor[2].n.i;
//   smpm.rs.resistor[2].v = smpm.rs.resistor[2].p.v - smpm.rs.resistor[2].n.v;
//   smpm.rs.resistor[2].T_heatPort = smpm.rs.resistor[2].T;
//   assert(1.0 + smpm.rs.resistor[3].alpha * (smpm.rs.resistor[3].T_heatPort - smpm.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smpm.rs.resistor[3].R_actual = smpm.rs.resistor[3].R * (1.0 + smpm.rs.resistor[3].alpha * (smpm.rs.resistor[3].T_heatPort - smpm.rs.resistor[3].T_ref));
//   smpm.rs.resistor[3].v = smpm.rs.resistor[3].R_actual * smpm.rs.resistor[3].i;
//   smpm.rs.resistor[3].LossPower = smpm.rs.resistor[3].v * smpm.rs.resistor[3].i;
//   smpm.rs.resistor[3].i = smpm.rs.resistor[3].p.i;
//   0.0 = smpm.rs.resistor[3].p.i + smpm.rs.resistor[3].n.i;
//   smpm.rs.resistor[3].v = smpm.rs.resistor[3].p.v - smpm.rs.resistor[3].n.v;
//   smpm.rs.resistor[3].T_heatPort = smpm.rs.resistor[3].T;
//   smpm.rs.v[1] = smpm.rs.plug_p.pin[1].v - smpm.rs.plug_n.pin[1].v;
//   smpm.rs.v[2] = smpm.rs.plug_p.pin[2].v - smpm.rs.plug_n.pin[2].v;
//   smpm.rs.v[3] = smpm.rs.plug_p.pin[3].v - smpm.rs.plug_n.pin[3].v;
//   smpm.rs.i[1] = smpm.rs.plug_p.pin[1].i;
//   smpm.rs.i[2] = smpm.rs.plug_p.pin[2].i;
//   smpm.rs.i[3] = smpm.rs.plug_p.pin[3].i;
//   smpm.lssigma.inductor[1].L * der(smpm.lssigma.inductor[1].i) = smpm.lssigma.inductor[1].v;
//   smpm.lssigma.inductor[1].v = smpm.lssigma.inductor[1].p.v - smpm.lssigma.inductor[1].n.v;
//   0.0 = smpm.lssigma.inductor[1].p.i + smpm.lssigma.inductor[1].n.i;
//   smpm.lssigma.inductor[1].i = smpm.lssigma.inductor[1].p.i;
//   smpm.lssigma.inductor[2].L * der(smpm.lssigma.inductor[2].i) = smpm.lssigma.inductor[2].v;
//   smpm.lssigma.inductor[2].v = smpm.lssigma.inductor[2].p.v - smpm.lssigma.inductor[2].n.v;
//   0.0 = smpm.lssigma.inductor[2].p.i + smpm.lssigma.inductor[2].n.i;
//   smpm.lssigma.inductor[2].i = smpm.lssigma.inductor[2].p.i;
//   smpm.lssigma.inductor[3].L * der(smpm.lssigma.inductor[3].i) = smpm.lssigma.inductor[3].v;
//   smpm.lssigma.inductor[3].v = smpm.lssigma.inductor[3].p.v - smpm.lssigma.inductor[3].n.v;
//   0.0 = smpm.lssigma.inductor[3].p.i + smpm.lssigma.inductor[3].n.i;
//   smpm.lssigma.inductor[3].i = smpm.lssigma.inductor[3].p.i;
//   smpm.lssigma.v[1] = smpm.lssigma.plug_p.pin[1].v - smpm.lssigma.plug_n.pin[1].v;
//   smpm.lssigma.v[2] = smpm.lssigma.plug_p.pin[2].v - smpm.lssigma.plug_n.pin[2].v;
//   smpm.lssigma.v[3] = smpm.lssigma.plug_p.pin[3].v - smpm.lssigma.plug_n.pin[3].v;
//   smpm.lssigma.i[1] = smpm.lssigma.plug_p.pin[1].i;
//   smpm.lssigma.i[2] = smpm.lssigma.plug_p.pin[2].i;
//   smpm.lssigma.i[3] = smpm.lssigma.plug_p.pin[3].i;
//   smpm.spacePhasorS.gnd.p.v = 0.0;
//   smpm.spacePhasorS.v[1] / smpm.spacePhasorS.turnsRatio = smpm.spacePhasorS.plug_p.pin[1].v - smpm.spacePhasorS.plug_n.pin[1].v;
//   smpm.spacePhasorS.v[2] / smpm.spacePhasorS.turnsRatio = smpm.spacePhasorS.plug_p.pin[2].v - smpm.spacePhasorS.plug_n.pin[2].v;
//   smpm.spacePhasorS.v[3] / smpm.spacePhasorS.turnsRatio = smpm.spacePhasorS.plug_p.pin[3].v - smpm.spacePhasorS.plug_n.pin[3].v;
//   smpm.spacePhasorS.turnsRatio * smpm.spacePhasorS.i[1] = smpm.spacePhasorS.plug_p.pin[1].i;
//   smpm.spacePhasorS.turnsRatio * smpm.spacePhasorS.i[2] = smpm.spacePhasorS.plug_p.pin[2].i;
//   smpm.spacePhasorS.turnsRatio * smpm.spacePhasorS.i[3] = smpm.spacePhasorS.plug_p.pin[3].i;
//   smpm.spacePhasorS.turnsRatio * smpm.spacePhasorS.i[1] = -smpm.spacePhasorS.plug_n.pin[1].i;
//   smpm.spacePhasorS.turnsRatio * smpm.spacePhasorS.i[2] = -smpm.spacePhasorS.plug_n.pin[2].i;
//   smpm.spacePhasorS.turnsRatio * smpm.spacePhasorS.i[3] = -smpm.spacePhasorS.plug_n.pin[3].i;
//   smpm.spacePhasorS.zero.v = 0.333333333333333 * (smpm.spacePhasorS.v[1] + (smpm.spacePhasorS.v[2] + smpm.spacePhasorS.v[3]));
//   smpm.spacePhasorS.spacePhasor.v_[1] = smpm.spacePhasorS.TransformationMatrix[1,1] * smpm.spacePhasorS.v[1] + (smpm.spacePhasorS.TransformationMatrix[1,2] * smpm.spacePhasorS.v[2] + smpm.spacePhasorS.TransformationMatrix[1,3] * smpm.spacePhasorS.v[3]);
//   smpm.spacePhasorS.spacePhasor.v_[2] = smpm.spacePhasorS.TransformationMatrix[2,1] * smpm.spacePhasorS.v[1] + (smpm.spacePhasorS.TransformationMatrix[2,2] * smpm.spacePhasorS.v[2] + smpm.spacePhasorS.TransformationMatrix[2,3] * smpm.spacePhasorS.v[3]);
//   -smpm.spacePhasorS.zero.i = 0.333333333333333 * (smpm.spacePhasorS.i[1] + (smpm.spacePhasorS.i[2] + smpm.spacePhasorS.i[3]));
//   -smpm.spacePhasorS.spacePhasor.i_[1] = smpm.spacePhasorS.TransformationMatrix[1,1] * smpm.spacePhasorS.i[1] + (smpm.spacePhasorS.TransformationMatrix[1,2] * smpm.spacePhasorS.i[2] + smpm.spacePhasorS.TransformationMatrix[1,3] * smpm.spacePhasorS.i[3]);
//   -smpm.spacePhasorS.spacePhasor.i_[2] = smpm.spacePhasorS.TransformationMatrix[2,1] * smpm.spacePhasorS.i[1] + (smpm.spacePhasorS.TransformationMatrix[2,2] * smpm.spacePhasorS.i[2] + smpm.spacePhasorS.TransformationMatrix[2,3] * smpm.spacePhasorS.i[3]);
//   smpm.airGapR.i_mr[1] = smpm.airGapR.i_sr[1] + smpm.airGapR.i_rr[1];
//   smpm.airGapR.i_mr[2] = smpm.airGapR.i_sr[2] + smpm.airGapR.i_rr[2];
//   smpm.airGapR.psi_mr[1] = smpm.airGapR.L[1,1] * smpm.airGapR.i_mr[1] + smpm.airGapR.L[1,2] * smpm.airGapR.i_mr[2];
//   smpm.airGapR.psi_mr[2] = smpm.airGapR.L[2,1] * smpm.airGapR.i_mr[1] + smpm.airGapR.L[2,2] * smpm.airGapR.i_mr[2];
//   smpm.airGapR.psi_ms[1] = smpm.airGapR.RotationMatrix[1,1] * smpm.airGapR.psi_mr[1] + smpm.airGapR.RotationMatrix[1,2] * smpm.airGapR.psi_mr[2];
//   smpm.airGapR.psi_ms[2] = smpm.airGapR.RotationMatrix[2,1] * smpm.airGapR.psi_mr[1] + smpm.airGapR.RotationMatrix[2,2] * smpm.airGapR.psi_mr[2];
//   smpm.airGapR.gamma = Real(smpm.airGapR.p) * (smpm.airGapR.flange.phi - smpm.airGapR.support.phi);
//   smpm.airGapR.RotationMatrix[1,1] = cos(smpm.airGapR.gamma);
//   smpm.airGapR.RotationMatrix[1,2] = -sin(smpm.airGapR.gamma);
//   smpm.airGapR.RotationMatrix[2,1] = sin(smpm.airGapR.gamma);
//   smpm.airGapR.RotationMatrix[2,2] = cos(smpm.airGapR.gamma);
//   smpm.airGapR.i_ss[1] = smpm.airGapR.spacePhasor_s.i_[1];
//   smpm.airGapR.i_ss[2] = smpm.airGapR.spacePhasor_s.i_[2];
//   smpm.airGapR.i_ss[1] = smpm.airGapR.RotationMatrix[1,1] * smpm.airGapR.i_sr[1] + smpm.airGapR.RotationMatrix[1,2] * smpm.airGapR.i_sr[2];
//   smpm.airGapR.i_ss[2] = smpm.airGapR.RotationMatrix[2,1] * smpm.airGapR.i_sr[1] + smpm.airGapR.RotationMatrix[2,2] * smpm.airGapR.i_sr[2];
//   smpm.airGapR.i_rr[1] = smpm.airGapR.spacePhasor_r.i_[1];
//   smpm.airGapR.i_rr[2] = smpm.airGapR.spacePhasor_r.i_[2];
//   smpm.airGapR.i_rs[1] = smpm.airGapR.RotationMatrix[1,1] * smpm.airGapR.i_rr[1] + smpm.airGapR.RotationMatrix[1,2] * smpm.airGapR.i_rr[2];
//   smpm.airGapR.i_rs[2] = smpm.airGapR.RotationMatrix[2,1] * smpm.airGapR.i_rr[1] + smpm.airGapR.RotationMatrix[2,2] * smpm.airGapR.i_rr[2];
//   smpm.airGapR.spacePhasor_s.v_[1] = der(smpm.airGapR.psi_ms[1]);
//   smpm.airGapR.spacePhasor_s.v_[2] = der(smpm.airGapR.psi_ms[2]);
//   smpm.airGapR.spacePhasor_r.v_[1] = der(smpm.airGapR.psi_mr[1]);
//   smpm.airGapR.spacePhasor_r.v_[2] = der(smpm.airGapR.psi_mr[2]);
//   smpm.airGapR.tauElectrical = Real(smpm.airGapR.m) * (Real(smpm.airGapR.p) * (smpm.airGapR.spacePhasor_s.i_[2] * smpm.airGapR.psi_ms[1] - smpm.airGapR.spacePhasor_s.i_[1] * smpm.airGapR.psi_ms[2]) / 2.0);
//   smpm.airGapR.flange.tau = -smpm.airGapR.tauElectrical;
//   smpm.airGapR.support.tau = smpm.airGapR.tauElectrical;
//   smpm.permanentMagnet.spacePhasor_r.i_[1] = -smpm.permanentMagnet.Ie;
//   smpm.permanentMagnet.spacePhasor_r.i_[2] = 0.0;
//   smpm.fixed.flange.phi = smpm.fixed.phi0;
//   smpm.damperCage.spacePhasor_r.v_[1] = smpm.damperCage.Rrd * smpm.damperCage.spacePhasor_r.i_[1] + smpm.damperCage.Lrsigmad * der(smpm.damperCage.spacePhasor_r.i_[1]);
//   smpm.damperCage.spacePhasor_r.v_[2] = smpm.damperCage.Rrq * smpm.damperCage.spacePhasor_r.i_[2] + smpm.damperCage.Lrsigmaq * der(smpm.damperCage.spacePhasor_r.i_[2]);
//   assert(smpm.spacePhasorS.plug_n.m == smpm.plug_sn.m,"automatically generated from connect");
//   assert(smpm.lssigma.plug_n.m == smpm.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(smpm.rs.plug_n.m == smpm.lssigma.plug_p.m,"automatically generated from connect");
//   assert(smpm.plug_sp.m == smpm.rs.plug_p.m,"automatically generated from connect");
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.ToSpacePhasorVS.zero = 0.333333333333333 * (rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.u[3]));
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.relativeAngleSensor.phi_rel = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi - rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + rotorDisplacementAngle.relativeAngleSensor.flange_b.tau;
//   rotorDisplacementAngle.constant_.y = rotorDisplacementAngle.constant_.k;
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.add.k1 * rotorDisplacementAngle.add.u1 + rotorDisplacementAngle.add.k2 * rotorDisplacementAngle.add.u2;
//   rotorDisplacementAngle.rotatorVS2R.y[1] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.rotatorVS2R.y[2] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.ToPolarVSR.y[1] = sqrt(rotorDisplacementAngle.ToPolarVSR.u[1] ^ 2.0 + rotorDisplacementAngle.ToPolarVSR.u[2] ^ 2.0);
//   rotorDisplacementAngle.ToPolarVSR.y[2] = if noEvent(rotorDisplacementAngle.ToPolarVSR.y[1] <= 1e-60) then 0.0 else atan2(rotorDisplacementAngle.ToPolarVSR.u[2],rotorDisplacementAngle.ToPolarVSR.u[1]);
//   rotorDisplacementAngle.deMultiplex2.u[1] = rotorDisplacementAngle.deMultiplex2.y1[1];
//   rotorDisplacementAngle.deMultiplex2.u[2] = rotorDisplacementAngle.deMultiplex2.y2[1];
//   rotorDisplacementAngle.fixed.flange.phi = rotorDisplacementAngle.fixed.phi0;
//   assert(rotorDisplacementAngle.plug_p.m == rotorDisplacementAngle.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_n.m == rotorDisplacementAngle.VoltageSensor1.plug_n.m,"automatically generated from connect");
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   vfController.amplitude = 1.4142135623731 * (vfController.VNominal * (if abs(vfController.u) < vfController.fNominal then abs(vfController.u) / vfController.fNominal else 1.0));
//   der(vfController.x) = 6.28318530717959 * vfController.u;
//   vfController.y[1] = vfController.amplitude * sin(vfController.x + vfController.BasePhase);
//   vfController.y[2] = vfController.amplitude * sin(vfController.x + vfController.BasePhase - 6.28318530717959 / Real(vfController.m));
//   vfController.y[3] = vfController.amplitude * sin(vfController.x + vfController.BasePhase - 12.5663706143592 / Real(vfController.m));
//   signalVoltage.signalVoltage[1].v = signalVoltage.signalVoltage[1].p.v - signalVoltage.signalVoltage[1].n.v;
//   0.0 = signalVoltage.signalVoltage[1].p.i + signalVoltage.signalVoltage[1].n.i;
//   signalVoltage.signalVoltage[1].i = signalVoltage.signalVoltage[1].p.i;
//   signalVoltage.signalVoltage[2].v = signalVoltage.signalVoltage[2].p.v - signalVoltage.signalVoltage[2].n.v;
//   0.0 = signalVoltage.signalVoltage[2].p.i + signalVoltage.signalVoltage[2].n.i;
//   signalVoltage.signalVoltage[2].i = signalVoltage.signalVoltage[2].p.i;
//   signalVoltage.signalVoltage[3].v = signalVoltage.signalVoltage[3].p.v - signalVoltage.signalVoltage[3].n.v;
//   0.0 = signalVoltage.signalVoltage[3].p.i + signalVoltage.signalVoltage[3].n.i;
//   signalVoltage.signalVoltage[3].i = signalVoltage.signalVoltage[3].p.i;
//   signalVoltage.i[1] = signalVoltage.plug_p.pin[1].i;
//   signalVoltage.i[2] = signalVoltage.plug_p.pin[2].i;
//   signalVoltage.i[3] = signalVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   loadTorqueStep.tau = -loadTorqueStep.flange.tau;
//   loadTorqueStep.tau = loadTorqueStep.offsetTorque + (if time < loadTorqueStep.startTime then 0.0 else loadTorqueStep.stepTorque);
//   loadTorqueStep.phi = loadTorqueStep.flange.phi - loadTorqueStep.phi_support;
//   loadTorqueStep.phi_support = 0.0;
//   assert(terminalBox.plug_sn.m == terminalBox.star.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   assert(signalVoltage.plug_n.m == star.plug_p.m,"automatically generated from connect");
//   assert(signalVoltage.plug_p.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_n.m == smpm.plug_sn.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_p.m == smpm.plug_sp.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == smpm.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == smpm.plug_sp.m,"automatically generated from connect");
//   smpm.flange.tau + (rotorDisplacementAngle.flange.tau + loadInertia.flange_a.tau) = 0.0;
//   loadInertia.flange_a.phi = rotorDisplacementAngle.flange.phi;
//   loadInertia.flange_a.phi = smpm.flange.phi;
//   terminalBox.plug_sp.pin[3].i + (rotorDisplacementAngle.plug_p.pin[3].i + smpm.plug_sp.pin[3].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[3].v = smpm.plug_sp.pin[3].v;
//   rotorDisplacementAngle.plug_p.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + (rotorDisplacementAngle.plug_p.pin[2].i + smpm.plug_sp.pin[2].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[2].v = smpm.plug_sp.pin[2].v;
//   rotorDisplacementAngle.plug_p.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + (rotorDisplacementAngle.plug_p.pin[1].i + smpm.plug_sp.pin[1].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[1].v = smpm.plug_sp.pin[1].v;
//   rotorDisplacementAngle.plug_p.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plug_sn.pin[3].i + (rotorDisplacementAngle.plug_n.pin[3].i + smpm.plug_sn.pin[3].i) = 0.0;
//   rotorDisplacementAngle.plug_n.pin[3].v = smpm.plug_sn.pin[3].v;
//   rotorDisplacementAngle.plug_n.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   terminalBox.plug_sn.pin[2].i + (rotorDisplacementAngle.plug_n.pin[2].i + smpm.plug_sn.pin[2].i) = 0.0;
//   rotorDisplacementAngle.plug_n.pin[2].v = smpm.plug_sn.pin[2].v;
//   rotorDisplacementAngle.plug_n.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   terminalBox.plug_sn.pin[1].i + (rotorDisplacementAngle.plug_n.pin[1].i + smpm.plug_sn.pin[1].i) = 0.0;
//   rotorDisplacementAngle.plug_n.pin[1].v = smpm.plug_sn.pin[1].v;
//   rotorDisplacementAngle.plug_n.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = terminalBox.plugSupply.pin[3].v;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = terminalBox.plugSupply.pin[2].v;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = terminalBox.plugSupply.pin[1].v;
//   signalVoltage.plug_p.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = signalVoltage.plug_p.pin[3].v;
//   signalVoltage.plug_p.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = signalVoltage.plug_p.pin[2].v;
//   signalVoltage.plug_p.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = signalVoltage.plug_p.pin[1].v;
//   loadInertia.flange_b.tau + loadTorqueStep.flange.tau = 0.0;
//   loadInertia.flange_b.phi = loadTorqueStep.flange.phi;
//   signalVoltage.v[1] = vfController.y[1];
//   signalVoltage.v[2] = vfController.y[2];
//   signalVoltage.v[3] = vfController.y[3];
//   ramp.y = vfController.u;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   signalVoltage.plug_n.pin[3].i + star.plug_p.pin[3].i = 0.0;
//   signalVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   signalVoltage.plug_n.pin[2].i + star.plug_p.pin[2].i = 0.0;
//   signalVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   signalVoltage.plug_n.pin[1].i + star.plug_p.pin[1].i = 0.0;
//   signalVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.i + (-terminalBox.starpoint.i) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.starpoint.v;
//   (-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i) = 0.0;
//   terminalBox.plugSupply.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   (-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i) = 0.0;
//   terminalBox.plugSupply.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   (-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i) = 0.0;
//   terminalBox.plugSupply.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.star.plug_p.pin[3].i = 0.0;
//   terminalBox.plug_sn.pin[3].v = terminalBox.star.plug_p.pin[3].v;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.star.plug_p.pin[2].i = 0.0;
//   terminalBox.plug_sn.pin[2].v = terminalBox.star.plug_p.pin[2].v;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.star.plug_p.pin[1].i = 0.0;
//   terminalBox.plug_sn.pin[1].v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.starpoint.i = 0.0;
//   (-terminalBox.star.plug_p.pin[3].i) + ((-terminalBox.star.plug_p.pin[2].i) + ((-terminalBox.star.plug_p.pin[1].i) + (-terminalBox.star.pin_n.i))) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[2].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[3].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   signalVoltage.signalVoltage[1].v = signalVoltage.v[1];
//   signalVoltage.signalVoltage[2].v = signalVoltage.v[2];
//   signalVoltage.signalVoltage[3].v = signalVoltage.v[3];
//   signalVoltage.signalVoltage[3].n.i + (-signalVoltage.plug_n.pin[3].i) = 0.0;
//   signalVoltage.plug_n.pin[3].v = signalVoltage.signalVoltage[3].n.v;
//   signalVoltage.signalVoltage[2].n.i + (-signalVoltage.plug_n.pin[2].i) = 0.0;
//   signalVoltage.plug_n.pin[2].v = signalVoltage.signalVoltage[2].n.v;
//   signalVoltage.signalVoltage[1].n.i + (-signalVoltage.plug_n.pin[1].i) = 0.0;
//   signalVoltage.plug_n.pin[1].v = signalVoltage.signalVoltage[1].n.v;
//   signalVoltage.signalVoltage[3].p.i + (-signalVoltage.plug_p.pin[3].i) = 0.0;
//   signalVoltage.plug_p.pin[3].v = signalVoltage.signalVoltage[3].p.v;
//   signalVoltage.signalVoltage[2].p.i + (-signalVoltage.plug_p.pin[2].i) = 0.0;
//   signalVoltage.plug_p.pin[2].v = signalVoltage.signalVoltage[2].p.v;
//   signalVoltage.signalVoltage[1].p.i + (-signalVoltage.plug_p.pin[1].i) = 0.0;
//   signalVoltage.plug_p.pin[1].v = signalVoltage.signalVoltage[1].p.v;
//   rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + rotorDisplacementAngle.fixed.flange.tau = 0.0;
//   rotorDisplacementAngle.fixed.flange.phi = rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   rotorDisplacementAngle.relativeAngleSensor.flange_b.tau + (-rotorDisplacementAngle.flange.tau) = 0.0;
//   rotorDisplacementAngle.flange.phi = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi;
//   rotorDisplacementAngle.add.u1 = rotorDisplacementAngle.relativeAngleSensor.phi_rel;
//   rotorDisplacementAngle.deMultiplex2.y2[1] = rotorDisplacementAngle.rotorDisplacementAngle;
//   rotorDisplacementAngle.ToSpacePhasorVS.u[1] = rotorDisplacementAngle.VoltageSensor1.v[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[2] = rotorDisplacementAngle.VoltageSensor1.v[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[3] = rotorDisplacementAngle.VoltageSensor1.v[3];
//   (-rotorDisplacementAngle.plug_n.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v = rotorDisplacementAngle.plug_n.pin[3].v;
//   (-rotorDisplacementAngle.plug_n.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v = rotorDisplacementAngle.plug_n.pin[2].v;
//   (-rotorDisplacementAngle.plug_n.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v = rotorDisplacementAngle.plug_n.pin[1].v;
//   (-rotorDisplacementAngle.plug_p.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v = rotorDisplacementAngle.plug_p.pin[3].v;
//   (-rotorDisplacementAngle.plug_p.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v = rotorDisplacementAngle.plug_p.pin[2].v;
//   (-rotorDisplacementAngle.plug_p.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v = rotorDisplacementAngle.plug_p.pin[1].v;
//   rotorDisplacementAngle.ToPolarVSR.y[1] = rotorDisplacementAngle.deMultiplex2.u[1];
//   rotorDisplacementAngle.ToPolarVSR.y[2] = rotorDisplacementAngle.deMultiplex2.u[2];
//   rotorDisplacementAngle.ToPolarVSR.u[1] = rotorDisplacementAngle.rotatorVS2R.y[1];
//   rotorDisplacementAngle.ToPolarVSR.u[2] = rotorDisplacementAngle.rotatorVS2R.y[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.rotatorVS2R.u[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.rotatorVS2R.angle;
//   rotorDisplacementAngle.add.u2 = rotorDisplacementAngle.constant_.y;
//   rotorDisplacementAngle.VoltageSensor1.v[1] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v;
//   rotorDisplacementAngle.VoltageSensor1.v[2] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v;
//   rotorDisplacementAngle.VoltageSensor1.v[3] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   smpm.airGapR.support.tau + ((-smpm.internalSupport.tau) + smpm.fixed.flange.tau) = 0.0;
//   smpm.airGapR.support.phi = smpm.fixed.flange.phi;
//   smpm.airGapR.support.phi = smpm.internalSupport.phi;
//   smpm.inertiaRotor.flange_b.tau + (-smpm.flange.tau) = 0.0;
//   smpm.flange.phi = smpm.inertiaRotor.flange_b.phi;
//   (-smpm.plug_sp.pin[3].i) + smpm.rs.plug_p.pin[3].i = 0.0;
//   smpm.plug_sp.pin[3].v = smpm.rs.plug_p.pin[3].v;
//   (-smpm.plug_sp.pin[2].i) + smpm.rs.plug_p.pin[2].i = 0.0;
//   smpm.plug_sp.pin[2].v = smpm.rs.plug_p.pin[2].v;
//   (-smpm.plug_sp.pin[1].i) + smpm.rs.plug_p.pin[1].i = 0.0;
//   smpm.plug_sp.pin[1].v = smpm.rs.plug_p.pin[1].v;
//   smpm.rs.plug_n.pin[3].i + smpm.lssigma.plug_p.pin[3].i = 0.0;
//   smpm.lssigma.plug_p.pin[3].v = smpm.rs.plug_n.pin[3].v;
//   smpm.rs.plug_n.pin[2].i + smpm.lssigma.plug_p.pin[2].i = 0.0;
//   smpm.lssigma.plug_p.pin[2].v = smpm.rs.plug_n.pin[2].v;
//   smpm.rs.plug_n.pin[1].i + smpm.lssigma.plug_p.pin[1].i = 0.0;
//   smpm.lssigma.plug_p.pin[1].v = smpm.rs.plug_n.pin[1].v;
//   smpm.lssigma.plug_n.pin[3].i + smpm.spacePhasorS.plug_p.pin[3].i = 0.0;
//   smpm.lssigma.plug_n.pin[3].v = smpm.spacePhasorS.plug_p.pin[3].v;
//   smpm.lssigma.plug_n.pin[2].i + smpm.spacePhasorS.plug_p.pin[2].i = 0.0;
//   smpm.lssigma.plug_n.pin[2].v = smpm.spacePhasorS.plug_p.pin[2].v;
//   smpm.lssigma.plug_n.pin[1].i + smpm.spacePhasorS.plug_p.pin[1].i = 0.0;
//   smpm.lssigma.plug_n.pin[1].v = smpm.spacePhasorS.plug_p.pin[1].v;
//   smpm.spacePhasorS.plug_n.pin[3].i + (-smpm.plug_sn.pin[3].i) = 0.0;
//   smpm.plug_sn.pin[3].v = smpm.spacePhasorS.plug_n.pin[3].v;
//   smpm.spacePhasorS.plug_n.pin[2].i + (-smpm.plug_sn.pin[2].i) = 0.0;
//   smpm.plug_sn.pin[2].v = smpm.spacePhasorS.plug_n.pin[2].v;
//   smpm.spacePhasorS.plug_n.pin[1].i + (-smpm.plug_sn.pin[1].i) = 0.0;
//   smpm.plug_sn.pin[1].v = smpm.spacePhasorS.plug_n.pin[1].v;
//   smpm.spacePhasorS.ground.i + smpm.spacePhasorS.zero.i = 0.0;
//   smpm.spacePhasorS.ground.v = smpm.spacePhasorS.zero.v;
//   smpm.airGapR.flange.tau + smpm.inertiaRotor.flange_a.tau = 0.0;
//   smpm.airGapR.flange.phi = smpm.inertiaRotor.flange_a.phi;
//   smpm.spacePhasorS.spacePhasor.i_[1] + smpm.airGapR.spacePhasor_s.i_[1] = 0.0;
//   smpm.spacePhasorS.spacePhasor.i_[2] + smpm.airGapR.spacePhasor_s.i_[2] = 0.0;
//   smpm.airGapR.spacePhasor_s.v_[1] = smpm.spacePhasorS.spacePhasor.v_[1];
//   smpm.airGapR.spacePhasor_s.v_[2] = smpm.spacePhasorS.spacePhasor.v_[2];
//   smpm.airGapR.spacePhasor_r.i_[1] + (smpm.damperCage.spacePhasor_r.i_[1] + smpm.permanentMagnet.spacePhasor_r.i_[1]) = 0.0;
//   smpm.airGapR.spacePhasor_r.i_[2] + (smpm.damperCage.spacePhasor_r.i_[2] + smpm.permanentMagnet.spacePhasor_r.i_[2]) = 0.0;
//   smpm.airGapR.spacePhasor_r.v_[1] = smpm.damperCage.spacePhasor_r.v_[1];
//   smpm.airGapR.spacePhasor_r.v_[1] = smpm.permanentMagnet.spacePhasor_r.v_[1];
//   smpm.airGapR.spacePhasor_r.v_[2] = smpm.damperCage.spacePhasor_r.v_[2];
//   smpm.airGapR.spacePhasor_r.v_[2] = smpm.permanentMagnet.spacePhasor_r.v_[2];
//   smpm.spacePhasorS.gnd.p.i + (-smpm.spacePhasorS.ground.i) = 0.0;
//   smpm.spacePhasorS.gnd.p.v = smpm.spacePhasorS.ground.v;
//   smpm.lssigma.inductor[3].n.i + (-smpm.lssigma.plug_n.pin[3].i) = 0.0;
//   smpm.lssigma.inductor[3].n.v = smpm.lssigma.plug_n.pin[3].v;
//   smpm.lssigma.inductor[2].n.i + (-smpm.lssigma.plug_n.pin[2].i) = 0.0;
//   smpm.lssigma.inductor[2].n.v = smpm.lssigma.plug_n.pin[2].v;
//   smpm.lssigma.inductor[1].n.i + (-smpm.lssigma.plug_n.pin[1].i) = 0.0;
//   smpm.lssigma.inductor[1].n.v = smpm.lssigma.plug_n.pin[1].v;
//   smpm.lssigma.inductor[3].p.i + (-smpm.lssigma.plug_p.pin[3].i) = 0.0;
//   smpm.lssigma.inductor[3].p.v = smpm.lssigma.plug_p.pin[3].v;
//   smpm.lssigma.inductor[2].p.i + (-smpm.lssigma.plug_p.pin[2].i) = 0.0;
//   smpm.lssigma.inductor[2].p.v = smpm.lssigma.plug_p.pin[2].v;
//   smpm.lssigma.inductor[1].p.i + (-smpm.lssigma.plug_p.pin[1].i) = 0.0;
//   smpm.lssigma.inductor[1].p.v = smpm.lssigma.plug_p.pin[1].v;
//   smpm.rs.resistor[3].n.i + (-smpm.rs.plug_n.pin[3].i) = 0.0;
//   smpm.rs.plug_n.pin[3].v = smpm.rs.resistor[3].n.v;
//   smpm.rs.resistor[2].n.i + (-smpm.rs.plug_n.pin[2].i) = 0.0;
//   smpm.rs.plug_n.pin[2].v = smpm.rs.resistor[2].n.v;
//   smpm.rs.resistor[1].n.i + (-smpm.rs.plug_n.pin[1].i) = 0.0;
//   smpm.rs.plug_n.pin[1].v = smpm.rs.resistor[1].n.v;
//   smpm.rs.resistor[3].p.i + (-smpm.rs.plug_p.pin[3].i) = 0.0;
//   smpm.rs.plug_p.pin[3].v = smpm.rs.resistor[3].p.v;
//   smpm.rs.resistor[2].p.i + (-smpm.rs.plug_p.pin[2].i) = 0.0;
//   smpm.rs.plug_p.pin[2].v = smpm.rs.resistor[2].p.v;
//   smpm.rs.resistor[1].p.i + (-smpm.rs.plug_p.pin[1].i) = 0.0;
//   smpm.rs.plug_p.pin[1].v = smpm.rs.resistor[1].p.v;
//   smpm.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.SMPM_Inverter;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.SMPM_Inverter completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.SMPM_Inverter has 422 equation(s) and 422 variable(s).
// 304 of these are trivial equation(s).
// "
// ""
// "function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
//   constant Integer m = 3 "number of phases";
//   constant Real pi = 3.14159265358979;
//   input Real[3] x;
//   output Real[2] y;
//   output Real y0;
// algorithm
//   y := {0.0,0.0};
//   for k in 1:3 loop
//     y := {y[1] + x[k] * 0.666666666666667 * cos(2.0943951023932 * /*REAL*/(k - 1)),y[2] + x[k] * 0.666666666666667 * sin(2.0943951023932 * /*REAL*/(k - 1))};
//   end for;
//   y0 := 0.333333333333333 * (x[1] + x[2] + x[3]);
// end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.SMEE_Generator
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real wActual(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 156.97491292437 "actual speed";
//   parameter Real Ie(quantity = "ElectricCurrent", unit = "A") = 19.0 "excitation current";
//   parameter Real Ie0(quantity = "ElectricCurrent", unit = "A") = 10.0 "initial excitation current";
//   parameter Real gamma0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "initial rotor displacement angle";
//   constant Real smee.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real smee.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean smee.useSupport = true "enable / disable (=fixed stator) support";
//   parameter Real smee.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = smee.Jr) "stator's moment of inertia";
//   output Real smee.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg", start = (-3.14159265358979 - gamma0) / Real(smee.p), fixed = true) = smee.flange.phi - smee.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real smee.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(smee.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real smee.tauElectrical(quantity = "Torque", unit = "N.m") = smee.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real smee.tauShaft(quantity = "Torque", unit = "N.m") = -smee.flange.tau "shaft torque";
//   Real smee.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smee.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = smee.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) smee.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real smee.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real smee.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real smee.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real smee.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real smee.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer smee.m = 3 "number of phases";
//   parameter Integer smee.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real smee.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real smee.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real smee.Lssigma(quantity = "Inductance", unit = "H", start = 0.1 * 1.0 / smee.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real smee.vs[1](quantity = "ElectricPotential", unit = "V") = smee.plug_sp.pin[1].v - smee.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real smee.vs[2](quantity = "ElectricPotential", unit = "V") = smee.plug_sp.pin[2].v - smee.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real smee.vs[3](quantity = "ElectricPotential", unit = "V") = smee.plug_sp.pin[3].v - smee.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real smee.is[1](quantity = "ElectricCurrent", unit = "A") = smee.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real smee.is[2](quantity = "ElectricCurrent", unit = "A") = smee.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real smee.is[3](quantity = "ElectricCurrent", unit = "A") = smee.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real smee.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real smee.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real smee.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real smee.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real smee.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real smee.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real smee.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = smee.airGapR.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real smee.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real smee.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.airGapR.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer smee.plug_sp.m(min = 1) = 3 "number of phases";
//   Real smee.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.plug_sn.m(min = 1) = 3 "number of phases";
//   Real smee.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.rs.m(min = 1) = 3 "number of phases";
//   Real smee.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smee.rs.plug_p.m(min = 1) = smee.rs.m "number of phases";
//   Real smee.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.rs.plug_n.m(min = 1) = smee.rs.m "number of phases";
//   Real smee.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.rs.mh(min = 1) = smee.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean smee.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real smee.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smee.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smee.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real smee.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smee.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smee.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real smee.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smee.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smee.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real smee.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smee.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real smee.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real smee.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.rs.resistor[1].useHeatPort = smee.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smee.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real smee.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real smee.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[1] "Reference temperature";
//   parameter Real smee.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smee.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.rs.resistor[2].useHeatPort = smee.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smee.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real smee.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real smee.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[2] "Reference temperature";
//   parameter Real smee.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smee.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.rs.resistor[3].useHeatPort = smee.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real smee.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real smee.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real smee.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.rs.T_ref[3] "Reference temperature";
//   parameter Real smee.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = smee.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer smee.lssigma.m(min = 1) = 3 "number of phases";
//   Real smee.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real smee.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real smee.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer smee.lssigma.plug_p.m(min = 1) = smee.lssigma.m "number of phases";
//   Real smee.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.lssigma.plug_n.m(min = 1) = smee.lssigma.m "number of phases";
//   Real smee.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = smee.Lssigma "Inductance";
//   parameter Real smee.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = smee.Lssigma "Inductance";
//   parameter Real smee.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = smee.Lssigma "Inductance";
//   Real smee.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = smee.lssigma.L[1] "Inductance";
//   Real smee.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = smee.lssigma.L[2] "Inductance";
//   Real smee.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = smee.lssigma.L[3] "Inductance";
//   constant Integer smee.spacePhasorS.m = 3 "number of phases";
//   constant Real smee.spacePhasorS.pi = 3.14159265358979;
//   parameter Real smee.spacePhasorS.turnsRatio = 1.0;
//   Real smee.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smee.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smee.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real smee.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smee.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real smee.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real smee.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real smee.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer smee.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real smee.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer smee.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real smee.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer smee.airGapR.m = 3 "number of phases";
//   parameter Integer smee.airGapR.p(min = 1) = smee.p "number of pole pairs";
//   output Real smee.airGapR.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real smee.airGapR.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real smee.airGapR.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real smee.airGapR.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smee.airGapR.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real smee.airGapR.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real smee.airGapR.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.airGapR.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.airGapR.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.airGapR.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.airGapR.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.airGapR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real smee.airGapR.Lmd(quantity = "Inductance", unit = "H") = smee.Lmd "main field inductance d-axis";
//   parameter Real smee.airGapR.Lmq(quantity = "Inductance", unit = "H") = smee.Lmq "main field inductance q-axis";
//   Real smee.airGapR.i_mr[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   Real smee.airGapR.i_mr[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the rotor fixed frame";
//   protected parameter Real smee.airGapR.L[1,1](quantity = "Inductance", unit = "H") = smee.airGapR.Lmd "inductance matrix";
//   protected parameter Real smee.airGapR.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smee.airGapR.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real smee.airGapR.L[2,2](quantity = "Inductance", unit = "H") = smee.airGapR.Lmq "inductance matrix";
//   parameter Real smee.Lmd(quantity = "Inductance", unit = "H", start = 1.5 * 1.0 / smee.fsNominal / 6.28318530717959) "main field inductance in d-axis";
//   parameter Real smee.Lmq(quantity = "Inductance", unit = "H", start = 1.5 * 1.0 / smee.fsNominal / 6.28318530717959) "main field inductance in q-axis";
//   parameter Boolean smee.useDamperCage(start = true) "enable / disable damper cage";
//   parameter Real smee.Lrsigmad(quantity = "Inductance", unit = "H", start = 0.05 * 1.0 / smee.fsNominal / 6.28318530717959) "damper stray inductance in d-axis";
//   parameter Real smee.Lrsigmaq(quantity = "Inductance", unit = "H") = smee.Lrsigmad "damper stray inductance in q-axis";
//   parameter Real smee.Rrd(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm damper resistance in d-axis";
//   parameter Real smee.Rrq(quantity = "Resistance", unit = "Ohm") = smee.Rrd "warm damper resistance in q-axis";
//   parameter Real smee.VsNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal stator RMS voltage per phase";
//   parameter Real smee.IeOpenCircuit(quantity = "ElectricCurrent", unit = "A", start = 10.0) "open circuit excitation current @ nominal voltage and frequency";
//   parameter Real smee.Re(quantity = "Resistance", unit = "Ohm", start = 2.5) "warm excitation resistance";
//   parameter Real smee.sigmae(min = 0.0, max = 1.0, start = 0.025) "stray fraction of total excitation inductance";
//   output Real smee.ve(quantity = "ElectricPotential", unit = "V") = smee.pin_ep.v - smee.pin_en.v "excitation voltage";
//   output Real smee.ie(quantity = "ElectricCurrent", unit = "A") = smee.pin_ep.i "excitation current";
//   protected parameter Real smee.turnsRatio = 1.4142135623731 * (smee.VsNominal * 1.0 / smee.IeOpenCircuit / smee.Lmd / smee.fsNominal / 6.28318530717959) "stator current / excitation current";
//   protected parameter Real smee.Lesigma(quantity = "Inductance", unit = "H") = 1.5 * (smee.Lmd * (smee.turnsRatio ^ 2.0 * smee.sigmae / (1.0 - smee.sigmae)));
//   parameter Real smee.electricalExcitation.turnsRatio(start = 1.0) = smee.turnsRatio "stator current / excitation current";
//   Real smee.electricalExcitation.ie(quantity = "ElectricCurrent", unit = "A") "excitation current";
//   Real smee.electricalExcitation.ve(quantity = "ElectricPotential", unit = "V") "excitation voltage";
//   Real smee.electricalExcitation.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.electricalExcitation.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.electricalExcitation.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.electricalExcitation.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.electricalExcitation.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean smee.re.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real smee.re.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = smee.re.T_ref "Fixed device temperature if useHeatPort = false";
//   Real smee.re.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real smee.re.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real smee.re.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = smee.Re "Resistance at temperature T_ref";
//   parameter Real smee.re.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real smee.re.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.re.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real smee.lesigma.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real smee.lesigma.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real smee.lesigma.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lesigma.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.lesigma.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.lesigma.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real smee.lesigma.L(quantity = "Inductance", unit = "H", start = 1.0) = smee.Lesigma "Inductance";
//   Real smee.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real smee.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real smee.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaStator.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaStator.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real smee.inertiaStator.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real smee.inertiaStator.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real smee.inertiaStator.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = smee.Js "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) smee.inertiaStator.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real smee.inertiaStator.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real smee.inertiaStator.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real smee.inertiaStator.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   output Real smee.idq_dr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.damperCage.spacePhasor_r.i_[1] "damper space phasor current / rotor fixed frame";
//   output Real smee.idq_dr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = smee.damperCage.spacePhasor_r.i_[2] "damper space phasor current / rotor fixed frame";
//   parameter Real smee.damperCage.Lrsigmad(quantity = "Inductance", unit = "H") = smee.Lrsigmad "stray inductance in d-axis per phase translated to stator";
//   parameter Real smee.damperCage.Lrsigmaq(quantity = "Inductance", unit = "H") = smee.Lrsigmaq "stray inductance in q-axis per phase translated to stator";
//   parameter Real smee.damperCage.Rrd(quantity = "Resistance", unit = "Ohm") = smee.Rrd "warm resistance in d-axis per phase translated to stator";
//   parameter Real smee.damperCage.Rrq(quantity = "Resistance", unit = "Ohm") = smee.Rrq "warm resistance in q-axis per phase translated to stator";
//   Real smee.damperCage.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.damperCage.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real smee.damperCage.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real smee.damperCage.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   constant Integer rotorDisplacementAngle.m = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.p(min = 1) = smee.p "number of pole pairs";
//   parameter Boolean rotorDisplacementAngle.useSupport = true "use support or fixed housing";
//   output Real rotorDisplacementAngle.rotorDisplacementAngle;
//   parameter Integer rotorDisplacementAngle.plug_p.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.plug_n.m(min = 1) = 3 "number of phases";
//   Real rotorDisplacementAngle.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_p.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer rotorDisplacementAngle.VoltageSensor1.plug_n.m(min = 1) = rotorDisplacementAngle.VoltageSensor1.m "number of phases";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real rotorDisplacementAngle.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nin = 3 "Number of inputs";
//   parameter Integer rotorDisplacementAngle.ToSpacePhasorVS.nout = 2 "Number of outputs";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[2] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToSpacePhasorVS.u[3] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.y[2] "Connector of Real output signals";
//   constant Integer rotorDisplacementAngle.ToSpacePhasorVS.m = 3 "number of phases";
//   constant Real rotorDisplacementAngle.ToSpacePhasorVS.pi = 3.14159265358979;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real rotorDisplacementAngle.ToSpacePhasorVS.InverseTransformation[3,2] = -0.866025403784438;
//   output Real rotorDisplacementAngle.ToSpacePhasorVS.zero;
//   Real rotorDisplacementAngle.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.relativeAngleSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real rotorDisplacementAngle.relativeAngleSensor.phi_rel "Relative angle between two flanges (= flange_b.phi - flange_a.phi)";
//   output Real rotorDisplacementAngle.constant_.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.constant_.k(start = 1.0) = 1.5707963267949 "Constant output value";
//   input Real rotorDisplacementAngle.add.u1 "Connector of Real input signal 1";
//   input Real rotorDisplacementAngle.add.u2 "Connector of Real input signal 2";
//   output Real rotorDisplacementAngle.add.y "Connector of Real output signal";
//   parameter Real rotorDisplacementAngle.add.k1 = Real(rotorDisplacementAngle.p) "Gain of upper input";
//   parameter Real rotorDisplacementAngle.add.k2 = 1.0 "Gain of lower input";
//   parameter Integer rotorDisplacementAngle.rotatorVS2R.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.rotatorVS2R.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.rotatorVS2R.y[2] "Connector of Real output signals";
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] = -sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] = sin(-rotorDisplacementAngle.rotatorVS2R.angle);
//   protected Real rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] = cos(-rotorDisplacementAngle.rotatorVS2R.angle);
//   input Real rotorDisplacementAngle.rotatorVS2R.angle;
//   parameter Integer rotorDisplacementAngle.ToPolarVSR.n = 2 "Number of inputs (= number of outputs)";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.ToPolarVSR.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[1] "Connector of Real output signals";
//   output Real rotorDisplacementAngle.ToPolarVSR.y[2] "Connector of Real output signals";
//   constant Real rotorDisplacementAngle.ToPolarVSR.small = 1e-60;
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n1 = 1 "dimension of output signal connector 1";
//   parameter Integer rotorDisplacementAngle.deMultiplex2.n2 = 1 "dimension of output signal connector 2";
//   input Real rotorDisplacementAngle.deMultiplex2.u[1] "Connector of Real input signals";
//   input Real rotorDisplacementAngle.deMultiplex2.u[2] "Connector of Real input signals";
//   output Real rotorDisplacementAngle.deMultiplex2.y1[1] "Connector of Real output signals 1";
//   output Real rotorDisplacementAngle.deMultiplex2.y2[1] "Connector of Real output signals 2";
//   Real rotorDisplacementAngle.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real rotorDisplacementAngle.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real groundExcitation.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundExcitation.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean constantSpeed.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real constantSpeed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real constantSpeed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real constantSpeed.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real constantSpeed.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   Real constantSpeed.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   parameter Real constantSpeed.w_fixed(quantity = "AngularVelocity", unit = "rad/s") = wActual "Fixed speed";
//   Real mechanicalPowerSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Boolean mechanicalPowerSensor.useSupport = true "use support or fixed housing";
//   output Real mechanicalPowerSensor.P;
//   Real mechanicalPowerSensor.torqueSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.torqueSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.torqueSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.torqueSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real mechanicalPowerSensor.torqueSensor.tau "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau)";
//   input Real mechanicalPowerSensor.product.u1 "Connector of Real input signal 1";
//   input Real mechanicalPowerSensor.product.u2 "Connector of Real input signal 2";
//   output Real mechanicalPowerSensor.product.y "Connector of Real output signal";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.relSpeedSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real mechanicalPowerSensor.relSpeedSensor.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg") "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//   output Real mechanicalPowerSensor.relSpeedSensor.w_rel "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi))";
//   Real mechanicalPowerSensor.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real mechanicalPowerSensor.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Integer electricalPowerSensor.m(min = 1) = 3 "Number of phases";
//   output Real electricalPowerSensor.P;
//   output Real electricalPowerSensor.Q;
//   parameter Integer electricalPowerSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensor.plug_ni.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensor.plug_ni.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_ni.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_ni.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_ni.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_ni.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_ni.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensor.plug_nv.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensor.plug_nv.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_nv.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_nv.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_nv.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensor.plug_nv.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensor.plug_nv.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected Real electricalPowerSensor.v_[1](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensor.v_[2](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensor.i_[1](quantity = "ElectricCurrent", unit = "A");
//   protected Real electricalPowerSensor.i_[2](quantity = "ElectricCurrent", unit = "A");
//   constant Integer currentQuasiRMSSensor.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensor.I;
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensor.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensor.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensor.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensor.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensor.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensor.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensor.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensor.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensor.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensor.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensor.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensor.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensor.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensor.ToPolar1.small = 1e-60;
//   parameter Integer sineVoltage.m(min = 1) = 3 "number of phases";
//   Real sineVoltage.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real sineVoltage.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real sineVoltage.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m "number of phases";
//   Real sineVoltage.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real sineVoltage.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real sineVoltage.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(sineVoltage.m) "Phases of sine waves";
//   parameter Real sineVoltage.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequencies of sine waves";
//   parameter Real sineVoltage.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real sineVoltage.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real sineVoltage.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real sineVoltage.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[1] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[1] "Time offset";
//   output Real sineVoltage.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[1] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[1] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[1] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[2] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[2] "Time offset";
//   output Real sineVoltage.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[2] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[2] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[2] "Frequency of sine wave";
//   Real sineVoltage.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = sineVoltage.offset[3] "Voltage offset";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = "Time", unit = "s") = sineVoltage.startTime[3] "Time offset";
//   output Real sineVoltage.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset "Offset of output signal";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = sineVoltage.V[3] "Amplitude of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase[3] "Phase of sine wave";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz[3] "Frequency of sine wave";
//   parameter Integer star.m(min = 1) = 3 "number of phases";
//   parameter Integer star.plug_p.m(min = 1) = star.m "number of phases";
//   Real star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rampCurrent.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real rampCurrent.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real rampCurrent.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rampCurrent.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real rampCurrent.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real rampCurrent.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real rampCurrent.offset(quantity = "ElectricCurrent", unit = "A") = Ie0 "Current offset";
//   parameter Real rampCurrent.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
//   output Real rampCurrent.signalSource.y "Connector of Real output signal";
//   parameter Real rampCurrent.signalSource.height = rampCurrent.I "Height of ramps";
//   parameter Real rampCurrent.signalSource.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = rampCurrent.duration "Durations of ramp";
//   parameter Real rampCurrent.signalSource.offset = rampCurrent.offset "Offset of output signal";
//   parameter Real rampCurrent.signalSource.startTime(quantity = "Time", unit = "s") = rampCurrent.startTime "Output = offset for time < startTime";
//   parameter Real rampCurrent.I(quantity = "ElectricCurrent", unit = "A", start = 1.0) = Ie - Ie0 "Height of ramp";
//   parameter Real rampCurrent.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = 0.1 "Duration of ramp";
//   constant Integer terminalBox.m = 3 "number of phases";
//   parameter String terminalBox.terminalConnection(start = "Y") "choose Y=star/D=delta";
//   parameter Integer terminalBox.plug_sp.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plug_sn.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.plugSupply.m(min = 1) = 3 "number of phases";
//   Real terminalBox.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer terminalBox.star.m(min = 1) = 3 "number of phases";
//   parameter Integer terminalBox.star.plug_p.m(min = 1) = terminalBox.star.m "number of phases";
//   Real terminalBox.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real terminalBox.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real terminalBox.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// equation
//   smee.inertiaRotor.phi = smee.inertiaRotor.flange_a.phi;
//   smee.inertiaRotor.phi = smee.inertiaRotor.flange_b.phi;
//   smee.inertiaRotor.w = der(smee.inertiaRotor.phi);
//   smee.inertiaRotor.a = der(smee.inertiaRotor.w);
//   smee.inertiaRotor.J * smee.inertiaRotor.a = smee.inertiaRotor.flange_a.tau + smee.inertiaRotor.flange_b.tau;
//   assert(1.0 + smee.rs.resistor[1].alpha * (smee.rs.resistor[1].T_heatPort - smee.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.rs.resistor[1].R_actual = smee.rs.resistor[1].R * (1.0 + smee.rs.resistor[1].alpha * (smee.rs.resistor[1].T_heatPort - smee.rs.resistor[1].T_ref));
//   smee.rs.resistor[1].v = smee.rs.resistor[1].R_actual * smee.rs.resistor[1].i;
//   smee.rs.resistor[1].LossPower = smee.rs.resistor[1].v * smee.rs.resistor[1].i;
//   smee.rs.resistor[1].i = smee.rs.resistor[1].p.i;
//   0.0 = smee.rs.resistor[1].p.i + smee.rs.resistor[1].n.i;
//   smee.rs.resistor[1].v = smee.rs.resistor[1].p.v - smee.rs.resistor[1].n.v;
//   smee.rs.resistor[1].T_heatPort = smee.rs.resistor[1].T;
//   assert(1.0 + smee.rs.resistor[2].alpha * (smee.rs.resistor[2].T_heatPort - smee.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.rs.resistor[2].R_actual = smee.rs.resistor[2].R * (1.0 + smee.rs.resistor[2].alpha * (smee.rs.resistor[2].T_heatPort - smee.rs.resistor[2].T_ref));
//   smee.rs.resistor[2].v = smee.rs.resistor[2].R_actual * smee.rs.resistor[2].i;
//   smee.rs.resistor[2].LossPower = smee.rs.resistor[2].v * smee.rs.resistor[2].i;
//   smee.rs.resistor[2].i = smee.rs.resistor[2].p.i;
//   0.0 = smee.rs.resistor[2].p.i + smee.rs.resistor[2].n.i;
//   smee.rs.resistor[2].v = smee.rs.resistor[2].p.v - smee.rs.resistor[2].n.v;
//   smee.rs.resistor[2].T_heatPort = smee.rs.resistor[2].T;
//   assert(1.0 + smee.rs.resistor[3].alpha * (smee.rs.resistor[3].T_heatPort - smee.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.rs.resistor[3].R_actual = smee.rs.resistor[3].R * (1.0 + smee.rs.resistor[3].alpha * (smee.rs.resistor[3].T_heatPort - smee.rs.resistor[3].T_ref));
//   smee.rs.resistor[3].v = smee.rs.resistor[3].R_actual * smee.rs.resistor[3].i;
//   smee.rs.resistor[3].LossPower = smee.rs.resistor[3].v * smee.rs.resistor[3].i;
//   smee.rs.resistor[3].i = smee.rs.resistor[3].p.i;
//   0.0 = smee.rs.resistor[3].p.i + smee.rs.resistor[3].n.i;
//   smee.rs.resistor[3].v = smee.rs.resistor[3].p.v - smee.rs.resistor[3].n.v;
//   smee.rs.resistor[3].T_heatPort = smee.rs.resistor[3].T;
//   smee.rs.v[1] = smee.rs.plug_p.pin[1].v - smee.rs.plug_n.pin[1].v;
//   smee.rs.v[2] = smee.rs.plug_p.pin[2].v - smee.rs.plug_n.pin[2].v;
//   smee.rs.v[3] = smee.rs.plug_p.pin[3].v - smee.rs.plug_n.pin[3].v;
//   smee.rs.i[1] = smee.rs.plug_p.pin[1].i;
//   smee.rs.i[2] = smee.rs.plug_p.pin[2].i;
//   smee.rs.i[3] = smee.rs.plug_p.pin[3].i;
//   smee.lssigma.inductor[1].L * der(smee.lssigma.inductor[1].i) = smee.lssigma.inductor[1].v;
//   smee.lssigma.inductor[1].v = smee.lssigma.inductor[1].p.v - smee.lssigma.inductor[1].n.v;
//   0.0 = smee.lssigma.inductor[1].p.i + smee.lssigma.inductor[1].n.i;
//   smee.lssigma.inductor[1].i = smee.lssigma.inductor[1].p.i;
//   smee.lssigma.inductor[2].L * der(smee.lssigma.inductor[2].i) = smee.lssigma.inductor[2].v;
//   smee.lssigma.inductor[2].v = smee.lssigma.inductor[2].p.v - smee.lssigma.inductor[2].n.v;
//   0.0 = smee.lssigma.inductor[2].p.i + smee.lssigma.inductor[2].n.i;
//   smee.lssigma.inductor[2].i = smee.lssigma.inductor[2].p.i;
//   smee.lssigma.inductor[3].L * der(smee.lssigma.inductor[3].i) = smee.lssigma.inductor[3].v;
//   smee.lssigma.inductor[3].v = smee.lssigma.inductor[3].p.v - smee.lssigma.inductor[3].n.v;
//   0.0 = smee.lssigma.inductor[3].p.i + smee.lssigma.inductor[3].n.i;
//   smee.lssigma.inductor[3].i = smee.lssigma.inductor[3].p.i;
//   smee.lssigma.v[1] = smee.lssigma.plug_p.pin[1].v - smee.lssigma.plug_n.pin[1].v;
//   smee.lssigma.v[2] = smee.lssigma.plug_p.pin[2].v - smee.lssigma.plug_n.pin[2].v;
//   smee.lssigma.v[3] = smee.lssigma.plug_p.pin[3].v - smee.lssigma.plug_n.pin[3].v;
//   smee.lssigma.i[1] = smee.lssigma.plug_p.pin[1].i;
//   smee.lssigma.i[2] = smee.lssigma.plug_p.pin[2].i;
//   smee.lssigma.i[3] = smee.lssigma.plug_p.pin[3].i;
//   smee.spacePhasorS.gnd.p.v = 0.0;
//   smee.spacePhasorS.v[1] / smee.spacePhasorS.turnsRatio = smee.spacePhasorS.plug_p.pin[1].v - smee.spacePhasorS.plug_n.pin[1].v;
//   smee.spacePhasorS.v[2] / smee.spacePhasorS.turnsRatio = smee.spacePhasorS.plug_p.pin[2].v - smee.spacePhasorS.plug_n.pin[2].v;
//   smee.spacePhasorS.v[3] / smee.spacePhasorS.turnsRatio = smee.spacePhasorS.plug_p.pin[3].v - smee.spacePhasorS.plug_n.pin[3].v;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[1] = smee.spacePhasorS.plug_p.pin[1].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[2] = smee.spacePhasorS.plug_p.pin[2].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[3] = smee.spacePhasorS.plug_p.pin[3].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[1] = -smee.spacePhasorS.plug_n.pin[1].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[2] = -smee.spacePhasorS.plug_n.pin[2].i;
//   smee.spacePhasorS.turnsRatio * smee.spacePhasorS.i[3] = -smee.spacePhasorS.plug_n.pin[3].i;
//   smee.spacePhasorS.zero.v = 0.333333333333333 * (smee.spacePhasorS.v[1] + (smee.spacePhasorS.v[2] + smee.spacePhasorS.v[3]));
//   smee.spacePhasorS.spacePhasor.v_[1] = smee.spacePhasorS.TransformationMatrix[1,1] * smee.spacePhasorS.v[1] + (smee.spacePhasorS.TransformationMatrix[1,2] * smee.spacePhasorS.v[2] + smee.spacePhasorS.TransformationMatrix[1,3] * smee.spacePhasorS.v[3]);
//   smee.spacePhasorS.spacePhasor.v_[2] = smee.spacePhasorS.TransformationMatrix[2,1] * smee.spacePhasorS.v[1] + (smee.spacePhasorS.TransformationMatrix[2,2] * smee.spacePhasorS.v[2] + smee.spacePhasorS.TransformationMatrix[2,3] * smee.spacePhasorS.v[3]);
//   -smee.spacePhasorS.zero.i = 0.333333333333333 * (smee.spacePhasorS.i[1] + (smee.spacePhasorS.i[2] + smee.spacePhasorS.i[3]));
//   -smee.spacePhasorS.spacePhasor.i_[1] = smee.spacePhasorS.TransformationMatrix[1,1] * smee.spacePhasorS.i[1] + (smee.spacePhasorS.TransformationMatrix[1,2] * smee.spacePhasorS.i[2] + smee.spacePhasorS.TransformationMatrix[1,3] * smee.spacePhasorS.i[3]);
//   -smee.spacePhasorS.spacePhasor.i_[2] = smee.spacePhasorS.TransformationMatrix[2,1] * smee.spacePhasorS.i[1] + (smee.spacePhasorS.TransformationMatrix[2,2] * smee.spacePhasorS.i[2] + smee.spacePhasorS.TransformationMatrix[2,3] * smee.spacePhasorS.i[3]);
//   smee.airGapR.i_mr[1] = smee.airGapR.i_sr[1] + smee.airGapR.i_rr[1];
//   smee.airGapR.i_mr[2] = smee.airGapR.i_sr[2] + smee.airGapR.i_rr[2];
//   smee.airGapR.psi_mr[1] = smee.airGapR.L[1,1] * smee.airGapR.i_mr[1] + smee.airGapR.L[1,2] * smee.airGapR.i_mr[2];
//   smee.airGapR.psi_mr[2] = smee.airGapR.L[2,1] * smee.airGapR.i_mr[1] + smee.airGapR.L[2,2] * smee.airGapR.i_mr[2];
//   smee.airGapR.psi_ms[1] = smee.airGapR.RotationMatrix[1,1] * smee.airGapR.psi_mr[1] + smee.airGapR.RotationMatrix[1,2] * smee.airGapR.psi_mr[2];
//   smee.airGapR.psi_ms[2] = smee.airGapR.RotationMatrix[2,1] * smee.airGapR.psi_mr[1] + smee.airGapR.RotationMatrix[2,2] * smee.airGapR.psi_mr[2];
//   smee.airGapR.gamma = Real(smee.airGapR.p) * (smee.airGapR.flange.phi - smee.airGapR.support.phi);
//   smee.airGapR.RotationMatrix[1,1] = cos(smee.airGapR.gamma);
//   smee.airGapR.RotationMatrix[1,2] = -sin(smee.airGapR.gamma);
//   smee.airGapR.RotationMatrix[2,1] = sin(smee.airGapR.gamma);
//   smee.airGapR.RotationMatrix[2,2] = cos(smee.airGapR.gamma);
//   smee.airGapR.i_ss[1] = smee.airGapR.spacePhasor_s.i_[1];
//   smee.airGapR.i_ss[2] = smee.airGapR.spacePhasor_s.i_[2];
//   smee.airGapR.i_ss[1] = smee.airGapR.RotationMatrix[1,1] * smee.airGapR.i_sr[1] + smee.airGapR.RotationMatrix[1,2] * smee.airGapR.i_sr[2];
//   smee.airGapR.i_ss[2] = smee.airGapR.RotationMatrix[2,1] * smee.airGapR.i_sr[1] + smee.airGapR.RotationMatrix[2,2] * smee.airGapR.i_sr[2];
//   smee.airGapR.i_rr[1] = smee.airGapR.spacePhasor_r.i_[1];
//   smee.airGapR.i_rr[2] = smee.airGapR.spacePhasor_r.i_[2];
//   smee.airGapR.i_rs[1] = smee.airGapR.RotationMatrix[1,1] * smee.airGapR.i_rr[1] + smee.airGapR.RotationMatrix[1,2] * smee.airGapR.i_rr[2];
//   smee.airGapR.i_rs[2] = smee.airGapR.RotationMatrix[2,1] * smee.airGapR.i_rr[1] + smee.airGapR.RotationMatrix[2,2] * smee.airGapR.i_rr[2];
//   smee.airGapR.spacePhasor_s.v_[1] = der(smee.airGapR.psi_ms[1]);
//   smee.airGapR.spacePhasor_s.v_[2] = der(smee.airGapR.psi_ms[2]);
//   smee.airGapR.spacePhasor_r.v_[1] = der(smee.airGapR.psi_mr[1]);
//   smee.airGapR.spacePhasor_r.v_[2] = der(smee.airGapR.psi_mr[2]);
//   smee.airGapR.tauElectrical = Real(smee.airGapR.m) * (Real(smee.airGapR.p) * (smee.airGapR.spacePhasor_s.i_[2] * smee.airGapR.psi_ms[1] - smee.airGapR.spacePhasor_s.i_[1] * smee.airGapR.psi_ms[2]) / 2.0);
//   smee.airGapR.flange.tau = -smee.airGapR.tauElectrical;
//   smee.airGapR.support.tau = smee.airGapR.tauElectrical;
//   smee.electricalExcitation.pin_ep.i + smee.electricalExcitation.pin_en.i = 0.0;
//   smee.electricalExcitation.ie = smee.electricalExcitation.pin_ep.i;
//   smee.electricalExcitation.ve = smee.electricalExcitation.pin_ep.v - smee.electricalExcitation.pin_en.v;
//   smee.electricalExcitation.spacePhasor_r.i_[1] = (-smee.electricalExcitation.ie) * smee.electricalExcitation.turnsRatio;
//   smee.electricalExcitation.spacePhasor_r.i_[2] = 0.0;
//   smee.electricalExcitation.ve = 1.5 * (smee.electricalExcitation.spacePhasor_r.v_[1] * smee.electricalExcitation.turnsRatio);
//   assert(1.0 + smee.re.alpha * (smee.re.T_heatPort - smee.re.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   smee.re.R_actual = smee.re.R * (1.0 + smee.re.alpha * (smee.re.T_heatPort - smee.re.T_ref));
//   smee.re.v = smee.re.R_actual * smee.re.i;
//   smee.re.LossPower = smee.re.v * smee.re.i;
//   smee.re.i = smee.re.p.i;
//   0.0 = smee.re.p.i + smee.re.n.i;
//   smee.re.v = smee.re.p.v - smee.re.n.v;
//   smee.re.T_heatPort = smee.re.T;
//   smee.lesigma.L * der(smee.lesigma.i) = smee.lesigma.v;
//   smee.lesigma.v = smee.lesigma.p.v - smee.lesigma.n.v;
//   0.0 = smee.lesigma.p.i + smee.lesigma.n.i;
//   smee.lesigma.i = smee.lesigma.p.i;
//   smee.inertiaStator.phi = smee.inertiaStator.flange_a.phi;
//   smee.inertiaStator.phi = smee.inertiaStator.flange_b.phi;
//   smee.inertiaStator.w = der(smee.inertiaStator.phi);
//   smee.inertiaStator.a = der(smee.inertiaStator.w);
//   smee.inertiaStator.J * smee.inertiaStator.a = smee.inertiaStator.flange_a.tau + smee.inertiaStator.flange_b.tau;
//   smee.damperCage.spacePhasor_r.v_[1] = smee.damperCage.Rrd * smee.damperCage.spacePhasor_r.i_[1] + smee.damperCage.Lrsigmad * der(smee.damperCage.spacePhasor_r.i_[1]);
//   smee.damperCage.spacePhasor_r.v_[2] = smee.damperCage.Rrq * smee.damperCage.spacePhasor_r.i_[2] + smee.damperCage.Lrsigmaq * der(smee.damperCage.spacePhasor_r.i_[2]);
//   assert(smee.spacePhasorS.plug_n.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(smee.lssigma.plug_n.m == smee.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(smee.rs.plug_n.m == smee.lssigma.plug_p.m,"automatically generated from connect");
//   assert(smee.plug_sp.m == smee.rs.plug_p.m,"automatically generated from connect");
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v - rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.ToSpacePhasorVS.zero = 0.333333333333333 * (rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.u[3]));
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[1,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,1] * rotorDisplacementAngle.ToSpacePhasorVS.u[1] + (rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,2] * rotorDisplacementAngle.ToSpacePhasorVS.u[2] + rotorDisplacementAngle.ToSpacePhasorVS.TransformationMatrix[2,3] * rotorDisplacementAngle.ToSpacePhasorVS.u[3]);
//   rotorDisplacementAngle.relativeAngleSensor.phi_rel = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi - rotorDisplacementAngle.relativeAngleSensor.flange_a.phi;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau;
//   0.0 = rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + rotorDisplacementAngle.relativeAngleSensor.flange_b.tau;
//   rotorDisplacementAngle.constant_.y = rotorDisplacementAngle.constant_.k;
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.add.k1 * rotorDisplacementAngle.add.u1 + rotorDisplacementAngle.add.k2 * rotorDisplacementAngle.add.u2;
//   rotorDisplacementAngle.rotatorVS2R.y[1] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[1,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.rotatorVS2R.y[2] = rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,1] * rotorDisplacementAngle.rotatorVS2R.u[1] + rotorDisplacementAngle.rotatorVS2R.RotationMatrix[2,2] * rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.ToPolarVSR.y[1] = sqrt(rotorDisplacementAngle.ToPolarVSR.u[1] ^ 2.0 + rotorDisplacementAngle.ToPolarVSR.u[2] ^ 2.0);
//   rotorDisplacementAngle.ToPolarVSR.y[2] = if noEvent(rotorDisplacementAngle.ToPolarVSR.y[1] <= 1e-60) then 0.0 else atan2(rotorDisplacementAngle.ToPolarVSR.u[2],rotorDisplacementAngle.ToPolarVSR.u[1]);
//   rotorDisplacementAngle.deMultiplex2.u[1] = rotorDisplacementAngle.deMultiplex2.y1[1];
//   rotorDisplacementAngle.deMultiplex2.u[2] = rotorDisplacementAngle.deMultiplex2.y2[1];
//   assert(rotorDisplacementAngle.plug_p.m == rotorDisplacementAngle.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_n.m == rotorDisplacementAngle.VoltageSensor1.plug_n.m,"automatically generated from connect");
//   groundExcitation.p.v = 0.0;
//   constantSpeed.w = der(constantSpeed.phi);
//   constantSpeed.w = constantSpeed.w_fixed;
//   constantSpeed.phi = constantSpeed.flange.phi - constantSpeed.phi_support;
//   constantSpeed.phi_support = 0.0;
//   mechanicalPowerSensor.torqueSensor.flange_a.phi = mechanicalPowerSensor.torqueSensor.flange_b.phi;
//   mechanicalPowerSensor.torqueSensor.flange_a.tau = mechanicalPowerSensor.torqueSensor.tau;
//   0.0 = mechanicalPowerSensor.torqueSensor.flange_a.tau + mechanicalPowerSensor.torqueSensor.flange_b.tau;
//   mechanicalPowerSensor.product.y = mechanicalPowerSensor.product.u1 * mechanicalPowerSensor.product.u2;
//   mechanicalPowerSensor.relSpeedSensor.phi_rel = mechanicalPowerSensor.relSpeedSensor.flange_b.phi - mechanicalPowerSensor.relSpeedSensor.flange_a.phi;
//   mechanicalPowerSensor.relSpeedSensor.w_rel = der(mechanicalPowerSensor.relSpeedSensor.phi_rel);
//   0.0 = mechanicalPowerSensor.relSpeedSensor.flange_a.tau;
//   0.0 = mechanicalPowerSensor.relSpeedSensor.flange_a.tau + mechanicalPowerSensor.relSpeedSensor.flange_b.tau;
//   electricalPowerSensor.plug_p.pin[1].v = electricalPowerSensor.plug_ni.pin[1].v;
//   electricalPowerSensor.plug_p.pin[2].v = electricalPowerSensor.plug_ni.pin[2].v;
//   electricalPowerSensor.plug_p.pin[3].v = electricalPowerSensor.plug_ni.pin[3].v;
//   electricalPowerSensor.plug_p.pin[1].i + electricalPowerSensor.plug_ni.pin[1].i = 0.0;
//   electricalPowerSensor.plug_p.pin[2].i + electricalPowerSensor.plug_ni.pin[2].i = 0.0;
//   electricalPowerSensor.plug_p.pin[3].i + electricalPowerSensor.plug_ni.pin[3].i = 0.0;
//   electricalPowerSensor.plug_nv.pin[1].i = 0.0;
//   electricalPowerSensor.plug_nv.pin[2].i = 0.0;
//   electricalPowerSensor.plug_nv.pin[3].i = 0.0;
//   (electricalPowerSensor.v_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensor.plug_p.pin[1].v - electricalPowerSensor.plug_nv.pin[1].v,electricalPowerSensor.plug_p.pin[2].v - electricalPowerSensor.plug_nv.pin[2].v,electricalPowerSensor.plug_p.pin[3].v - electricalPowerSensor.plug_nv.pin[3].v});
//   (electricalPowerSensor.i_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensor.plug_p.pin[1].i,electricalPowerSensor.plug_p.pin[2].i,electricalPowerSensor.plug_p.pin[3].i});
//   0.666666666666667 * electricalPowerSensor.P = electricalPowerSensor.v_[1] * electricalPowerSensor.i_[1] + electricalPowerSensor.v_[2] * electricalPowerSensor.i_[2];
//   0.666666666666667 * electricalPowerSensor.Q = (-electricalPowerSensor.v_[1]) * electricalPowerSensor.i_[2] + electricalPowerSensor.v_[2] * electricalPowerSensor.i_[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.Gain1.k * currentQuasiRMSSensor.Gain1.u;
//   currentQuasiRMSSensor.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensor.ToSpacePhasor1.y[1] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToSpacePhasor1.y[2] = currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensor.ToSpacePhasor1.u[1] + (currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensor.ToSpacePhasor1.u[2] + currentQuasiRMSSensor.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensor.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensor.ToPolar1.y[1] = sqrt(currentQuasiRMSSensor.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensor.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensor.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensor.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensor.ToPolar1.u[2],currentQuasiRMSSensor.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensor.plug_p.m == currentQuasiRMSSensor.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensor.CurrentSensor1.plug_n.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   ground.p.v = 0.0;
//   rampCurrent.signalSource.y = rampCurrent.signalSource.offset + (if time < rampCurrent.signalSource.startTime then 0.0 else if time < rampCurrent.signalSource.startTime + rampCurrent.signalSource.duration then ((time - rampCurrent.signalSource.startTime) * rampCurrent.signalSource.height) / rampCurrent.signalSource.duration else rampCurrent.signalSource.height);
//   rampCurrent.i = rampCurrent.signalSource.y;
//   rampCurrent.v = rampCurrent.p.v - rampCurrent.n.v;
//   0.0 = rampCurrent.p.i + rampCurrent.n.i;
//   rampCurrent.i = rampCurrent.p.i;
//   assert(terminalBox.plug_sn.m == terminalBox.star.plug_p.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == terminalBox.plugSupply.m,"automatically generated from connect");
//   fixed.flange.phi = fixed.phi0;
//   assert(rotorDisplacementAngle.plug_n.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(rotorDisplacementAngle.plug_p.m == smee.plug_sp.m,"automatically generated from connect");
//   assert(star.plug_p.m == sineVoltage.plug_n.m,"automatically generated from connect");
//   assert(electricalPowerSensor.plug_ni.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(sineVoltage.plug_p.m == electricalPowerSensor.plug_p.m,"automatically generated from connect");
//   assert(electricalPowerSensor.plug_nv.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plugSupply.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(terminalBox.plug_sn.m == smee.plug_sn.m,"automatically generated from connect");
//   assert(terminalBox.plug_sp.m == smee.plug_sp.m,"automatically generated from connect");
//   smee.flange.tau + (rotorDisplacementAngle.flange.tau + mechanicalPowerSensor.flange_a.tau) = 0.0;
//   mechanicalPowerSensor.flange_a.phi = rotorDisplacementAngle.flange.phi;
//   mechanicalPowerSensor.flange_a.phi = smee.flange.phi;
//   rotorDisplacementAngle.support.tau + (smee.support.tau + (mechanicalPowerSensor.support.tau + fixed.flange.tau)) = 0.0;
//   fixed.flange.phi = mechanicalPowerSensor.support.phi;
//   fixed.flange.phi = rotorDisplacementAngle.support.phi;
//   fixed.flange.phi = smee.support.phi;
//   terminalBox.plug_sp.pin[3].i + (rotorDisplacementAngle.plug_p.pin[3].i + smee.plug_sp.pin[3].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[3].v = smee.plug_sp.pin[3].v;
//   rotorDisplacementAngle.plug_p.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   terminalBox.plug_sp.pin[2].i + (rotorDisplacementAngle.plug_p.pin[2].i + smee.plug_sp.pin[2].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[2].v = smee.plug_sp.pin[2].v;
//   rotorDisplacementAngle.plug_p.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   terminalBox.plug_sp.pin[1].i + (rotorDisplacementAngle.plug_p.pin[1].i + smee.plug_sp.pin[1].i) = 0.0;
//   rotorDisplacementAngle.plug_p.pin[1].v = smee.plug_sp.pin[1].v;
//   rotorDisplacementAngle.plug_p.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   terminalBox.plug_sn.pin[3].i + (electricalPowerSensor.plug_nv.pin[3].i + (rotorDisplacementAngle.plug_n.pin[3].i + smee.plug_sn.pin[3].i)) = 0.0;
//   electricalPowerSensor.plug_nv.pin[3].v = rotorDisplacementAngle.plug_n.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[3].v = smee.plug_sn.pin[3].v;
//   electricalPowerSensor.plug_nv.pin[3].v = terminalBox.plug_sn.pin[3].v;
//   terminalBox.plug_sn.pin[2].i + (electricalPowerSensor.plug_nv.pin[2].i + (rotorDisplacementAngle.plug_n.pin[2].i + smee.plug_sn.pin[2].i)) = 0.0;
//   electricalPowerSensor.plug_nv.pin[2].v = rotorDisplacementAngle.plug_n.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[2].v = smee.plug_sn.pin[2].v;
//   electricalPowerSensor.plug_nv.pin[2].v = terminalBox.plug_sn.pin[2].v;
//   terminalBox.plug_sn.pin[1].i + (electricalPowerSensor.plug_nv.pin[1].i + (rotorDisplacementAngle.plug_n.pin[1].i + smee.plug_sn.pin[1].i)) = 0.0;
//   electricalPowerSensor.plug_nv.pin[1].v = rotorDisplacementAngle.plug_n.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = smee.plug_sn.pin[1].v;
//   electricalPowerSensor.plug_nv.pin[1].v = terminalBox.plug_sn.pin[1].v;
//   terminalBox.plugSupply.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = terminalBox.plugSupply.pin[3].v;
//   terminalBox.plugSupply.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = terminalBox.plugSupply.pin[2].v;
//   terminalBox.plugSupply.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = terminalBox.plugSupply.pin[1].v;
//   rampCurrent.n.i + smee.pin_ep.i = 0.0;
//   rampCurrent.n.v = smee.pin_ep.v;
//   rampCurrent.p.i + (groundExcitation.p.i + smee.pin_en.i) = 0.0;
//   groundExcitation.p.v = rampCurrent.p.v;
//   groundExcitation.p.v = smee.pin_en.v;
//   sineVoltage.plug_p.pin[3].i + electricalPowerSensor.plug_p.pin[3].i = 0.0;
//   electricalPowerSensor.plug_p.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + electricalPowerSensor.plug_p.pin[2].i = 0.0;
//   electricalPowerSensor.plug_p.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + electricalPowerSensor.plug_p.pin[1].i = 0.0;
//   electricalPowerSensor.plug_p.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   mechanicalPowerSensor.flange_b.tau + constantSpeed.flange.tau = 0.0;
//   constantSpeed.flange.phi = mechanicalPowerSensor.flange_b.phi;
//   electricalPowerSensor.plug_ni.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = electricalPowerSensor.plug_ni.pin[3].v;
//   electricalPowerSensor.plug_ni.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = electricalPowerSensor.plug_ni.pin[2].v;
//   electricalPowerSensor.plug_ni.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = electricalPowerSensor.plug_ni.pin[1].v;
//   star.plug_p.pin[3].i + sineVoltage.plug_n.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = star.plug_p.pin[3].v;
//   star.plug_p.pin[2].i + sineVoltage.plug_n.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = star.plug_p.pin[2].v;
//   star.plug_p.pin[1].i + sineVoltage.plug_n.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = star.plug_p.pin[1].v;
//   star.pin_n.i + ground.p.i = 0.0;
//   ground.p.v = star.pin_n.v;
//   terminalBox.star.pin_n.i + (-terminalBox.starpoint.i) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.starpoint.v;
//   (-terminalBox.plug_sp.pin[3].i) + (-terminalBox.plugSupply.pin[3].i) = 0.0;
//   terminalBox.plugSupply.pin[3].v = terminalBox.plug_sp.pin[3].v;
//   (-terminalBox.plug_sp.pin[2].i) + (-terminalBox.plugSupply.pin[2].i) = 0.0;
//   terminalBox.plugSupply.pin[2].v = terminalBox.plug_sp.pin[2].v;
//   (-terminalBox.plug_sp.pin[1].i) + (-terminalBox.plugSupply.pin[1].i) = 0.0;
//   terminalBox.plugSupply.pin[1].v = terminalBox.plug_sp.pin[1].v;
//   (-terminalBox.plug_sn.pin[3].i) + terminalBox.star.plug_p.pin[3].i = 0.0;
//   terminalBox.plug_sn.pin[3].v = terminalBox.star.plug_p.pin[3].v;
//   (-terminalBox.plug_sn.pin[2].i) + terminalBox.star.plug_p.pin[2].i = 0.0;
//   terminalBox.plug_sn.pin[2].v = terminalBox.star.plug_p.pin[2].v;
//   (-terminalBox.plug_sn.pin[1].i) + terminalBox.star.plug_p.pin[1].i = 0.0;
//   terminalBox.plug_sn.pin[1].v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.starpoint.i = 0.0;
//   (-terminalBox.star.plug_p.pin[3].i) + ((-terminalBox.star.plug_p.pin[2].i) + ((-terminalBox.star.plug_p.pin[1].i) + (-terminalBox.star.pin_n.i))) = 0.0;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[1].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[2].v;
//   terminalBox.star.pin_n.v = terminalBox.star.plug_p.pin[3].v;
//   (-star.plug_p.pin[3].i) + ((-star.plug_p.pin[2].i) + ((-star.plug_p.pin[1].i) + (-star.pin_n.i))) = 0.0;
//   star.pin_n.v = star.plug_p.pin[1].v;
//   star.pin_n.v = star.plug_p.pin[2].v;
//   star.pin_n.v = star.plug_p.pin[3].v;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
//   currentQuasiRMSSensor.Gain1.y = currentQuasiRMSSensor.I;
//   currentQuasiRMSSensor.Gain1.u = currentQuasiRMSSensor.ToPolar1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[1] = currentQuasiRMSSensor.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensor.ToPolar1.u[2] = currentQuasiRMSSensor.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[1] = currentQuasiRMSSensor.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensor.CurrentSensor1.i[2] = currentQuasiRMSSensor.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensor.CurrentSensor1.i[3] = currentQuasiRMSSensor.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensor.CurrentSensor1.i[1];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensor.CurrentSensor1.i[2];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensor.CurrentSensor1.i[3];
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensor.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensor.CurrentSensor1.plug_p.pin[1].v;
//   mechanicalPowerSensor.relSpeedSensor.flange_a.tau + (-mechanicalPowerSensor.support.tau) = 0.0;
//   mechanicalPowerSensor.relSpeedSensor.flange_a.phi = mechanicalPowerSensor.support.phi;
//   mechanicalPowerSensor.product.u1 = mechanicalPowerSensor.relSpeedSensor.w_rel;
//   (-mechanicalPowerSensor.flange_a.tau) + (mechanicalPowerSensor.torqueSensor.flange_a.tau + mechanicalPowerSensor.relSpeedSensor.flange_b.tau) = 0.0;
//   mechanicalPowerSensor.flange_a.phi = mechanicalPowerSensor.relSpeedSensor.flange_b.phi;
//   mechanicalPowerSensor.flange_a.phi = mechanicalPowerSensor.torqueSensor.flange_a.phi;
//   mechanicalPowerSensor.product.u2 = mechanicalPowerSensor.torqueSensor.tau;
//   mechanicalPowerSensor.P = mechanicalPowerSensor.product.y;
//   mechanicalPowerSensor.torqueSensor.flange_b.tau + (-mechanicalPowerSensor.flange_b.tau) = 0.0;
//   mechanicalPowerSensor.flange_b.phi = mechanicalPowerSensor.torqueSensor.flange_b.phi;
//   rotorDisplacementAngle.relativeAngleSensor.flange_a.tau + (-rotorDisplacementAngle.support.tau) = 0.0;
//   rotorDisplacementAngle.relativeAngleSensor.flange_a.phi = rotorDisplacementAngle.support.phi;
//   rotorDisplacementAngle.relativeAngleSensor.flange_b.tau + (-rotorDisplacementAngle.flange.tau) = 0.0;
//   rotorDisplacementAngle.flange.phi = rotorDisplacementAngle.relativeAngleSensor.flange_b.phi;
//   rotorDisplacementAngle.add.u1 = rotorDisplacementAngle.relativeAngleSensor.phi_rel;
//   rotorDisplacementAngle.deMultiplex2.y2[1] = rotorDisplacementAngle.rotorDisplacementAngle;
//   rotorDisplacementAngle.ToSpacePhasorVS.u[1] = rotorDisplacementAngle.VoltageSensor1.v[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[2] = rotorDisplacementAngle.VoltageSensor1.v[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.u[3] = rotorDisplacementAngle.VoltageSensor1.v[3];
//   (-rotorDisplacementAngle.plug_n.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v = rotorDisplacementAngle.plug_n.pin[3].v;
//   (-rotorDisplacementAngle.plug_n.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v = rotorDisplacementAngle.plug_n.pin[2].v;
//   (-rotorDisplacementAngle.plug_n.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v = rotorDisplacementAngle.plug_n.pin[1].v;
//   (-rotorDisplacementAngle.plug_p.pin[3].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v = rotorDisplacementAngle.plug_p.pin[3].v;
//   (-rotorDisplacementAngle.plug_p.pin[2].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v = rotorDisplacementAngle.plug_p.pin[2].v;
//   (-rotorDisplacementAngle.plug_p.pin[1].i) + rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v = rotorDisplacementAngle.plug_p.pin[1].v;
//   rotorDisplacementAngle.ToPolarVSR.y[1] = rotorDisplacementAngle.deMultiplex2.u[1];
//   rotorDisplacementAngle.ToPolarVSR.y[2] = rotorDisplacementAngle.deMultiplex2.u[2];
//   rotorDisplacementAngle.ToPolarVSR.u[1] = rotorDisplacementAngle.rotatorVS2R.y[1];
//   rotorDisplacementAngle.ToPolarVSR.u[2] = rotorDisplacementAngle.rotatorVS2R.y[2];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[1] = rotorDisplacementAngle.rotatorVS2R.u[1];
//   rotorDisplacementAngle.ToSpacePhasorVS.y[2] = rotorDisplacementAngle.rotatorVS2R.u[2];
//   rotorDisplacementAngle.add.y = rotorDisplacementAngle.rotatorVS2R.angle;
//   rotorDisplacementAngle.add.u2 = rotorDisplacementAngle.constant_.y;
//   rotorDisplacementAngle.VoltageSensor1.v[1] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].v;
//   rotorDisplacementAngle.VoltageSensor1.v[2] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].v;
//   rotorDisplacementAngle.VoltageSensor1.v[3] = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.i + (-rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_p.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].p.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[3].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[3].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[2].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[2].n.v;
//   rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.i + (-rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   rotorDisplacementAngle.VoltageSensor1.plug_n.pin[1].v = rotorDisplacementAngle.VoltageSensor1.voltageSensor[1].n.v;
//   smee.airGapR.support.tau + ((-smee.internalSupport.tau) + smee.inertiaStator.flange_a.tau) = 0.0;
//   smee.airGapR.support.phi = smee.inertiaStator.flange_a.phi;
//   smee.airGapR.support.phi = smee.internalSupport.phi;
//   smee.inertiaStator.flange_b.tau + (-smee.support.tau) = 0.0;
//   smee.inertiaStator.flange_b.phi = smee.support.phi;
//   smee.inertiaRotor.flange_b.tau + (-smee.flange.tau) = 0.0;
//   smee.flange.phi = smee.inertiaRotor.flange_b.phi;
//   (-smee.plug_sp.pin[3].i) + smee.rs.plug_p.pin[3].i = 0.0;
//   smee.plug_sp.pin[3].v = smee.rs.plug_p.pin[3].v;
//   (-smee.plug_sp.pin[2].i) + smee.rs.plug_p.pin[2].i = 0.0;
//   smee.plug_sp.pin[2].v = smee.rs.plug_p.pin[2].v;
//   (-smee.plug_sp.pin[1].i) + smee.rs.plug_p.pin[1].i = 0.0;
//   smee.plug_sp.pin[1].v = smee.rs.plug_p.pin[1].v;
//   smee.rs.plug_n.pin[3].i + smee.lssigma.plug_p.pin[3].i = 0.0;
//   smee.lssigma.plug_p.pin[3].v = smee.rs.plug_n.pin[3].v;
//   smee.rs.plug_n.pin[2].i + smee.lssigma.plug_p.pin[2].i = 0.0;
//   smee.lssigma.plug_p.pin[2].v = smee.rs.plug_n.pin[2].v;
//   smee.rs.plug_n.pin[1].i + smee.lssigma.plug_p.pin[1].i = 0.0;
//   smee.lssigma.plug_p.pin[1].v = smee.rs.plug_n.pin[1].v;
//   smee.lssigma.plug_n.pin[3].i + smee.spacePhasorS.plug_p.pin[3].i = 0.0;
//   smee.lssigma.plug_n.pin[3].v = smee.spacePhasorS.plug_p.pin[3].v;
//   smee.lssigma.plug_n.pin[2].i + smee.spacePhasorS.plug_p.pin[2].i = 0.0;
//   smee.lssigma.plug_n.pin[2].v = smee.spacePhasorS.plug_p.pin[2].v;
//   smee.lssigma.plug_n.pin[1].i + smee.spacePhasorS.plug_p.pin[1].i = 0.0;
//   smee.lssigma.plug_n.pin[1].v = smee.spacePhasorS.plug_p.pin[1].v;
//   smee.spacePhasorS.plug_n.pin[3].i + (-smee.plug_sn.pin[3].i) = 0.0;
//   smee.plug_sn.pin[3].v = smee.spacePhasorS.plug_n.pin[3].v;
//   smee.spacePhasorS.plug_n.pin[2].i + (-smee.plug_sn.pin[2].i) = 0.0;
//   smee.plug_sn.pin[2].v = smee.spacePhasorS.plug_n.pin[2].v;
//   smee.spacePhasorS.plug_n.pin[1].i + (-smee.plug_sn.pin[1].i) = 0.0;
//   smee.plug_sn.pin[1].v = smee.spacePhasorS.plug_n.pin[1].v;
//   smee.spacePhasorS.ground.i + smee.spacePhasorS.zero.i = 0.0;
//   smee.spacePhasorS.ground.v = smee.spacePhasorS.zero.v;
//   smee.airGapR.flange.tau + smee.inertiaRotor.flange_a.tau = 0.0;
//   smee.airGapR.flange.phi = smee.inertiaRotor.flange_a.phi;
//   smee.spacePhasorS.spacePhasor.i_[1] + smee.airGapR.spacePhasor_s.i_[1] = 0.0;
//   smee.spacePhasorS.spacePhasor.i_[2] + smee.airGapR.spacePhasor_s.i_[2] = 0.0;
//   smee.airGapR.spacePhasor_s.v_[1] = smee.spacePhasorS.spacePhasor.v_[1];
//   smee.airGapR.spacePhasor_s.v_[2] = smee.spacePhasorS.spacePhasor.v_[2];
//   smee.airGapR.spacePhasor_r.i_[1] + (smee.damperCage.spacePhasor_r.i_[1] + smee.electricalExcitation.spacePhasor_r.i_[1]) = 0.0;
//   smee.airGapR.spacePhasor_r.i_[2] + (smee.damperCage.spacePhasor_r.i_[2] + smee.electricalExcitation.spacePhasor_r.i_[2]) = 0.0;
//   smee.airGapR.spacePhasor_r.v_[1] = smee.damperCage.spacePhasor_r.v_[1];
//   smee.airGapR.spacePhasor_r.v_[1] = smee.electricalExcitation.spacePhasor_r.v_[1];
//   smee.airGapR.spacePhasor_r.v_[2] = smee.damperCage.spacePhasor_r.v_[2];
//   smee.airGapR.spacePhasor_r.v_[2] = smee.electricalExcitation.spacePhasor_r.v_[2];
//   smee.lesigma.n.i + smee.electricalExcitation.pin_ep.i = 0.0;
//   smee.electricalExcitation.pin_ep.v = smee.lesigma.n.v;
//   smee.lesigma.p.i + smee.re.n.i = 0.0;
//   smee.lesigma.p.v = smee.re.n.v;
//   (-smee.pin_ep.i) + smee.re.p.i = 0.0;
//   smee.pin_ep.v = smee.re.p.v;
//   smee.electricalExcitation.pin_en.i + (-smee.pin_en.i) = 0.0;
//   smee.electricalExcitation.pin_en.v = smee.pin_en.v;
//   smee.spacePhasorS.gnd.p.i + (-smee.spacePhasorS.ground.i) = 0.0;
//   smee.spacePhasorS.gnd.p.v = smee.spacePhasorS.ground.v;
//   smee.lssigma.inductor[3].n.i + (-smee.lssigma.plug_n.pin[3].i) = 0.0;
//   smee.lssigma.inductor[3].n.v = smee.lssigma.plug_n.pin[3].v;
//   smee.lssigma.inductor[2].n.i + (-smee.lssigma.plug_n.pin[2].i) = 0.0;
//   smee.lssigma.inductor[2].n.v = smee.lssigma.plug_n.pin[2].v;
//   smee.lssigma.inductor[1].n.i + (-smee.lssigma.plug_n.pin[1].i) = 0.0;
//   smee.lssigma.inductor[1].n.v = smee.lssigma.plug_n.pin[1].v;
//   smee.lssigma.inductor[3].p.i + (-smee.lssigma.plug_p.pin[3].i) = 0.0;
//   smee.lssigma.inductor[3].p.v = smee.lssigma.plug_p.pin[3].v;
//   smee.lssigma.inductor[2].p.i + (-smee.lssigma.plug_p.pin[2].i) = 0.0;
//   smee.lssigma.inductor[2].p.v = smee.lssigma.plug_p.pin[2].v;
//   smee.lssigma.inductor[1].p.i + (-smee.lssigma.plug_p.pin[1].i) = 0.0;
//   smee.lssigma.inductor[1].p.v = smee.lssigma.plug_p.pin[1].v;
//   smee.rs.resistor[3].n.i + (-smee.rs.plug_n.pin[3].i) = 0.0;
//   smee.rs.plug_n.pin[3].v = smee.rs.resistor[3].n.v;
//   smee.rs.resistor[2].n.i + (-smee.rs.plug_n.pin[2].i) = 0.0;
//   smee.rs.plug_n.pin[2].v = smee.rs.resistor[2].n.v;
//   smee.rs.resistor[1].n.i + (-smee.rs.plug_n.pin[1].i) = 0.0;
//   smee.rs.plug_n.pin[1].v = smee.rs.resistor[1].n.v;
//   smee.rs.resistor[3].p.i + (-smee.rs.plug_p.pin[3].i) = 0.0;
//   smee.rs.plug_p.pin[3].v = smee.rs.resistor[3].p.v;
//   smee.rs.resistor[2].p.i + (-smee.rs.plug_p.pin[2].i) = 0.0;
//   smee.rs.plug_p.pin[2].v = smee.rs.resistor[2].p.v;
//   smee.rs.resistor[1].p.i + (-smee.rs.plug_p.pin[1].i) = 0.0;
//   smee.rs.plug_p.pin[1].v = smee.rs.resistor[1].p.v;
//   smee.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.SMEE_Generator;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.SMEE_Generator completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.SMEE_Generator has 501 equation(s) and 501 variable(s).
// 358 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// class Modelica.Electrical.Machines.Examples.DCPM_Start
//   parameter Real Va(quantity = "ElectricPotential", unit = "V") = 100.0 "actual armature voltage";
//   parameter Real tStart(quantity = "Time", unit = "s") = 0.2 "armature voltage ramp";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 0.8 "armature voltage ramp";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 63.66 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.5 "time of load torque step";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "load's moment of inertia";
//   constant Real dcpm.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real dcpm.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.15) "rotor's moment of inertia";
//   parameter Boolean dcpm.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real dcpm.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = dcpm.Jr) "stator's moment of inertia";
//   output Real dcpm.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = dcpm.flange.phi - dcpm.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real dcpm.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(dcpm.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real dcpm.tauElectrical(quantity = "Torque", unit = "N.m") = dcpm.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real dcpm.tauShaft(quantity = "Torque", unit = "N.m") = -dcpm.flange.tau "shaft torque";
//   Real dcpm.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcpm.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcpm.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcpm.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcpm.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcpm.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real dcpm.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = dcpm.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) dcpm.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real dcpm.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real dcpm.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real dcpm.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real dcpm.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real dcpm.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   parameter Real dcpm.VaNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal armature voltage";
//   parameter Real dcpm.IaNominal(quantity = "ElectricCurrent", unit = "A", start = 100.0) "nominal armature current";
//   parameter Real dcpm.wNominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min", start = 149.225651045515) "nominal speed";
//   parameter Real dcpm.Ra(quantity = "Resistance", unit = "Ohm", start = 0.05) "warm armature resistance";
//   parameter Real dcpm.La(quantity = "Inductance", unit = "H", start = 0.0015) "armature inductance";
//   parameter Real dcpm.turnsRatio = (dcpm.VaNominal - dcpm.Ra * dcpm.IaNominal) / dcpm.wNominal "ratio of armature turns over number of turns of the excitation winding";
//   output Real dcpm.va(quantity = "ElectricPotential", unit = "V") = dcpm.pin_ap.v - dcpm.pin_an.v "armature voltage";
//   output Real dcpm.ia(quantity = "ElectricCurrent", unit = "A") = dcpm.pin_ap.i "armature current";
//   Real dcpm.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.ra.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcpm.ra.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcpm.ra.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.ra.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.ra.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.ra.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean dcpm.ra.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real dcpm.ra.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = dcpm.ra.T_ref "Fixed device temperature if useHeatPort = false";
//   Real dcpm.ra.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real dcpm.ra.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real dcpm.ra.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = dcpm.Ra "Resistance at temperature T_ref";
//   parameter Real dcpm.ra.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real dcpm.ra.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcpm.ra.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcpm.la.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcpm.la.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcpm.la.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.la.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.la.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.la.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcpm.la.L(quantity = "Inductance", unit = "H", start = 1.0) = dcpm.La "Inductance";
//   parameter Real dcpm.airGapDC.turnsRatio = dcpm.turnsRatio "ratio of armature turns over number of turns of the excitation winding";
//   Real dcpm.airGapDC.w(quantity = "AngularVelocity", unit = "rad/s") "Angluar velocity";
//   Real dcpm.airGapDC.vei(quantity = "ElectricPotential", unit = "V") "Voltage drop across field excitation inductance";
//   Real dcpm.airGapDC.ie(quantity = "ElectricCurrent", unit = "A") "Excitation current";
//   Real dcpm.airGapDC.psi_e(quantity = "MagneticFlux", unit = "Wb") "Excitation flux";
//   Real dcpm.airGapDC.vai(quantity = "ElectricPotential", unit = "V") "Induced armature voltage";
//   Real dcpm.airGapDC.ia(quantity = "ElectricCurrent", unit = "A") "Armature current";
//   output Real dcpm.airGapDC.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real dcpm.airGapDC.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcpm.airGapDC.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcpm.airGapDC.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcpm.airGapDC.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcpm.airGapDC.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.airGapDC.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.airGapDC.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.airGapDC.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.airGapDC.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.airGapDC.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.airGapDC.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.airGapDC.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcpm.airGapDC.Le(quantity = "Inductance", unit = "H") = 1.0 "excitation inductance";
//   protected constant Real dcpm.Le(quantity = "Inductance", unit = "H") = 1.0 "total field excitation inductance";
//   protected constant Real dcpm.IeNominal(quantity = "ElectricCurrent", unit = "A") = 1.0 "equivalent excitation current";
//   Real dcpm.eGround.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.eGround.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.ie.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcpm.ie.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcpm.ie.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.ie.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcpm.ie.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcpm.ie.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcpm.ie.I(quantity = "ElectricCurrent", unit = "A", start = 1.0) = 1.0 "Value of constant current";
//   parameter Real dcpm.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real dcpm.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcpm.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real ramp.y "Connector of Real output signal";
//   parameter Real ramp.height = Va "Height of ramps";
//   parameter Real ramp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = tRamp "Durations of ramp";
//   parameter Real ramp.offset = 0.0 "Offset of output signal";
//   parameter Real ramp.startTime(quantity = "Time", unit = "s") = tStart "Output = offset for time < startTime";
//   Real signalVoltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean loadTorqueStep.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real loadTorqueStep.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorqueStep.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real loadTorqueStep.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real loadTorqueStep.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real loadTorqueStep.stepTorque(quantity = "Torque", unit = "N.m", start = 1.0) = -TLoad "Height of torque step (if negative, torque is acting as load)";
//   parameter Real loadTorqueStep.offsetTorque(quantity = "Torque", unit = "N.m", start = 0.0) "Offset of torque";
//   parameter Real loadTorqueStep.startTime(quantity = "Time", unit = "s") = tStep "Torque = offset for time < startTime";
//   Real loadTorqueStep.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
// equation
//   dcpm.inertiaRotor.phi = dcpm.inertiaRotor.flange_a.phi;
//   dcpm.inertiaRotor.phi = dcpm.inertiaRotor.flange_b.phi;
//   dcpm.inertiaRotor.w = der(dcpm.inertiaRotor.phi);
//   dcpm.inertiaRotor.a = der(dcpm.inertiaRotor.w);
//   dcpm.inertiaRotor.J * dcpm.inertiaRotor.a = dcpm.inertiaRotor.flange_a.tau + dcpm.inertiaRotor.flange_b.tau;
//   assert(1.0 + dcpm.ra.alpha * (dcpm.ra.T_heatPort - dcpm.ra.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   dcpm.ra.R_actual = dcpm.ra.R * (1.0 + dcpm.ra.alpha * (dcpm.ra.T_heatPort - dcpm.ra.T_ref));
//   dcpm.ra.v = dcpm.ra.R_actual * dcpm.ra.i;
//   dcpm.ra.LossPower = dcpm.ra.v * dcpm.ra.i;
//   dcpm.ra.i = dcpm.ra.p.i;
//   0.0 = dcpm.ra.p.i + dcpm.ra.n.i;
//   dcpm.ra.v = dcpm.ra.p.v - dcpm.ra.n.v;
//   dcpm.ra.T_heatPort = dcpm.ra.T;
//   dcpm.la.L * der(dcpm.la.i) = dcpm.la.v;
//   dcpm.la.v = dcpm.la.p.v - dcpm.la.n.v;
//   0.0 = dcpm.la.p.i + dcpm.la.n.i;
//   dcpm.la.i = dcpm.la.p.i;
//   dcpm.airGapDC.psi_e = dcpm.airGapDC.Le * dcpm.airGapDC.ie;
//   dcpm.airGapDC.vai = dcpm.airGapDC.pin_ap.v - dcpm.airGapDC.pin_an.v;
//   dcpm.airGapDC.ia = dcpm.airGapDC.pin_ap.i;
//   dcpm.airGapDC.ia = -dcpm.airGapDC.pin_an.i;
//   dcpm.airGapDC.vei = dcpm.airGapDC.pin_ep.v - dcpm.airGapDC.pin_en.v;
//   dcpm.airGapDC.ie = dcpm.airGapDC.pin_ep.i;
//   dcpm.airGapDC.ie = -dcpm.airGapDC.pin_en.i;
//   dcpm.airGapDC.vei = der(dcpm.airGapDC.psi_e);
//   dcpm.airGapDC.w = der(dcpm.airGapDC.flange.phi) - der(dcpm.airGapDC.support.phi);
//   dcpm.airGapDC.vai = dcpm.airGapDC.turnsRatio * (dcpm.airGapDC.psi_e * dcpm.airGapDC.w);
//   dcpm.airGapDC.tauElectrical = dcpm.airGapDC.turnsRatio * (dcpm.airGapDC.psi_e * dcpm.airGapDC.ia);
//   dcpm.airGapDC.flange.tau = -dcpm.airGapDC.tauElectrical;
//   dcpm.airGapDC.support.tau = dcpm.airGapDC.tauElectrical;
//   dcpm.eGround.p.v = 0.0;
//   dcpm.ie.i = dcpm.ie.I;
//   dcpm.ie.v = dcpm.ie.p.v - dcpm.ie.n.v;
//   0.0 = dcpm.ie.p.i + dcpm.ie.n.i;
//   dcpm.ie.i = dcpm.ie.p.i;
//   dcpm.fixed.flange.phi = dcpm.fixed.phi0;
//   assert(dcpm.VaNominal > dcpm.Ra * dcpm.IaNominal,"VaNominal has to be > Ra*IaNominal");
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   signalVoltage.v = signalVoltage.p.v - signalVoltage.n.v;
//   0.0 = signalVoltage.p.i + signalVoltage.n.i;
//   signalVoltage.i = signalVoltage.p.i;
//   ground.p.v = 0.0;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   loadTorqueStep.tau = -loadTorqueStep.flange.tau;
//   loadTorqueStep.tau = loadTorqueStep.offsetTorque + (if time < loadTorqueStep.startTime then 0.0 else loadTorqueStep.stepTorque);
//   loadTorqueStep.phi = loadTorqueStep.flange.phi - loadTorqueStep.phi_support;
//   loadTorqueStep.phi_support = 0.0;
//   dcpm.flange.tau + loadInertia.flange_a.tau = 0.0;
//   dcpm.flange.phi = loadInertia.flange_a.phi;
//   loadInertia.flange_b.tau + loadTorqueStep.flange.tau = 0.0;
//   loadInertia.flange_b.phi = loadTorqueStep.flange.phi;
//   dcpm.pin_an.i + (signalVoltage.n.i + ground.p.i) = 0.0;
//   dcpm.pin_an.v = ground.p.v;
//   dcpm.pin_an.v = signalVoltage.n.v;
//   signalVoltage.p.i + dcpm.pin_ap.i = 0.0;
//   dcpm.pin_ap.v = signalVoltage.p.v;
//   ramp.y = signalVoltage.v;
//   dcpm.airGapDC.support.tau + ((-dcpm.internalSupport.tau) + dcpm.fixed.flange.tau) = 0.0;
//   dcpm.airGapDC.support.phi = dcpm.fixed.flange.phi;
//   dcpm.airGapDC.support.phi = dcpm.internalSupport.phi;
//   dcpm.inertiaRotor.flange_b.tau + (-dcpm.flange.tau) = 0.0;
//   dcpm.flange.phi = dcpm.inertiaRotor.flange_b.phi;
//   dcpm.la.p.i + dcpm.ra.n.i = 0.0;
//   dcpm.la.p.v = dcpm.ra.n.v;
//   (-dcpm.pin_ap.i) + dcpm.ra.p.i = 0.0;
//   dcpm.pin_ap.v = dcpm.ra.p.v;
//   dcpm.airGapDC.flange.tau + dcpm.inertiaRotor.flange_a.tau = 0.0;
//   dcpm.airGapDC.flange.phi = dcpm.inertiaRotor.flange_a.phi;
//   dcpm.airGapDC.pin_an.i + (-dcpm.pin_an.i) = 0.0;
//   dcpm.airGapDC.pin_an.v = dcpm.pin_an.v;
//   dcpm.airGapDC.pin_ap.i + dcpm.la.n.i = 0.0;
//   dcpm.airGapDC.pin_ap.v = dcpm.la.n.v;
//   dcpm.airGapDC.pin_en.i + (dcpm.eGround.p.i + dcpm.ie.p.i) = 0.0;
//   dcpm.airGapDC.pin_en.v = dcpm.eGround.p.v;
//   dcpm.airGapDC.pin_en.v = dcpm.ie.p.v;
//   dcpm.airGapDC.pin_ep.i + dcpm.ie.n.i = 0.0;
//   dcpm.airGapDC.pin_ep.v = dcpm.ie.n.v;
//   dcpm.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.DCPM_Start;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.DCPM_Start completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.DCPM_Start has 86 equation(s) and 86 variable(s).
// 56 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// class Modelica.Electrical.Machines.Examples.DCEE_Start
//   parameter Real Va(quantity = "ElectricPotential", unit = "V") = 100.0 "actual armature voltage";
//   parameter Real tStart(quantity = "Time", unit = "s") = 0.2 "armature voltage ramp";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 0.8 "armature voltage ramp";
//   parameter Real Ve(quantity = "ElectricPotential", unit = "V") = 100.0 "actual excitation voltage";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 63.66 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.5 "time of load torque step";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "load's moment of inertia";
//   constant Real dcee.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real dcee.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.15) "rotor's moment of inertia";
//   parameter Boolean dcee.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real dcee.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = dcee.Jr) "stator's moment of inertia";
//   output Real dcee.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = dcee.flange.phi - dcee.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real dcee.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(dcee.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real dcee.tauElectrical(quantity = "Torque", unit = "N.m") = dcee.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real dcee.tauShaft(quantity = "Torque", unit = "N.m") = -dcee.flange.tau "shaft torque";
//   Real dcee.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcee.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcee.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcee.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcee.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcee.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real dcee.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = dcee.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) dcee.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real dcee.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real dcee.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real dcee.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real dcee.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real dcee.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   parameter Real dcee.VaNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal armature voltage";
//   parameter Real dcee.IaNominal(quantity = "ElectricCurrent", unit = "A", start = 100.0) "nominal armature current";
//   parameter Real dcee.wNominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min", start = 149.225651045515) "nominal speed";
//   parameter Real dcee.Ra(quantity = "Resistance", unit = "Ohm", start = 0.05) "warm armature resistance";
//   parameter Real dcee.La(quantity = "Inductance", unit = "H", start = 0.0015) "armature inductance";
//   parameter Real dcee.turnsRatio = (dcee.VaNominal - dcee.Ra * dcee.IaNominal) * 1.0 / dcee.IeNominal / dcee.Le / dcee.wNominal "ratio of armature turns over number of turns of the excitation winding";
//   output Real dcee.va(quantity = "ElectricPotential", unit = "V") = dcee.pin_ap.v - dcee.pin_an.v "armature voltage";
//   output Real dcee.ia(quantity = "ElectricCurrent", unit = "A") = dcee.pin_ap.i "armature current";
//   Real dcee.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.ra.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcee.ra.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcee.ra.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.ra.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.ra.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.ra.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean dcee.ra.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real dcee.ra.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = dcee.ra.T_ref "Fixed device temperature if useHeatPort = false";
//   Real dcee.ra.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real dcee.ra.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real dcee.ra.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = dcee.Ra "Resistance at temperature T_ref";
//   parameter Real dcee.ra.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real dcee.ra.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcee.ra.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcee.la.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcee.la.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcee.la.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.la.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.la.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.la.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcee.la.L(quantity = "Inductance", unit = "H", start = 1.0) = dcee.La "Inductance";
//   parameter Real dcee.airGapDC.turnsRatio = dcee.turnsRatio "ratio of armature turns over number of turns of the excitation winding";
//   Real dcee.airGapDC.w(quantity = "AngularVelocity", unit = "rad/s") "Angluar velocity";
//   Real dcee.airGapDC.vei(quantity = "ElectricPotential", unit = "V") "Voltage drop across field excitation inductance";
//   Real dcee.airGapDC.ie(quantity = "ElectricCurrent", unit = "A") "Excitation current";
//   Real dcee.airGapDC.psi_e(quantity = "MagneticFlux", unit = "Wb") "Excitation flux";
//   Real dcee.airGapDC.vai(quantity = "ElectricPotential", unit = "V") "Induced armature voltage";
//   Real dcee.airGapDC.ia(quantity = "ElectricCurrent", unit = "A") "Armature current";
//   output Real dcee.airGapDC.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real dcee.airGapDC.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcee.airGapDC.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcee.airGapDC.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcee.airGapDC.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcee.airGapDC.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.airGapDC.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.airGapDC.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.airGapDC.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.airGapDC.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.airGapDC.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.airGapDC.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.airGapDC.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcee.airGapDC.Le(quantity = "Inductance", unit = "H") = dcee.Le "excitation inductance";
//   parameter Real dcee.IeNominal(quantity = "ElectricCurrent", unit = "A", start = 1.0) "nominal excitation current";
//   parameter Real dcee.Re(quantity = "Resistance", unit = "Ohm", start = 100.0) "warm field excitation resistance";
//   parameter Real dcee.Le(quantity = "Inductance", unit = "H", start = 1.0) "total field excitation inductance";
//   output Real dcee.ve(quantity = "ElectricPotential", unit = "V") = dcee.pin_ep.v - dcee.pin_en.v "Field excitation voltage";
//   output Real dcee.ie(quantity = "ElectricCurrent", unit = "A") = dcee.pin_ep.i "Field excitation current";
//   Real dcee.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcee.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcee.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean dcee.re.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real dcee.re.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = dcee.re.T_ref "Fixed device temperature if useHeatPort = false";
//   Real dcee.re.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real dcee.re.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real dcee.re.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = dcee.Re "Resistance at temperature T_ref";
//   parameter Real dcee.re.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real dcee.re.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcee.re.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcee.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcee.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcee.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcee.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real dcee.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcee.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real ramp.y "Connector of Real output signal";
//   parameter Real ramp.height = Va "Height of ramps";
//   parameter Real ramp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = tRamp "Durations of ramp";
//   parameter Real ramp.offset = 0.0 "Offset of output signal";
//   parameter Real ramp.startTime(quantity = "Time", unit = "s") = tStart "Output = offset for time < startTime";
//   Real signalVoltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real constantVoltage.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real constantVoltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real constantVoltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real constantVoltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real constantVoltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real constantVoltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real constantVoltage.V(quantity = "ElectricPotential", unit = "V", start = 1.0) = Ve "Value of constant voltage";
//   Real groundExcitation.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundExcitation.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean loadTorqueStep.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real loadTorqueStep.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadTorqueStep.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real loadTorqueStep.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real loadTorqueStep.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real loadTorqueStep.stepTorque(quantity = "Torque", unit = "N.m", start = 1.0) = -TLoad "Height of torque step (if negative, torque is acting as load)";
//   parameter Real loadTorqueStep.offsetTorque(quantity = "Torque", unit = "N.m", start = 0.0) "Offset of torque";
//   parameter Real loadTorqueStep.startTime(quantity = "Time", unit = "s") = tStep "Torque = offset for time < startTime";
//   Real loadTorqueStep.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
// equation
//   dcee.inertiaRotor.phi = dcee.inertiaRotor.flange_a.phi;
//   dcee.inertiaRotor.phi = dcee.inertiaRotor.flange_b.phi;
//   dcee.inertiaRotor.w = der(dcee.inertiaRotor.phi);
//   dcee.inertiaRotor.a = der(dcee.inertiaRotor.w);
//   dcee.inertiaRotor.J * dcee.inertiaRotor.a = dcee.inertiaRotor.flange_a.tau + dcee.inertiaRotor.flange_b.tau;
//   assert(1.0 + dcee.ra.alpha * (dcee.ra.T_heatPort - dcee.ra.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   dcee.ra.R_actual = dcee.ra.R * (1.0 + dcee.ra.alpha * (dcee.ra.T_heatPort - dcee.ra.T_ref));
//   dcee.ra.v = dcee.ra.R_actual * dcee.ra.i;
//   dcee.ra.LossPower = dcee.ra.v * dcee.ra.i;
//   dcee.ra.i = dcee.ra.p.i;
//   0.0 = dcee.ra.p.i + dcee.ra.n.i;
//   dcee.ra.v = dcee.ra.p.v - dcee.ra.n.v;
//   dcee.ra.T_heatPort = dcee.ra.T;
//   dcee.la.L * der(dcee.la.i) = dcee.la.v;
//   dcee.la.v = dcee.la.p.v - dcee.la.n.v;
//   0.0 = dcee.la.p.i + dcee.la.n.i;
//   dcee.la.i = dcee.la.p.i;
//   dcee.airGapDC.psi_e = dcee.airGapDC.Le * dcee.airGapDC.ie;
//   dcee.airGapDC.vai = dcee.airGapDC.pin_ap.v - dcee.airGapDC.pin_an.v;
//   dcee.airGapDC.ia = dcee.airGapDC.pin_ap.i;
//   dcee.airGapDC.ia = -dcee.airGapDC.pin_an.i;
//   dcee.airGapDC.vei = dcee.airGapDC.pin_ep.v - dcee.airGapDC.pin_en.v;
//   dcee.airGapDC.ie = dcee.airGapDC.pin_ep.i;
//   dcee.airGapDC.ie = -dcee.airGapDC.pin_en.i;
//   dcee.airGapDC.vei = der(dcee.airGapDC.psi_e);
//   dcee.airGapDC.w = der(dcee.airGapDC.flange.phi) - der(dcee.airGapDC.support.phi);
//   dcee.airGapDC.vai = dcee.airGapDC.turnsRatio * (dcee.airGapDC.psi_e * dcee.airGapDC.w);
//   dcee.airGapDC.tauElectrical = dcee.airGapDC.turnsRatio * (dcee.airGapDC.psi_e * dcee.airGapDC.ia);
//   dcee.airGapDC.flange.tau = -dcee.airGapDC.tauElectrical;
//   dcee.airGapDC.support.tau = dcee.airGapDC.tauElectrical;
//   assert(1.0 + dcee.re.alpha * (dcee.re.T_heatPort - dcee.re.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   dcee.re.R_actual = dcee.re.R * (1.0 + dcee.re.alpha * (dcee.re.T_heatPort - dcee.re.T_ref));
//   dcee.re.v = dcee.re.R_actual * dcee.re.i;
//   dcee.re.LossPower = dcee.re.v * dcee.re.i;
//   dcee.re.i = dcee.re.p.i;
//   0.0 = dcee.re.p.i + dcee.re.n.i;
//   dcee.re.v = dcee.re.p.v - dcee.re.n.v;
//   dcee.re.T_heatPort = dcee.re.T;
//   dcee.fixed.flange.phi = dcee.fixed.phi0;
//   assert(dcee.VaNominal > dcee.Ra * dcee.IaNominal,"VaNominal has to be > Ra*IaNominal");
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   signalVoltage.v = signalVoltage.p.v - signalVoltage.n.v;
//   0.0 = signalVoltage.p.i + signalVoltage.n.i;
//   signalVoltage.i = signalVoltage.p.i;
//   ground.p.v = 0.0;
//   constantVoltage.v = constantVoltage.V;
//   constantVoltage.v = constantVoltage.p.v - constantVoltage.n.v;
//   0.0 = constantVoltage.p.i + constantVoltage.n.i;
//   constantVoltage.i = constantVoltage.p.i;
//   groundExcitation.p.v = 0.0;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   loadTorqueStep.tau = -loadTorqueStep.flange.tau;
//   loadTorqueStep.tau = loadTorqueStep.offsetTorque + (if time < loadTorqueStep.startTime then 0.0 else loadTorqueStep.stepTorque);
//   loadTorqueStep.phi = loadTorqueStep.flange.phi - loadTorqueStep.phi_support;
//   loadTorqueStep.phi_support = 0.0;
//   dcee.flange.tau + loadInertia.flange_a.tau = 0.0;
//   dcee.flange.phi = loadInertia.flange_a.phi;
//   loadInertia.flange_b.tau + loadTorqueStep.flange.tau = 0.0;
//   loadInertia.flange_b.phi = loadTorqueStep.flange.phi;
//   dcee.pin_en.i + (constantVoltage.n.i + groundExcitation.p.i) = 0.0;
//   constantVoltage.n.v = dcee.pin_en.v;
//   constantVoltage.n.v = groundExcitation.p.v;
//   dcee.pin_ep.i + constantVoltage.p.i = 0.0;
//   constantVoltage.p.v = dcee.pin_ep.v;
//   dcee.pin_an.i + (signalVoltage.n.i + ground.p.i) = 0.0;
//   dcee.pin_an.v = ground.p.v;
//   dcee.pin_an.v = signalVoltage.n.v;
//   signalVoltage.p.i + dcee.pin_ap.i = 0.0;
//   dcee.pin_ap.v = signalVoltage.p.v;
//   ramp.y = signalVoltage.v;
//   dcee.airGapDC.support.tau + ((-dcee.internalSupport.tau) + dcee.fixed.flange.tau) = 0.0;
//   dcee.airGapDC.support.phi = dcee.fixed.flange.phi;
//   dcee.airGapDC.support.phi = dcee.internalSupport.phi;
//   dcee.inertiaRotor.flange_b.tau + (-dcee.flange.tau) = 0.0;
//   dcee.flange.phi = dcee.inertiaRotor.flange_b.phi;
//   dcee.la.p.i + dcee.ra.n.i = 0.0;
//   dcee.la.p.v = dcee.ra.n.v;
//   (-dcee.pin_ap.i) + dcee.ra.p.i = 0.0;
//   dcee.pin_ap.v = dcee.ra.p.v;
//   dcee.airGapDC.flange.tau + dcee.inertiaRotor.flange_a.tau = 0.0;
//   dcee.airGapDC.flange.phi = dcee.inertiaRotor.flange_a.phi;
//   dcee.airGapDC.pin_an.i + (-dcee.pin_an.i) = 0.0;
//   dcee.airGapDC.pin_an.v = dcee.pin_an.v;
//   dcee.airGapDC.pin_ap.i + dcee.la.n.i = 0.0;
//   dcee.airGapDC.pin_ap.v = dcee.la.n.v;
//   dcee.re.n.i + dcee.airGapDC.pin_ep.i = 0.0;
//   dcee.airGapDC.pin_ep.v = dcee.re.n.v;
//   (-dcee.pin_en.i) + dcee.airGapDC.pin_en.i = 0.0;
//   dcee.airGapDC.pin_en.v = dcee.pin_en.v;
//   dcee.re.p.i + (-dcee.pin_ep.i) = 0.0;
//   dcee.pin_ep.v = dcee.re.p.v;
//   dcee.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.DCEE_Start;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.DCEE_Start completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.DCEE_Start has 101 equation(s) and 101 variable(s).
// 66 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// class Modelica.Electrical.Machines.Examples.DCSE_Start
//   parameter Real Va(quantity = "ElectricPotential", unit = "V") = 100.0 "actual armature voltage";
//   parameter Real tStart(quantity = "Time", unit = "s") = 0.2 "armature voltage ramp";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 0.8 "armature voltage ramp";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 63.66 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 147.65485471872 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "load's moment of inertia";
//   constant Real dcse.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real dcse.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.15) "rotor's moment of inertia";
//   parameter Boolean dcse.useSupport = false "enable / disable (=fixed stator) support";
//   parameter Real dcse.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = dcse.Jr) "stator's moment of inertia";
//   output Real dcse.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = dcse.flange.phi - dcse.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real dcse.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(dcse.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real dcse.tauElectrical(quantity = "Torque", unit = "N.m") = dcse.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real dcse.tauShaft(quantity = "Torque", unit = "N.m") = -dcse.flange.tau "shaft torque";
//   Real dcse.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcse.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcse.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcse.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcse.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcse.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real dcse.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = dcse.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) dcse.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real dcse.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real dcse.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real dcse.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real dcse.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real dcse.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   parameter Real dcse.VaNominal(quantity = "ElectricPotential", unit = "V", start = 100.0) "nominal armature voltage";
//   parameter Real dcse.IaNominal(quantity = "ElectricCurrent", unit = "A", start = 100.0) "nominal armature current";
//   parameter Real dcse.wNominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min", start = 147.65485471872) "nominal speed";
//   parameter Real dcse.Ra(quantity = "Resistance", unit = "Ohm", start = 0.05) "warm armature resistance";
//   parameter Real dcse.La(quantity = "Inductance", unit = "H", start = 0.0015) "armature inductance";
//   parameter Real dcse.turnsRatio = (dcse.VaNominal - (dcse.Ra + dcse.Re) * dcse.IaNominal) * 1.0 / dcse.IaNominal / dcse.Le / dcse.wNominal "ratio of armature turns over number of turns of the excitation winding";
//   output Real dcse.va(quantity = "ElectricPotential", unit = "V") = dcse.pin_ap.v - dcse.pin_an.v "armature voltage";
//   output Real dcse.ia(quantity = "ElectricCurrent", unit = "A") = dcse.pin_ap.i "armature current";
//   Real dcse.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.ra.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcse.ra.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcse.ra.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.ra.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.ra.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.ra.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean dcse.ra.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real dcse.ra.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = dcse.ra.T_ref "Fixed device temperature if useHeatPort = false";
//   Real dcse.ra.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real dcse.ra.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real dcse.ra.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = dcse.Ra "Resistance at temperature T_ref";
//   parameter Real dcse.ra.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real dcse.ra.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcse.ra.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcse.la.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcse.la.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcse.la.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.la.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.la.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.la.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcse.la.L(quantity = "Inductance", unit = "H", start = 1.0) = dcse.La "Inductance";
//   parameter Real dcse.airGapDC.turnsRatio = dcse.turnsRatio "ratio of armature turns over number of turns of the excitation winding";
//   Real dcse.airGapDC.w(quantity = "AngularVelocity", unit = "rad/s") "Angluar velocity";
//   Real dcse.airGapDC.vei(quantity = "ElectricPotential", unit = "V") "Voltage drop across field excitation inductance";
//   Real dcse.airGapDC.ie(quantity = "ElectricCurrent", unit = "A") "Excitation current";
//   Real dcse.airGapDC.psi_e(quantity = "MagneticFlux", unit = "Wb") "Excitation flux";
//   Real dcse.airGapDC.vai(quantity = "ElectricPotential", unit = "V") "Induced armature voltage";
//   Real dcse.airGapDC.ia(quantity = "ElectricCurrent", unit = "A") "Armature current";
//   output Real dcse.airGapDC.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real dcse.airGapDC.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcse.airGapDC.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcse.airGapDC.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcse.airGapDC.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real dcse.airGapDC.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.airGapDC.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.airGapDC.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.airGapDC.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.airGapDC.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.airGapDC.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.airGapDC.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.airGapDC.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcse.airGapDC.Le(quantity = "Inductance", unit = "H") = dcse.Le "excitation inductance";
//   parameter Real dcse.Re(quantity = "Resistance", unit = "Ohm", start = 0.01) "warm field excitation resistance";
//   parameter Real dcse.Le(quantity = "Inductance", unit = "H", start = 0.0005) "total field excitation inductance";
//   output Real dcse.ve(quantity = "ElectricPotential", unit = "V") = dcse.pin_ep.v - dcse.pin_en.v "Field excitation voltage";
//   output Real dcse.ie(quantity = "ElectricCurrent", unit = "A") = dcse.pin_ep.i "Field excitation current";
//   Real dcse.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real dcse.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real dcse.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean dcse.re.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real dcse.re.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = dcse.re.T_ref "Fixed device temperature if useHeatPort = false";
//   Real dcse.re.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real dcse.re.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real dcse.re.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = dcse.Re "Resistance at temperature T_ref";
//   parameter Real dcse.re.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real dcse.re.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcse.re.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real dcse.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real dcse.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real dcse.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real dcse.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real dcse.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real dcse.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real ramp.y "Connector of Real output signal";
//   parameter Real ramp.height = Va "Height of ramps";
//   parameter Real ramp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = tRamp "Durations of ramp";
//   parameter Real ramp.offset = 0.0 "Offset of output signal";
//   parameter Real ramp.startTime(quantity = "Time", unit = "s") = tStart "Output = offset for time < startTime";
//   Real signalVoltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real signalVoltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real signalVoltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real signalVoltage.v "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real signalVoltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
// equation
//   dcse.inertiaRotor.phi = dcse.inertiaRotor.flange_a.phi;
//   dcse.inertiaRotor.phi = dcse.inertiaRotor.flange_b.phi;
//   dcse.inertiaRotor.w = der(dcse.inertiaRotor.phi);
//   dcse.inertiaRotor.a = der(dcse.inertiaRotor.w);
//   dcse.inertiaRotor.J * dcse.inertiaRotor.a = dcse.inertiaRotor.flange_a.tau + dcse.inertiaRotor.flange_b.tau;
//   assert(1.0 + dcse.ra.alpha * (dcse.ra.T_heatPort - dcse.ra.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   dcse.ra.R_actual = dcse.ra.R * (1.0 + dcse.ra.alpha * (dcse.ra.T_heatPort - dcse.ra.T_ref));
//   dcse.ra.v = dcse.ra.R_actual * dcse.ra.i;
//   dcse.ra.LossPower = dcse.ra.v * dcse.ra.i;
//   dcse.ra.i = dcse.ra.p.i;
//   0.0 = dcse.ra.p.i + dcse.ra.n.i;
//   dcse.ra.v = dcse.ra.p.v - dcse.ra.n.v;
//   dcse.ra.T_heatPort = dcse.ra.T;
//   dcse.la.L * der(dcse.la.i) = dcse.la.v;
//   dcse.la.v = dcse.la.p.v - dcse.la.n.v;
//   0.0 = dcse.la.p.i + dcse.la.n.i;
//   dcse.la.i = dcse.la.p.i;
//   dcse.airGapDC.psi_e = dcse.airGapDC.Le * dcse.airGapDC.ie;
//   dcse.airGapDC.vai = dcse.airGapDC.pin_ap.v - dcse.airGapDC.pin_an.v;
//   dcse.airGapDC.ia = dcse.airGapDC.pin_ap.i;
//   dcse.airGapDC.ia = -dcse.airGapDC.pin_an.i;
//   dcse.airGapDC.vei = dcse.airGapDC.pin_ep.v - dcse.airGapDC.pin_en.v;
//   dcse.airGapDC.ie = dcse.airGapDC.pin_ep.i;
//   dcse.airGapDC.ie = -dcse.airGapDC.pin_en.i;
//   dcse.airGapDC.vei = der(dcse.airGapDC.psi_e);
//   dcse.airGapDC.w = der(dcse.airGapDC.flange.phi) - der(dcse.airGapDC.support.phi);
//   dcse.airGapDC.vai = dcse.airGapDC.turnsRatio * (dcse.airGapDC.psi_e * dcse.airGapDC.w);
//   dcse.airGapDC.tauElectrical = dcse.airGapDC.turnsRatio * (dcse.airGapDC.psi_e * dcse.airGapDC.ia);
//   dcse.airGapDC.flange.tau = -dcse.airGapDC.tauElectrical;
//   dcse.airGapDC.support.tau = dcse.airGapDC.tauElectrical;
//   assert(1.0 + dcse.re.alpha * (dcse.re.T_heatPort - dcse.re.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   dcse.re.R_actual = dcse.re.R * (1.0 + dcse.re.alpha * (dcse.re.T_heatPort - dcse.re.T_ref));
//   dcse.re.v = dcse.re.R_actual * dcse.re.i;
//   dcse.re.LossPower = dcse.re.v * dcse.re.i;
//   dcse.re.i = dcse.re.p.i;
//   0.0 = dcse.re.p.i + dcse.re.n.i;
//   dcse.re.v = dcse.re.p.v - dcse.re.n.v;
//   dcse.re.T_heatPort = dcse.re.T;
//   dcse.fixed.flange.phi = dcse.fixed.phi0;
//   assert(dcse.VaNominal > (dcse.Ra + dcse.Re) * dcse.IaNominal,"VaNominal has to be > (Ra+Re)*IaNominal");
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   signalVoltage.v = signalVoltage.p.v - signalVoltage.n.v;
//   0.0 = signalVoltage.p.i + signalVoltage.n.i;
//   signalVoltage.i = signalVoltage.p.i;
//   ground.p.v = 0.0;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   dcse.flange.tau + loadInertia.flange_a.tau = 0.0;
//   dcse.flange.phi = loadInertia.flange_a.phi;
//   dcse.pin_en.i + (signalVoltage.n.i + ground.p.i) = 0.0;
//   dcse.pin_en.v = ground.p.v;
//   dcse.pin_en.v = signalVoltage.n.v;
//   dcse.pin_an.i + dcse.pin_ep.i = 0.0;
//   dcse.pin_an.v = dcse.pin_ep.v;
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   signalVoltage.p.i + dcse.pin_ap.i = 0.0;
//   dcse.pin_ap.v = signalVoltage.p.v;
//   ramp.y = signalVoltage.v;
//   dcse.airGapDC.support.tau + ((-dcse.internalSupport.tau) + dcse.fixed.flange.tau) = 0.0;
//   dcse.airGapDC.support.phi = dcse.fixed.flange.phi;
//   dcse.airGapDC.support.phi = dcse.internalSupport.phi;
//   dcse.inertiaRotor.flange_b.tau + (-dcse.flange.tau) = 0.0;
//   dcse.flange.phi = dcse.inertiaRotor.flange_b.phi;
//   dcse.la.p.i + dcse.ra.n.i = 0.0;
//   dcse.la.p.v = dcse.ra.n.v;
//   (-dcse.pin_ap.i) + dcse.ra.p.i = 0.0;
//   dcse.pin_ap.v = dcse.ra.p.v;
//   dcse.airGapDC.flange.tau + dcse.inertiaRotor.flange_a.tau = 0.0;
//   dcse.airGapDC.flange.phi = dcse.inertiaRotor.flange_a.phi;
//   dcse.airGapDC.pin_an.i + (-dcse.pin_an.i) = 0.0;
//   dcse.airGapDC.pin_an.v = dcse.pin_an.v;
//   dcse.airGapDC.pin_ap.i + dcse.la.n.i = 0.0;
//   dcse.airGapDC.pin_ap.v = dcse.la.n.v;
//   dcse.re.n.i + dcse.airGapDC.pin_ep.i = 0.0;
//   dcse.airGapDC.pin_ep.v = dcse.re.n.v;
//   (-dcse.pin_en.i) + dcse.airGapDC.pin_en.i = 0.0;
//   dcse.airGapDC.pin_en.v = dcse.pin_en.v;
//   dcse.re.p.i + (-dcse.pin_ep.i) = 0.0;
//   dcse.pin_ep.v = dcse.re.p.v;
//   dcse.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.DCSE_Start;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.DCSE_Start completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.DCSE_Start has 94 equation(s) and 94 variable(s).
// 60 of these are trivial equation(s).
// "
// ""
// "function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
//   constant Integer m = 3 "number of phases";
//   constant Real pi = 3.14159265358979;
//   input Real[3] x;
//   output Real[2] y;
//   output Real y0;
// algorithm
//   y := {0.0,0.0};
//   for k in 1:3 loop
//     y := {y[1] + x[k] * 0.666666666666667 * cos(2.0943951023932 * /*REAL*/(k - 1)),y[2] + x[k] * 0.666666666666667 * sin(2.0943951023932 * /*REAL*/(k - 1))};
//   end for;
//   y0 := 0.333333333333333 * (x[1] + x[2] + x[3]);
// end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Utilities.Strings.substring
//   input String string "String from which a substring is inquired";
//   input Integer startIndex(min = 1) "Character position of substring begin (index=1 is first character in string)";
//   input Integer endIndex(min = 1) "Character position of substring end";
//   output String result "String containing substring string[startIndex:endIndex]";
// 
// external "C";
// end Modelica.Utilities.Strings.substring;
// 
// class Modelica.Electrical.Machines.Examples.TransformerTestbench
//   parameter Real RL[1](quantity = "Resistance", unit = "Ohm") = 0.333333333333333 "Load resistance";
//   parameter Real RL[2](quantity = "Resistance", unit = "Ohm") = 0.333333333333333 "Load resistance";
//   parameter Real RL[3](quantity = "Resistance", unit = "Ohm") = 0.333333333333333 "Load resistance";
//   parameter Integer source.m(min = 1) = 3 "number of phases";
//   Real source.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real source.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real source.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer source.plug_p.m(min = 1) = source.m "number of phases";
//   Real source.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer source.plug_n.m(min = 1) = source.m "number of phases";
//   Real source.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = 81.6496580927726 "Amplitudes of sine waves";
//   parameter Real source.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = 81.6496580927726 "Amplitudes of sine waves";
//   parameter Real source.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = 81.6496580927726 "Amplitudes of sine waves";
//   parameter Real source.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real source.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(source.m) "Phases of sine waves";
//   parameter Real source.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(source.m) "Phases of sine waves";
//   parameter Real source.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = 50.0 "Frequencies of sine waves";
//   parameter Real source.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = 50.0 "Frequencies of sine waves";
//   parameter Real source.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = 50.0 "Frequencies of sine waves";
//   parameter Real source.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real source.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real source.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real source.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = source.offset[1] "Voltage offset";
//   parameter Real source.sineVoltage[1].startTime(quantity = "Time", unit = "s") = source.startTime[1] "Time offset";
//   output Real source.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[1].signalSource.amplitude = source.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.offset = source.sineVoltage[1].offset "Offset of output signal";
//   parameter Real source.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[1] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[1] "Phase of sine wave";
//   parameter Real source.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[1] "Frequency of sine wave";
//   Real source.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = source.offset[2] "Voltage offset";
//   parameter Real source.sineVoltage[2].startTime(quantity = "Time", unit = "s") = source.startTime[2] "Time offset";
//   output Real source.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[2].signalSource.amplitude = source.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.offset = source.sineVoltage[2].offset "Offset of output signal";
//   parameter Real source.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[2] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[2] "Phase of sine wave";
//   parameter Real source.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[2] "Frequency of sine wave";
//   Real source.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = source.offset[3] "Voltage offset";
//   parameter Real source.sineVoltage[3].startTime(quantity = "Time", unit = "s") = source.startTime[3] "Time offset";
//   output Real source.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[3].signalSource.amplitude = source.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.offset = source.sineVoltage[3].offset "Offset of output signal";
//   parameter Real source.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[3] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[3] "Phase of sine wave";
//   parameter Real source.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[3] "Frequency of sine wave";
//   parameter Integer starS.m(min = 1) = 3 "number of phases";
//   parameter Integer starS.plug_p.m(min = 1) = starS.m "number of phases";
//   Real starS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starS.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starS.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real groundS.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundS.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer electricalPowerSensorS.m(min = 1) = 3 "Number of phases";
//   output Real electricalPowerSensorS.P;
//   output Real electricalPowerSensorS.Q;
//   parameter Integer electricalPowerSensorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensorS.plug_ni.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensorS.plug_ni.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_ni.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorS.plug_ni.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_ni.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorS.plug_ni.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_ni.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensorS.plug_nv.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensorS.plug_nv.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_nv.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorS.plug_nv.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_nv.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorS.plug_nv.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorS.plug_nv.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected Real electricalPowerSensorS.v_[1](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensorS.v_[2](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensorS.i_[1](quantity = "ElectricCurrent", unit = "A");
//   protected Real electricalPowerSensorS.i_[2](quantity = "ElectricCurrent", unit = "A");
//   constant Integer currentQuasiRMSSensorS.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensorS.I;
//   parameter Integer currentQuasiRMSSensorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensorS.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensorS.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensorS.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensorS.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensorS.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorS.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensorS.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensorS.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensorS.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensorS.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensorS.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensorS.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensorS.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensorS.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensorS.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensorS.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensorS.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensorS.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensorS.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensorS.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensorS.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensorS.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensorS.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensorS.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensorS.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensorS.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensorS.ToPolar1.small = 1e-60;
//   constant Integer voltageQuasiRMSSensorS.m(min = 1) = 3 "Number of phases";
//   output Real voltageQuasiRMSSensorS.V;
//   parameter Integer voltageQuasiRMSSensorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real voltageQuasiRMSSensorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer voltageQuasiRMSSensorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real voltageQuasiRMSSensorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer voltageQuasiRMSSensorS.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer voltageQuasiRMSSensorS.VoltageSensor1.plug_p.m(min = 1) = voltageQuasiRMSSensorS.VoltageSensor1.m "number of phases";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer voltageQuasiRMSSensorS.VoltageSensor1.plug_n.m(min = 1) = voltageQuasiRMSSensorS.VoltageSensor1.m "number of phases";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageQuasiRMSSensorS.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real voltageQuasiRMSSensorS.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real voltageQuasiRMSSensorS.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Real voltageQuasiRMSSensorS.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real voltageQuasiRMSSensorS.Gain1.u "Input signal connector";
//   output Real voltageQuasiRMSSensorS.Gain1.y "Output signal connector";
//   parameter Integer voltageQuasiRMSSensorS.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer voltageQuasiRMSSensorS.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real voltageQuasiRMSSensorS.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real voltageQuasiRMSSensorS.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real voltageQuasiRMSSensorS.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real voltageQuasiRMSSensorS.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real voltageQuasiRMSSensorS.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer voltageQuasiRMSSensorS.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real voltageQuasiRMSSensorS.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real voltageQuasiRMSSensorS.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real voltageQuasiRMSSensorS.ToSpacePhasor1.zero;
//   parameter Integer voltageQuasiRMSSensorS.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real voltageQuasiRMSSensorS.ToPolar1.u[1] "Connector of Real input signals";
//   input Real voltageQuasiRMSSensorS.ToPolar1.u[2] "Connector of Real input signals";
//   output Real voltageQuasiRMSSensorS.ToPolar1.y[1] "Connector of Real output signals";
//   output Real voltageQuasiRMSSensorS.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real voltageQuasiRMSSensorS.ToPolar1.small = 1e-60;
//   parameter Integer deltaS.m(min = 2) = 3 "number of phases";
//   parameter Integer deltaS.plug_p.m(min = 1) = deltaS.m "number of phases";
//   Real deltaS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer deltaS.plug_n.m(min = 1) = deltaS.m "number of phases";
//   Real deltaS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real earth.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real earth.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real earth.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real earth.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real earth.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real earth.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean earth.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real earth.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = earth.T_ref "Fixed device temperature if useHeatPort = false";
//   Real earth.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real earth.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real earth.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = 1000000.0 "Resistance at temperature T_ref";
//   parameter Real earth.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperature";
//   parameter Real earth.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real earth.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real groundT.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundT.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer voltageRMSSensorL.m(min = 1) = 3 "Number of phases";
//   output Real voltageRMSSensorL.V;
//   parameter Integer voltageRMSSensorL.plug_p.m(min = 1) = 3 "number of phases";
//   Real voltageRMSSensorL.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer voltageRMSSensorL.plug_n.m(min = 1) = 3 "number of phases";
//   Real voltageRMSSensorL.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer voltageRMSSensorL.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer voltageRMSSensorL.VoltageSensor1.plug_p.m(min = 1) = voltageRMSSensorL.VoltageSensor1.m "number of phases";
//   Real voltageRMSSensorL.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer voltageRMSSensorL.VoltageSensor1.plug_n.m(min = 1) = voltageRMSSensorL.VoltageSensor1.m "number of phases";
//   Real voltageRMSSensorL.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageRMSSensorL.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real voltageRMSSensorL.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real voltageRMSSensorL.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageRMSSensorL.VoltageSensor1.voltageSensor[1].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageRMSSensorL.VoltageSensor1.voltageSensor[2].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real voltageRMSSensorL.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real voltageRMSSensorL.VoltageSensor1.voltageSensor[3].v "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Real voltageRMSSensorL.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real voltageRMSSensorL.Gain1.u "Input signal connector";
//   output Real voltageRMSSensorL.Gain1.y "Output signal connector";
//   parameter Integer voltageRMSSensorL.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer voltageRMSSensorL.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real voltageRMSSensorL.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real voltageRMSSensorL.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real voltageRMSSensorL.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real voltageRMSSensorL.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real voltageRMSSensorL.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer voltageRMSSensorL.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real voltageRMSSensorL.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real voltageRMSSensorL.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real voltageRMSSensorL.ToSpacePhasor1.zero;
//   parameter Integer voltageRMSSensorL.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real voltageRMSSensorL.ToPolar1.u[1] "Connector of Real input signals";
//   input Real voltageRMSSensorL.ToPolar1.u[2] "Connector of Real input signals";
//   output Real voltageRMSSensorL.ToPolar1.y[1] "Connector of Real output signals";
//   output Real voltageRMSSensorL.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real voltageRMSSensorL.ToPolar1.small = 1e-60;
//   parameter Integer deltaL.m(min = 2) = 3 "number of phases";
//   parameter Integer deltaL.plug_p.m(min = 1) = deltaL.m "number of phases";
//   Real deltaL.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaL.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaL.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaL.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaL.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaL.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer deltaL.plug_n.m(min = 1) = deltaL.m "number of phases";
//   Real deltaL.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaL.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaL.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaL.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real deltaL.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real deltaL.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer currentQuasiRMSSensorL.m(min = 1) = 3 "Number of phases";
//   output Real currentQuasiRMSSensorL.I;
//   parameter Integer currentQuasiRMSSensorL.plug_p.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensorL.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensorL.plug_n.m(min = 1) = 3 "number of phases";
//   Real currentQuasiRMSSensorL.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensorL.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensorL.CurrentSensor1.plug_p.m(min = 1) = currentQuasiRMSSensorL.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensorL.CurrentSensor1.plug_n.m(min = 1) = currentQuasiRMSSensorL.CurrentSensor1.m "number of phases";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorL.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensorL.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensorL.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Real currentQuasiRMSSensorL.Gain1.k(start = 1.0) = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real currentQuasiRMSSensorL.Gain1.u "Input signal connector";
//   output Real currentQuasiRMSSensorL.Gain1.y "Output signal connector";
//   parameter Integer currentQuasiRMSSensorL.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer currentQuasiRMSSensorL.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real currentQuasiRMSSensorL.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensorL.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real currentQuasiRMSSensorL.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real currentQuasiRMSSensorL.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensorL.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer currentQuasiRMSSensorL.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real currentQuasiRMSSensorL.ToSpacePhasor1.pi = 3.14159265358979;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real currentQuasiRMSSensorL.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   output Real currentQuasiRMSSensorL.ToSpacePhasor1.zero;
//   parameter Integer currentQuasiRMSSensorL.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real currentQuasiRMSSensorL.ToPolar1.u[1] "Connector of Real input signals";
//   input Real currentQuasiRMSSensorL.ToPolar1.u[2] "Connector of Real input signals";
//   output Real currentQuasiRMSSensorL.ToPolar1.y[1] "Connector of Real output signals";
//   output Real currentQuasiRMSSensorL.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real currentQuasiRMSSensorL.ToPolar1.small = 1e-60;
//   constant Integer electricalPowerSensorL.m(min = 1) = 3 "Number of phases";
//   output Real electricalPowerSensorL.P;
//   output Real electricalPowerSensorL.Q;
//   parameter Integer electricalPowerSensorL.plug_p.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensorL.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorL.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorL.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensorL.plug_ni.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensorL.plug_ni.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_ni.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorL.plug_ni.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_ni.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorL.plug_ni.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_ni.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer electricalPowerSensorL.plug_nv.m(min = 1) = 3 "number of phases";
//   Real electricalPowerSensorL.plug_nv.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_nv.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorL.plug_nv.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_nv.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real electricalPowerSensorL.plug_nv.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real electricalPowerSensorL.plug_nv.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected Real electricalPowerSensorL.v_[1](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensorL.v_[2](quantity = "ElectricPotential", unit = "V");
//   protected Real electricalPowerSensorL.i_[1](quantity = "ElectricCurrent", unit = "A");
//   protected Real electricalPowerSensorL.i_[2](quantity = "ElectricCurrent", unit = "A");
//   parameter Integer load.m(min = 1) = 3 "number of phases";
//   Real load.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real load.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real load.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real load.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real load.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real load.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer load.plug_p.m(min = 1) = load.m "number of phases";
//   Real load.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer load.plug_n.m(min = 1) = load.m "number of phases";
//   Real load.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer load.mh(min = 1) = load.m "Number of heatPorts=number of phases";
//   parameter Boolean load.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real load.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real load.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real load.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real load.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = RL[1] "Resistances R_ref at temperatures T_ref";
//   parameter Real load.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = RL[2] "Resistances R_ref at temperatures T_ref";
//   parameter Real load.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = RL[3] "Resistances R_ref at temperatures T_ref";
//   parameter Real load.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real load.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real load.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperatures";
//   parameter Real load.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real load.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real load.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real load.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real load.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real load.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean load.resistor[1].useHeatPort = load.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real load.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T[1] "Fixed device temperature if useHeatPort = false";
//   Real load.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real load.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real load.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = load.R[1] "Resistance at temperature T_ref";
//   parameter Real load.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref[1] "Reference temperature";
//   parameter Real load.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = load.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real load.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real load.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean load.resistor[2].useHeatPort = load.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real load.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T[2] "Fixed device temperature if useHeatPort = false";
//   Real load.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real load.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real load.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = load.R[2] "Resistance at temperature T_ref";
//   parameter Real load.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref[2] "Reference temperature";
//   parameter Real load.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = load.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real load.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real load.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean load.resistor[3].useHeatPort = load.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real load.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T[3] "Fixed device temperature if useHeatPort = false";
//   Real load.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real load.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real load.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = load.R[3] "Resistance at temperature T_ref";
//   parameter Real load.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref[3] "Reference temperature";
//   parameter Real load.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = load.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer starL.m(min = 1) = 3 "number of phases";
//   parameter Integer starL.plug_p.m(min = 1) = starL.m "number of phases";
//   Real starL.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starL.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starL.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starL.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starL.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starL.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starL.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starL.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real groundL.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundL.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformerData.f(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real transformerData.V1(quantity = "ElectricPotential", unit = "V", start = 100.0) "primary nominal line-to-line voltage (RMS)";
//   parameter String transformerData.C1(start = "Y") = "Y" "choose primary connection";
//   parameter Real transformerData.V2(quantity = "ElectricPotential", unit = "V", start = 100.0) "secondary open circuit line-to-line voltage (RMS) @ primary nominal voltage";
//   parameter String transformerData.C2(start = "y") = "d" "choose secondary connection";
//   parameter Real transformerData.SNominal(quantity = "Power", unit = "VA", start = 30000.0) "nominal apparent power";
//   parameter Real transformerData.v_sc(min = 0.0, max = 1.0, start = 0.05) "impedance voltage drop pu";
//   parameter Real transformerData.P_sc(quantity = "Power", unit = "W", start = 300.0) "short-circuit (copper) losses";
//   parameter Real transformerData.n = transformerData.V1 / transformerData.V2 "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformerData.V1ph(quantity = "ElectricPotential", unit = "V") = transformerData.V1 / (if transformerData.C1 == "D" then 1.0 else 1.73205080756888) "primary phase voltage (RMS)";
//   parameter Real transformerData.I1ph(quantity = "ElectricCurrent", unit = "A") = transformerData.SNominal * 1.0 / transformerData.V1ph / 3.0 "primary phase current (RMS)";
//   parameter Real transformerData.V2ph(quantity = "ElectricPotential", unit = "V") = transformerData.V2 / (if transformerData.C2 == "d" then 1.0 else 1.73205080756888) "secondary phase voltage (RMS)";
//   parameter Real transformerData.I2ph(quantity = "ElectricCurrent", unit = "A") = transformerData.SNominal * 1.0 / transformerData.V2ph / 3.0 "secondary phase current (RMS)";
//   parameter Real transformerData.Z1ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData.v_sc * transformerData.V1ph / transformerData.I1ph) "primary impedance per phase";
//   parameter Real transformerData.R1(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData.P_sc * transformerData.I1ph ^ -2.0 / 3.0) "warm primary resistance per phase";
//   parameter Real transformerData.L1sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData.Z1ph ^ 2.0 - transformerData.R1 ^ 2.0) * 1.0 / transformerData.f / 6.28318530717959 "primary stray inductance per phase";
//   parameter Real transformerData.Z2ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData.v_sc * transformerData.V2ph / transformerData.I2ph) "secondary impedance per phase";
//   parameter Real transformerData.R2(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData.P_sc * transformerData.I2ph ^ -2.0 / 3.0) "warm secondary resistance per phase";
//   parameter Real transformerData.L2sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData.Z2ph ^ 2.0 - transformerData.R2 ^ 2.0) * 1.0 / transformerData.f / 6.28318530717959 "secondary stray inductance per phase";
//   constant Integer transformer.m(min = 1) = 3 "Number of phases";
//   constant String transformer.VectorGroup = "Yd01";
//   parameter Real transformer.n(start = 1.0) = transformerData.n "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformer.R1(quantity = "Resistance", unit = "Ohm", start = 0.00166666666666667) = transformerData.R1 "warm primary resistance per phase";
//   parameter Real transformer.L1sigma(quantity = "Inductance", unit = "H", start = 2.6e-05) = transformerData.L1sigma "primary stray inductance per phase";
//   parameter Real transformer.R2(quantity = "Resistance", unit = "Ohm", start = 0.005) = transformerData.R2 "warm secondary resistance per phase";
//   parameter Real transformer.L2sigma(quantity = "Inductance", unit = "H", start = 7.8e-05) = transformerData.L2sigma "secondary stray inductance per phase";
//   output Real transformer.v1[1](quantity = "ElectricPotential", unit = "V") = transformer.plug1.pin[1].v "Primary voltage";
//   output Real transformer.v1[2](quantity = "ElectricPotential", unit = "V") = transformer.plug1.pin[2].v "Primary voltage";
//   output Real transformer.v1[3](quantity = "ElectricPotential", unit = "V") = transformer.plug1.pin[3].v "Primary voltage";
//   output Real transformer.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer.plug1.pin[1].i "Primary current";
//   output Real transformer.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer.plug1.pin[2].i "Primary current";
//   output Real transformer.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer.plug1.pin[3].i "Primary current";
//   output Real transformer.v2[1](quantity = "ElectricPotential", unit = "V") = transformer.plug2.pin[1].v "Secondary voltage";
//   output Real transformer.v2[2](quantity = "ElectricPotential", unit = "V") = transformer.plug2.pin[2].v "Secondary voltage";
//   output Real transformer.v2[3](quantity = "ElectricPotential", unit = "V") = transformer.plug2.pin[3].v "Secondary voltage";
//   output Real transformer.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer.plug2.pin[1].i "Secondary current";
//   output Real transformer.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer.plug2.pin[2].i "Secondary current";
//   output Real transformer.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer.plug2.pin[3].i "Secondary current";
//   protected constant String transformer.C1 = "Y";
//   protected constant String transformer.C2 = "d";
//   protected parameter Real transformer.ni = 1.15470053837925 * transformer.n;
//   parameter Integer transformer.plug1.m(min = 1) = 3 "number of phases";
//   Real transformer.plug1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.plug1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.plug1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.plug1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.plug1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.plug1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.plug2.m(min = 1) = 3 "number of phases";
//   Real transformer.plug2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.plug2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.plug2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.plug2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.plug2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.plug2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.r1.m(min = 1) = 3 "number of phases";
//   Real transformer.r1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.r1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.r1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.r1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.r1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.r1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer.r1.plug_p.m(min = 1) = transformer.r1.m "number of phases";
//   Real transformer.r1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.r1.plug_n.m(min = 1) = transformer.r1.m "number of phases";
//   Real transformer.r1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.r1.mh(min = 1) = transformer.r1.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer.r1.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer.r1.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer.r1.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer.r1.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer.r1.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer.r1.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer.r1.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer.r1.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer.r1.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer.r1.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer.r1.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer.r1.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer.r1.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer.r1.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.r1.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.r1.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer.r1.resistor[1].useHeatPort = transformer.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer.r1.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer.r1.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer.r1.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer.r1.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.r1.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer.r1.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T_ref[1] "Reference temperature";
//   parameter Real transformer.r1.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer.r1.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r1.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r1.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.r1.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.r1.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer.r1.resistor[2].useHeatPort = transformer.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer.r1.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer.r1.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer.r1.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer.r1.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.r1.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer.r1.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T_ref[2] "Reference temperature";
//   parameter Real transformer.r1.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer.r1.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r1.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r1.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.r1.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.r1.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r1.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r1.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer.r1.resistor[3].useHeatPort = transformer.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer.r1.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer.r1.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer.r1.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer.r1.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.r1.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer.r1.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r1.T_ref[3] "Reference temperature";
//   parameter Real transformer.r1.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer.r1.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r1.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer.l1sigma.m(min = 1) = 3 "number of phases";
//   Real transformer.l1sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.l1sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.l1sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.l1sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.l1sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.l1sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer.l1sigma.plug_p.m(min = 1) = transformer.l1sigma.m "number of phases";
//   Real transformer.l1sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.l1sigma.plug_n.m(min = 1) = transformer.l1sigma.m "number of phases";
//   Real transformer.l1sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l1sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer.L1sigma "Inductance";
//   parameter Real transformer.l1sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer.L1sigma "Inductance";
//   parameter Real transformer.l1sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer.L1sigma "Inductance";
//   Real transformer.l1sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.l1sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.l1sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l1sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer.l1sigma.L[1] "Inductance";
//   Real transformer.l1sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.l1sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.l1sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l1sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer.l1sigma.L[2] "Inductance";
//   Real transformer.l1sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.l1sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.l1sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l1sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l1sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l1sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer.l1sigma.L[3] "Inductance";
//   parameter Integer transformer.r2.m(min = 1) = 3 "number of phases";
//   Real transformer.r2.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.r2.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.r2.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.r2.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.r2.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.r2.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer.r2.plug_p.m(min = 1) = transformer.r2.m "number of phases";
//   Real transformer.r2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.r2.plug_n.m(min = 1) = transformer.r2.m "number of phases";
//   Real transformer.r2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.r2.mh(min = 1) = transformer.r2.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer.r2.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer.r2.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer.r2.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer.r2.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer.r2.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer.r2.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer.r2.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer.r2.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer.r2.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer.r2.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer.r2.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer.r2.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer.r2.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer.r2.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.r2.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.r2.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer.r2.resistor[1].useHeatPort = transformer.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer.r2.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer.r2.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer.r2.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer.r2.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.r2.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer.r2.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T_ref[1] "Reference temperature";
//   parameter Real transformer.r2.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer.r2.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r2.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r2.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.r2.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.r2.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer.r2.resistor[2].useHeatPort = transformer.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer.r2.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer.r2.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer.r2.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer.r2.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.r2.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer.r2.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T_ref[2] "Reference temperature";
//   parameter Real transformer.r2.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer.r2.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r2.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r2.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.r2.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.r2.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.r2.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.r2.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer.r2.resistor[3].useHeatPort = transformer.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer.r2.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer.r2.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer.r2.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer.r2.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer.r2.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer.r2.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer.r2.T_ref[3] "Reference temperature";
//   parameter Real transformer.r2.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer.r2.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer.r2.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer.l2sigma.m(min = 1) = 3 "number of phases";
//   Real transformer.l2sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.l2sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.l2sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer.l2sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.l2sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer.l2sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer.l2sigma.plug_p.m(min = 1) = transformer.l2sigma.m "number of phases";
//   Real transformer.l2sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.l2sigma.plug_n.m(min = 1) = transformer.l2sigma.m "number of phases";
//   Real transformer.l2sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l2sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer.L2sigma "Inductance";
//   parameter Real transformer.l2sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer.L2sigma "Inductance";
//   parameter Real transformer.l2sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer.L2sigma "Inductance";
//   Real transformer.l2sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.l2sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.l2sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l2sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer.l2sigma.L[1] "Inductance";
//   Real transformer.l2sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.l2sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.l2sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l2sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer.l2sigma.L[2] "Inductance";
//   Real transformer.l2sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer.l2sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer.l2sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.l2sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.l2sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer.l2sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer.l2sigma.L[3] "Inductance";
//   parameter Integer transformer.core.m(min = 1) = 3 "number of phases";
//   parameter Real transformer.core.n12(start = 1.0) = transformer.ni "turns ratio 1:2";
//   parameter Real transformer.core.n13(start = 1.0) = transformer.ni "turns ratio 1:3";
//   Real transformer.core.v1[1](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p1.pin[1].v - transformer.core.plug_n1.pin[1].v;
//   Real transformer.core.v1[2](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p1.pin[2].v - transformer.core.plug_n1.pin[2].v;
//   Real transformer.core.v1[3](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p1.pin[3].v - transformer.core.plug_n1.pin[3].v;
//   Real transformer.core.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p1.pin[1].i;
//   Real transformer.core.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p1.pin[2].i;
//   Real transformer.core.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p1.pin[3].i;
//   Real transformer.core.v2[1](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p2.pin[1].v - transformer.core.plug_n2.pin[1].v;
//   Real transformer.core.v2[2](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p2.pin[2].v - transformer.core.plug_n2.pin[2].v;
//   Real transformer.core.v2[3](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p2.pin[3].v - transformer.core.plug_n2.pin[3].v;
//   Real transformer.core.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p2.pin[1].i;
//   Real transformer.core.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p2.pin[2].i;
//   Real transformer.core.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p2.pin[3].i;
//   Real transformer.core.v3[1](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p3.pin[1].v - transformer.core.plug_n3.pin[1].v;
//   Real transformer.core.v3[2](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p3.pin[2].v - transformer.core.plug_n3.pin[2].v;
//   Real transformer.core.v3[3](quantity = "ElectricPotential", unit = "V") = transformer.core.plug_p3.pin[3].v - transformer.core.plug_n3.pin[3].v;
//   Real transformer.core.i3[1](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p3.pin[1].i;
//   Real transformer.core.i3[2](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p3.pin[2].i;
//   Real transformer.core.i3[3](quantity = "ElectricCurrent", unit = "A") = transformer.core.plug_p3.pin[3].i;
//   Real transformer.core.im[1](quantity = "ElectricCurrent", unit = "A") = transformer.core.i1[1] + (transformer.core.i2[1] / transformer.core.n12 + transformer.core.i3[1] / transformer.core.n13) "Magnetizing current";
//   Real transformer.core.im[2](quantity = "ElectricCurrent", unit = "A") = transformer.core.i1[2] + (transformer.core.i2[2] / transformer.core.n12 + transformer.core.i3[2] / transformer.core.n13) "Magnetizing current";
//   Real transformer.core.im[3](quantity = "ElectricCurrent", unit = "A") = transformer.core.i1[3] + (transformer.core.i2[3] / transformer.core.n12 + transformer.core.i3[3] / transformer.core.n13) "Magnetizing current";
//   parameter Integer transformer.core.plug_p1.m(min = 1) = transformer.core.m "number of phases";
//   Real transformer.core.plug_p1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_p1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_p1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.core.plug_n1.m(min = 1) = transformer.core.m "number of phases";
//   Real transformer.core.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.core.plug_p2.m(min = 1) = transformer.core.m "number of phases";
//   Real transformer.core.plug_p2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_p2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_p2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.core.plug_n2.m(min = 1) = transformer.core.m "number of phases";
//   Real transformer.core.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.core.plug_p3.m(min = 1) = transformer.core.m "number of phases";
//   Real transformer.core.plug_p3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_p3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_p3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_p3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.core.plug_n3.m(min = 1) = transformer.core.m "number of phases";
//   Real transformer.core.plug_n3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_n3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.core.plug_n3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.core.plug_n3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.star1.m(min = 1) = 3 "number of phases";
//   parameter Integer transformer.star1.plug_p.m(min = 1) = transformer.star1.m "number of phases";
//   Real transformer.star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.starpoint1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.starpoint1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.Delta2.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer.Delta2.plug_p.m(min = 1) = transformer.Delta2.m "number of phases";
//   Real transformer.Delta2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.Delta2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.Delta2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.Delta2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.Delta2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.Delta2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer.Delta2.plug_n.m(min = 1) = transformer.Delta2.m "number of phases";
//   Real transformer.Delta2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.Delta2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.Delta2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.Delta2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer.Delta2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer.Delta2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   source.sineVoltage[1].signalSource.y = source.sineVoltage[1].signalSource.offset + (if time < source.sineVoltage[1].signalSource.startTime then 0.0 else source.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[1].signalSource.freqHz * (time - source.sineVoltage[1].signalSource.startTime)) + source.sineVoltage[1].signalSource.phase));
//   source.sineVoltage[1].v = source.sineVoltage[1].signalSource.y;
//   source.sineVoltage[1].v = source.sineVoltage[1].p.v - source.sineVoltage[1].n.v;
//   0.0 = source.sineVoltage[1].p.i + source.sineVoltage[1].n.i;
//   source.sineVoltage[1].i = source.sineVoltage[1].p.i;
//   source.sineVoltage[2].signalSource.y = source.sineVoltage[2].signalSource.offset + (if time < source.sineVoltage[2].signalSource.startTime then 0.0 else source.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[2].signalSource.freqHz * (time - source.sineVoltage[2].signalSource.startTime)) + source.sineVoltage[2].signalSource.phase));
//   source.sineVoltage[2].v = source.sineVoltage[2].signalSource.y;
//   source.sineVoltage[2].v = source.sineVoltage[2].p.v - source.sineVoltage[2].n.v;
//   0.0 = source.sineVoltage[2].p.i + source.sineVoltage[2].n.i;
//   source.sineVoltage[2].i = source.sineVoltage[2].p.i;
//   source.sineVoltage[3].signalSource.y = source.sineVoltage[3].signalSource.offset + (if time < source.sineVoltage[3].signalSource.startTime then 0.0 else source.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[3].signalSource.freqHz * (time - source.sineVoltage[3].signalSource.startTime)) + source.sineVoltage[3].signalSource.phase));
//   source.sineVoltage[3].v = source.sineVoltage[3].signalSource.y;
//   source.sineVoltage[3].v = source.sineVoltage[3].p.v - source.sineVoltage[3].n.v;
//   0.0 = source.sineVoltage[3].p.i + source.sineVoltage[3].n.i;
//   source.sineVoltage[3].i = source.sineVoltage[3].p.i;
//   source.v[1] = source.plug_p.pin[1].v - source.plug_n.pin[1].v;
//   source.v[2] = source.plug_p.pin[2].v - source.plug_n.pin[2].v;
//   source.v[3] = source.plug_p.pin[3].v - source.plug_n.pin[3].v;
//   source.i[1] = source.plug_p.pin[1].i;
//   source.i[2] = source.plug_p.pin[2].i;
//   source.i[3] = source.plug_p.pin[3].i;
//   groundS.p.v = 0.0;
//   electricalPowerSensorS.plug_p.pin[1].v = electricalPowerSensorS.plug_ni.pin[1].v;
//   electricalPowerSensorS.plug_p.pin[2].v = electricalPowerSensorS.plug_ni.pin[2].v;
//   electricalPowerSensorS.plug_p.pin[3].v = electricalPowerSensorS.plug_ni.pin[3].v;
//   electricalPowerSensorS.plug_p.pin[1].i + electricalPowerSensorS.plug_ni.pin[1].i = 0.0;
//   electricalPowerSensorS.plug_p.pin[2].i + electricalPowerSensorS.plug_ni.pin[2].i = 0.0;
//   electricalPowerSensorS.plug_p.pin[3].i + electricalPowerSensorS.plug_ni.pin[3].i = 0.0;
//   electricalPowerSensorS.plug_nv.pin[1].i = 0.0;
//   electricalPowerSensorS.plug_nv.pin[2].i = 0.0;
//   electricalPowerSensorS.plug_nv.pin[3].i = 0.0;
//   (electricalPowerSensorS.v_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensorS.plug_p.pin[1].v - electricalPowerSensorS.plug_nv.pin[1].v,electricalPowerSensorS.plug_p.pin[2].v - electricalPowerSensorS.plug_nv.pin[2].v,electricalPowerSensorS.plug_p.pin[3].v - electricalPowerSensorS.plug_nv.pin[3].v});
//   (electricalPowerSensorS.i_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensorS.plug_p.pin[1].i,electricalPowerSensorS.plug_p.pin[2].i,electricalPowerSensorS.plug_p.pin[3].i});
//   0.666666666666667 * electricalPowerSensorS.P = electricalPowerSensorS.v_[1] * electricalPowerSensorS.i_[1] + electricalPowerSensorS.v_[2] * electricalPowerSensorS.i_[2];
//   0.666666666666667 * electricalPowerSensorS.Q = (-electricalPowerSensorS.v_[1]) * electricalPowerSensorS.i_[2] + electricalPowerSensorS.v_[2] * electricalPowerSensorS.i_[1];
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensorS.Gain1.y = currentQuasiRMSSensorS.Gain1.k * currentQuasiRMSSensorS.Gain1.u;
//   currentQuasiRMSSensorS.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensorS.ToSpacePhasor1.u[1] + (currentQuasiRMSSensorS.ToSpacePhasor1.u[2] + currentQuasiRMSSensorS.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensorS.ToSpacePhasor1.y[1] = currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensorS.ToSpacePhasor1.u[1] + (currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensorS.ToSpacePhasor1.u[2] + currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensorS.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensorS.ToSpacePhasor1.y[2] = currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensorS.ToSpacePhasor1.u[1] + (currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensorS.ToSpacePhasor1.u[2] + currentQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensorS.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensorS.ToPolar1.y[1] = sqrt(currentQuasiRMSSensorS.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensorS.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensorS.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensorS.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensorS.ToPolar1.u[2],currentQuasiRMSSensorS.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensorS.plug_p.m == currentQuasiRMSSensorS.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensorS.CurrentSensor1.plug_n.m == currentQuasiRMSSensorS.plug_n.m,"automatically generated from connect");
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].p.v - voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].n.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].p.v - voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].n.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].p.v - voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].n.v;
//   voltageQuasiRMSSensorS.Gain1.y = voltageQuasiRMSSensorS.Gain1.k * voltageQuasiRMSSensorS.Gain1.u;
//   voltageQuasiRMSSensorS.ToSpacePhasor1.zero = 0.333333333333333 * (voltageQuasiRMSSensorS.ToSpacePhasor1.u[1] + (voltageQuasiRMSSensorS.ToSpacePhasor1.u[2] + voltageQuasiRMSSensorS.ToSpacePhasor1.u[3]));
//   voltageQuasiRMSSensorS.ToSpacePhasor1.y[1] = voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,1] * voltageQuasiRMSSensorS.ToSpacePhasor1.u[1] + (voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,2] * voltageQuasiRMSSensorS.ToSpacePhasor1.u[2] + voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[1,3] * voltageQuasiRMSSensorS.ToSpacePhasor1.u[3]);
//   voltageQuasiRMSSensorS.ToSpacePhasor1.y[2] = voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,1] * voltageQuasiRMSSensorS.ToSpacePhasor1.u[1] + (voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,2] * voltageQuasiRMSSensorS.ToSpacePhasor1.u[2] + voltageQuasiRMSSensorS.ToSpacePhasor1.TransformationMatrix[2,3] * voltageQuasiRMSSensorS.ToSpacePhasor1.u[3]);
//   voltageQuasiRMSSensorS.ToPolar1.y[1] = sqrt(voltageQuasiRMSSensorS.ToPolar1.u[1] ^ 2.0 + voltageQuasiRMSSensorS.ToPolar1.u[2] ^ 2.0);
//   voltageQuasiRMSSensorS.ToPolar1.y[2] = if noEvent(voltageQuasiRMSSensorS.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(voltageQuasiRMSSensorS.ToPolar1.u[2],voltageQuasiRMSSensorS.ToPolar1.u[1]);
//   assert(voltageQuasiRMSSensorS.plug_p.m == voltageQuasiRMSSensorS.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(voltageQuasiRMSSensorS.VoltageSensor1.plug_n.m == voltageQuasiRMSSensorS.plug_n.m,"automatically generated from connect");
//   assert(1.0 + earth.alpha * (earth.T_heatPort - earth.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   earth.R_actual = earth.R * (1.0 + earth.alpha * (earth.T_heatPort - earth.T_ref));
//   earth.v = earth.R_actual * earth.i;
//   earth.LossPower = earth.v * earth.i;
//   earth.i = earth.p.i;
//   0.0 = earth.p.i + earth.n.i;
//   earth.v = earth.p.v - earth.n.v;
//   earth.T_heatPort = earth.T;
//   groundT.p.v = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[1].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[1].p.v - voltageRMSSensorL.VoltageSensor1.voltageSensor[1].n.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[2].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[2].p.v - voltageRMSSensorL.VoltageSensor1.voltageSensor[2].n.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[3].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[3].p.v - voltageRMSSensorL.VoltageSensor1.voltageSensor[3].n.v;
//   voltageRMSSensorL.Gain1.y = voltageRMSSensorL.Gain1.k * voltageRMSSensorL.Gain1.u;
//   voltageRMSSensorL.ToSpacePhasor1.zero = 0.333333333333333 * (voltageRMSSensorL.ToSpacePhasor1.u[1] + (voltageRMSSensorL.ToSpacePhasor1.u[2] + voltageRMSSensorL.ToSpacePhasor1.u[3]));
//   voltageRMSSensorL.ToSpacePhasor1.y[1] = voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,1] * voltageRMSSensorL.ToSpacePhasor1.u[1] + (voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,2] * voltageRMSSensorL.ToSpacePhasor1.u[2] + voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,3] * voltageRMSSensorL.ToSpacePhasor1.u[3]);
//   voltageRMSSensorL.ToSpacePhasor1.y[2] = voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,1] * voltageRMSSensorL.ToSpacePhasor1.u[1] + (voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,2] * voltageRMSSensorL.ToSpacePhasor1.u[2] + voltageRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,3] * voltageRMSSensorL.ToSpacePhasor1.u[3]);
//   voltageRMSSensorL.ToPolar1.y[1] = sqrt(voltageRMSSensorL.ToPolar1.u[1] ^ 2.0 + voltageRMSSensorL.ToPolar1.u[2] ^ 2.0);
//   voltageRMSSensorL.ToPolar1.y[2] = if noEvent(voltageRMSSensorL.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(voltageRMSSensorL.ToPolar1.u[2],voltageRMSSensorL.ToPolar1.u[1]);
//   assert(voltageRMSSensorL.plug_p.m == voltageRMSSensorL.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(voltageRMSSensorL.VoltageSensor1.plug_n.m == voltageRMSSensorL.plug_n.m,"automatically generated from connect");
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].n.v;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].p.i = currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].n.i = -currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].i;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].n.v;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].p.i = currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].n.i = -currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].i;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].n.v;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].p.i = currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].n.i = -currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].i;
//   currentQuasiRMSSensorL.Gain1.y = currentQuasiRMSSensorL.Gain1.k * currentQuasiRMSSensorL.Gain1.u;
//   currentQuasiRMSSensorL.ToSpacePhasor1.zero = 0.333333333333333 * (currentQuasiRMSSensorL.ToSpacePhasor1.u[1] + (currentQuasiRMSSensorL.ToSpacePhasor1.u[2] + currentQuasiRMSSensorL.ToSpacePhasor1.u[3]));
//   currentQuasiRMSSensorL.ToSpacePhasor1.y[1] = currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,1] * currentQuasiRMSSensorL.ToSpacePhasor1.u[1] + (currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,2] * currentQuasiRMSSensorL.ToSpacePhasor1.u[2] + currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[1,3] * currentQuasiRMSSensorL.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensorL.ToSpacePhasor1.y[2] = currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,1] * currentQuasiRMSSensorL.ToSpacePhasor1.u[1] + (currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,2] * currentQuasiRMSSensorL.ToSpacePhasor1.u[2] + currentQuasiRMSSensorL.ToSpacePhasor1.TransformationMatrix[2,3] * currentQuasiRMSSensorL.ToSpacePhasor1.u[3]);
//   currentQuasiRMSSensorL.ToPolar1.y[1] = sqrt(currentQuasiRMSSensorL.ToPolar1.u[1] ^ 2.0 + currentQuasiRMSSensorL.ToPolar1.u[2] ^ 2.0);
//   currentQuasiRMSSensorL.ToPolar1.y[2] = if noEvent(currentQuasiRMSSensorL.ToPolar1.y[1] <= 1e-60) then 0.0 else atan2(currentQuasiRMSSensorL.ToPolar1.u[2],currentQuasiRMSSensorL.ToPolar1.u[1]);
//   assert(currentQuasiRMSSensorL.plug_p.m == currentQuasiRMSSensorL.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensorL.CurrentSensor1.plug_n.m == currentQuasiRMSSensorL.plug_n.m,"automatically generated from connect");
//   electricalPowerSensorL.plug_p.pin[1].v = electricalPowerSensorL.plug_ni.pin[1].v;
//   electricalPowerSensorL.plug_p.pin[2].v = electricalPowerSensorL.plug_ni.pin[2].v;
//   electricalPowerSensorL.plug_p.pin[3].v = electricalPowerSensorL.plug_ni.pin[3].v;
//   electricalPowerSensorL.plug_p.pin[1].i + electricalPowerSensorL.plug_ni.pin[1].i = 0.0;
//   electricalPowerSensorL.plug_p.pin[2].i + electricalPowerSensorL.plug_ni.pin[2].i = 0.0;
//   electricalPowerSensorL.plug_p.pin[3].i + electricalPowerSensorL.plug_ni.pin[3].i = 0.0;
//   electricalPowerSensorL.plug_nv.pin[1].i = 0.0;
//   electricalPowerSensorL.plug_nv.pin[2].i = 0.0;
//   electricalPowerSensorL.plug_nv.pin[3].i = 0.0;
//   (electricalPowerSensorL.v_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensorL.plug_p.pin[1].v - electricalPowerSensorL.plug_nv.pin[1].v,electricalPowerSensorL.plug_p.pin[2].v - electricalPowerSensorL.plug_nv.pin[2].v,electricalPowerSensorL.plug_p.pin[3].v - electricalPowerSensorL.plug_nv.pin[3].v});
//   (electricalPowerSensorL.i_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({electricalPowerSensorL.plug_p.pin[1].i,electricalPowerSensorL.plug_p.pin[2].i,electricalPowerSensorL.plug_p.pin[3].i});
//   0.666666666666667 * electricalPowerSensorL.P = electricalPowerSensorL.v_[1] * electricalPowerSensorL.i_[1] + electricalPowerSensorL.v_[2] * electricalPowerSensorL.i_[2];
//   0.666666666666667 * electricalPowerSensorL.Q = (-electricalPowerSensorL.v_[1]) * electricalPowerSensorL.i_[2] + electricalPowerSensorL.v_[2] * electricalPowerSensorL.i_[1];
//   assert(1.0 + load.resistor[1].alpha * (load.resistor[1].T_heatPort - load.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   load.resistor[1].R_actual = load.resistor[1].R * (1.0 + load.resistor[1].alpha * (load.resistor[1].T_heatPort - load.resistor[1].T_ref));
//   load.resistor[1].v = load.resistor[1].R_actual * load.resistor[1].i;
//   load.resistor[1].LossPower = load.resistor[1].v * load.resistor[1].i;
//   load.resistor[1].i = load.resistor[1].p.i;
//   0.0 = load.resistor[1].p.i + load.resistor[1].n.i;
//   load.resistor[1].v = load.resistor[1].p.v - load.resistor[1].n.v;
//   load.resistor[1].T_heatPort = load.resistor[1].T;
//   assert(1.0 + load.resistor[2].alpha * (load.resistor[2].T_heatPort - load.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   load.resistor[2].R_actual = load.resistor[2].R * (1.0 + load.resistor[2].alpha * (load.resistor[2].T_heatPort - load.resistor[2].T_ref));
//   load.resistor[2].v = load.resistor[2].R_actual * load.resistor[2].i;
//   load.resistor[2].LossPower = load.resistor[2].v * load.resistor[2].i;
//   load.resistor[2].i = load.resistor[2].p.i;
//   0.0 = load.resistor[2].p.i + load.resistor[2].n.i;
//   load.resistor[2].v = load.resistor[2].p.v - load.resistor[2].n.v;
//   load.resistor[2].T_heatPort = load.resistor[2].T;
//   assert(1.0 + load.resistor[3].alpha * (load.resistor[3].T_heatPort - load.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   load.resistor[3].R_actual = load.resistor[3].R * (1.0 + load.resistor[3].alpha * (load.resistor[3].T_heatPort - load.resistor[3].T_ref));
//   load.resistor[3].v = load.resistor[3].R_actual * load.resistor[3].i;
//   load.resistor[3].LossPower = load.resistor[3].v * load.resistor[3].i;
//   load.resistor[3].i = load.resistor[3].p.i;
//   0.0 = load.resistor[3].p.i + load.resistor[3].n.i;
//   load.resistor[3].v = load.resistor[3].p.v - load.resistor[3].n.v;
//   load.resistor[3].T_heatPort = load.resistor[3].T;
//   load.v[1] = load.plug_p.pin[1].v - load.plug_n.pin[1].v;
//   load.v[2] = load.plug_p.pin[2].v - load.plug_n.pin[2].v;
//   load.v[3] = load.plug_p.pin[3].v - load.plug_n.pin[3].v;
//   load.i[1] = load.plug_p.pin[1].i;
//   load.i[2] = load.plug_p.pin[2].i;
//   load.i[3] = load.plug_p.pin[3].i;
//   groundL.p.v = 0.0;
//   assert(1.0 + transformer.r1.resistor[1].alpha * (transformer.r1.resistor[1].T_heatPort - transformer.r1.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer.r1.resistor[1].R_actual = transformer.r1.resistor[1].R * (1.0 + transformer.r1.resistor[1].alpha * (transformer.r1.resistor[1].T_heatPort - transformer.r1.resistor[1].T_ref));
//   transformer.r1.resistor[1].v = transformer.r1.resistor[1].R_actual * transformer.r1.resistor[1].i;
//   transformer.r1.resistor[1].LossPower = transformer.r1.resistor[1].v * transformer.r1.resistor[1].i;
//   transformer.r1.resistor[1].i = transformer.r1.resistor[1].p.i;
//   0.0 = transformer.r1.resistor[1].p.i + transformer.r1.resistor[1].n.i;
//   transformer.r1.resistor[1].v = transformer.r1.resistor[1].p.v - transformer.r1.resistor[1].n.v;
//   transformer.r1.resistor[1].T_heatPort = transformer.r1.resistor[1].T;
//   assert(1.0 + transformer.r1.resistor[2].alpha * (transformer.r1.resistor[2].T_heatPort - transformer.r1.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer.r1.resistor[2].R_actual = transformer.r1.resistor[2].R * (1.0 + transformer.r1.resistor[2].alpha * (transformer.r1.resistor[2].T_heatPort - transformer.r1.resistor[2].T_ref));
//   transformer.r1.resistor[2].v = transformer.r1.resistor[2].R_actual * transformer.r1.resistor[2].i;
//   transformer.r1.resistor[2].LossPower = transformer.r1.resistor[2].v * transformer.r1.resistor[2].i;
//   transformer.r1.resistor[2].i = transformer.r1.resistor[2].p.i;
//   0.0 = transformer.r1.resistor[2].p.i + transformer.r1.resistor[2].n.i;
//   transformer.r1.resistor[2].v = transformer.r1.resistor[2].p.v - transformer.r1.resistor[2].n.v;
//   transformer.r1.resistor[2].T_heatPort = transformer.r1.resistor[2].T;
//   assert(1.0 + transformer.r1.resistor[3].alpha * (transformer.r1.resistor[3].T_heatPort - transformer.r1.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer.r1.resistor[3].R_actual = transformer.r1.resistor[3].R * (1.0 + transformer.r1.resistor[3].alpha * (transformer.r1.resistor[3].T_heatPort - transformer.r1.resistor[3].T_ref));
//   transformer.r1.resistor[3].v = transformer.r1.resistor[3].R_actual * transformer.r1.resistor[3].i;
//   transformer.r1.resistor[3].LossPower = transformer.r1.resistor[3].v * transformer.r1.resistor[3].i;
//   transformer.r1.resistor[3].i = transformer.r1.resistor[3].p.i;
//   0.0 = transformer.r1.resistor[3].p.i + transformer.r1.resistor[3].n.i;
//   transformer.r1.resistor[3].v = transformer.r1.resistor[3].p.v - transformer.r1.resistor[3].n.v;
//   transformer.r1.resistor[3].T_heatPort = transformer.r1.resistor[3].T;
//   transformer.r1.v[1] = transformer.r1.plug_p.pin[1].v - transformer.r1.plug_n.pin[1].v;
//   transformer.r1.v[2] = transformer.r1.plug_p.pin[2].v - transformer.r1.plug_n.pin[2].v;
//   transformer.r1.v[3] = transformer.r1.plug_p.pin[3].v - transformer.r1.plug_n.pin[3].v;
//   transformer.r1.i[1] = transformer.r1.plug_p.pin[1].i;
//   transformer.r1.i[2] = transformer.r1.plug_p.pin[2].i;
//   transformer.r1.i[3] = transformer.r1.plug_p.pin[3].i;
//   transformer.l1sigma.inductor[1].L * der(transformer.l1sigma.inductor[1].i) = transformer.l1sigma.inductor[1].v;
//   transformer.l1sigma.inductor[1].v = transformer.l1sigma.inductor[1].p.v - transformer.l1sigma.inductor[1].n.v;
//   0.0 = transformer.l1sigma.inductor[1].p.i + transformer.l1sigma.inductor[1].n.i;
//   transformer.l1sigma.inductor[1].i = transformer.l1sigma.inductor[1].p.i;
//   transformer.l1sigma.inductor[2].L * der(transformer.l1sigma.inductor[2].i) = transformer.l1sigma.inductor[2].v;
//   transformer.l1sigma.inductor[2].v = transformer.l1sigma.inductor[2].p.v - transformer.l1sigma.inductor[2].n.v;
//   0.0 = transformer.l1sigma.inductor[2].p.i + transformer.l1sigma.inductor[2].n.i;
//   transformer.l1sigma.inductor[2].i = transformer.l1sigma.inductor[2].p.i;
//   transformer.l1sigma.inductor[3].L * der(transformer.l1sigma.inductor[3].i) = transformer.l1sigma.inductor[3].v;
//   transformer.l1sigma.inductor[3].v = transformer.l1sigma.inductor[3].p.v - transformer.l1sigma.inductor[3].n.v;
//   0.0 = transformer.l1sigma.inductor[3].p.i + transformer.l1sigma.inductor[3].n.i;
//   transformer.l1sigma.inductor[3].i = transformer.l1sigma.inductor[3].p.i;
//   transformer.l1sigma.v[1] = transformer.l1sigma.plug_p.pin[1].v - transformer.l1sigma.plug_n.pin[1].v;
//   transformer.l1sigma.v[2] = transformer.l1sigma.plug_p.pin[2].v - transformer.l1sigma.plug_n.pin[2].v;
//   transformer.l1sigma.v[3] = transformer.l1sigma.plug_p.pin[3].v - transformer.l1sigma.plug_n.pin[3].v;
//   transformer.l1sigma.i[1] = transformer.l1sigma.plug_p.pin[1].i;
//   transformer.l1sigma.i[2] = transformer.l1sigma.plug_p.pin[2].i;
//   transformer.l1sigma.i[3] = transformer.l1sigma.plug_p.pin[3].i;
//   assert(1.0 + transformer.r2.resistor[1].alpha * (transformer.r2.resistor[1].T_heatPort - transformer.r2.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer.r2.resistor[1].R_actual = transformer.r2.resistor[1].R * (1.0 + transformer.r2.resistor[1].alpha * (transformer.r2.resistor[1].T_heatPort - transformer.r2.resistor[1].T_ref));
//   transformer.r2.resistor[1].v = transformer.r2.resistor[1].R_actual * transformer.r2.resistor[1].i;
//   transformer.r2.resistor[1].LossPower = transformer.r2.resistor[1].v * transformer.r2.resistor[1].i;
//   transformer.r2.resistor[1].i = transformer.r2.resistor[1].p.i;
//   0.0 = transformer.r2.resistor[1].p.i + transformer.r2.resistor[1].n.i;
//   transformer.r2.resistor[1].v = transformer.r2.resistor[1].p.v - transformer.r2.resistor[1].n.v;
//   transformer.r2.resistor[1].T_heatPort = transformer.r2.resistor[1].T;
//   assert(1.0 + transformer.r2.resistor[2].alpha * (transformer.r2.resistor[2].T_heatPort - transformer.r2.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer.r2.resistor[2].R_actual = transformer.r2.resistor[2].R * (1.0 + transformer.r2.resistor[2].alpha * (transformer.r2.resistor[2].T_heatPort - transformer.r2.resistor[2].T_ref));
//   transformer.r2.resistor[2].v = transformer.r2.resistor[2].R_actual * transformer.r2.resistor[2].i;
//   transformer.r2.resistor[2].LossPower = transformer.r2.resistor[2].v * transformer.r2.resistor[2].i;
//   transformer.r2.resistor[2].i = transformer.r2.resistor[2].p.i;
//   0.0 = transformer.r2.resistor[2].p.i + transformer.r2.resistor[2].n.i;
//   transformer.r2.resistor[2].v = transformer.r2.resistor[2].p.v - transformer.r2.resistor[2].n.v;
//   transformer.r2.resistor[2].T_heatPort = transformer.r2.resistor[2].T;
//   assert(1.0 + transformer.r2.resistor[3].alpha * (transformer.r2.resistor[3].T_heatPort - transformer.r2.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer.r2.resistor[3].R_actual = transformer.r2.resistor[3].R * (1.0 + transformer.r2.resistor[3].alpha * (transformer.r2.resistor[3].T_heatPort - transformer.r2.resistor[3].T_ref));
//   transformer.r2.resistor[3].v = transformer.r2.resistor[3].R_actual * transformer.r2.resistor[3].i;
//   transformer.r2.resistor[3].LossPower = transformer.r2.resistor[3].v * transformer.r2.resistor[3].i;
//   transformer.r2.resistor[3].i = transformer.r2.resistor[3].p.i;
//   0.0 = transformer.r2.resistor[3].p.i + transformer.r2.resistor[3].n.i;
//   transformer.r2.resistor[3].v = transformer.r2.resistor[3].p.v - transformer.r2.resistor[3].n.v;
//   transformer.r2.resistor[3].T_heatPort = transformer.r2.resistor[3].T;
//   transformer.r2.v[1] = transformer.r2.plug_p.pin[1].v - transformer.r2.plug_n.pin[1].v;
//   transformer.r2.v[2] = transformer.r2.plug_p.pin[2].v - transformer.r2.plug_n.pin[2].v;
//   transformer.r2.v[3] = transformer.r2.plug_p.pin[3].v - transformer.r2.plug_n.pin[3].v;
//   transformer.r2.i[1] = transformer.r2.plug_p.pin[1].i;
//   transformer.r2.i[2] = transformer.r2.plug_p.pin[2].i;
//   transformer.r2.i[3] = transformer.r2.plug_p.pin[3].i;
//   transformer.l2sigma.inductor[1].L * der(transformer.l2sigma.inductor[1].i) = transformer.l2sigma.inductor[1].v;
//   transformer.l2sigma.inductor[1].v = transformer.l2sigma.inductor[1].p.v - transformer.l2sigma.inductor[1].n.v;
//   0.0 = transformer.l2sigma.inductor[1].p.i + transformer.l2sigma.inductor[1].n.i;
//   transformer.l2sigma.inductor[1].i = transformer.l2sigma.inductor[1].p.i;
//   transformer.l2sigma.inductor[2].L * der(transformer.l2sigma.inductor[2].i) = transformer.l2sigma.inductor[2].v;
//   transformer.l2sigma.inductor[2].v = transformer.l2sigma.inductor[2].p.v - transformer.l2sigma.inductor[2].n.v;
//   0.0 = transformer.l2sigma.inductor[2].p.i + transformer.l2sigma.inductor[2].n.i;
//   transformer.l2sigma.inductor[2].i = transformer.l2sigma.inductor[2].p.i;
//   transformer.l2sigma.inductor[3].L * der(transformer.l2sigma.inductor[3].i) = transformer.l2sigma.inductor[3].v;
//   transformer.l2sigma.inductor[3].v = transformer.l2sigma.inductor[3].p.v - transformer.l2sigma.inductor[3].n.v;
//   0.0 = transformer.l2sigma.inductor[3].p.i + transformer.l2sigma.inductor[3].n.i;
//   transformer.l2sigma.inductor[3].i = transformer.l2sigma.inductor[3].p.i;
//   transformer.l2sigma.v[1] = transformer.l2sigma.plug_p.pin[1].v - transformer.l2sigma.plug_n.pin[1].v;
//   transformer.l2sigma.v[2] = transformer.l2sigma.plug_p.pin[2].v - transformer.l2sigma.plug_n.pin[2].v;
//   transformer.l2sigma.v[3] = transformer.l2sigma.plug_p.pin[3].v - transformer.l2sigma.plug_n.pin[3].v;
//   transformer.l2sigma.i[1] = transformer.l2sigma.plug_p.pin[1].i;
//   transformer.l2sigma.i[2] = transformer.l2sigma.plug_p.pin[2].i;
//   transformer.l2sigma.i[3] = transformer.l2sigma.plug_p.pin[3].i;
//   transformer.core.im[1] = 0.0;
//   transformer.core.im[2] = 0.0;
//   transformer.core.im[3] = 0.0;
//   transformer.core.v1[1] = transformer.core.n12 * transformer.core.v2[1];
//   transformer.core.v1[2] = transformer.core.n12 * transformer.core.v2[2];
//   transformer.core.v1[3] = transformer.core.n12 * transformer.core.v2[3];
//   transformer.core.v1[1] = transformer.core.n13 * transformer.core.v3[1];
//   transformer.core.v1[2] = transformer.core.n13 * transformer.core.v3[2];
//   transformer.core.v1[3] = transformer.core.n13 * transformer.core.v3[3];
//   transformer.core.plug_p1.pin[1].i + transformer.core.plug_n1.pin[1].i = 0.0;
//   transformer.core.plug_p1.pin[2].i + transformer.core.plug_n1.pin[2].i = 0.0;
//   transformer.core.plug_p1.pin[3].i + transformer.core.plug_n1.pin[3].i = 0.0;
//   transformer.core.plug_p2.pin[1].i + transformer.core.plug_n2.pin[1].i = 0.0;
//   transformer.core.plug_p2.pin[2].i + transformer.core.plug_n2.pin[2].i = 0.0;
//   transformer.core.plug_p2.pin[3].i + transformer.core.plug_n2.pin[3].i = 0.0;
//   transformer.core.plug_p3.pin[1].i + transformer.core.plug_n3.pin[1].i = 0.0;
//   transformer.core.plug_p3.pin[2].i + transformer.core.plug_n3.pin[2].i = 0.0;
//   transformer.core.plug_p3.pin[3].i + transformer.core.plug_n3.pin[3].i = 0.0;
//   assert(transformer.Delta2.plug_p.m == transformer.r2.plug_n.m,"automatically generated from connect");
//   assert(transformer.l1sigma.plug_n.m == transformer.core.plug_p1.m,"automatically generated from connect");
//   assert(transformer.core.plug_n1.m == transformer.star1.plug_p.m,"automatically generated from connect");
//   assert(transformer.core.plug_n2.m == transformer.core.plug_p3.m,"automatically generated from connect");
//   assert(transformer.core.plug_n3.m == transformer.Delta2.plug_n.m,"automatically generated from connect");
//   assert(transformer.core.plug_p2.m == transformer.l2sigma.plug_p.m,"automatically generated from connect");
//   assert(transformer.r1.plug_n.m == transformer.l1sigma.plug_p.m,"automatically generated from connect");
//   assert(transformer.l2sigma.plug_n.m == transformer.r2.plug_p.m,"automatically generated from connect");
//   assert(transformer.plug1.m == transformer.r1.plug_p.m,"automatically generated from connect");
//   assert(transformer.r2.plug_n.m == transformer.plug2.m,"automatically generated from connect");
//   assert(source.plug_n.m == starS.plug_p.m,"automatically generated from connect");
//   assert(load.plug_n.m == starL.plug_p.m,"automatically generated from connect");
//   assert(electricalPowerSensorS.plug_nv.m == starS.plug_p.m,"automatically generated from connect");
//   assert(source.plug_p.m == electricalPowerSensorS.plug_p.m,"automatically generated from connect");
//   assert(electricalPowerSensorS.plug_ni.m == currentQuasiRMSSensorS.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensorL.plug_n.m == electricalPowerSensorL.plug_p.m,"automatically generated from connect");
//   assert(electricalPowerSensorL.plug_ni.m == load.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensorS.plug_n.m == voltageQuasiRMSSensorS.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensorL.plug_p.m == voltageRMSSensorL.plug_p.m,"automatically generated from connect");
//   assert(electricalPowerSensorL.plug_nv.m == starL.plug_p.m,"automatically generated from connect");
//   assert(voltageQuasiRMSSensorS.plug_n.m == deltaS.plug_p.m,"automatically generated from connect");
//   assert(deltaL.plug_p.m == voltageRMSSensorL.plug_n.m,"automatically generated from connect");
//   assert(deltaS.plug_n.m == voltageQuasiRMSSensorS.plug_p.m,"automatically generated from connect");
//   assert(deltaL.plug_n.m == voltageRMSSensorL.plug_p.m,"automatically generated from connect");
//   assert(currentQuasiRMSSensorS.plug_n.m == transformer.plug1.m,"automatically generated from connect");
//   assert(transformer.plug2.m == currentQuasiRMSSensorL.plug_p.m,"automatically generated from connect");
//   transformer.plug2.pin[3].i + (deltaL.plug_n.pin[3].i + (currentQuasiRMSSensorL.plug_p.pin[3].i + voltageRMSSensorL.plug_p.pin[3].i)) = 0.0;
//   currentQuasiRMSSensorL.plug_p.pin[3].v = deltaL.plug_n.pin[3].v;
//   currentQuasiRMSSensorL.plug_p.pin[3].v = transformer.plug2.pin[3].v;
//   currentQuasiRMSSensorL.plug_p.pin[3].v = voltageRMSSensorL.plug_p.pin[3].v;
//   transformer.plug2.pin[2].i + (deltaL.plug_n.pin[2].i + (currentQuasiRMSSensorL.plug_p.pin[2].i + voltageRMSSensorL.plug_p.pin[2].i)) = 0.0;
//   currentQuasiRMSSensorL.plug_p.pin[2].v = deltaL.plug_n.pin[2].v;
//   currentQuasiRMSSensorL.plug_p.pin[2].v = transformer.plug2.pin[2].v;
//   currentQuasiRMSSensorL.plug_p.pin[2].v = voltageRMSSensorL.plug_p.pin[2].v;
//   transformer.plug2.pin[1].i + (deltaL.plug_n.pin[1].i + (currentQuasiRMSSensorL.plug_p.pin[1].i + voltageRMSSensorL.plug_p.pin[1].i)) = 0.0;
//   currentQuasiRMSSensorL.plug_p.pin[1].v = deltaL.plug_n.pin[1].v;
//   currentQuasiRMSSensorL.plug_p.pin[1].v = transformer.plug2.pin[1].v;
//   currentQuasiRMSSensorL.plug_p.pin[1].v = voltageRMSSensorL.plug_p.pin[1].v;
//   deltaS.plug_n.pin[3].i + (currentQuasiRMSSensorS.plug_n.pin[3].i + (voltageQuasiRMSSensorS.plug_p.pin[3].i + transformer.plug1.pin[3].i)) = 0.0;
//   currentQuasiRMSSensorS.plug_n.pin[3].v = deltaS.plug_n.pin[3].v;
//   currentQuasiRMSSensorS.plug_n.pin[3].v = transformer.plug1.pin[3].v;
//   currentQuasiRMSSensorS.plug_n.pin[3].v = voltageQuasiRMSSensorS.plug_p.pin[3].v;
//   deltaS.plug_n.pin[2].i + (currentQuasiRMSSensorS.plug_n.pin[2].i + (voltageQuasiRMSSensorS.plug_p.pin[2].i + transformer.plug1.pin[2].i)) = 0.0;
//   currentQuasiRMSSensorS.plug_n.pin[2].v = deltaS.plug_n.pin[2].v;
//   currentQuasiRMSSensorS.plug_n.pin[2].v = transformer.plug1.pin[2].v;
//   currentQuasiRMSSensorS.plug_n.pin[2].v = voltageQuasiRMSSensorS.plug_p.pin[2].v;
//   deltaS.plug_n.pin[1].i + (currentQuasiRMSSensorS.plug_n.pin[1].i + (voltageQuasiRMSSensorS.plug_p.pin[1].i + transformer.plug1.pin[1].i)) = 0.0;
//   currentQuasiRMSSensorS.plug_n.pin[1].v = deltaS.plug_n.pin[1].v;
//   currentQuasiRMSSensorS.plug_n.pin[1].v = transformer.plug1.pin[1].v;
//   currentQuasiRMSSensorS.plug_n.pin[1].v = voltageQuasiRMSSensorS.plug_p.pin[1].v;
//   deltaL.plug_p.pin[3].i + voltageRMSSensorL.plug_n.pin[3].i = 0.0;
//   deltaL.plug_p.pin[3].v = voltageRMSSensorL.plug_n.pin[3].v;
//   deltaL.plug_p.pin[2].i + voltageRMSSensorL.plug_n.pin[2].i = 0.0;
//   deltaL.plug_p.pin[2].v = voltageRMSSensorL.plug_n.pin[2].v;
//   deltaL.plug_p.pin[1].i + voltageRMSSensorL.plug_n.pin[1].i = 0.0;
//   deltaL.plug_p.pin[1].v = voltageRMSSensorL.plug_n.pin[1].v;
//   voltageQuasiRMSSensorS.plug_n.pin[3].i + deltaS.plug_p.pin[3].i = 0.0;
//   deltaS.plug_p.pin[3].v = voltageQuasiRMSSensorS.plug_n.pin[3].v;
//   voltageQuasiRMSSensorS.plug_n.pin[2].i + deltaS.plug_p.pin[2].i = 0.0;
//   deltaS.plug_p.pin[2].v = voltageQuasiRMSSensorS.plug_n.pin[2].v;
//   voltageQuasiRMSSensorS.plug_n.pin[1].i + deltaS.plug_p.pin[1].i = 0.0;
//   deltaS.plug_p.pin[1].v = voltageQuasiRMSSensorS.plug_n.pin[1].v;
//   electricalPowerSensorL.plug_nv.pin[3].i + (load.plug_n.pin[3].i + starL.plug_p.pin[3].i) = 0.0;
//   electricalPowerSensorL.plug_nv.pin[3].v = load.plug_n.pin[3].v;
//   electricalPowerSensorL.plug_nv.pin[3].v = starL.plug_p.pin[3].v;
//   electricalPowerSensorL.plug_nv.pin[2].i + (load.plug_n.pin[2].i + starL.plug_p.pin[2].i) = 0.0;
//   electricalPowerSensorL.plug_nv.pin[2].v = load.plug_n.pin[2].v;
//   electricalPowerSensorL.plug_nv.pin[2].v = starL.plug_p.pin[2].v;
//   electricalPowerSensorL.plug_nv.pin[1].i + (load.plug_n.pin[1].i + starL.plug_p.pin[1].i) = 0.0;
//   electricalPowerSensorL.plug_nv.pin[1].v = load.plug_n.pin[1].v;
//   electricalPowerSensorL.plug_nv.pin[1].v = starL.plug_p.pin[1].v;
//   electricalPowerSensorL.plug_ni.pin[3].i + load.plug_p.pin[3].i = 0.0;
//   electricalPowerSensorL.plug_ni.pin[3].v = load.plug_p.pin[3].v;
//   electricalPowerSensorL.plug_ni.pin[2].i + load.plug_p.pin[2].i = 0.0;
//   electricalPowerSensorL.plug_ni.pin[2].v = load.plug_p.pin[2].v;
//   electricalPowerSensorL.plug_ni.pin[1].i + load.plug_p.pin[1].i = 0.0;
//   electricalPowerSensorL.plug_ni.pin[1].v = load.plug_p.pin[1].v;
//   currentQuasiRMSSensorL.plug_n.pin[3].i + electricalPowerSensorL.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensorL.plug_n.pin[3].v = electricalPowerSensorL.plug_p.pin[3].v;
//   currentQuasiRMSSensorL.plug_n.pin[2].i + electricalPowerSensorL.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensorL.plug_n.pin[2].v = electricalPowerSensorL.plug_p.pin[2].v;
//   currentQuasiRMSSensorL.plug_n.pin[1].i + electricalPowerSensorL.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensorL.plug_n.pin[1].v = electricalPowerSensorL.plug_p.pin[1].v;
//   electricalPowerSensorS.plug_ni.pin[3].i + currentQuasiRMSSensorS.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensorS.plug_p.pin[3].v = electricalPowerSensorS.plug_ni.pin[3].v;
//   electricalPowerSensorS.plug_ni.pin[2].i + currentQuasiRMSSensorS.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensorS.plug_p.pin[2].v = electricalPowerSensorS.plug_ni.pin[2].v;
//   electricalPowerSensorS.plug_ni.pin[1].i + currentQuasiRMSSensorS.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensorS.plug_p.pin[1].v = electricalPowerSensorS.plug_ni.pin[1].v;
//   source.plug_p.pin[3].i + electricalPowerSensorS.plug_p.pin[3].i = 0.0;
//   electricalPowerSensorS.plug_p.pin[3].v = source.plug_p.pin[3].v;
//   source.plug_p.pin[2].i + electricalPowerSensorS.plug_p.pin[2].i = 0.0;
//   electricalPowerSensorS.plug_p.pin[2].v = source.plug_p.pin[2].v;
//   source.plug_p.pin[1].i + electricalPowerSensorS.plug_p.pin[1].i = 0.0;
//   electricalPowerSensorS.plug_p.pin[1].v = source.plug_p.pin[1].v;
//   electricalPowerSensorS.plug_nv.pin[3].i + (source.plug_n.pin[3].i + starS.plug_p.pin[3].i) = 0.0;
//   electricalPowerSensorS.plug_nv.pin[3].v = source.plug_n.pin[3].v;
//   electricalPowerSensorS.plug_nv.pin[3].v = starS.plug_p.pin[3].v;
//   electricalPowerSensorS.plug_nv.pin[2].i + (source.plug_n.pin[2].i + starS.plug_p.pin[2].i) = 0.0;
//   electricalPowerSensorS.plug_nv.pin[2].v = source.plug_n.pin[2].v;
//   electricalPowerSensorS.plug_nv.pin[2].v = starS.plug_p.pin[2].v;
//   electricalPowerSensorS.plug_nv.pin[1].i + (source.plug_n.pin[1].i + starS.plug_p.pin[1].i) = 0.0;
//   electricalPowerSensorS.plug_nv.pin[1].v = source.plug_n.pin[1].v;
//   electricalPowerSensorS.plug_nv.pin[1].v = starS.plug_p.pin[1].v;
//   earth.n.i + groundT.p.i = 0.0;
//   earth.n.v = groundT.p.v;
//   starL.pin_n.i + groundL.p.i = 0.0;
//   groundL.p.v = starL.pin_n.v;
//   starS.pin_n.i + groundS.p.i = 0.0;
//   groundS.p.v = starS.pin_n.v;
//   transformer.Delta2.plug_p.pin[3].i + (transformer.r2.plug_n.pin[3].i + (-transformer.plug2.pin[3].i)) = 0.0;
//   transformer.Delta2.plug_p.pin[3].v = transformer.plug2.pin[3].v;
//   transformer.Delta2.plug_p.pin[3].v = transformer.r2.plug_n.pin[3].v;
//   transformer.Delta2.plug_p.pin[2].i + (transformer.r2.plug_n.pin[2].i + (-transformer.plug2.pin[2].i)) = 0.0;
//   transformer.Delta2.plug_p.pin[2].v = transformer.plug2.pin[2].v;
//   transformer.Delta2.plug_p.pin[2].v = transformer.r2.plug_n.pin[2].v;
//   transformer.Delta2.plug_p.pin[1].i + (transformer.r2.plug_n.pin[1].i + (-transformer.plug2.pin[1].i)) = 0.0;
//   transformer.Delta2.plug_p.pin[1].v = transformer.plug2.pin[1].v;
//   transformer.Delta2.plug_p.pin[1].v = transformer.r2.plug_n.pin[1].v;
//   (-transformer.plug1.pin[3].i) + transformer.r1.plug_p.pin[3].i = 0.0;
//   transformer.plug1.pin[3].v = transformer.r1.plug_p.pin[3].v;
//   (-transformer.plug1.pin[2].i) + transformer.r1.plug_p.pin[2].i = 0.0;
//   transformer.plug1.pin[2].v = transformer.r1.plug_p.pin[2].v;
//   (-transformer.plug1.pin[1].i) + transformer.r1.plug_p.pin[1].i = 0.0;
//   transformer.plug1.pin[1].v = transformer.r1.plug_p.pin[1].v;
//   transformer.l2sigma.plug_n.pin[3].i + transformer.r2.plug_p.pin[3].i = 0.0;
//   transformer.l2sigma.plug_n.pin[3].v = transformer.r2.plug_p.pin[3].v;
//   transformer.l2sigma.plug_n.pin[2].i + transformer.r2.plug_p.pin[2].i = 0.0;
//   transformer.l2sigma.plug_n.pin[2].v = transformer.r2.plug_p.pin[2].v;
//   transformer.l2sigma.plug_n.pin[1].i + transformer.r2.plug_p.pin[1].i = 0.0;
//   transformer.l2sigma.plug_n.pin[1].v = transformer.r2.plug_p.pin[1].v;
//   transformer.r1.plug_n.pin[3].i + transformer.l1sigma.plug_p.pin[3].i = 0.0;
//   transformer.l1sigma.plug_p.pin[3].v = transformer.r1.plug_n.pin[3].v;
//   transformer.r1.plug_n.pin[2].i + transformer.l1sigma.plug_p.pin[2].i = 0.0;
//   transformer.l1sigma.plug_p.pin[2].v = transformer.r1.plug_n.pin[2].v;
//   transformer.r1.plug_n.pin[1].i + transformer.l1sigma.plug_p.pin[1].i = 0.0;
//   transformer.l1sigma.plug_p.pin[1].v = transformer.r1.plug_n.pin[1].v;
//   transformer.core.plug_p2.pin[3].i + transformer.l2sigma.plug_p.pin[3].i = 0.0;
//   transformer.core.plug_p2.pin[3].v = transformer.l2sigma.plug_p.pin[3].v;
//   transformer.core.plug_p2.pin[2].i + transformer.l2sigma.plug_p.pin[2].i = 0.0;
//   transformer.core.plug_p2.pin[2].v = transformer.l2sigma.plug_p.pin[2].v;
//   transformer.core.plug_p2.pin[1].i + transformer.l2sigma.plug_p.pin[1].i = 0.0;
//   transformer.core.plug_p2.pin[1].v = transformer.l2sigma.plug_p.pin[1].v;
//   transformer.core.plug_n3.pin[3].i + transformer.Delta2.plug_n.pin[3].i = 0.0;
//   transformer.Delta2.plug_n.pin[3].v = transformer.core.plug_n3.pin[3].v;
//   transformer.core.plug_n3.pin[2].i + transformer.Delta2.plug_n.pin[2].i = 0.0;
//   transformer.Delta2.plug_n.pin[2].v = transformer.core.plug_n3.pin[2].v;
//   transformer.core.plug_n3.pin[1].i + transformer.Delta2.plug_n.pin[1].i = 0.0;
//   transformer.Delta2.plug_n.pin[1].v = transformer.core.plug_n3.pin[1].v;
//   transformer.core.plug_n2.pin[3].i + transformer.core.plug_p3.pin[3].i = 0.0;
//   transformer.core.plug_n2.pin[3].v = transformer.core.plug_p3.pin[3].v;
//   transformer.core.plug_n2.pin[2].i + transformer.core.plug_p3.pin[2].i = 0.0;
//   transformer.core.plug_n2.pin[2].v = transformer.core.plug_p3.pin[2].v;
//   transformer.core.plug_n2.pin[1].i + transformer.core.plug_p3.pin[1].i = 0.0;
//   transformer.core.plug_n2.pin[1].v = transformer.core.plug_p3.pin[1].v;
//   transformer.core.plug_n1.pin[3].i + transformer.star1.plug_p.pin[3].i = 0.0;
//   transformer.core.plug_n1.pin[3].v = transformer.star1.plug_p.pin[3].v;
//   transformer.core.plug_n1.pin[2].i + transformer.star1.plug_p.pin[2].i = 0.0;
//   transformer.core.plug_n1.pin[2].v = transformer.star1.plug_p.pin[2].v;
//   transformer.core.plug_n1.pin[1].i + transformer.star1.plug_p.pin[1].i = 0.0;
//   transformer.core.plug_n1.pin[1].v = transformer.star1.plug_p.pin[1].v;
//   transformer.l1sigma.plug_n.pin[3].i + transformer.core.plug_p1.pin[3].i = 0.0;
//   transformer.core.plug_p1.pin[3].v = transformer.l1sigma.plug_n.pin[3].v;
//   transformer.l1sigma.plug_n.pin[2].i + transformer.core.plug_p1.pin[2].i = 0.0;
//   transformer.core.plug_p1.pin[2].v = transformer.l1sigma.plug_n.pin[2].v;
//   transformer.l1sigma.plug_n.pin[1].i + transformer.core.plug_p1.pin[1].i = 0.0;
//   transformer.core.plug_p1.pin[1].v = transformer.l1sigma.plug_n.pin[1].v;
//   transformer.star1.pin_n.i + (-transformer.starpoint1.i) = 0.0;
//   transformer.star1.pin_n.v = transformer.starpoint1.v;
//   (-transformer.Delta2.plug_n.pin[3].i) + (-transformer.Delta2.plug_p.pin[1].i) = 0.0;
//   transformer.Delta2.plug_n.pin[3].v = transformer.Delta2.plug_p.pin[1].v;
//   (-transformer.Delta2.plug_n.pin[2].i) + (-transformer.Delta2.plug_p.pin[3].i) = 0.0;
//   transformer.Delta2.plug_n.pin[2].v = transformer.Delta2.plug_p.pin[3].v;
//   (-transformer.Delta2.plug_n.pin[1].i) + (-transformer.Delta2.plug_p.pin[2].i) = 0.0;
//   transformer.Delta2.plug_n.pin[1].v = transformer.Delta2.plug_p.pin[2].v;
//   transformer.starpoint1.i = 0.0;
//   (-transformer.star1.plug_p.pin[3].i) + ((-transformer.star1.plug_p.pin[2].i) + ((-transformer.star1.plug_p.pin[1].i) + (-transformer.star1.pin_n.i))) = 0.0;
//   transformer.star1.pin_n.v = transformer.star1.plug_p.pin[1].v;
//   transformer.star1.pin_n.v = transformer.star1.plug_p.pin[2].v;
//   transformer.star1.pin_n.v = transformer.star1.plug_p.pin[3].v;
//   transformer.l2sigma.inductor[3].n.i + (-transformer.l2sigma.plug_n.pin[3].i) = 0.0;
//   transformer.l2sigma.inductor[3].n.v = transformer.l2sigma.plug_n.pin[3].v;
//   transformer.l2sigma.inductor[2].n.i + (-transformer.l2sigma.plug_n.pin[2].i) = 0.0;
//   transformer.l2sigma.inductor[2].n.v = transformer.l2sigma.plug_n.pin[2].v;
//   transformer.l2sigma.inductor[1].n.i + (-transformer.l2sigma.plug_n.pin[1].i) = 0.0;
//   transformer.l2sigma.inductor[1].n.v = transformer.l2sigma.plug_n.pin[1].v;
//   transformer.l2sigma.inductor[3].p.i + (-transformer.l2sigma.plug_p.pin[3].i) = 0.0;
//   transformer.l2sigma.inductor[3].p.v = transformer.l2sigma.plug_p.pin[3].v;
//   transformer.l2sigma.inductor[2].p.i + (-transformer.l2sigma.plug_p.pin[2].i) = 0.0;
//   transformer.l2sigma.inductor[2].p.v = transformer.l2sigma.plug_p.pin[2].v;
//   transformer.l2sigma.inductor[1].p.i + (-transformer.l2sigma.plug_p.pin[1].i) = 0.0;
//   transformer.l2sigma.inductor[1].p.v = transformer.l2sigma.plug_p.pin[1].v;
//   transformer.r2.resistor[3].n.i + (-transformer.r2.plug_n.pin[3].i) = 0.0;
//   transformer.r2.plug_n.pin[3].v = transformer.r2.resistor[3].n.v;
//   transformer.r2.resistor[2].n.i + (-transformer.r2.plug_n.pin[2].i) = 0.0;
//   transformer.r2.plug_n.pin[2].v = transformer.r2.resistor[2].n.v;
//   transformer.r2.resistor[1].n.i + (-transformer.r2.plug_n.pin[1].i) = 0.0;
//   transformer.r2.plug_n.pin[1].v = transformer.r2.resistor[1].n.v;
//   transformer.r2.resistor[3].p.i + (-transformer.r2.plug_p.pin[3].i) = 0.0;
//   transformer.r2.plug_p.pin[3].v = transformer.r2.resistor[3].p.v;
//   transformer.r2.resistor[2].p.i + (-transformer.r2.plug_p.pin[2].i) = 0.0;
//   transformer.r2.plug_p.pin[2].v = transformer.r2.resistor[2].p.v;
//   transformer.r2.resistor[1].p.i + (-transformer.r2.plug_p.pin[1].i) = 0.0;
//   transformer.r2.plug_p.pin[1].v = transformer.r2.resistor[1].p.v;
//   transformer.l1sigma.inductor[3].n.i + (-transformer.l1sigma.plug_n.pin[3].i) = 0.0;
//   transformer.l1sigma.inductor[3].n.v = transformer.l1sigma.plug_n.pin[3].v;
//   transformer.l1sigma.inductor[2].n.i + (-transformer.l1sigma.plug_n.pin[2].i) = 0.0;
//   transformer.l1sigma.inductor[2].n.v = transformer.l1sigma.plug_n.pin[2].v;
//   transformer.l1sigma.inductor[1].n.i + (-transformer.l1sigma.plug_n.pin[1].i) = 0.0;
//   transformer.l1sigma.inductor[1].n.v = transformer.l1sigma.plug_n.pin[1].v;
//   transformer.l1sigma.inductor[3].p.i + (-transformer.l1sigma.plug_p.pin[3].i) = 0.0;
//   transformer.l1sigma.inductor[3].p.v = transformer.l1sigma.plug_p.pin[3].v;
//   transformer.l1sigma.inductor[2].p.i + (-transformer.l1sigma.plug_p.pin[2].i) = 0.0;
//   transformer.l1sigma.inductor[2].p.v = transformer.l1sigma.plug_p.pin[2].v;
//   transformer.l1sigma.inductor[1].p.i + (-transformer.l1sigma.plug_p.pin[1].i) = 0.0;
//   transformer.l1sigma.inductor[1].p.v = transformer.l1sigma.plug_p.pin[1].v;
//   transformer.r1.resistor[3].n.i + (-transformer.r1.plug_n.pin[3].i) = 0.0;
//   transformer.r1.plug_n.pin[3].v = transformer.r1.resistor[3].n.v;
//   transformer.r1.resistor[2].n.i + (-transformer.r1.plug_n.pin[2].i) = 0.0;
//   transformer.r1.plug_n.pin[2].v = transformer.r1.resistor[2].n.v;
//   transformer.r1.resistor[1].n.i + (-transformer.r1.plug_n.pin[1].i) = 0.0;
//   transformer.r1.plug_n.pin[1].v = transformer.r1.resistor[1].n.v;
//   transformer.r1.resistor[3].p.i + (-transformer.r1.plug_p.pin[3].i) = 0.0;
//   transformer.r1.plug_p.pin[3].v = transformer.r1.resistor[3].p.v;
//   transformer.r1.resistor[2].p.i + (-transformer.r1.plug_p.pin[2].i) = 0.0;
//   transformer.r1.plug_p.pin[2].v = transformer.r1.resistor[2].p.v;
//   transformer.r1.resistor[1].p.i + (-transformer.r1.plug_p.pin[1].i) = 0.0;
//   transformer.r1.plug_p.pin[1].v = transformer.r1.resistor[1].p.v;
//   (-starL.plug_p.pin[3].i) + ((-starL.plug_p.pin[2].i) + ((-starL.plug_p.pin[1].i) + (-starL.pin_n.i))) = 0.0;
//   starL.pin_n.v = starL.plug_p.pin[1].v;
//   starL.pin_n.v = starL.plug_p.pin[2].v;
//   starL.pin_n.v = starL.plug_p.pin[3].v;
//   load.resistor[3].n.i + (-load.plug_n.pin[3].i) = 0.0;
//   load.plug_n.pin[3].v = load.resistor[3].n.v;
//   load.resistor[2].n.i + (-load.plug_n.pin[2].i) = 0.0;
//   load.plug_n.pin[2].v = load.resistor[2].n.v;
//   load.resistor[1].n.i + (-load.plug_n.pin[1].i) = 0.0;
//   load.plug_n.pin[1].v = load.resistor[1].n.v;
//   load.resistor[3].p.i + (-load.plug_p.pin[3].i) = 0.0;
//   load.plug_p.pin[3].v = load.resistor[3].p.v;
//   load.resistor[2].p.i + (-load.plug_p.pin[2].i) = 0.0;
//   load.plug_p.pin[2].v = load.resistor[2].p.v;
//   load.resistor[1].p.i + (-load.plug_p.pin[1].i) = 0.0;
//   load.plug_p.pin[1].v = load.resistor[1].p.v;
//   currentQuasiRMSSensorL.Gain1.y = currentQuasiRMSSensorL.I;
//   currentQuasiRMSSensorL.Gain1.u = currentQuasiRMSSensorL.ToPolar1.y[1];
//   currentQuasiRMSSensorL.ToPolar1.u[1] = currentQuasiRMSSensorL.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensorL.ToPolar1.u[2] = currentQuasiRMSSensorL.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensorL.CurrentSensor1.i[1] = currentQuasiRMSSensorL.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensorL.CurrentSensor1.i[2] = currentQuasiRMSSensorL.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensorL.CurrentSensor1.i[3] = currentQuasiRMSSensorL.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensorL.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensorL.plug_n.pin[3].v;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensorL.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensorL.plug_n.pin[2].v;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensorL.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensorL.plug_n.pin[1].v;
//   (-currentQuasiRMSSensorL.plug_p.pin[3].i) + currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensorL.plug_p.pin[3].v;
//   (-currentQuasiRMSSensorL.plug_p.pin[2].i) + currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensorL.plug_p.pin[2].v;
//   (-currentQuasiRMSSensorL.plug_p.pin[1].i) + currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensorL.plug_p.pin[1].v;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensorL.CurrentSensor1.i[1];
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensorL.CurrentSensor1.i[2];
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensorL.CurrentSensor1.i[3];
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensorL.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensorL.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensorL.CurrentSensor1.plug_p.pin[1].v;
//   (-deltaL.plug_n.pin[3].i) + (-deltaL.plug_p.pin[1].i) = 0.0;
//   deltaL.plug_n.pin[3].v = deltaL.plug_p.pin[1].v;
//   (-deltaL.plug_n.pin[2].i) + (-deltaL.plug_p.pin[3].i) = 0.0;
//   deltaL.plug_n.pin[2].v = deltaL.plug_p.pin[3].v;
//   (-deltaL.plug_n.pin[1].i) + (-deltaL.plug_p.pin[2].i) = 0.0;
//   deltaL.plug_n.pin[1].v = deltaL.plug_p.pin[2].v;
//   voltageRMSSensorL.Gain1.y = voltageRMSSensorL.V;
//   voltageRMSSensorL.Gain1.u = voltageRMSSensorL.ToPolar1.y[1];
//   voltageRMSSensorL.ToPolar1.u[1] = voltageRMSSensorL.ToSpacePhasor1.y[1];
//   voltageRMSSensorL.ToPolar1.u[2] = voltageRMSSensorL.ToSpacePhasor1.y[2];
//   voltageRMSSensorL.ToSpacePhasor1.u[1] = voltageRMSSensorL.VoltageSensor1.v[1];
//   voltageRMSSensorL.ToSpacePhasor1.u[2] = voltageRMSSensorL.VoltageSensor1.v[2];
//   voltageRMSSensorL.ToSpacePhasor1.u[3] = voltageRMSSensorL.VoltageSensor1.v[3];
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[3].i + (-voltageRMSSensorL.plug_n.pin[3].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[3].v = voltageRMSSensorL.plug_n.pin[3].v;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[2].i + (-voltageRMSSensorL.plug_n.pin[2].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[2].v = voltageRMSSensorL.plug_n.pin[2].v;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[1].i + (-voltageRMSSensorL.plug_n.pin[1].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[1].v = voltageRMSSensorL.plug_n.pin[1].v;
//   (-voltageRMSSensorL.plug_p.pin[3].i) + voltageRMSSensorL.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_p.pin[3].v = voltageRMSSensorL.plug_p.pin[3].v;
//   (-voltageRMSSensorL.plug_p.pin[2].i) + voltageRMSSensorL.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_p.pin[2].v = voltageRMSSensorL.plug_p.pin[2].v;
//   (-voltageRMSSensorL.plug_p.pin[1].i) + voltageRMSSensorL.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_p.pin[1].v = voltageRMSSensorL.plug_p.pin[1].v;
//   voltageRMSSensorL.VoltageSensor1.v[1] = voltageRMSSensorL.VoltageSensor1.voltageSensor[1].v;
//   voltageRMSSensorL.VoltageSensor1.v[2] = voltageRMSSensorL.VoltageSensor1.voltageSensor[2].v;
//   voltageRMSSensorL.VoltageSensor1.v[3] = voltageRMSSensorL.VoltageSensor1.voltageSensor[3].v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[3].p.i + (-voltageRMSSensorL.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_p.pin[3].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[3].p.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[2].p.i + (-voltageRMSSensorL.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_p.pin[2].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[2].p.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[1].p.i + (-voltageRMSSensorL.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_p.pin[1].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[1].p.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[3].n.i + (-voltageRMSSensorL.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[3].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[3].n.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[2].n.i + (-voltageRMSSensorL.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[2].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[2].n.v;
//   voltageRMSSensorL.VoltageSensor1.voltageSensor[1].n.i + (-voltageRMSSensorL.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   voltageRMSSensorL.VoltageSensor1.plug_n.pin[1].v = voltageRMSSensorL.VoltageSensor1.voltageSensor[1].n.v;
//   earth.p.i = 0.0;
//   (-deltaS.plug_n.pin[3].i) + (-deltaS.plug_p.pin[1].i) = 0.0;
//   deltaS.plug_n.pin[3].v = deltaS.plug_p.pin[1].v;
//   (-deltaS.plug_n.pin[2].i) + (-deltaS.plug_p.pin[3].i) = 0.0;
//   deltaS.plug_n.pin[2].v = deltaS.plug_p.pin[3].v;
//   (-deltaS.plug_n.pin[1].i) + (-deltaS.plug_p.pin[2].i) = 0.0;
//   deltaS.plug_n.pin[1].v = deltaS.plug_p.pin[2].v;
//   voltageQuasiRMSSensorS.Gain1.y = voltageQuasiRMSSensorS.V;
//   voltageQuasiRMSSensorS.Gain1.u = voltageQuasiRMSSensorS.ToPolar1.y[1];
//   voltageQuasiRMSSensorS.ToPolar1.u[1] = voltageQuasiRMSSensorS.ToSpacePhasor1.y[1];
//   voltageQuasiRMSSensorS.ToPolar1.u[2] = voltageQuasiRMSSensorS.ToSpacePhasor1.y[2];
//   voltageQuasiRMSSensorS.ToSpacePhasor1.u[1] = voltageQuasiRMSSensorS.VoltageSensor1.v[1];
//   voltageQuasiRMSSensorS.ToSpacePhasor1.u[2] = voltageQuasiRMSSensorS.VoltageSensor1.v[2];
//   voltageQuasiRMSSensorS.ToSpacePhasor1.u[3] = voltageQuasiRMSSensorS.VoltageSensor1.v[3];
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[3].i + (-voltageQuasiRMSSensorS.plug_n.pin[3].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[3].v = voltageQuasiRMSSensorS.plug_n.pin[3].v;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[2].i + (-voltageQuasiRMSSensorS.plug_n.pin[2].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[2].v = voltageQuasiRMSSensorS.plug_n.pin[2].v;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[1].i + (-voltageQuasiRMSSensorS.plug_n.pin[1].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[1].v = voltageQuasiRMSSensorS.plug_n.pin[1].v;
//   (-voltageQuasiRMSSensorS.plug_p.pin[3].i) + voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[3].v = voltageQuasiRMSSensorS.plug_p.pin[3].v;
//   (-voltageQuasiRMSSensorS.plug_p.pin[2].i) + voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[2].v = voltageQuasiRMSSensorS.plug_p.pin[2].v;
//   (-voltageQuasiRMSSensorS.plug_p.pin[1].i) + voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[1].v = voltageQuasiRMSSensorS.plug_p.pin[1].v;
//   voltageQuasiRMSSensorS.VoltageSensor1.v[1] = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].v;
//   voltageQuasiRMSSensorS.VoltageSensor1.v[2] = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].v;
//   voltageQuasiRMSSensorS.VoltageSensor1.v[3] = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].p.i + (-voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[3].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].p.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].p.i + (-voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[2].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].p.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].p.i + (-voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_p.pin[1].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].p.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].n.i + (-voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[3].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[3].n.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].n.i + (-voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[2].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[2].n.v;
//   voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].n.i + (-voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   voltageQuasiRMSSensorS.VoltageSensor1.plug_n.pin[1].v = voltageQuasiRMSSensorS.VoltageSensor1.voltageSensor[1].n.v;
//   currentQuasiRMSSensorS.Gain1.y = currentQuasiRMSSensorS.I;
//   currentQuasiRMSSensorS.Gain1.u = currentQuasiRMSSensorS.ToPolar1.y[1];
//   currentQuasiRMSSensorS.ToPolar1.u[1] = currentQuasiRMSSensorS.ToSpacePhasor1.y[1];
//   currentQuasiRMSSensorS.ToPolar1.u[2] = currentQuasiRMSSensorS.ToSpacePhasor1.y[2];
//   currentQuasiRMSSensorS.CurrentSensor1.i[1] = currentQuasiRMSSensorS.ToSpacePhasor1.u[1];
//   currentQuasiRMSSensorS.CurrentSensor1.i[2] = currentQuasiRMSSensorS.ToSpacePhasor1.u[2];
//   currentQuasiRMSSensorS.CurrentSensor1.i[3] = currentQuasiRMSSensorS.ToSpacePhasor1.u[3];
//   currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[3].i + (-currentQuasiRMSSensorS.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[3].v = currentQuasiRMSSensorS.plug_n.pin[3].v;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[2].i + (-currentQuasiRMSSensorS.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[2].v = currentQuasiRMSSensorS.plug_n.pin[2].v;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[1].i + (-currentQuasiRMSSensorS.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[1].v = currentQuasiRMSSensorS.plug_n.pin[1].v;
//   (-currentQuasiRMSSensorS.plug_p.pin[3].i) + currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[3].v = currentQuasiRMSSensorS.plug_p.pin[3].v;
//   (-currentQuasiRMSSensorS.plug_p.pin[2].i) + currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[2].v = currentQuasiRMSSensorS.plug_p.pin[2].v;
//   (-currentQuasiRMSSensorS.plug_p.pin[1].i) + currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[1].v = currentQuasiRMSSensorS.plug_p.pin[1].v;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].i = currentQuasiRMSSensorS.CurrentSensor1.i[1];
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].i = currentQuasiRMSSensorS.CurrentSensor1.i[2];
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].i = currentQuasiRMSSensorS.CurrentSensor1.i[3];
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].n.i + (-currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].n.v = currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[3].v;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].n.i + (-currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].n.v = currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[2].v;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].n.i + (-currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].n.v = currentQuasiRMSSensorS.CurrentSensor1.plug_n.pin[1].v;
//   (-currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[3].i) + currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[3].p.v = currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[3].v;
//   (-currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[2].i) + currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[2].p.v = currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[2].v;
//   (-currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[1].i) + currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensorS.CurrentSensor1.currentSensor[1].p.v = currentQuasiRMSSensorS.CurrentSensor1.plug_p.pin[1].v;
//   (-starS.plug_p.pin[3].i) + ((-starS.plug_p.pin[2].i) + ((-starS.plug_p.pin[1].i) + (-starS.pin_n.i))) = 0.0;
//   starS.pin_n.v = starS.plug_p.pin[1].v;
//   starS.pin_n.v = starS.plug_p.pin[2].v;
//   starS.pin_n.v = starS.plug_p.pin[3].v;
//   source.sineVoltage[3].n.i + (-source.plug_n.pin[3].i) = 0.0;
//   source.plug_n.pin[3].v = source.sineVoltage[3].n.v;
//   source.sineVoltage[2].n.i + (-source.plug_n.pin[2].i) = 0.0;
//   source.plug_n.pin[2].v = source.sineVoltage[2].n.v;
//   source.sineVoltage[1].n.i + (-source.plug_n.pin[1].i) = 0.0;
//   source.plug_n.pin[1].v = source.sineVoltage[1].n.v;
//   source.sineVoltage[3].p.i + (-source.plug_p.pin[3].i) = 0.0;
//   source.plug_p.pin[3].v = source.sineVoltage[3].p.v;
//   source.sineVoltage[2].p.i + (-source.plug_p.pin[2].i) = 0.0;
//   source.plug_p.pin[2].v = source.sineVoltage[2].p.v;
//   source.sineVoltage[1].p.i + (-source.plug_p.pin[1].i) = 0.0;
//   source.plug_p.pin[1].v = source.sineVoltage[1].p.v;
// end Modelica.Electrical.Machines.Examples.TransformerTestbench;
// "
// ""
// "Check of Modelica.Electrical.Machines.Examples.TransformerTestbench completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.TransformerTestbench has 672 equation(s) and 672 variable(s).
// 518 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Utilities.Strings.substring
//   input String string "String from which a substring is inquired";
//   input Integer startIndex(min = 1) "Character position of substring begin (index=1 is first character in string)";
//   input Integer endIndex(min = 1) "Character position of substring end";
//   output String result "String containing substring string[startIndex:endIndex]";
// 
// external "C";
// end Modelica.Utilities.Strings.substring;
// 
// class Modelica.Electrical.Machines.Examples.Rectifier6pulse
//   constant Integer m = 3 "Number of phases";
//   parameter Real V(quantity = "ElectricPotential", unit = "V") = 81.6496580927726 "Amplitude of star-voltage";
//   parameter Real f(quantity = "Frequency", unit = "Hz") = 50.0 "Frequency";
//   parameter Real RL(quantity = "Resistance", unit = "Ohm") = 0.4 "Load resistance";
//   parameter Real C(quantity = "Capacitance", unit = "F", min = 0.0) = 0.005 "Total DC-capacitance";
//   parameter Real VC0(quantity = "ElectricPotential", unit = "V") = 1.73205080756888 * V "Initial voltage of capacitance";
//   parameter Integer source.m(min = 1) = 3 "number of phases";
//   Real source.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real source.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real source.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer source.plug_p.m(min = 1) = source.m "number of phases";
//   Real source.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer source.plug_n.m(min = 1) = source.m "number of phases";
//   Real source.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = V "Amplitudes of sine waves";
//   parameter Real source.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = V "Amplitudes of sine waves";
//   parameter Real source.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = V "Amplitudes of sine waves";
//   parameter Real source.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real source.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(source.m) "Phases of sine waves";
//   parameter Real source.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(source.m) "Phases of sine waves";
//   parameter Real source.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = f "Frequencies of sine waves";
//   parameter Real source.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = f "Frequencies of sine waves";
//   parameter Real source.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = f "Frequencies of sine waves";
//   parameter Real source.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real source.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real source.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real source.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = source.offset[1] "Voltage offset";
//   parameter Real source.sineVoltage[1].startTime(quantity = "Time", unit = "s") = source.startTime[1] "Time offset";
//   output Real source.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[1].signalSource.amplitude = source.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.offset = source.sineVoltage[1].offset "Offset of output signal";
//   parameter Real source.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[1] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[1] "Phase of sine wave";
//   parameter Real source.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[1] "Frequency of sine wave";
//   Real source.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = source.offset[2] "Voltage offset";
//   parameter Real source.sineVoltage[2].startTime(quantity = "Time", unit = "s") = source.startTime[2] "Time offset";
//   output Real source.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[2].signalSource.amplitude = source.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.offset = source.sineVoltage[2].offset "Offset of output signal";
//   parameter Real source.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[2] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[2] "Phase of sine wave";
//   parameter Real source.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[2] "Frequency of sine wave";
//   Real source.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = source.offset[3] "Voltage offset";
//   parameter Real source.sineVoltage[3].startTime(quantity = "Time", unit = "s") = source.startTime[3] "Time offset";
//   output Real source.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[3].signalSource.amplitude = source.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.offset = source.sineVoltage[3].offset "Offset of output signal";
//   parameter Real source.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[3] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[3] "Phase of sine wave";
//   parameter Real source.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[3] "Frequency of sine wave";
//   parameter Integer starAC.m(min = 1) = 3 "number of phases";
//   parameter Integer starAC.plug_p.m(min = 1) = starAC.m "number of phases";
//   Real starAC.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starAC.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starAC.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starAC.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real groundAC.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundAC.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = currentQuasiRMSSensor.m "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = currentQuasiRMSSensor.m "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Integer diode1.m(min = 1) = 3 "number of phases";
//   Real diode1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer diode1.plug_p.m(min = 1) = diode1.m "number of phases";
//   Real diode1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode1.plug_n.m(min = 1) = diode1.m "number of phases";
//   Real diode1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode1.mh(min = 1) = diode1.m "Number of heatPorts=number of phases";
//   parameter Boolean diode1.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real diode1.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode1.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode1.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode1.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode1.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode1.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode1.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode1.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode1.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode1.Vknee[1](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode1.Vknee[2](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode1.Vknee[3](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   Real diode1.idealDiode[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode1.idealDiode[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode1.idealDiode[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.idealDiode[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode1.idealDiode[1].useHeatPort = diode1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode1.idealDiode[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode1.idealDiode[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode1.idealDiode[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode1.idealDiode[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode1.Ron[1] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode1.idealDiode[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode1.Goff[1] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode1.idealDiode[1].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode1.Vknee[1] "Forward threshold voltage";
//   Boolean diode1.idealDiode[1].off(start = true) "Switching state";
//   protected Real diode1.idealDiode[1].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode1.idealDiode[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode1.idealDiode[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode1.idealDiode[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode1.idealDiode[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode1.idealDiode[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.idealDiode[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode1.idealDiode[2].useHeatPort = diode1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode1.idealDiode[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode1.idealDiode[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode1.idealDiode[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode1.idealDiode[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode1.Ron[2] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode1.idealDiode[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode1.Goff[2] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode1.idealDiode[2].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode1.Vknee[2] "Forward threshold voltage";
//   Boolean diode1.idealDiode[2].off(start = true) "Switching state";
//   protected Real diode1.idealDiode[2].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode1.idealDiode[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode1.idealDiode[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode1.idealDiode[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode1.idealDiode[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode1.idealDiode[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.idealDiode[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode1.idealDiode[3].useHeatPort = diode1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode1.idealDiode[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode1.idealDiode[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode1.idealDiode[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode1.idealDiode[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode1.Ron[3] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode1.idealDiode[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode1.Goff[3] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode1.idealDiode[3].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode1.Vknee[3] "Forward threshold voltage";
//   Boolean diode1.idealDiode[3].off(start = true) "Switching state";
//   protected Real diode1.idealDiode[3].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode1.idealDiode[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode1.idealDiode[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer star1.m(min = 1) = 3 "number of phases";
//   parameter Integer star1.plug_p.m(min = 1) = star1.m "number of phases";
//   Real star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode2.m(min = 1) = 3 "number of phases";
//   Real diode2.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode2.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode2.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode2.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode2.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode2.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer diode2.plug_p.m(min = 1) = diode2.m "number of phases";
//   Real diode2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode2.plug_n.m(min = 1) = diode2.m "number of phases";
//   Real diode2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode2.mh(min = 1) = diode2.m "Number of heatPorts=number of phases";
//   parameter Boolean diode2.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real diode2.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode2.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode2.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode2.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode2.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode2.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode2.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode2.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode2.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode2.Vknee[1](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode2.Vknee[2](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode2.Vknee[3](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   Real diode2.idealDiode[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode2.idealDiode[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode2.idealDiode[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.idealDiode[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode2.idealDiode[1].useHeatPort = diode2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode2.idealDiode[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode2.idealDiode[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode2.idealDiode[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode2.idealDiode[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode2.Ron[1] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode2.idealDiode[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode2.Goff[1] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode2.idealDiode[1].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode2.Vknee[1] "Forward threshold voltage";
//   Boolean diode2.idealDiode[1].off(start = true) "Switching state";
//   protected Real diode2.idealDiode[1].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode2.idealDiode[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode2.idealDiode[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode2.idealDiode[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode2.idealDiode[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode2.idealDiode[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.idealDiode[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode2.idealDiode[2].useHeatPort = diode2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode2.idealDiode[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode2.idealDiode[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode2.idealDiode[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode2.idealDiode[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode2.Ron[2] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode2.idealDiode[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode2.Goff[2] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode2.idealDiode[2].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode2.Vknee[2] "Forward threshold voltage";
//   Boolean diode2.idealDiode[2].off(start = true) "Switching state";
//   protected Real diode2.idealDiode[2].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode2.idealDiode[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode2.idealDiode[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode2.idealDiode[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode2.idealDiode[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode2.idealDiode[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.idealDiode[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode2.idealDiode[3].useHeatPort = diode2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode2.idealDiode[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode2.idealDiode[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode2.idealDiode[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode2.idealDiode[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode2.Ron[3] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode2.idealDiode[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode2.Goff[3] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode2.idealDiode[3].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode2.Vknee[3] "Forward threshold voltage";
//   Boolean diode2.idealDiode[3].off(start = true) "Switching state";
//   protected Real diode2.idealDiode[3].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode2.idealDiode[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode2.idealDiode[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer star2.m(min = 1) = 3 "number of phases";
//   parameter Integer star2.plug_p.m(min = 1) = star2.m "number of phases";
//   Real star2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star2.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real load.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real load.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean load.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real load.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref "Fixed device temperature if useHeatPort = false";
//   Real load.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real load.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real load.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = RL "Resistance at temperature T_ref";
//   parameter Real load.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperature";
//   parameter Real load.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real cDC1.v(quantity = "ElectricPotential", unit = "V", start = VC0 / 2.0) "Voltage drop between the two pins (= p.v - n.v)";
//   Real cDC1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real cDC1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cDC1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real cDC1.C(quantity = "Capacitance", unit = "F", min = 0.0, start = 1.0) = 2.0 * C "Capacitance";
//   Real cDC2.v(quantity = "ElectricPotential", unit = "V", start = VC0 / 2.0) "Voltage drop between the two pins (= p.v - n.v)";
//   Real cDC2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real cDC2.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC2.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cDC2.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC2.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real cDC2.C(quantity = "Capacitance", unit = "F", min = 0.0, start = 1.0) = 2.0 * C "Capacitance";
//   Real groundDC.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundDC.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformerData1.f(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real transformerData1.V1(quantity = "ElectricPotential", unit = "V", start = 100.0) "primary nominal line-to-line voltage (RMS)";
//   parameter String transformerData1.C1(start = "Y") = "D" "choose primary connection";
//   parameter Real transformerData1.V2(quantity = "ElectricPotential", unit = "V", start = 100.0) "secondary open circuit line-to-line voltage (RMS) @ primary nominal voltage";
//   parameter String transformerData1.C2(start = "y") = "y" "choose secondary connection";
//   parameter Real transformerData1.SNominal(quantity = "Power", unit = "VA", start = 30000.0) "nominal apparent power";
//   parameter Real transformerData1.v_sc(min = 0.0, max = 1.0, start = 0.05) "impedance voltage drop pu";
//   parameter Real transformerData1.P_sc(quantity = "Power", unit = "W", start = 300.0) "short-circuit (copper) losses";
//   parameter Real transformerData1.n = transformerData1.V1 / transformerData1.V2 "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformerData1.V1ph(quantity = "ElectricPotential", unit = "V") = transformerData1.V1 / (if transformerData1.C1 == "D" then 1.0 else 1.73205080756888) "primary phase voltage (RMS)";
//   parameter Real transformerData1.I1ph(quantity = "ElectricCurrent", unit = "A") = transformerData1.SNominal * 1.0 / transformerData1.V1ph / 3.0 "primary phase current (RMS)";
//   parameter Real transformerData1.V2ph(quantity = "ElectricPotential", unit = "V") = transformerData1.V2 / (if transformerData1.C2 == "d" then 1.0 else 1.73205080756888) "secondary phase voltage (RMS)";
//   parameter Real transformerData1.I2ph(quantity = "ElectricCurrent", unit = "A") = transformerData1.SNominal * 1.0 / transformerData1.V2ph / 3.0 "secondary phase current (RMS)";
//   parameter Real transformerData1.Z1ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.v_sc * transformerData1.V1ph / transformerData1.I1ph) "primary impedance per phase";
//   parameter Real transformerData1.R1(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.P_sc * transformerData1.I1ph ^ -2.0 / 3.0) "warm primary resistance per phase";
//   parameter Real transformerData1.L1sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData1.Z1ph ^ 2.0 - transformerData1.R1 ^ 2.0) * 1.0 / transformerData1.f / 6.28318530717959 "primary stray inductance per phase";
//   parameter Real transformerData1.Z2ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.v_sc * transformerData1.V2ph / transformerData1.I2ph) "secondary impedance per phase";
//   parameter Real transformerData1.R2(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.P_sc * transformerData1.I2ph ^ -2.0 / 3.0) "warm secondary resistance per phase";
//   parameter Real transformerData1.L2sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData1.Z2ph ^ 2.0 - transformerData1.R2 ^ 2.0) * 1.0 / transformerData1.f / 6.28318530717959 "secondary stray inductance per phase";
//   constant Integer transformer1.m(min = 1) = 3 "Number of phases";
//   constant String transformer1.VectorGroup = "Dy01";
//   parameter Real transformer1.n(start = 1.0) = transformerData1.n "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformer1.R1(quantity = "Resistance", unit = "Ohm", start = 0.005) = transformerData1.R1 "warm primary resistance per phase";
//   parameter Real transformer1.L1sigma(quantity = "Inductance", unit = "H", start = 7.8e-05) = transformerData1.L1sigma "primary stray inductance per phase";
//   parameter Real transformer1.R2(quantity = "Resistance", unit = "Ohm", start = 0.00166666666666667) = transformerData1.R2 "warm secondary resistance per phase";
//   parameter Real transformer1.L2sigma(quantity = "Inductance", unit = "H", start = 2.6e-05) = transformerData1.L2sigma "secondary stray inductance per phase";
//   output Real transformer1.v1[1](quantity = "ElectricPotential", unit = "V") = transformer1.plug1.pin[1].v "Primary voltage";
//   output Real transformer1.v1[2](quantity = "ElectricPotential", unit = "V") = transformer1.plug1.pin[2].v "Primary voltage";
//   output Real transformer1.v1[3](quantity = "ElectricPotential", unit = "V") = transformer1.plug1.pin[3].v "Primary voltage";
//   output Real transformer1.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer1.plug1.pin[1].i "Primary current";
//   output Real transformer1.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer1.plug1.pin[2].i "Primary current";
//   output Real transformer1.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer1.plug1.pin[3].i "Primary current";
//   output Real transformer1.v2[1](quantity = "ElectricPotential", unit = "V") = transformer1.plug2.pin[1].v "Secondary voltage";
//   output Real transformer1.v2[2](quantity = "ElectricPotential", unit = "V") = transformer1.plug2.pin[2].v "Secondary voltage";
//   output Real transformer1.v2[3](quantity = "ElectricPotential", unit = "V") = transformer1.plug2.pin[3].v "Secondary voltage";
//   output Real transformer1.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer1.plug2.pin[1].i "Secondary current";
//   output Real transformer1.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer1.plug2.pin[2].i "Secondary current";
//   output Real transformer1.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer1.plug2.pin[3].i "Secondary current";
//   protected constant String transformer1.C1 = "D";
//   protected constant String transformer1.C2 = "y";
//   protected parameter Real transformer1.ni = 3.46410161513775 * transformer1.n;
//   parameter Integer transformer1.plug1.m(min = 1) = 3 "number of phases";
//   Real transformer1.plug1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.plug2.m(min = 1) = 3 "number of phases";
//   Real transformer1.plug2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r1.m(min = 1) = 3 "number of phases";
//   Real transformer1.r1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.r1.plug_p.m(min = 1) = transformer1.r1.m "number of phases";
//   Real transformer1.r1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r1.plug_n.m(min = 1) = transformer1.r1.m "number of phases";
//   Real transformer1.r1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r1.mh(min = 1) = transformer1.r1.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer1.r1.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer1.r1.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r1.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r1.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r1.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r1.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r1.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r1.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r1.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r1.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r1.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r1.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r1.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer1.r1.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r1.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r1.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r1.resistor[1].useHeatPort = transformer1.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r1.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r1.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r1.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r1.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r1.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer1.r1.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[1] "Reference temperature";
//   parameter Real transformer1.r1.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r1.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r1.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r1.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r1.resistor[2].useHeatPort = transformer1.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r1.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r1.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r1.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r1.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r1.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer1.r1.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[2] "Reference temperature";
//   parameter Real transformer1.r1.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r1.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r1.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r1.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r1.resistor[3].useHeatPort = transformer1.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r1.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r1.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r1.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r1.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r1.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer1.r1.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[3] "Reference temperature";
//   parameter Real transformer1.r1.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r1.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer1.l1sigma.m(min = 1) = 3 "number of phases";
//   Real transformer1.l1sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l1sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l1sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l1sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l1sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l1sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.l1sigma.plug_p.m(min = 1) = transformer1.l1sigma.m "number of phases";
//   Real transformer1.l1sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.l1sigma.plug_n.m(min = 1) = transformer1.l1sigma.m "number of phases";
//   Real transformer1.l1sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L1sigma "Inductance";
//   parameter Real transformer1.l1sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L1sigma "Inductance";
//   parameter Real transformer1.l1sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L1sigma "Inductance";
//   Real transformer1.l1sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l1sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l1sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l1sigma.L[1] "Inductance";
//   Real transformer1.l1sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l1sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l1sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l1sigma.L[2] "Inductance";
//   Real transformer1.l1sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l1sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l1sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l1sigma.L[3] "Inductance";
//   parameter Integer transformer1.r2.m(min = 1) = 3 "number of phases";
//   Real transformer1.r2.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r2.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r2.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r2.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r2.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r2.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.r2.plug_p.m(min = 1) = transformer1.r2.m "number of phases";
//   Real transformer1.r2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r2.plug_n.m(min = 1) = transformer1.r2.m "number of phases";
//   Real transformer1.r2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r2.mh(min = 1) = transformer1.r2.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer1.r2.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer1.r2.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r2.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r2.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r2.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r2.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r2.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r2.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r2.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r2.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r2.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r2.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r2.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer1.r2.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r2.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r2.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r2.resistor[1].useHeatPort = transformer1.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r2.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r2.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r2.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r2.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r2.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer1.r2.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[1] "Reference temperature";
//   parameter Real transformer1.r2.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r2.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r2.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r2.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r2.resistor[2].useHeatPort = transformer1.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r2.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r2.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r2.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r2.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r2.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer1.r2.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[2] "Reference temperature";
//   parameter Real transformer1.r2.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r2.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r2.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r2.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r2.resistor[3].useHeatPort = transformer1.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r2.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r2.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r2.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r2.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r2.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer1.r2.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[3] "Reference temperature";
//   parameter Real transformer1.r2.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r2.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer1.l2sigma.m(min = 1) = 3 "number of phases";
//   Real transformer1.l2sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l2sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l2sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l2sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l2sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l2sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.l2sigma.plug_p.m(min = 1) = transformer1.l2sigma.m "number of phases";
//   Real transformer1.l2sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.l2sigma.plug_n.m(min = 1) = transformer1.l2sigma.m "number of phases";
//   Real transformer1.l2sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L2sigma "Inductance";
//   parameter Real transformer1.l2sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L2sigma "Inductance";
//   parameter Real transformer1.l2sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L2sigma "Inductance";
//   Real transformer1.l2sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l2sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l2sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l2sigma.L[1] "Inductance";
//   Real transformer1.l2sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l2sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l2sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l2sigma.L[2] "Inductance";
//   Real transformer1.l2sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l2sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l2sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l2sigma.L[3] "Inductance";
//   parameter Integer transformer1.core.m(min = 1) = 3 "number of phases";
//   parameter Real transformer1.core.n12(start = 1.0) = transformer1.ni "turns ratio 1:2";
//   parameter Real transformer1.core.n13(start = 1.0) = transformer1.ni "turns ratio 1:3";
//   Real transformer1.core.v1[1](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p1.pin[1].v - transformer1.core.plug_n1.pin[1].v;
//   Real transformer1.core.v1[2](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p1.pin[2].v - transformer1.core.plug_n1.pin[2].v;
//   Real transformer1.core.v1[3](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p1.pin[3].v - transformer1.core.plug_n1.pin[3].v;
//   Real transformer1.core.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p1.pin[1].i;
//   Real transformer1.core.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p1.pin[2].i;
//   Real transformer1.core.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p1.pin[3].i;
//   Real transformer1.core.v2[1](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p2.pin[1].v - transformer1.core.plug_n2.pin[1].v;
//   Real transformer1.core.v2[2](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p2.pin[2].v - transformer1.core.plug_n2.pin[2].v;
//   Real transformer1.core.v2[3](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p2.pin[3].v - transformer1.core.plug_n2.pin[3].v;
//   Real transformer1.core.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p2.pin[1].i;
//   Real transformer1.core.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p2.pin[2].i;
//   Real transformer1.core.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p2.pin[3].i;
//   Real transformer1.core.v3[1](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p3.pin[1].v - transformer1.core.plug_n3.pin[1].v;
//   Real transformer1.core.v3[2](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p3.pin[2].v - transformer1.core.plug_n3.pin[2].v;
//   Real transformer1.core.v3[3](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p3.pin[3].v - transformer1.core.plug_n3.pin[3].v;
//   Real transformer1.core.i3[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p3.pin[1].i;
//   Real transformer1.core.i3[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p3.pin[2].i;
//   Real transformer1.core.i3[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p3.pin[3].i;
//   Real transformer1.core.im[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.i1[1] + (transformer1.core.i2[1] / transformer1.core.n12 + transformer1.core.i3[1] / transformer1.core.n13) "Magnetizing current";
//   Real transformer1.core.im[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.i1[2] + (transformer1.core.i2[2] / transformer1.core.n12 + transformer1.core.i3[2] / transformer1.core.n13) "Magnetizing current";
//   Real transformer1.core.im[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.i1[3] + (transformer1.core.i2[3] / transformer1.core.n12 + transformer1.core.i3[3] / transformer1.core.n13) "Magnetizing current";
//   parameter Integer transformer1.core.plug_p1.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_p1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_n1.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_p2.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_p2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_n2.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_p3.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_p3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_n3.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_n3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.star2.m(min = 1) = 3 "number of phases";
//   parameter Integer transformer1.star2.plug_p.m(min = 1) = transformer1.star2.m "number of phases";
//   Real transformer1.star2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.star2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.star2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.star2.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.starpoint2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.starpoint2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Delta1.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer1.Delta1.plug_p.m(min = 1) = transformer1.Delta1.m "number of phases";
//   Real transformer1.Delta1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Delta1.plug_n.m(min = 1) = transformer1.Delta1.m "number of phases";
//   Real transformer1.Delta1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Rot2.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer1.Rot2.plug_p.m(min = 1) = transformer1.Rot2.m "number of phases";
//   Real transformer1.Rot2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Rot2.plug_n.m(min = 1) = transformer1.Rot2.m "number of phases";
//   Real transformer1.Rot2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   source.sineVoltage[1].signalSource.y = source.sineVoltage[1].signalSource.offset + (if time < source.sineVoltage[1].signalSource.startTime then 0.0 else source.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[1].signalSource.freqHz * (time - source.sineVoltage[1].signalSource.startTime)) + source.sineVoltage[1].signalSource.phase));
//   source.sineVoltage[1].v = source.sineVoltage[1].signalSource.y;
//   source.sineVoltage[1].v = source.sineVoltage[1].p.v - source.sineVoltage[1].n.v;
//   0.0 = source.sineVoltage[1].p.i + source.sineVoltage[1].n.i;
//   source.sineVoltage[1].i = source.sineVoltage[1].p.i;
//   source.sineVoltage[2].signalSource.y = source.sineVoltage[2].signalSource.offset + (if time < source.sineVoltage[2].signalSource.startTime then 0.0 else source.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[2].signalSource.freqHz * (time - source.sineVoltage[2].signalSource.startTime)) + source.sineVoltage[2].signalSource.phase));
//   source.sineVoltage[2].v = source.sineVoltage[2].signalSource.y;
//   source.sineVoltage[2].v = source.sineVoltage[2].p.v - source.sineVoltage[2].n.v;
//   0.0 = source.sineVoltage[2].p.i + source.sineVoltage[2].n.i;
//   source.sineVoltage[2].i = source.sineVoltage[2].p.i;
//   source.sineVoltage[3].signalSource.y = source.sineVoltage[3].signalSource.offset + (if time < source.sineVoltage[3].signalSource.startTime then 0.0 else source.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[3].signalSource.freqHz * (time - source.sineVoltage[3].signalSource.startTime)) + source.sineVoltage[3].signalSource.phase));
//   source.sineVoltage[3].v = source.sineVoltage[3].signalSource.y;
//   source.sineVoltage[3].v = source.sineVoltage[3].p.v - source.sineVoltage[3].n.v;
//   0.0 = source.sineVoltage[3].p.i + source.sineVoltage[3].n.i;
//   source.sineVoltage[3].i = source.sineVoltage[3].p.i;
//   source.v[1] = source.plug_p.pin[1].v - source.plug_n.pin[1].v;
//   source.v[2] = source.plug_p.pin[2].v - source.plug_n.pin[2].v;
//   source.v[3] = source.plug_p.pin[3].v - source.plug_n.pin[3].v;
//   source.i[1] = source.plug_p.pin[1].i;
//   source.i[2] = source.plug_p.pin[2].i;
//   source.i[3] = source.plug_p.pin[3].i;
//   groundAC.p.v = 0.0;
//   currentQuasiRMSSensor.currentSensor[1].p.v = currentQuasiRMSSensor.currentSensor[1].n.v;
//   currentQuasiRMSSensor.currentSensor[1].p.i = currentQuasiRMSSensor.currentSensor[1].i;
//   currentQuasiRMSSensor.currentSensor[1].n.i = -currentQuasiRMSSensor.currentSensor[1].i;
//   currentQuasiRMSSensor.currentSensor[2].p.v = currentQuasiRMSSensor.currentSensor[2].n.v;
//   currentQuasiRMSSensor.currentSensor[2].p.i = currentQuasiRMSSensor.currentSensor[2].i;
//   currentQuasiRMSSensor.currentSensor[2].n.i = -currentQuasiRMSSensor.currentSensor[2].i;
//   currentQuasiRMSSensor.currentSensor[3].p.v = currentQuasiRMSSensor.currentSensor[3].n.v;
//   currentQuasiRMSSensor.currentSensor[3].p.i = currentQuasiRMSSensor.currentSensor[3].i;
//   currentQuasiRMSSensor.currentSensor[3].n.i = -currentQuasiRMSSensor.currentSensor[3].i;
//   diode1.idealDiode[1].off = diode1.idealDiode[1].s < 0.0;
//   diode1.idealDiode[1].v = diode1.idealDiode[1].s * (if diode1.idealDiode[1].off then 1.0 else diode1.idealDiode[1].Ron) + diode1.idealDiode[1].Vknee;
//   diode1.idealDiode[1].i = diode1.idealDiode[1].s * (if diode1.idealDiode[1].off then diode1.idealDiode[1].Goff else 1.0) + diode1.idealDiode[1].Goff * diode1.idealDiode[1].Vknee;
//   diode1.idealDiode[1].LossPower = diode1.idealDiode[1].v * diode1.idealDiode[1].i;
//   diode1.idealDiode[1].i = diode1.idealDiode[1].p.i;
//   0.0 = diode1.idealDiode[1].p.i + diode1.idealDiode[1].n.i;
//   diode1.idealDiode[1].v = diode1.idealDiode[1].p.v - diode1.idealDiode[1].n.v;
//   diode1.idealDiode[1].T_heatPort = diode1.idealDiode[1].T;
//   diode1.idealDiode[2].off = diode1.idealDiode[2].s < 0.0;
//   diode1.idealDiode[2].v = diode1.idealDiode[2].s * (if diode1.idealDiode[2].off then 1.0 else diode1.idealDiode[2].Ron) + diode1.idealDiode[2].Vknee;
//   diode1.idealDiode[2].i = diode1.idealDiode[2].s * (if diode1.idealDiode[2].off then diode1.idealDiode[2].Goff else 1.0) + diode1.idealDiode[2].Goff * diode1.idealDiode[2].Vknee;
//   diode1.idealDiode[2].LossPower = diode1.idealDiode[2].v * diode1.idealDiode[2].i;
//   diode1.idealDiode[2].i = diode1.idealDiode[2].p.i;
//   0.0 = diode1.idealDiode[2].p.i + diode1.idealDiode[2].n.i;
//   diode1.idealDiode[2].v = diode1.idealDiode[2].p.v - diode1.idealDiode[2].n.v;
//   diode1.idealDiode[2].T_heatPort = diode1.idealDiode[2].T;
//   diode1.idealDiode[3].off = diode1.idealDiode[3].s < 0.0;
//   diode1.idealDiode[3].v = diode1.idealDiode[3].s * (if diode1.idealDiode[3].off then 1.0 else diode1.idealDiode[3].Ron) + diode1.idealDiode[3].Vknee;
//   diode1.idealDiode[3].i = diode1.idealDiode[3].s * (if diode1.idealDiode[3].off then diode1.idealDiode[3].Goff else 1.0) + diode1.idealDiode[3].Goff * diode1.idealDiode[3].Vknee;
//   diode1.idealDiode[3].LossPower = diode1.idealDiode[3].v * diode1.idealDiode[3].i;
//   diode1.idealDiode[3].i = diode1.idealDiode[3].p.i;
//   0.0 = diode1.idealDiode[3].p.i + diode1.idealDiode[3].n.i;
//   diode1.idealDiode[3].v = diode1.idealDiode[3].p.v - diode1.idealDiode[3].n.v;
//   diode1.idealDiode[3].T_heatPort = diode1.idealDiode[3].T;
//   diode1.v[1] = diode1.plug_p.pin[1].v - diode1.plug_n.pin[1].v;
//   diode1.v[2] = diode1.plug_p.pin[2].v - diode1.plug_n.pin[2].v;
//   diode1.v[3] = diode1.plug_p.pin[3].v - diode1.plug_n.pin[3].v;
//   diode1.i[1] = diode1.plug_p.pin[1].i;
//   diode1.i[2] = diode1.plug_p.pin[2].i;
//   diode1.i[3] = diode1.plug_p.pin[3].i;
//   diode2.idealDiode[1].off = diode2.idealDiode[1].s < 0.0;
//   diode2.idealDiode[1].v = diode2.idealDiode[1].s * (if diode2.idealDiode[1].off then 1.0 else diode2.idealDiode[1].Ron) + diode2.idealDiode[1].Vknee;
//   diode2.idealDiode[1].i = diode2.idealDiode[1].s * (if diode2.idealDiode[1].off then diode2.idealDiode[1].Goff else 1.0) + diode2.idealDiode[1].Goff * diode2.idealDiode[1].Vknee;
//   diode2.idealDiode[1].LossPower = diode2.idealDiode[1].v * diode2.idealDiode[1].i;
//   diode2.idealDiode[1].i = diode2.idealDiode[1].p.i;
//   0.0 = diode2.idealDiode[1].p.i + diode2.idealDiode[1].n.i;
//   diode2.idealDiode[1].v = diode2.idealDiode[1].p.v - diode2.idealDiode[1].n.v;
//   diode2.idealDiode[1].T_heatPort = diode2.idealDiode[1].T;
//   diode2.idealDiode[2].off = diode2.idealDiode[2].s < 0.0;
//   diode2.idealDiode[2].v = diode2.idealDiode[2].s * (if diode2.idealDiode[2].off then 1.0 else diode2.idealDiode[2].Ron) + diode2.idealDiode[2].Vknee;
//   diode2.idealDiode[2].i = diode2.idealDiode[2].s * (if diode2.idealDiode[2].off then diode2.idealDiode[2].Goff else 1.0) + diode2.idealDiode[2].Goff * diode2.idealDiode[2].Vknee;
//   diode2.idealDiode[2].LossPower = diode2.idealDiode[2].v * diode2.idealDiode[2].i;
//   diode2.idealDiode[2].i = diode2.idealDiode[2].p.i;
//   0.0 = diode2.idealDiode[2].p.i + diode2.idealDiode[2].n.i;
//   diode2.idealDiode[2].v = diode2.idealDiode[2].p.v - diode2.idealDiode[2].n.v;
//   diode2.idealDiode[2].T_heatPort = diode2.idealDiode[2].T;
//   diode2.idealDiode[3].off = diode2.idealDiode[3].s < 0.0;
//   diode2.idealDiode[3].v = diode2.idealDiode[3].s * (if diode2.idealDiode[3].off then 1.0 else diode2.idealDiode[3].Ron) + diode2.idealDiode[3].Vknee;
//   diode2.idealDiode[3].i = diode2.idealDiode[3].s * (if diode2.idealDiode[3].off then diode2.idealDiode[3].Goff else 1.0) + diode2.idealDiode[3].Goff * diode2.idealDiode[3].Vknee;
//   diode2.idealDiode[3].LossPower = diode2.idealDiode[3].v * diode2.idealDiode[3].i;
//   diode2.idealDiode[3].i = diode2.idealDiode[3].p.i;
//   0.0 = diode2.idealDiode[3].p.i + diode2.idealDiode[3].n.i;
//   diode2.idealDiode[3].v = diode2.idealDiode[3].p.v - diode2.idealDiode[3].n.v;
//   diode2.idealDiode[3].T_heatPort = diode2.idealDiode[3].T;
//   diode2.v[1] = diode2.plug_p.pin[1].v - diode2.plug_n.pin[1].v;
//   diode2.v[2] = diode2.plug_p.pin[2].v - diode2.plug_n.pin[2].v;
//   diode2.v[3] = diode2.plug_p.pin[3].v - diode2.plug_n.pin[3].v;
//   diode2.i[1] = diode2.plug_p.pin[1].i;
//   diode2.i[2] = diode2.plug_p.pin[2].i;
//   diode2.i[3] = diode2.plug_p.pin[3].i;
//   assert(1.0 + load.alpha * (load.T_heatPort - load.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   load.R_actual = load.R * (1.0 + load.alpha * (load.T_heatPort - load.T_ref));
//   load.v = load.R_actual * load.i;
//   load.LossPower = load.v * load.i;
//   load.i = load.p.i;
//   0.0 = load.p.i + load.n.i;
//   load.v = load.p.v - load.n.v;
//   load.T_heatPort = load.T;
//   cDC1.i = cDC1.C * der(cDC1.v);
//   cDC1.v = cDC1.p.v - cDC1.n.v;
//   0.0 = cDC1.p.i + cDC1.n.i;
//   cDC1.i = cDC1.p.i;
//   cDC2.i = cDC2.C * der(cDC2.v);
//   cDC2.v = cDC2.p.v - cDC2.n.v;
//   0.0 = cDC2.p.i + cDC2.n.i;
//   cDC2.i = cDC2.p.i;
//   groundDC.p.v = 0.0;
//   assert(1.0 + transformer1.r1.resistor[1].alpha * (transformer1.r1.resistor[1].T_heatPort - transformer1.r1.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r1.resistor[1].R_actual = transformer1.r1.resistor[1].R * (1.0 + transformer1.r1.resistor[1].alpha * (transformer1.r1.resistor[1].T_heatPort - transformer1.r1.resistor[1].T_ref));
//   transformer1.r1.resistor[1].v = transformer1.r1.resistor[1].R_actual * transformer1.r1.resistor[1].i;
//   transformer1.r1.resistor[1].LossPower = transformer1.r1.resistor[1].v * transformer1.r1.resistor[1].i;
//   transformer1.r1.resistor[1].i = transformer1.r1.resistor[1].p.i;
//   0.0 = transformer1.r1.resistor[1].p.i + transformer1.r1.resistor[1].n.i;
//   transformer1.r1.resistor[1].v = transformer1.r1.resistor[1].p.v - transformer1.r1.resistor[1].n.v;
//   transformer1.r1.resistor[1].T_heatPort = transformer1.r1.resistor[1].T;
//   assert(1.0 + transformer1.r1.resistor[2].alpha * (transformer1.r1.resistor[2].T_heatPort - transformer1.r1.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r1.resistor[2].R_actual = transformer1.r1.resistor[2].R * (1.0 + transformer1.r1.resistor[2].alpha * (transformer1.r1.resistor[2].T_heatPort - transformer1.r1.resistor[2].T_ref));
//   transformer1.r1.resistor[2].v = transformer1.r1.resistor[2].R_actual * transformer1.r1.resistor[2].i;
//   transformer1.r1.resistor[2].LossPower = transformer1.r1.resistor[2].v * transformer1.r1.resistor[2].i;
//   transformer1.r1.resistor[2].i = transformer1.r1.resistor[2].p.i;
//   0.0 = transformer1.r1.resistor[2].p.i + transformer1.r1.resistor[2].n.i;
//   transformer1.r1.resistor[2].v = transformer1.r1.resistor[2].p.v - transformer1.r1.resistor[2].n.v;
//   transformer1.r1.resistor[2].T_heatPort = transformer1.r1.resistor[2].T;
//   assert(1.0 + transformer1.r1.resistor[3].alpha * (transformer1.r1.resistor[3].T_heatPort - transformer1.r1.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r1.resistor[3].R_actual = transformer1.r1.resistor[3].R * (1.0 + transformer1.r1.resistor[3].alpha * (transformer1.r1.resistor[3].T_heatPort - transformer1.r1.resistor[3].T_ref));
//   transformer1.r1.resistor[3].v = transformer1.r1.resistor[3].R_actual * transformer1.r1.resistor[3].i;
//   transformer1.r1.resistor[3].LossPower = transformer1.r1.resistor[3].v * transformer1.r1.resistor[3].i;
//   transformer1.r1.resistor[3].i = transformer1.r1.resistor[3].p.i;
//   0.0 = transformer1.r1.resistor[3].p.i + transformer1.r1.resistor[3].n.i;
//   transformer1.r1.resistor[3].v = transformer1.r1.resistor[3].p.v - transformer1.r1.resistor[3].n.v;
//   transformer1.r1.resistor[3].T_heatPort = transformer1.r1.resistor[3].T;
//   transformer1.r1.v[1] = transformer1.r1.plug_p.pin[1].v - transformer1.r1.plug_n.pin[1].v;
//   transformer1.r1.v[2] = transformer1.r1.plug_p.pin[2].v - transformer1.r1.plug_n.pin[2].v;
//   transformer1.r1.v[3] = transformer1.r1.plug_p.pin[3].v - transformer1.r1.plug_n.pin[3].v;
//   transformer1.r1.i[1] = transformer1.r1.plug_p.pin[1].i;
//   transformer1.r1.i[2] = transformer1.r1.plug_p.pin[2].i;
//   transformer1.r1.i[3] = transformer1.r1.plug_p.pin[3].i;
//   transformer1.l1sigma.inductor[1].L * der(transformer1.l1sigma.inductor[1].i) = transformer1.l1sigma.inductor[1].v;
//   transformer1.l1sigma.inductor[1].v = transformer1.l1sigma.inductor[1].p.v - transformer1.l1sigma.inductor[1].n.v;
//   0.0 = transformer1.l1sigma.inductor[1].p.i + transformer1.l1sigma.inductor[1].n.i;
//   transformer1.l1sigma.inductor[1].i = transformer1.l1sigma.inductor[1].p.i;
//   transformer1.l1sigma.inductor[2].L * der(transformer1.l1sigma.inductor[2].i) = transformer1.l1sigma.inductor[2].v;
//   transformer1.l1sigma.inductor[2].v = transformer1.l1sigma.inductor[2].p.v - transformer1.l1sigma.inductor[2].n.v;
//   0.0 = transformer1.l1sigma.inductor[2].p.i + transformer1.l1sigma.inductor[2].n.i;
//   transformer1.l1sigma.inductor[2].i = transformer1.l1sigma.inductor[2].p.i;
//   transformer1.l1sigma.inductor[3].L * der(transformer1.l1sigma.inductor[3].i) = transformer1.l1sigma.inductor[3].v;
//   transformer1.l1sigma.inductor[3].v = transformer1.l1sigma.inductor[3].p.v - transformer1.l1sigma.inductor[3].n.v;
//   0.0 = transformer1.l1sigma.inductor[3].p.i + transformer1.l1sigma.inductor[3].n.i;
//   transformer1.l1sigma.inductor[3].i = transformer1.l1sigma.inductor[3].p.i;
//   transformer1.l1sigma.v[1] = transformer1.l1sigma.plug_p.pin[1].v - transformer1.l1sigma.plug_n.pin[1].v;
//   transformer1.l1sigma.v[2] = transformer1.l1sigma.plug_p.pin[2].v - transformer1.l1sigma.plug_n.pin[2].v;
//   transformer1.l1sigma.v[3] = transformer1.l1sigma.plug_p.pin[3].v - transformer1.l1sigma.plug_n.pin[3].v;
//   transformer1.l1sigma.i[1] = transformer1.l1sigma.plug_p.pin[1].i;
//   transformer1.l1sigma.i[2] = transformer1.l1sigma.plug_p.pin[2].i;
//   transformer1.l1sigma.i[3] = transformer1.l1sigma.plug_p.pin[3].i;
//   assert(1.0 + transformer1.r2.resistor[1].alpha * (transformer1.r2.resistor[1].T_heatPort - transformer1.r2.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r2.resistor[1].R_actual = transformer1.r2.resistor[1].R * (1.0 + transformer1.r2.resistor[1].alpha * (transformer1.r2.resistor[1].T_heatPort - transformer1.r2.resistor[1].T_ref));
//   transformer1.r2.resistor[1].v = transformer1.r2.resistor[1].R_actual * transformer1.r2.resistor[1].i;
//   transformer1.r2.resistor[1].LossPower = transformer1.r2.resistor[1].v * transformer1.r2.resistor[1].i;
//   transformer1.r2.resistor[1].i = transformer1.r2.resistor[1].p.i;
//   0.0 = transformer1.r2.resistor[1].p.i + transformer1.r2.resistor[1].n.i;
//   transformer1.r2.resistor[1].v = transformer1.r2.resistor[1].p.v - transformer1.r2.resistor[1].n.v;
//   transformer1.r2.resistor[1].T_heatPort = transformer1.r2.resistor[1].T;
//   assert(1.0 + transformer1.r2.resistor[2].alpha * (transformer1.r2.resistor[2].T_heatPort - transformer1.r2.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r2.resistor[2].R_actual = transformer1.r2.resistor[2].R * (1.0 + transformer1.r2.resistor[2].alpha * (transformer1.r2.resistor[2].T_heatPort - transformer1.r2.resistor[2].T_ref));
//   transformer1.r2.resistor[2].v = transformer1.r2.resistor[2].R_actual * transformer1.r2.resistor[2].i;
//   transformer1.r2.resistor[2].LossPower = transformer1.r2.resistor[2].v * transformer1.r2.resistor[2].i;
//   transformer1.r2.resistor[2].i = transformer1.r2.resistor[2].p.i;
//   0.0 = transformer1.r2.resistor[2].p.i + transformer1.r2.resistor[2].n.i;
//   transformer1.r2.resistor[2].v = transformer1.r2.resistor[2].p.v - transformer1.r2.resistor[2].n.v;
//   transformer1.r2.resistor[2].T_heatPort = transformer1.r2.resistor[2].T;
//   assert(1.0 + transformer1.r2.resistor[3].alpha * (transformer1.r2.resistor[3].T_heatPort - transformer1.r2.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r2.resistor[3].R_actual = transformer1.r2.resistor[3].R * (1.0 + transformer1.r2.resistor[3].alpha * (transformer1.r2.resistor[3].T_heatPort - transformer1.r2.resistor[3].T_ref));
//   transformer1.r2.resistor[3].v = transformer1.r2.resistor[3].R_actual * transformer1.r2.resistor[3].i;
//   transformer1.r2.resistor[3].LossPower = transformer1.r2.resistor[3].v * transformer1.r2.resistor[3].i;
//   transformer1.r2.resistor[3].i = transformer1.r2.resistor[3].p.i;
//   0.0 = transformer1.r2.resistor[3].p.i + transformer1.r2.resistor[3].n.i;
//   transformer1.r2.resistor[3].v = transformer1.r2.resistor[3].p.v - transformer1.r2.resistor[3].n.v;
//   transformer1.r2.resistor[3].T_heatPort = transformer1.r2.resistor[3].T;
//   transformer1.r2.v[1] = transformer1.r2.plug_p.pin[1].v - transformer1.r2.plug_n.pin[1].v;
//   transformer1.r2.v[2] = transformer1.r2.plug_p.pin[2].v - transformer1.r2.plug_n.pin[2].v;
//   transformer1.r2.v[3] = transformer1.r2.plug_p.pin[3].v - transformer1.r2.plug_n.pin[3].v;
//   transformer1.r2.i[1] = transformer1.r2.plug_p.pin[1].i;
//   transformer1.r2.i[2] = transformer1.r2.plug_p.pin[2].i;
//   transformer1.r2.i[3] = transformer1.r2.plug_p.pin[3].i;
//   transformer1.l2sigma.inductor[1].L * der(transformer1.l2sigma.inductor[1].i) = transformer1.l2sigma.inductor[1].v;
//   transformer1.l2sigma.inductor[1].v = transformer1.l2sigma.inductor[1].p.v - transformer1.l2sigma.inductor[1].n.v;
//   0.0 = transformer1.l2sigma.inductor[1].p.i + transformer1.l2sigma.inductor[1].n.i;
//   transformer1.l2sigma.inductor[1].i = transformer1.l2sigma.inductor[1].p.i;
//   transformer1.l2sigma.inductor[2].L * der(transformer1.l2sigma.inductor[2].i) = transformer1.l2sigma.inductor[2].v;
//   transformer1.l2sigma.inductor[2].v = transformer1.l2sigma.inductor[2].p.v - transformer1.l2sigma.inductor[2].n.v;
//   0.0 = transformer1.l2sigma.inductor[2].p.i + transformer1.l2sigma.inductor[2].n.i;
//   transformer1.l2sigma.inductor[2].i = transformer1.l2sigma.inductor[2].p.i;
//   transformer1.l2sigma.inductor[3].L * der(transformer1.l2sigma.inductor[3].i) = transformer1.l2sigma.inductor[3].v;
//   transformer1.l2sigma.inductor[3].v = transformer1.l2sigma.inductor[3].p.v - transformer1.l2sigma.inductor[3].n.v;
//   0.0 = transformer1.l2sigma.inductor[3].p.i + transformer1.l2sigma.inductor[3].n.i;
//   transformer1.l2sigma.inductor[3].i = transformer1.l2sigma.inductor[3].p.i;
//   transformer1.l2sigma.v[1] = transformer1.l2sigma.plug_p.pin[1].v - transformer1.l2sigma.plug_n.pin[1].v;
//   transformer1.l2sigma.v[2] = transformer1.l2sigma.plug_p.pin[2].v - transformer1.l2sigma.plug_n.pin[2].v;
//   transformer1.l2sigma.v[3] = transformer1.l2sigma.plug_p.pin[3].v - transformer1.l2sigma.plug_n.pin[3].v;
//   transformer1.l2sigma.i[1] = transformer1.l2sigma.plug_p.pin[1].i;
//   transformer1.l2sigma.i[2] = transformer1.l2sigma.plug_p.pin[2].i;
//   transformer1.l2sigma.i[3] = transformer1.l2sigma.plug_p.pin[3].i;
//   transformer1.core.im[1] = 0.0;
//   transformer1.core.im[2] = 0.0;
//   transformer1.core.im[3] = 0.0;
//   transformer1.core.v1[1] = transformer1.core.n12 * transformer1.core.v2[1];
//   transformer1.core.v1[2] = transformer1.core.n12 * transformer1.core.v2[2];
//   transformer1.core.v1[3] = transformer1.core.n12 * transformer1.core.v2[3];
//   transformer1.core.v1[1] = transformer1.core.n13 * transformer1.core.v3[1];
//   transformer1.core.v1[2] = transformer1.core.n13 * transformer1.core.v3[2];
//   transformer1.core.v1[3] = transformer1.core.n13 * transformer1.core.v3[3];
//   transformer1.core.plug_p1.pin[1].i + transformer1.core.plug_n1.pin[1].i = 0.0;
//   transformer1.core.plug_p1.pin[2].i + transformer1.core.plug_n1.pin[2].i = 0.0;
//   transformer1.core.plug_p1.pin[3].i + transformer1.core.plug_n1.pin[3].i = 0.0;
//   transformer1.core.plug_p2.pin[1].i + transformer1.core.plug_n2.pin[1].i = 0.0;
//   transformer1.core.plug_p2.pin[2].i + transformer1.core.plug_n2.pin[2].i = 0.0;
//   transformer1.core.plug_p2.pin[3].i + transformer1.core.plug_n2.pin[3].i = 0.0;
//   transformer1.core.plug_p3.pin[1].i + transformer1.core.plug_n3.pin[1].i = 0.0;
//   transformer1.core.plug_p3.pin[2].i + transformer1.core.plug_n3.pin[2].i = 0.0;
//   transformer1.core.plug_p3.pin[3].i + transformer1.core.plug_n3.pin[3].i = 0.0;
//   assert(transformer1.l2sigma.plug_p.m == transformer1.Rot2.plug_p.m,"automatically generated from connect");
//   assert(transformer1.Delta1.plug_p.m == transformer1.r1.plug_p.m,"automatically generated from connect");
//   assert(transformer1.Delta1.plug_n.m == transformer1.core.plug_n1.m,"automatically generated from connect");
//   assert(transformer1.l1sigma.plug_n.m == transformer1.core.plug_p1.m,"automatically generated from connect");
//   assert(transformer1.core.plug_n2.m == transformer1.core.plug_p3.m,"automatically generated from connect");
//   assert(transformer1.core.plug_n3.m == transformer1.Rot2.plug_n.m,"automatically generated from connect");
//   assert(transformer1.core.plug_p2.m == transformer1.star2.plug_p.m,"automatically generated from connect");
//   assert(transformer1.r1.plug_n.m == transformer1.l1sigma.plug_p.m,"automatically generated from connect");
//   assert(transformer1.l2sigma.plug_n.m == transformer1.r2.plug_p.m,"automatically generated from connect");
//   assert(transformer1.plug1.m == transformer1.r1.plug_p.m,"automatically generated from connect");
//   assert(transformer1.r2.plug_n.m == transformer1.plug2.m,"automatically generated from connect");
//   assert(starAC.plug_p.m == source.plug_n.m,"automatically generated from connect");
//   assert(diode1.plug_n.m == star1.plug_p.m,"automatically generated from connect");
//   assert(diode2.plug_p.m == star2.plug_p.m,"automatically generated from connect");
//   assert(diode2.plug_n.m == diode1.plug_p.m,"automatically generated from connect");
//   assert(source.plug_p.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(transformer1.plug1.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(transformer1.plug2.m == diode1.plug_p.m,"automatically generated from connect");
//   transformer1.plug2.pin[3].i + (diode2.plug_n.pin[3].i + diode1.plug_p.pin[3].i) = 0.0;
//   diode1.plug_p.pin[3].v = diode2.plug_n.pin[3].v;
//   diode1.plug_p.pin[3].v = transformer1.plug2.pin[3].v;
//   transformer1.plug2.pin[2].i + (diode2.plug_n.pin[2].i + diode1.plug_p.pin[2].i) = 0.0;
//   diode1.plug_p.pin[2].v = diode2.plug_n.pin[2].v;
//   diode1.plug_p.pin[2].v = transformer1.plug2.pin[2].v;
//   transformer1.plug2.pin[1].i + (diode2.plug_n.pin[1].i + diode1.plug_p.pin[1].i) = 0.0;
//   diode1.plug_p.pin[1].v = diode2.plug_n.pin[1].v;
//   diode1.plug_p.pin[1].v = transformer1.plug2.pin[1].v;
//   transformer1.plug1.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = transformer1.plug1.pin[3].v;
//   transformer1.plug1.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = transformer1.plug1.pin[2].v;
//   transformer1.plug1.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = transformer1.plug1.pin[1].v;
//   star2.pin_n.i + (load.n.i + cDC2.n.i) = 0.0;
//   cDC2.n.v = load.n.v;
//   cDC2.n.v = star2.pin_n.v;
//   star1.pin_n.i + (load.p.i + cDC1.p.i) = 0.0;
//   cDC1.p.v = load.p.v;
//   cDC1.p.v = star1.pin_n.v;
//   source.plug_p.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = source.plug_p.pin[3].v;
//   source.plug_p.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = source.plug_p.pin[2].v;
//   source.plug_p.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = source.plug_p.pin[1].v;
//   starAC.pin_n.i + groundAC.p.i = 0.0;
//   groundAC.p.v = starAC.pin_n.v;
//   diode2.plug_p.pin[3].i + star2.plug_p.pin[3].i = 0.0;
//   diode2.plug_p.pin[3].v = star2.plug_p.pin[3].v;
//   diode2.plug_p.pin[2].i + star2.plug_p.pin[2].i = 0.0;
//   diode2.plug_p.pin[2].v = star2.plug_p.pin[2].v;
//   diode2.plug_p.pin[1].i + star2.plug_p.pin[1].i = 0.0;
//   diode2.plug_p.pin[1].v = star2.plug_p.pin[1].v;
//   diode1.plug_n.pin[3].i + star1.plug_p.pin[3].i = 0.0;
//   diode1.plug_n.pin[3].v = star1.plug_p.pin[3].v;
//   diode1.plug_n.pin[2].i + star1.plug_p.pin[2].i = 0.0;
//   diode1.plug_n.pin[2].v = star1.plug_p.pin[2].v;
//   diode1.plug_n.pin[1].i + star1.plug_p.pin[1].i = 0.0;
//   diode1.plug_n.pin[1].v = star1.plug_p.pin[1].v;
//   starAC.plug_p.pin[3].i + source.plug_n.pin[3].i = 0.0;
//   source.plug_n.pin[3].v = starAC.plug_p.pin[3].v;
//   starAC.plug_p.pin[2].i + source.plug_n.pin[2].i = 0.0;
//   source.plug_n.pin[2].v = starAC.plug_p.pin[2].v;
//   starAC.plug_p.pin[1].i + source.plug_n.pin[1].i = 0.0;
//   source.plug_n.pin[1].v = starAC.plug_p.pin[1].v;
//   cDC1.n.i + (cDC2.p.i + groundDC.p.i) = 0.0;
//   cDC1.n.v = cDC2.p.v;
//   cDC1.n.v = groundDC.p.v;
//   transformer1.r2.plug_n.pin[3].i + (-transformer1.plug2.pin[3].i) = 0.0;
//   transformer1.plug2.pin[3].v = transformer1.r2.plug_n.pin[3].v;
//   transformer1.r2.plug_n.pin[2].i + (-transformer1.plug2.pin[2].i) = 0.0;
//   transformer1.plug2.pin[2].v = transformer1.r2.plug_n.pin[2].v;
//   transformer1.r2.plug_n.pin[1].i + (-transformer1.plug2.pin[1].i) = 0.0;
//   transformer1.plug2.pin[1].v = transformer1.r2.plug_n.pin[1].v;
//   (-transformer1.plug1.pin[3].i) + (transformer1.Delta1.plug_p.pin[3].i + transformer1.r1.plug_p.pin[3].i) = 0.0;
//   transformer1.Delta1.plug_p.pin[3].v = transformer1.plug1.pin[3].v;
//   transformer1.Delta1.plug_p.pin[3].v = transformer1.r1.plug_p.pin[3].v;
//   (-transformer1.plug1.pin[2].i) + (transformer1.Delta1.plug_p.pin[2].i + transformer1.r1.plug_p.pin[2].i) = 0.0;
//   transformer1.Delta1.plug_p.pin[2].v = transformer1.plug1.pin[2].v;
//   transformer1.Delta1.plug_p.pin[2].v = transformer1.r1.plug_p.pin[2].v;
//   (-transformer1.plug1.pin[1].i) + (transformer1.Delta1.plug_p.pin[1].i + transformer1.r1.plug_p.pin[1].i) = 0.0;
//   transformer1.Delta1.plug_p.pin[1].v = transformer1.plug1.pin[1].v;
//   transformer1.Delta1.plug_p.pin[1].v = transformer1.r1.plug_p.pin[1].v;
//   transformer1.l2sigma.plug_n.pin[3].i + transformer1.r2.plug_p.pin[3].i = 0.0;
//   transformer1.l2sigma.plug_n.pin[3].v = transformer1.r2.plug_p.pin[3].v;
//   transformer1.l2sigma.plug_n.pin[2].i + transformer1.r2.plug_p.pin[2].i = 0.0;
//   transformer1.l2sigma.plug_n.pin[2].v = transformer1.r2.plug_p.pin[2].v;
//   transformer1.l2sigma.plug_n.pin[1].i + transformer1.r2.plug_p.pin[1].i = 0.0;
//   transformer1.l2sigma.plug_n.pin[1].v = transformer1.r2.plug_p.pin[1].v;
//   transformer1.r1.plug_n.pin[3].i + transformer1.l1sigma.plug_p.pin[3].i = 0.0;
//   transformer1.l1sigma.plug_p.pin[3].v = transformer1.r1.plug_n.pin[3].v;
//   transformer1.r1.plug_n.pin[2].i + transformer1.l1sigma.plug_p.pin[2].i = 0.0;
//   transformer1.l1sigma.plug_p.pin[2].v = transformer1.r1.plug_n.pin[2].v;
//   transformer1.r1.plug_n.pin[1].i + transformer1.l1sigma.plug_p.pin[1].i = 0.0;
//   transformer1.l1sigma.plug_p.pin[1].v = transformer1.r1.plug_n.pin[1].v;
//   transformer1.core.plug_p2.pin[3].i + transformer1.star2.plug_p.pin[3].i = 0.0;
//   transformer1.core.plug_p2.pin[3].v = transformer1.star2.plug_p.pin[3].v;
//   transformer1.core.plug_p2.pin[2].i + transformer1.star2.plug_p.pin[2].i = 0.0;
//   transformer1.core.plug_p2.pin[2].v = transformer1.star2.plug_p.pin[2].v;
//   transformer1.core.plug_p2.pin[1].i + transformer1.star2.plug_p.pin[1].i = 0.0;
//   transformer1.core.plug_p2.pin[1].v = transformer1.star2.plug_p.pin[1].v;
//   transformer1.core.plug_n3.pin[3].i + transformer1.Rot2.plug_n.pin[3].i = 0.0;
//   transformer1.Rot2.plug_n.pin[3].v = transformer1.core.plug_n3.pin[3].v;
//   transformer1.core.plug_n3.pin[2].i + transformer1.Rot2.plug_n.pin[2].i = 0.0;
//   transformer1.Rot2.plug_n.pin[2].v = transformer1.core.plug_n3.pin[2].v;
//   transformer1.core.plug_n3.pin[1].i + transformer1.Rot2.plug_n.pin[1].i = 0.0;
//   transformer1.Rot2.plug_n.pin[1].v = transformer1.core.plug_n3.pin[1].v;
//   transformer1.core.plug_n2.pin[3].i + transformer1.core.plug_p3.pin[3].i = 0.0;
//   transformer1.core.plug_n2.pin[3].v = transformer1.core.plug_p3.pin[3].v;
//   transformer1.core.plug_n2.pin[2].i + transformer1.core.plug_p3.pin[2].i = 0.0;
//   transformer1.core.plug_n2.pin[2].v = transformer1.core.plug_p3.pin[2].v;
//   transformer1.core.plug_n2.pin[1].i + transformer1.core.plug_p3.pin[1].i = 0.0;
//   transformer1.core.plug_n2.pin[1].v = transformer1.core.plug_p3.pin[1].v;
//   transformer1.l1sigma.plug_n.pin[3].i + transformer1.core.plug_p1.pin[3].i = 0.0;
//   transformer1.core.plug_p1.pin[3].v = transformer1.l1sigma.plug_n.pin[3].v;
//   transformer1.l1sigma.plug_n.pin[2].i + transformer1.core.plug_p1.pin[2].i = 0.0;
//   transformer1.core.plug_p1.pin[2].v = transformer1.l1sigma.plug_n.pin[2].v;
//   transformer1.l1sigma.plug_n.pin[1].i + transformer1.core.plug_p1.pin[1].i = 0.0;
//   transformer1.core.plug_p1.pin[1].v = transformer1.l1sigma.plug_n.pin[1].v;
//   transformer1.Delta1.plug_n.pin[3].i + transformer1.core.plug_n1.pin[3].i = 0.0;
//   transformer1.Delta1.plug_n.pin[3].v = transformer1.core.plug_n1.pin[3].v;
//   transformer1.Delta1.plug_n.pin[2].i + transformer1.core.plug_n1.pin[2].i = 0.0;
//   transformer1.Delta1.plug_n.pin[2].v = transformer1.core.plug_n1.pin[2].v;
//   transformer1.Delta1.plug_n.pin[1].i + transformer1.core.plug_n1.pin[1].i = 0.0;
//   transformer1.Delta1.plug_n.pin[1].v = transformer1.core.plug_n1.pin[1].v;
//   transformer1.l2sigma.plug_p.pin[3].i + transformer1.Rot2.plug_p.pin[3].i = 0.0;
//   transformer1.Rot2.plug_p.pin[3].v = transformer1.l2sigma.plug_p.pin[3].v;
//   transformer1.l2sigma.plug_p.pin[2].i + transformer1.Rot2.plug_p.pin[2].i = 0.0;
//   transformer1.Rot2.plug_p.pin[2].v = transformer1.l2sigma.plug_p.pin[2].v;
//   transformer1.l2sigma.plug_p.pin[1].i + transformer1.Rot2.plug_p.pin[1].i = 0.0;
//   transformer1.Rot2.plug_p.pin[1].v = transformer1.l2sigma.plug_p.pin[1].v;
//   transformer1.star2.pin_n.i + (-transformer1.starpoint2.i) = 0.0;
//   transformer1.star2.pin_n.v = transformer1.starpoint2.v;
//   (-transformer1.Rot2.plug_n.pin[3].i) + (-transformer1.Rot2.plug_p.pin[1].i) = 0.0;
//   transformer1.Rot2.plug_n.pin[3].v = transformer1.Rot2.plug_p.pin[1].v;
//   (-transformer1.Rot2.plug_n.pin[2].i) + (-transformer1.Rot2.plug_p.pin[3].i) = 0.0;
//   transformer1.Rot2.plug_n.pin[2].v = transformer1.Rot2.plug_p.pin[3].v;
//   (-transformer1.Rot2.plug_n.pin[1].i) + (-transformer1.Rot2.plug_p.pin[2].i) = 0.0;
//   transformer1.Rot2.plug_n.pin[1].v = transformer1.Rot2.plug_p.pin[2].v;
//   (-transformer1.Delta1.plug_n.pin[3].i) + (-transformer1.Delta1.plug_p.pin[1].i) = 0.0;
//   transformer1.Delta1.plug_n.pin[3].v = transformer1.Delta1.plug_p.pin[1].v;
//   (-transformer1.Delta1.plug_n.pin[2].i) + (-transformer1.Delta1.plug_p.pin[3].i) = 0.0;
//   transformer1.Delta1.plug_n.pin[2].v = transformer1.Delta1.plug_p.pin[3].v;
//   (-transformer1.Delta1.plug_n.pin[1].i) + (-transformer1.Delta1.plug_p.pin[2].i) = 0.0;
//   transformer1.Delta1.plug_n.pin[1].v = transformer1.Delta1.plug_p.pin[2].v;
//   transformer1.starpoint2.i = 0.0;
//   (-transformer1.star2.plug_p.pin[3].i) + ((-transformer1.star2.plug_p.pin[2].i) + ((-transformer1.star2.plug_p.pin[1].i) + (-transformer1.star2.pin_n.i))) = 0.0;
//   transformer1.star2.pin_n.v = transformer1.star2.plug_p.pin[1].v;
//   transformer1.star2.pin_n.v = transformer1.star2.plug_p.pin[2].v;
//   transformer1.star2.pin_n.v = transformer1.star2.plug_p.pin[3].v;
//   transformer1.l2sigma.inductor[3].n.i + (-transformer1.l2sigma.plug_n.pin[3].i) = 0.0;
//   transformer1.l2sigma.inductor[3].n.v = transformer1.l2sigma.plug_n.pin[3].v;
//   transformer1.l2sigma.inductor[2].n.i + (-transformer1.l2sigma.plug_n.pin[2].i) = 0.0;
//   transformer1.l2sigma.inductor[2].n.v = transformer1.l2sigma.plug_n.pin[2].v;
//   transformer1.l2sigma.inductor[1].n.i + (-transformer1.l2sigma.plug_n.pin[1].i) = 0.0;
//   transformer1.l2sigma.inductor[1].n.v = transformer1.l2sigma.plug_n.pin[1].v;
//   transformer1.l2sigma.inductor[3].p.i + (-transformer1.l2sigma.plug_p.pin[3].i) = 0.0;
//   transformer1.l2sigma.inductor[3].p.v = transformer1.l2sigma.plug_p.pin[3].v;
//   transformer1.l2sigma.inductor[2].p.i + (-transformer1.l2sigma.plug_p.pin[2].i) = 0.0;
//   transformer1.l2sigma.inductor[2].p.v = transformer1.l2sigma.plug_p.pin[2].v;
//   transformer1.l2sigma.inductor[1].p.i + (-transformer1.l2sigma.plug_p.pin[1].i) = 0.0;
//   transformer1.l2sigma.inductor[1].p.v = transformer1.l2sigma.plug_p.pin[1].v;
//   transformer1.r2.resistor[3].n.i + (-transformer1.r2.plug_n.pin[3].i) = 0.0;
//   transformer1.r2.plug_n.pin[3].v = transformer1.r2.resistor[3].n.v;
//   transformer1.r2.resistor[2].n.i + (-transformer1.r2.plug_n.pin[2].i) = 0.0;
//   transformer1.r2.plug_n.pin[2].v = transformer1.r2.resistor[2].n.v;
//   transformer1.r2.resistor[1].n.i + (-transformer1.r2.plug_n.pin[1].i) = 0.0;
//   transformer1.r2.plug_n.pin[1].v = transformer1.r2.resistor[1].n.v;
//   transformer1.r2.resistor[3].p.i + (-transformer1.r2.plug_p.pin[3].i) = 0.0;
//   transformer1.r2.plug_p.pin[3].v = transformer1.r2.resistor[3].p.v;
//   transformer1.r2.resistor[2].p.i + (-transformer1.r2.plug_p.pin[2].i) = 0.0;
//   transformer1.r2.plug_p.pin[2].v = transformer1.r2.resistor[2].p.v;
//   transformer1.r2.resistor[1].p.i + (-transformer1.r2.plug_p.pin[1].i) = 0.0;
//   transformer1.r2.plug_p.pin[1].v = transformer1.r2.resistor[1].p.v;
//   transformer1.l1sigma.inductor[3].n.i + (-transformer1.l1sigma.plug_n.pin[3].i) = 0.0;
//   transformer1.l1sigma.inductor[3].n.v = transformer1.l1sigma.plug_n.pin[3].v;
//   transformer1.l1sigma.inductor[2].n.i + (-transformer1.l1sigma.plug_n.pin[2].i) = 0.0;
//   transformer1.l1sigma.inductor[2].n.v = transformer1.l1sigma.plug_n.pin[2].v;
//   transformer1.l1sigma.inductor[1].n.i + (-transformer1.l1sigma.plug_n.pin[1].i) = 0.0;
//   transformer1.l1sigma.inductor[1].n.v = transformer1.l1sigma.plug_n.pin[1].v;
//   transformer1.l1sigma.inductor[3].p.i + (-transformer1.l1sigma.plug_p.pin[3].i) = 0.0;
//   transformer1.l1sigma.inductor[3].p.v = transformer1.l1sigma.plug_p.pin[3].v;
//   transformer1.l1sigma.inductor[2].p.i + (-transformer1.l1sigma.plug_p.pin[2].i) = 0.0;
//   transformer1.l1sigma.inductor[2].p.v = transformer1.l1sigma.plug_p.pin[2].v;
//   transformer1.l1sigma.inductor[1].p.i + (-transformer1.l1sigma.plug_p.pin[1].i) = 0.0;
//   transformer1.l1sigma.inductor[1].p.v = transformer1.l1sigma.plug_p.pin[1].v;
//   transformer1.r1.resistor[3].n.i + (-transformer1.r1.plug_n.pin[3].i) = 0.0;
//   transformer1.r1.plug_n.pin[3].v = transformer1.r1.resistor[3].n.v;
//   transformer1.r1.resistor[2].n.i + (-transformer1.r1.plug_n.pin[2].i) = 0.0;
//   transformer1.r1.plug_n.pin[2].v = transformer1.r1.resistor[2].n.v;
//   transformer1.r1.resistor[1].n.i + (-transformer1.r1.plug_n.pin[1].i) = 0.0;
//   transformer1.r1.plug_n.pin[1].v = transformer1.r1.resistor[1].n.v;
//   transformer1.r1.resistor[3].p.i + (-transformer1.r1.plug_p.pin[3].i) = 0.0;
//   transformer1.r1.plug_p.pin[3].v = transformer1.r1.resistor[3].p.v;
//   transformer1.r1.resistor[2].p.i + (-transformer1.r1.plug_p.pin[2].i) = 0.0;
//   transformer1.r1.plug_p.pin[2].v = transformer1.r1.resistor[2].p.v;
//   transformer1.r1.resistor[1].p.i + (-transformer1.r1.plug_p.pin[1].i) = 0.0;
//   transformer1.r1.plug_p.pin[1].v = transformer1.r1.resistor[1].p.v;
//   (-star2.plug_p.pin[3].i) + ((-star2.plug_p.pin[2].i) + ((-star2.plug_p.pin[1].i) + (-star2.pin_n.i))) = 0.0;
//   star2.pin_n.v = star2.plug_p.pin[1].v;
//   star2.pin_n.v = star2.plug_p.pin[2].v;
//   star2.pin_n.v = star2.plug_p.pin[3].v;
//   diode2.idealDiode[3].n.i + (-diode2.plug_n.pin[3].i) = 0.0;
//   diode2.idealDiode[3].n.v = diode2.plug_n.pin[3].v;
//   diode2.idealDiode[2].n.i + (-diode2.plug_n.pin[2].i) = 0.0;
//   diode2.idealDiode[2].n.v = diode2.plug_n.pin[2].v;
//   diode2.idealDiode[1].n.i + (-diode2.plug_n.pin[1].i) = 0.0;
//   diode2.idealDiode[1].n.v = diode2.plug_n.pin[1].v;
//   (-diode2.plug_p.pin[3].i) + diode2.idealDiode[3].p.i = 0.0;
//   diode2.idealDiode[3].p.v = diode2.plug_p.pin[3].v;
//   (-diode2.plug_p.pin[2].i) + diode2.idealDiode[2].p.i = 0.0;
//   diode2.idealDiode[2].p.v = diode2.plug_p.pin[2].v;
//   (-diode2.plug_p.pin[1].i) + diode2.idealDiode[1].p.i = 0.0;
//   diode2.idealDiode[1].p.v = diode2.plug_p.pin[1].v;
//   (-star1.plug_p.pin[3].i) + ((-star1.plug_p.pin[2].i) + ((-star1.plug_p.pin[1].i) + (-star1.pin_n.i))) = 0.0;
//   star1.pin_n.v = star1.plug_p.pin[1].v;
//   star1.pin_n.v = star1.plug_p.pin[2].v;
//   star1.pin_n.v = star1.plug_p.pin[3].v;
//   diode1.idealDiode[3].n.i + (-diode1.plug_n.pin[3].i) = 0.0;
//   diode1.idealDiode[3].n.v = diode1.plug_n.pin[3].v;
//   diode1.idealDiode[2].n.i + (-diode1.plug_n.pin[2].i) = 0.0;
//   diode1.idealDiode[2].n.v = diode1.plug_n.pin[2].v;
//   diode1.idealDiode[1].n.i + (-diode1.plug_n.pin[1].i) = 0.0;
//   diode1.idealDiode[1].n.v = diode1.plug_n.pin[1].v;
//   (-diode1.plug_p.pin[3].i) + diode1.idealDiode[3].p.i = 0.0;
//   diode1.idealDiode[3].p.v = diode1.plug_p.pin[3].v;
//   (-diode1.plug_p.pin[2].i) + diode1.idealDiode[2].p.i = 0.0;
//   diode1.idealDiode[2].p.v = diode1.plug_p.pin[2].v;
//   (-diode1.plug_p.pin[1].i) + diode1.idealDiode[1].p.i = 0.0;
//   diode1.idealDiode[1].p.v = diode1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.currentSensor[1].i = currentQuasiRMSSensor.i[1];
//   currentQuasiRMSSensor.currentSensor[2].i = currentQuasiRMSSensor.i[2];
//   currentQuasiRMSSensor.currentSensor[3].i = currentQuasiRMSSensor.i[3];
//   currentQuasiRMSSensor.currentSensor[3].n.i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.currentSensor[3].n.v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.currentSensor[2].n.i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.currentSensor[2].n.v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.currentSensor[1].n.i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.currentSensor[1].n.v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.currentSensor[3].p.v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.currentSensor[2].p.v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.currentSensor[1].p.v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   (-starAC.plug_p.pin[3].i) + ((-starAC.plug_p.pin[2].i) + ((-starAC.plug_p.pin[1].i) + (-starAC.pin_n.i))) = 0.0;
//   starAC.pin_n.v = starAC.plug_p.pin[1].v;
//   starAC.pin_n.v = starAC.plug_p.pin[2].v;
//   starAC.pin_n.v = starAC.plug_p.pin[3].v;
//   source.sineVoltage[3].n.i + (-source.plug_n.pin[3].i) = 0.0;
//   source.plug_n.pin[3].v = source.sineVoltage[3].n.v;
//   source.sineVoltage[2].n.i + (-source.plug_n.pin[2].i) = 0.0;
//   source.plug_n.pin[2].v = source.sineVoltage[2].n.v;
//   source.sineVoltage[1].n.i + (-source.plug_n.pin[1].i) = 0.0;
//   source.plug_n.pin[1].v = source.sineVoltage[1].n.v;
//   source.sineVoltage[3].p.i + (-source.plug_p.pin[3].i) = 0.0;
//   source.plug_p.pin[3].v = source.sineVoltage[3].p.v;
//   source.sineVoltage[2].p.i + (-source.plug_p.pin[2].i) = 0.0;
//   source.plug_p.pin[2].v = source.sineVoltage[2].p.v;
//   source.sineVoltage[1].p.i + (-source.plug_p.pin[1].i) = 0.0;
//   source.plug_p.pin[1].v = source.sineVoltage[1].p.v;
// end Modelica.Electrical.Machines.Examples.Rectifier6pulse;
// "
// 
// "Check of Modelica.Electrical.Machines.Examples.Rectifier6pulse completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.Rectifier6pulse has 491 equation(s) and 491 variable(s).
// 359 of these are trivial equation(s).
// "
// 
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Utilities.Strings.substring
//   input String string "String from which a substring is inquired";
//   input Integer startIndex(min = 1) "Character position of substring begin (index=1 is first character in string)";
//   input Integer endIndex(min = 1) "Character position of substring end";
//   output String result "String containing substring string[startIndex:endIndex]";
// 
// external "C";
// end Modelica.Utilities.Strings.substring;
// 
// class Modelica.Electrical.Machines.Examples.Rectifier12pulse
//   constant Integer m = 3 "Number of phases";
//   parameter Real V(quantity = "ElectricPotential", unit = "V") = 81.6496580927726 "Amplitude of star-voltage";
//   parameter Real f(quantity = "Frequency", unit = "Hz") = 50.0 "Frequency";
//   parameter Real RL(quantity = "Resistance", unit = "Ohm") = 0.2 "Load resistance";
//   parameter Real C(quantity = "Capacitance", unit = "F", min = 0.0) = 0.005 "Total DC-capacitance";
//   parameter Real VC0(quantity = "ElectricPotential", unit = "V") = 1.73205080756888 * V "Initial voltage of capacitance";
//   parameter Integer source.m(min = 1) = 3 "number of phases";
//   Real source.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real source.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real source.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real source.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer source.plug_p.m(min = 1) = source.m "number of phases";
//   Real source.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer source.plug_n.m(min = 1) = source.m "number of phases";
//   Real source.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.V[1](quantity = "ElectricPotential", unit = "V", start = 1.0) = V "Amplitudes of sine waves";
//   parameter Real source.V[2](quantity = "ElectricPotential", unit = "V", start = 1.0) = V "Amplitudes of sine waves";
//   parameter Real source.V[3](quantity = "ElectricPotential", unit = "V", start = 1.0) = V "Amplitudes of sine waves";
//   parameter Real source.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real source.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(source.m) "Phases of sine waves";
//   parameter Real source.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(source.m) "Phases of sine waves";
//   parameter Real source.freqHz[1](quantity = "Frequency", unit = "Hz", start = 1.0) = f "Frequencies of sine waves";
//   parameter Real source.freqHz[2](quantity = "Frequency", unit = "Hz", start = 1.0) = f "Frequencies of sine waves";
//   parameter Real source.freqHz[3](quantity = "Frequency", unit = "Hz", start = 1.0) = f "Frequencies of sine waves";
//   parameter Real source.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real source.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real source.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real source.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real source.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = source.offset[1] "Voltage offset";
//   parameter Real source.sineVoltage[1].startTime(quantity = "Time", unit = "s") = source.startTime[1] "Time offset";
//   output Real source.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[1].signalSource.amplitude = source.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[1].signalSource.offset = source.sineVoltage[1].offset "Offset of output signal";
//   parameter Real source.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[1] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[1] "Phase of sine wave";
//   parameter Real source.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[1] "Frequency of sine wave";
//   Real source.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = source.offset[2] "Voltage offset";
//   parameter Real source.sineVoltage[2].startTime(quantity = "Time", unit = "s") = source.startTime[2] "Time offset";
//   output Real source.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[2].signalSource.amplitude = source.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[2].signalSource.offset = source.sineVoltage[2].offset "Offset of output signal";
//   parameter Real source.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[2] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[2] "Phase of sine wave";
//   parameter Real source.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[2] "Frequency of sine wave";
//   Real source.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real source.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real source.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real source.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real source.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real source.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = source.offset[3] "Voltage offset";
//   parameter Real source.sineVoltage[3].startTime(quantity = "Time", unit = "s") = source.startTime[3] "Time offset";
//   output Real source.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real source.sineVoltage[3].signalSource.amplitude = source.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real source.sineVoltage[3].signalSource.offset = source.sineVoltage[3].offset "Offset of output signal";
//   parameter Real source.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = source.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real source.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real source.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V", start = 1.0) = source.V[3] "Amplitude of sine wave";
//   parameter Real source.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = source.phase[3] "Phase of sine wave";
//   parameter Real source.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = source.freqHz[3] "Frequency of sine wave";
//   parameter Integer starAC.m(min = 1) = 3 "number of phases";
//   parameter Integer starAC.plug_p.m(min = 1) = starAC.m "number of phases";
//   Real starAC.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starAC.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starAC.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real starAC.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real starAC.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real groundAC.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundAC.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.m(min = 1) = 3 "number of phases";
//   parameter Integer currentQuasiRMSSensor.plug_p.m(min = 1) = currentQuasiRMSSensor.m "number of phases";
//   Real currentQuasiRMSSensor.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer currentQuasiRMSSensor.plug_n.m(min = 1) = currentQuasiRMSSensor.m "number of phases";
//   Real currentQuasiRMSSensor.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.i[1] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.i[2] "current in the branch from p to n as output signal";
//   output Real currentQuasiRMSSensor.i[3] "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.currentSensor[1].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.currentSensor[2].i "current in the branch from p to n as output signal";
//   Real currentQuasiRMSSensor.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real currentQuasiRMSSensor.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real currentQuasiRMSSensor.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real currentQuasiRMSSensor.currentSensor[3].i "current in the branch from p to n as output signal";
//   parameter Integer diode1.m(min = 1) = 3 "number of phases";
//   Real diode1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer diode1.plug_p.m(min = 1) = diode1.m "number of phases";
//   Real diode1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode1.plug_n.m(min = 1) = diode1.m "number of phases";
//   Real diode1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode1.mh(min = 1) = diode1.m "Number of heatPorts=number of phases";
//   parameter Boolean diode1.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real diode1.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode1.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode1.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode1.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode1.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode1.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode1.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode1.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode1.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode1.Vknee[1](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode1.Vknee[2](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode1.Vknee[3](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   Real diode1.idealDiode[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode1.idealDiode[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode1.idealDiode[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.idealDiode[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode1.idealDiode[1].useHeatPort = diode1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode1.idealDiode[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode1.idealDiode[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode1.idealDiode[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode1.idealDiode[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode1.Ron[1] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode1.idealDiode[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode1.Goff[1] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode1.idealDiode[1].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode1.Vknee[1] "Forward threshold voltage";
//   Boolean diode1.idealDiode[1].off(start = true) "Switching state";
//   protected Real diode1.idealDiode[1].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode1.idealDiode[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode1.idealDiode[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode1.idealDiode[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode1.idealDiode[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode1.idealDiode[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.idealDiode[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode1.idealDiode[2].useHeatPort = diode1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode1.idealDiode[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode1.idealDiode[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode1.idealDiode[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode1.idealDiode[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode1.Ron[2] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode1.idealDiode[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode1.Goff[2] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode1.idealDiode[2].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode1.Vknee[2] "Forward threshold voltage";
//   Boolean diode1.idealDiode[2].off(start = true) "Switching state";
//   protected Real diode1.idealDiode[2].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode1.idealDiode[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode1.idealDiode[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode1.idealDiode[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode1.idealDiode[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode1.idealDiode[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode1.idealDiode[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode1.idealDiode[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode1.idealDiode[3].useHeatPort = diode1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode1.idealDiode[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode1.idealDiode[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode1.idealDiode[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode1.idealDiode[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode1.Ron[3] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode1.idealDiode[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode1.Goff[3] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode1.idealDiode[3].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode1.Vknee[3] "Forward threshold voltage";
//   Boolean diode1.idealDiode[3].off(start = true) "Switching state";
//   protected Real diode1.idealDiode[3].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode1.idealDiode[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode1.idealDiode[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer star1.m(min = 1) = 3 "number of phases";
//   parameter Integer star1.plug_p.m(min = 1) = star1.m "number of phases";
//   Real star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode2.m(min = 1) = 3 "number of phases";
//   Real diode2.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode2.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode2.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode2.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode2.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode2.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer diode2.plug_p.m(min = 1) = diode2.m "number of phases";
//   Real diode2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode2.plug_n.m(min = 1) = diode2.m "number of phases";
//   Real diode2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode2.mh(min = 1) = diode2.m "Number of heatPorts=number of phases";
//   parameter Boolean diode2.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real diode2.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode2.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode2.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode2.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode2.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode2.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode2.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode2.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode2.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode2.Vknee[1](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode2.Vknee[2](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode2.Vknee[3](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   Real diode2.idealDiode[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode2.idealDiode[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode2.idealDiode[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.idealDiode[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode2.idealDiode[1].useHeatPort = diode2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode2.idealDiode[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode2.idealDiode[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode2.idealDiode[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode2.idealDiode[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode2.Ron[1] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode2.idealDiode[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode2.Goff[1] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode2.idealDiode[1].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode2.Vknee[1] "Forward threshold voltage";
//   Boolean diode2.idealDiode[1].off(start = true) "Switching state";
//   protected Real diode2.idealDiode[1].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode2.idealDiode[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode2.idealDiode[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode2.idealDiode[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode2.idealDiode[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode2.idealDiode[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.idealDiode[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode2.idealDiode[2].useHeatPort = diode2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode2.idealDiode[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode2.idealDiode[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode2.idealDiode[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode2.idealDiode[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode2.Ron[2] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode2.idealDiode[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode2.Goff[2] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode2.idealDiode[2].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode2.Vknee[2] "Forward threshold voltage";
//   Boolean diode2.idealDiode[2].off(start = true) "Switching state";
//   protected Real diode2.idealDiode[2].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode2.idealDiode[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode2.idealDiode[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode2.idealDiode[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode2.idealDiode[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode2.idealDiode[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode2.idealDiode[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode2.idealDiode[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode2.idealDiode[3].useHeatPort = diode2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode2.idealDiode[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode2.idealDiode[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode2.idealDiode[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode2.idealDiode[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode2.Ron[3] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode2.idealDiode[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode2.Goff[3] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode2.idealDiode[3].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode2.Vknee[3] "Forward threshold voltage";
//   Boolean diode2.idealDiode[3].off(start = true) "Switching state";
//   protected Real diode2.idealDiode[3].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode2.idealDiode[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode2.idealDiode[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer star2.m(min = 1) = 3 "number of phases";
//   parameter Integer star2.plug_p.m(min = 1) = star2.m "number of phases";
//   Real star2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star2.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star2.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real load.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real load.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real load.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real load.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean load.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real load.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = load.T_ref "Fixed device temperature if useHeatPort = false";
//   Real load.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real load.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real load.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = RL "Resistance at temperature T_ref";
//   parameter Real load.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Reference temperature";
//   parameter Real load.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real load.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real cDC1.v(quantity = "ElectricPotential", unit = "V", start = VC0 / 2.0) "Voltage drop between the two pins (= p.v - n.v)";
//   Real cDC1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real cDC1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cDC1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real cDC1.C(quantity = "Capacitance", unit = "F", min = 0.0, start = 1.0) = 2.0 * C "Capacitance";
//   Real cDC2.v(quantity = "ElectricPotential", unit = "V", start = VC0 / 2.0) "Voltage drop between the two pins (= p.v - n.v)";
//   Real cDC2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real cDC2.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC2.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cDC2.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cDC2.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real cDC2.C(quantity = "Capacitance", unit = "F", min = 0.0, start = 1.0) = 2.0 * C "Capacitance";
//   Real groundDC.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real groundDC.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformerData1.f(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real transformerData1.V1(quantity = "ElectricPotential", unit = "V", start = 100.0) "primary nominal line-to-line voltage (RMS)";
//   parameter String transformerData1.C1(start = "Y") = "D" "choose primary connection";
//   parameter Real transformerData1.V2(quantity = "ElectricPotential", unit = "V", start = 100.0) "secondary open circuit line-to-line voltage (RMS) @ primary nominal voltage";
//   parameter String transformerData1.C2(start = "y") = "y" "choose secondary connection";
//   parameter Real transformerData1.SNominal(quantity = "Power", unit = "VA", start = 30000.0) "nominal apparent power";
//   parameter Real transformerData1.v_sc(min = 0.0, max = 1.0, start = 0.05) "impedance voltage drop pu";
//   parameter Real transformerData1.P_sc(quantity = "Power", unit = "W", start = 300.0) "short-circuit (copper) losses";
//   parameter Real transformerData1.n = transformerData1.V1 / transformerData1.V2 "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformerData1.V1ph(quantity = "ElectricPotential", unit = "V") = transformerData1.V1 / (if transformerData1.C1 == "D" then 1.0 else 1.73205080756888) "primary phase voltage (RMS)";
//   parameter Real transformerData1.I1ph(quantity = "ElectricCurrent", unit = "A") = transformerData1.SNominal * 1.0 / transformerData1.V1ph / 3.0 "primary phase current (RMS)";
//   parameter Real transformerData1.V2ph(quantity = "ElectricPotential", unit = "V") = transformerData1.V2 / (if transformerData1.C2 == "d" then 1.0 else 1.73205080756888) "secondary phase voltage (RMS)";
//   parameter Real transformerData1.I2ph(quantity = "ElectricCurrent", unit = "A") = transformerData1.SNominal * 1.0 / transformerData1.V2ph / 3.0 "secondary phase current (RMS)";
//   parameter Real transformerData1.Z1ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.v_sc * transformerData1.V1ph / transformerData1.I1ph) "primary impedance per phase";
//   parameter Real transformerData1.R1(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.P_sc * transformerData1.I1ph ^ -2.0 / 3.0) "warm primary resistance per phase";
//   parameter Real transformerData1.L1sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData1.Z1ph ^ 2.0 - transformerData1.R1 ^ 2.0) * 1.0 / transformerData1.f / 6.28318530717959 "primary stray inductance per phase";
//   parameter Real transformerData1.Z2ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.v_sc * transformerData1.V2ph / transformerData1.I2ph) "secondary impedance per phase";
//   parameter Real transformerData1.R2(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData1.P_sc * transformerData1.I2ph ^ -2.0 / 3.0) "warm secondary resistance per phase";
//   parameter Real transformerData1.L2sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData1.Z2ph ^ 2.0 - transformerData1.R2 ^ 2.0) * 1.0 / transformerData1.f / 6.28318530717959 "secondary stray inductance per phase";
//   constant Integer transformer1.m(min = 1) = 3 "Number of phases";
//   constant String transformer1.VectorGroup = "Dy01";
//   parameter Real transformer1.n(start = 1.0) = transformerData1.n "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformer1.R1(quantity = "Resistance", unit = "Ohm", start = 0.005) = transformerData1.R1 "warm primary resistance per phase";
//   parameter Real transformer1.L1sigma(quantity = "Inductance", unit = "H", start = 7.8e-05) = transformerData1.L1sigma "primary stray inductance per phase";
//   parameter Real transformer1.R2(quantity = "Resistance", unit = "Ohm", start = 0.00166666666666667) = transformerData1.R2 "warm secondary resistance per phase";
//   parameter Real transformer1.L2sigma(quantity = "Inductance", unit = "H", start = 2.6e-05) = transformerData1.L2sigma "secondary stray inductance per phase";
//   output Real transformer1.v1[1](quantity = "ElectricPotential", unit = "V") = transformer1.plug1.pin[1].v "Primary voltage";
//   output Real transformer1.v1[2](quantity = "ElectricPotential", unit = "V") = transformer1.plug1.pin[2].v "Primary voltage";
//   output Real transformer1.v1[3](quantity = "ElectricPotential", unit = "V") = transformer1.plug1.pin[3].v "Primary voltage";
//   output Real transformer1.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer1.plug1.pin[1].i "Primary current";
//   output Real transformer1.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer1.plug1.pin[2].i "Primary current";
//   output Real transformer1.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer1.plug1.pin[3].i "Primary current";
//   output Real transformer1.v2[1](quantity = "ElectricPotential", unit = "V") = transformer1.plug2.pin[1].v "Secondary voltage";
//   output Real transformer1.v2[2](quantity = "ElectricPotential", unit = "V") = transformer1.plug2.pin[2].v "Secondary voltage";
//   output Real transformer1.v2[3](quantity = "ElectricPotential", unit = "V") = transformer1.plug2.pin[3].v "Secondary voltage";
//   output Real transformer1.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer1.plug2.pin[1].i "Secondary current";
//   output Real transformer1.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer1.plug2.pin[2].i "Secondary current";
//   output Real transformer1.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer1.plug2.pin[3].i "Secondary current";
//   protected constant String transformer1.C1 = "D";
//   protected constant String transformer1.C2 = "y";
//   protected parameter Real transformer1.ni = 3.46410161513775 * transformer1.n;
//   parameter Integer transformer1.plug1.m(min = 1) = 3 "number of phases";
//   Real transformer1.plug1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.plug2.m(min = 1) = 3 "number of phases";
//   Real transformer1.plug2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.plug2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.plug2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r1.m(min = 1) = 3 "number of phases";
//   Real transformer1.r1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.r1.plug_p.m(min = 1) = transformer1.r1.m "number of phases";
//   Real transformer1.r1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r1.plug_n.m(min = 1) = transformer1.r1.m "number of phases";
//   Real transformer1.r1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r1.mh(min = 1) = transformer1.r1.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer1.r1.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer1.r1.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r1.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r1.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r1.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r1.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r1.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r1.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r1.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r1.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r1.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r1.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r1.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer1.r1.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r1.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r1.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r1.resistor[1].useHeatPort = transformer1.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r1.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r1.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r1.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r1.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r1.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer1.r1.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[1] "Reference temperature";
//   parameter Real transformer1.r1.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r1.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r1.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r1.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r1.resistor[2].useHeatPort = transformer1.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r1.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r1.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r1.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r1.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r1.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer1.r1.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[2] "Reference temperature";
//   parameter Real transformer1.r1.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r1.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r1.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r1.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r1.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r1.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r1.resistor[3].useHeatPort = transformer1.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r1.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r1.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r1.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r1.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r1.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer1.r1.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r1.T_ref[3] "Reference temperature";
//   parameter Real transformer1.r1.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r1.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r1.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer1.l1sigma.m(min = 1) = 3 "number of phases";
//   Real transformer1.l1sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l1sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l1sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l1sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l1sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l1sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.l1sigma.plug_p.m(min = 1) = transformer1.l1sigma.m "number of phases";
//   Real transformer1.l1sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.l1sigma.plug_n.m(min = 1) = transformer1.l1sigma.m "number of phases";
//   Real transformer1.l1sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L1sigma "Inductance";
//   parameter Real transformer1.l1sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L1sigma "Inductance";
//   parameter Real transformer1.l1sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L1sigma "Inductance";
//   Real transformer1.l1sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l1sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l1sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l1sigma.L[1] "Inductance";
//   Real transformer1.l1sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l1sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l1sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l1sigma.L[2] "Inductance";
//   Real transformer1.l1sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l1sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l1sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l1sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l1sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l1sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l1sigma.L[3] "Inductance";
//   parameter Integer transformer1.r2.m(min = 1) = 3 "number of phases";
//   Real transformer1.r2.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r2.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r2.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.r2.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r2.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.r2.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.r2.plug_p.m(min = 1) = transformer1.r2.m "number of phases";
//   Real transformer1.r2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r2.plug_n.m(min = 1) = transformer1.r2.m "number of phases";
//   Real transformer1.r2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.r2.mh(min = 1) = transformer1.r2.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer1.r2.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer1.r2.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r2.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r2.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer1.r2.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r2.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r2.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer1.r2.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r2.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r2.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer1.r2.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r2.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer1.r2.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer1.r2.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r2.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r2.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r2.resistor[1].useHeatPort = transformer1.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r2.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r2.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r2.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r2.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r2.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer1.r2.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[1] "Reference temperature";
//   parameter Real transformer1.r2.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r2.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r2.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r2.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r2.resistor[2].useHeatPort = transformer1.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r2.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r2.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r2.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r2.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r2.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer1.r2.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[2] "Reference temperature";
//   parameter Real transformer1.r2.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r2.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.r2.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.r2.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.r2.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.r2.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer1.r2.resistor[3].useHeatPort = transformer1.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer1.r2.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer1.r2.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer1.r2.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer1.r2.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer1.r2.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer1.r2.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer1.r2.T_ref[3] "Reference temperature";
//   parameter Real transformer1.r2.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer1.r2.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer1.r2.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer1.l2sigma.m(min = 1) = 3 "number of phases";
//   Real transformer1.l2sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l2sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l2sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer1.l2sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l2sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer1.l2sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer1.l2sigma.plug_p.m(min = 1) = transformer1.l2sigma.m "number of phases";
//   Real transformer1.l2sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.l2sigma.plug_n.m(min = 1) = transformer1.l2sigma.m "number of phases";
//   Real transformer1.l2sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L2sigma "Inductance";
//   parameter Real transformer1.l2sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L2sigma "Inductance";
//   parameter Real transformer1.l2sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer1.L2sigma "Inductance";
//   Real transformer1.l2sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l2sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l2sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l2sigma.L[1] "Inductance";
//   Real transformer1.l2sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l2sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l2sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l2sigma.L[2] "Inductance";
//   Real transformer1.l2sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer1.l2sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer1.l2sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.l2sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.l2sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer1.l2sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer1.l2sigma.L[3] "Inductance";
//   parameter Integer transformer1.core.m(min = 1) = 3 "number of phases";
//   parameter Real transformer1.core.n12(start = 1.0) = transformer1.ni "turns ratio 1:2";
//   parameter Real transformer1.core.n13(start = 1.0) = transformer1.ni "turns ratio 1:3";
//   Real transformer1.core.v1[1](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p1.pin[1].v - transformer1.core.plug_n1.pin[1].v;
//   Real transformer1.core.v1[2](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p1.pin[2].v - transformer1.core.plug_n1.pin[2].v;
//   Real transformer1.core.v1[3](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p1.pin[3].v - transformer1.core.plug_n1.pin[3].v;
//   Real transformer1.core.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p1.pin[1].i;
//   Real transformer1.core.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p1.pin[2].i;
//   Real transformer1.core.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p1.pin[3].i;
//   Real transformer1.core.v2[1](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p2.pin[1].v - transformer1.core.plug_n2.pin[1].v;
//   Real transformer1.core.v2[2](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p2.pin[2].v - transformer1.core.plug_n2.pin[2].v;
//   Real transformer1.core.v2[3](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p2.pin[3].v - transformer1.core.plug_n2.pin[3].v;
//   Real transformer1.core.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p2.pin[1].i;
//   Real transformer1.core.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p2.pin[2].i;
//   Real transformer1.core.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p2.pin[3].i;
//   Real transformer1.core.v3[1](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p3.pin[1].v - transformer1.core.plug_n3.pin[1].v;
//   Real transformer1.core.v3[2](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p3.pin[2].v - transformer1.core.plug_n3.pin[2].v;
//   Real transformer1.core.v3[3](quantity = "ElectricPotential", unit = "V") = transformer1.core.plug_p3.pin[3].v - transformer1.core.plug_n3.pin[3].v;
//   Real transformer1.core.i3[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p3.pin[1].i;
//   Real transformer1.core.i3[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p3.pin[2].i;
//   Real transformer1.core.i3[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.plug_p3.pin[3].i;
//   Real transformer1.core.im[1](quantity = "ElectricCurrent", unit = "A") = transformer1.core.i1[1] + (transformer1.core.i2[1] / transformer1.core.n12 + transformer1.core.i3[1] / transformer1.core.n13) "Magnetizing current";
//   Real transformer1.core.im[2](quantity = "ElectricCurrent", unit = "A") = transformer1.core.i1[2] + (transformer1.core.i2[2] / transformer1.core.n12 + transformer1.core.i3[2] / transformer1.core.n13) "Magnetizing current";
//   Real transformer1.core.im[3](quantity = "ElectricCurrent", unit = "A") = transformer1.core.i1[3] + (transformer1.core.i2[3] / transformer1.core.n12 + transformer1.core.i3[3] / transformer1.core.n13) "Magnetizing current";
//   parameter Integer transformer1.core.plug_p1.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_p1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_n1.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_p2.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_p2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_n2.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_p3.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_p3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_p3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_p3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.core.plug_n3.m(min = 1) = transformer1.core.m "number of phases";
//   Real transformer1.core.plug_n3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.core.plug_n3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.core.plug_n3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.star2.m(min = 1) = 3 "number of phases";
//   parameter Integer transformer1.star2.plug_p.m(min = 1) = transformer1.star2.m "number of phases";
//   Real transformer1.star2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.star2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.star2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.star2.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.star2.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.starpoint2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.starpoint2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Delta1.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer1.Delta1.plug_p.m(min = 1) = transformer1.Delta1.m "number of phases";
//   Real transformer1.Delta1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Delta1.plug_n.m(min = 1) = transformer1.Delta1.m "number of phases";
//   Real transformer1.Delta1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Delta1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Delta1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Rot2.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer1.Rot2.plug_p.m(min = 1) = transformer1.Rot2.m "number of phases";
//   Real transformer1.Rot2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer1.Rot2.plug_n.m(min = 1) = transformer1.Rot2.m "number of phases";
//   Real transformer1.Rot2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer1.Rot2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer1.Rot2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode3.m(min = 1) = 3 "number of phases";
//   Real diode3.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode3.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode3.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode3.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode3.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode3.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer diode3.plug_p.m(min = 1) = diode3.m "number of phases";
//   Real diode3.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode3.plug_n.m(min = 1) = diode3.m "number of phases";
//   Real diode3.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode3.mh(min = 1) = diode3.m "Number of heatPorts=number of phases";
//   parameter Boolean diode3.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real diode3.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode3.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode3.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode3.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode3.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode3.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode3.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode3.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode3.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode3.Vknee[1](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode3.Vknee[2](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode3.Vknee[3](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   Real diode3.idealDiode[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode3.idealDiode[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode3.idealDiode[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.idealDiode[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.idealDiode[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.idealDiode[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode3.idealDiode[1].useHeatPort = diode3.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode3.idealDiode[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode3.idealDiode[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode3.idealDiode[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode3.idealDiode[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode3.Ron[1] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode3.idealDiode[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode3.Goff[1] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode3.idealDiode[1].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode3.Vknee[1] "Forward threshold voltage";
//   Boolean diode3.idealDiode[1].off(start = true) "Switching state";
//   protected Real diode3.idealDiode[1].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode3.idealDiode[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode3.idealDiode[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode3.idealDiode[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode3.idealDiode[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode3.idealDiode[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.idealDiode[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.idealDiode[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.idealDiode[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode3.idealDiode[2].useHeatPort = diode3.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode3.idealDiode[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode3.idealDiode[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode3.idealDiode[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode3.idealDiode[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode3.Ron[2] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode3.idealDiode[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode3.Goff[2] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode3.idealDiode[2].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode3.Vknee[2] "Forward threshold voltage";
//   Boolean diode3.idealDiode[2].off(start = true) "Switching state";
//   protected Real diode3.idealDiode[2].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode3.idealDiode[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode3.idealDiode[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode3.idealDiode[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode3.idealDiode[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode3.idealDiode[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.idealDiode[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode3.idealDiode[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode3.idealDiode[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode3.idealDiode[3].useHeatPort = diode3.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode3.idealDiode[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode3.idealDiode[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode3.idealDiode[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode3.idealDiode[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode3.Ron[3] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode3.idealDiode[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode3.Goff[3] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode3.idealDiode[3].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode3.Vknee[3] "Forward threshold voltage";
//   Boolean diode3.idealDiode[3].off(start = true) "Switching state";
//   protected Real diode3.idealDiode[3].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode3.idealDiode[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode3.idealDiode[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer star3.m(min = 1) = 3 "number of phases";
//   parameter Integer star3.plug_p.m(min = 1) = star3.m "number of phases";
//   Real star3.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star3.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star3.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star3.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star3.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star3.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star3.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star3.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode4.m(min = 1) = 3 "number of phases";
//   Real diode4.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode4.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode4.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real diode4.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode4.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real diode4.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer diode4.plug_p.m(min = 1) = diode4.m "number of phases";
//   Real diode4.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode4.plug_n.m(min = 1) = diode4.m "number of phases";
//   Real diode4.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer diode4.mh(min = 1) = diode4.m "Number of heatPorts=number of phases";
//   parameter Boolean diode4.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real diode4.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode4.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode4.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperatures if useHeatPort = false";
//   parameter Real diode4.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode4.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode4.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0, start = 1e-05) "Closed diode resistance";
//   parameter Real diode4.Goff[1](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode4.Goff[2](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode4.Goff[3](quantity = "Conductance", unit = "S", min = 0.0, start = 1e-05) "Opened diode conductance";
//   parameter Real diode4.Vknee[1](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode4.Vknee[2](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   parameter Real diode4.Vknee[3](quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) "Treshold voltage";
//   Real diode4.idealDiode[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode4.idealDiode[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode4.idealDiode[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.idealDiode[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.idealDiode[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.idealDiode[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode4.idealDiode[1].useHeatPort = diode4.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode4.idealDiode[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode4.idealDiode[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode4.idealDiode[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode4.idealDiode[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode4.Ron[1] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode4.idealDiode[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode4.Goff[1] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode4.idealDiode[1].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode4.Vknee[1] "Forward threshold voltage";
//   Boolean diode4.idealDiode[1].off(start = true) "Switching state";
//   protected Real diode4.idealDiode[1].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode4.idealDiode[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode4.idealDiode[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode4.idealDiode[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode4.idealDiode[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode4.idealDiode[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.idealDiode[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.idealDiode[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.idealDiode[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode4.idealDiode[2].useHeatPort = diode4.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode4.idealDiode[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode4.idealDiode[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode4.idealDiode[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode4.idealDiode[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode4.Ron[2] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode4.idealDiode[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode4.Goff[2] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode4.idealDiode[2].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode4.Vknee[2] "Forward threshold voltage";
//   Boolean diode4.idealDiode[2].off(start = true) "Switching state";
//   protected Real diode4.idealDiode[2].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode4.idealDiode[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode4.idealDiode[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real diode4.idealDiode[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real diode4.idealDiode[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real diode4.idealDiode[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.idealDiode[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real diode4.idealDiode[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real diode4.idealDiode[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean diode4.idealDiode[3].useHeatPort = diode4.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real diode4.idealDiode[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real diode4.idealDiode[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real diode4.idealDiode[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real diode4.idealDiode[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = diode4.Ron[3] "Forward state-on differential resistance (closed diode resistance)";
//   parameter Real diode4.idealDiode[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = diode4.Goff[3] "Backward state-off conductance (opened diode conductance)";
//   parameter Real diode4.idealDiode[3].Vknee(quantity = "ElectricPotential", unit = "V", min = 0.0, start = 0.0) = diode4.Vknee[3] "Forward threshold voltage";
//   Boolean diode4.idealDiode[3].off(start = true) "Switching state";
//   protected Real diode4.idealDiode[3].s(unit = "1") "Auxiliary variable: if on then current, if opened then voltage";
//   protected constant Real diode4.idealDiode[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real diode4.idealDiode[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Integer star4.m(min = 1) = 3 "number of phases";
//   parameter Integer star4.plug_p.m(min = 1) = star4.m "number of phases";
//   Real star4.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star4.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star4.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star4.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star4.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star4.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real star4.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real star4.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer transformer2.m(min = 1) = 3 "Number of phases";
//   constant String transformer2.VectorGroup = "Dd00";
//   parameter Real transformer2.n(start = 1.0) = transformerData2.n "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformer2.R1(quantity = "Resistance", unit = "Ohm", start = 0.005) = transformerData2.R1 "warm primary resistance per phase";
//   parameter Real transformer2.L1sigma(quantity = "Inductance", unit = "H", start = 7.8e-05) = transformerData2.L1sigma "primary stray inductance per phase";
//   parameter Real transformer2.R2(quantity = "Resistance", unit = "Ohm", start = 0.005) = transformerData2.R2 "warm secondary resistance per phase";
//   parameter Real transformer2.L2sigma(quantity = "Inductance", unit = "H", start = 7.8e-05) = transformerData2.L2sigma "secondary stray inductance per phase";
//   output Real transformer2.v1[1](quantity = "ElectricPotential", unit = "V") = transformer2.plug1.pin[1].v "Primary voltage";
//   output Real transformer2.v1[2](quantity = "ElectricPotential", unit = "V") = transformer2.plug1.pin[2].v "Primary voltage";
//   output Real transformer2.v1[3](quantity = "ElectricPotential", unit = "V") = transformer2.plug1.pin[3].v "Primary voltage";
//   output Real transformer2.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer2.plug1.pin[1].i "Primary current";
//   output Real transformer2.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer2.plug1.pin[2].i "Primary current";
//   output Real transformer2.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer2.plug1.pin[3].i "Primary current";
//   output Real transformer2.v2[1](quantity = "ElectricPotential", unit = "V") = transformer2.plug2.pin[1].v "Secondary voltage";
//   output Real transformer2.v2[2](quantity = "ElectricPotential", unit = "V") = transformer2.plug2.pin[2].v "Secondary voltage";
//   output Real transformer2.v2[3](quantity = "ElectricPotential", unit = "V") = transformer2.plug2.pin[3].v "Secondary voltage";
//   output Real transformer2.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer2.plug2.pin[1].i "Secondary current";
//   output Real transformer2.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer2.plug2.pin[2].i "Secondary current";
//   output Real transformer2.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer2.plug2.pin[3].i "Secondary current";
//   protected constant String transformer2.C1 = "D";
//   protected constant String transformer2.C2 = "d";
//   protected parameter Real transformer2.ni = 2.0 * transformer2.n;
//   parameter Integer transformer2.plug1.m(min = 1) = 3 "number of phases";
//   Real transformer2.plug1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.plug1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.plug1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.plug1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.plug1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.plug1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.plug2.m(min = 1) = 3 "number of phases";
//   Real transformer2.plug2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.plug2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.plug2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.plug2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.plug2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.plug2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.r1.m(min = 1) = 3 "number of phases";
//   Real transformer2.r1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.r1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.r1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.r1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.r1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.r1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer2.r1.plug_p.m(min = 1) = transformer2.r1.m "number of phases";
//   Real transformer2.r1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.r1.plug_n.m(min = 1) = transformer2.r1.m "number of phases";
//   Real transformer2.r1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.r1.mh(min = 1) = transformer2.r1.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer2.r1.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer2.r1.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer2.r1.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer2.r1.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer2.r1.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer2.r1.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer2.r1.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.R1 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer2.r1.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer2.r1.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer2.r1.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer2.r1.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer2.r1.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer2.r1.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer2.r1.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.r1.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.r1.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer2.r1.resistor[1].useHeatPort = transformer2.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer2.r1.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer2.r1.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer2.r1.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer2.r1.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.r1.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer2.r1.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T_ref[1] "Reference temperature";
//   parameter Real transformer2.r1.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer2.r1.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r1.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r1.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.r1.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.r1.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer2.r1.resistor[2].useHeatPort = transformer2.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer2.r1.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer2.r1.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer2.r1.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer2.r1.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.r1.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer2.r1.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T_ref[2] "Reference temperature";
//   parameter Real transformer2.r1.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer2.r1.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r1.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r1.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.r1.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.r1.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r1.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r1.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer2.r1.resistor[3].useHeatPort = transformer2.r1.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer2.r1.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer2.r1.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer2.r1.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer2.r1.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.r1.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer2.r1.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r1.T_ref[3] "Reference temperature";
//   parameter Real transformer2.r1.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer2.r1.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r1.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer2.l1sigma.m(min = 1) = 3 "number of phases";
//   Real transformer2.l1sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.l1sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.l1sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.l1sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.l1sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.l1sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer2.l1sigma.plug_p.m(min = 1) = transformer2.l1sigma.m "number of phases";
//   Real transformer2.l1sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.l1sigma.plug_n.m(min = 1) = transformer2.l1sigma.m "number of phases";
//   Real transformer2.l1sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l1sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer2.L1sigma "Inductance";
//   parameter Real transformer2.l1sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer2.L1sigma "Inductance";
//   parameter Real transformer2.l1sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer2.L1sigma "Inductance";
//   Real transformer2.l1sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.l1sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.l1sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l1sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer2.l1sigma.L[1] "Inductance";
//   Real transformer2.l1sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.l1sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.l1sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l1sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer2.l1sigma.L[2] "Inductance";
//   Real transformer2.l1sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.l1sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.l1sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l1sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l1sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l1sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer2.l1sigma.L[3] "Inductance";
//   parameter Integer transformer2.r2.m(min = 1) = 3 "number of phases";
//   Real transformer2.r2.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.r2.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.r2.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.r2.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.r2.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.r2.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer2.r2.plug_p.m(min = 1) = transformer2.r2.m "number of phases";
//   Real transformer2.r2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.r2.plug_n.m(min = 1) = transformer2.r2.m "number of phases";
//   Real transformer2.r2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.r2.mh(min = 1) = transformer2.r2.m "Number of heatPorts=number of phases";
//   parameter Boolean transformer2.r2.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real transformer2.r2.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer2.r2.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer2.r2.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real transformer2.r2.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer2.r2.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer2.r2.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.R2 "Resistances R_ref at temperatures T_ref";
//   parameter Real transformer2.r2.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer2.r2.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer2.r2.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real transformer2.r2.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer2.r2.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real transformer2.r2.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real transformer2.r2.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.r2.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.r2.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer2.r2.resistor[1].useHeatPort = transformer2.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer2.r2.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T[1] "Fixed device temperature if useHeatPort = false";
//   Real transformer2.r2.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer2.r2.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer2.r2.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.r2.R[1] "Resistance at temperature T_ref";
//   parameter Real transformer2.r2.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T_ref[1] "Reference temperature";
//   parameter Real transformer2.r2.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer2.r2.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r2.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r2.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.r2.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.r2.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer2.r2.resistor[2].useHeatPort = transformer2.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer2.r2.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T[2] "Fixed device temperature if useHeatPort = false";
//   Real transformer2.r2.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer2.r2.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer2.r2.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.r2.R[2] "Resistance at temperature T_ref";
//   parameter Real transformer2.r2.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T_ref[2] "Reference temperature";
//   parameter Real transformer2.r2.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer2.r2.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r2.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r2.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.r2.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.r2.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.r2.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.r2.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean transformer2.r2.resistor[3].useHeatPort = transformer2.r2.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real transformer2.r2.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T[3] "Fixed device temperature if useHeatPort = false";
//   Real transformer2.r2.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real transformer2.r2.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real transformer2.r2.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = transformer2.r2.R[3] "Resistance at temperature T_ref";
//   parameter Real transformer2.r2.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = transformer2.r2.T_ref[3] "Reference temperature";
//   parameter Real transformer2.r2.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = transformer2.r2.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real transformer2.r2.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer transformer2.l2sigma.m(min = 1) = 3 "number of phases";
//   Real transformer2.l2sigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.l2sigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.l2sigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real transformer2.l2sigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.l2sigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real transformer2.l2sigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer transformer2.l2sigma.plug_p.m(min = 1) = transformer2.l2sigma.m "number of phases";
//   Real transformer2.l2sigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.l2sigma.plug_n.m(min = 1) = transformer2.l2sigma.m "number of phases";
//   Real transformer2.l2sigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l2sigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = transformer2.L2sigma "Inductance";
//   parameter Real transformer2.l2sigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = transformer2.L2sigma "Inductance";
//   parameter Real transformer2.l2sigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = transformer2.L2sigma "Inductance";
//   Real transformer2.l2sigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.l2sigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.l2sigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l2sigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer2.l2sigma.L[1] "Inductance";
//   Real transformer2.l2sigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.l2sigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.l2sigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l2sigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer2.l2sigma.L[2] "Inductance";
//   Real transformer2.l2sigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real transformer2.l2sigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real transformer2.l2sigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.l2sigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.l2sigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformer2.l2sigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = transformer2.l2sigma.L[3] "Inductance";
//   parameter Integer transformer2.core.m(min = 1) = 3 "number of phases";
//   parameter Real transformer2.core.n12(start = 1.0) = transformer2.ni "turns ratio 1:2";
//   parameter Real transformer2.core.n13(start = 1.0) = transformer2.ni "turns ratio 1:3";
//   Real transformer2.core.v1[1](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p1.pin[1].v - transformer2.core.plug_n1.pin[1].v;
//   Real transformer2.core.v1[2](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p1.pin[2].v - transformer2.core.plug_n1.pin[2].v;
//   Real transformer2.core.v1[3](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p1.pin[3].v - transformer2.core.plug_n1.pin[3].v;
//   Real transformer2.core.i1[1](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p1.pin[1].i;
//   Real transformer2.core.i1[2](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p1.pin[2].i;
//   Real transformer2.core.i1[3](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p1.pin[3].i;
//   Real transformer2.core.v2[1](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p2.pin[1].v - transformer2.core.plug_n2.pin[1].v;
//   Real transformer2.core.v2[2](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p2.pin[2].v - transformer2.core.plug_n2.pin[2].v;
//   Real transformer2.core.v2[3](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p2.pin[3].v - transformer2.core.plug_n2.pin[3].v;
//   Real transformer2.core.i2[1](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p2.pin[1].i;
//   Real transformer2.core.i2[2](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p2.pin[2].i;
//   Real transformer2.core.i2[3](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p2.pin[3].i;
//   Real transformer2.core.v3[1](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p3.pin[1].v - transformer2.core.plug_n3.pin[1].v;
//   Real transformer2.core.v3[2](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p3.pin[2].v - transformer2.core.plug_n3.pin[2].v;
//   Real transformer2.core.v3[3](quantity = "ElectricPotential", unit = "V") = transformer2.core.plug_p3.pin[3].v - transformer2.core.plug_n3.pin[3].v;
//   Real transformer2.core.i3[1](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p3.pin[1].i;
//   Real transformer2.core.i3[2](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p3.pin[2].i;
//   Real transformer2.core.i3[3](quantity = "ElectricCurrent", unit = "A") = transformer2.core.plug_p3.pin[3].i;
//   Real transformer2.core.im[1](quantity = "ElectricCurrent", unit = "A") = transformer2.core.i1[1] + (transformer2.core.i2[1] / transformer2.core.n12 + transformer2.core.i3[1] / transformer2.core.n13) "Magnetizing current";
//   Real transformer2.core.im[2](quantity = "ElectricCurrent", unit = "A") = transformer2.core.i1[2] + (transformer2.core.i2[2] / transformer2.core.n12 + transformer2.core.i3[2] / transformer2.core.n13) "Magnetizing current";
//   Real transformer2.core.im[3](quantity = "ElectricCurrent", unit = "A") = transformer2.core.i1[3] + (transformer2.core.i2[3] / transformer2.core.n12 + transformer2.core.i3[3] / transformer2.core.n13) "Magnetizing current";
//   parameter Integer transformer2.core.plug_p1.m(min = 1) = transformer2.core.m "number of phases";
//   Real transformer2.core.plug_p1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_p1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_p1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.core.plug_n1.m(min = 1) = transformer2.core.m "number of phases";
//   Real transformer2.core.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.core.plug_p2.m(min = 1) = transformer2.core.m "number of phases";
//   Real transformer2.core.plug_p2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_p2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_p2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.core.plug_n2.m(min = 1) = transformer2.core.m "number of phases";
//   Real transformer2.core.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.core.plug_p3.m(min = 1) = transformer2.core.m "number of phases";
//   Real transformer2.core.plug_p3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_p3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_p3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_p3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.core.plug_n3.m(min = 1) = transformer2.core.m "number of phases";
//   Real transformer2.core.plug_n3.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n3.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_n3.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n3.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.core.plug_n3.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.core.plug_n3.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.Delta1.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer2.Delta1.plug_p.m(min = 1) = transformer2.Delta1.m "number of phases";
//   Real transformer2.Delta1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.Delta1.plug_n.m(min = 1) = transformer2.Delta1.m "number of phases";
//   Real transformer2.Delta1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.Delta2.m(min = 2) = 3 "number of phases";
//   parameter Integer transformer2.Delta2.plug_p.m(min = 1) = transformer2.Delta2.m "number of phases";
//   Real transformer2.Delta2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer transformer2.Delta2.plug_n.m(min = 1) = transformer2.Delta2.m "number of phases";
//   Real transformer2.Delta2.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta2.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta2.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta2.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real transformer2.Delta2.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real transformer2.Delta2.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real transformerData2.f(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real transformerData2.V1(quantity = "ElectricPotential", unit = "V", start = 100.0) "primary nominal line-to-line voltage (RMS)";
//   parameter String transformerData2.C1(start = "Y") = "D" "choose primary connection";
//   parameter Real transformerData2.V2(quantity = "ElectricPotential", unit = "V", start = 100.0) "secondary open circuit line-to-line voltage (RMS) @ primary nominal voltage";
//   parameter String transformerData2.C2(start = "y") = "d" "choose secondary connection";
//   parameter Real transformerData2.SNominal(quantity = "Power", unit = "VA", start = 30000.0) "nominal apparent power";
//   parameter Real transformerData2.v_sc(min = 0.0, max = 1.0, start = 0.05) "impedance voltage drop pu";
//   parameter Real transformerData2.P_sc(quantity = "Power", unit = "W", start = 300.0) "short-circuit (copper) losses";
//   parameter Real transformerData2.n = transformerData2.V1 / transformerData2.V2 "primary voltage (line-to-line) / secondary voltage (line-to-line)";
//   parameter Real transformerData2.V1ph(quantity = "ElectricPotential", unit = "V") = transformerData2.V1 / (if transformerData2.C1 == "D" then 1.0 else 1.73205080756888) "primary phase voltage (RMS)";
//   parameter Real transformerData2.I1ph(quantity = "ElectricCurrent", unit = "A") = transformerData2.SNominal * 1.0 / transformerData2.V1ph / 3.0 "primary phase current (RMS)";
//   parameter Real transformerData2.V2ph(quantity = "ElectricPotential", unit = "V") = transformerData2.V2 / (if transformerData2.C2 == "d" then 1.0 else 1.73205080756888) "secondary phase voltage (RMS)";
//   parameter Real transformerData2.I2ph(quantity = "ElectricCurrent", unit = "A") = transformerData2.SNominal * 1.0 / transformerData2.V2ph / 3.0 "secondary phase current (RMS)";
//   parameter Real transformerData2.Z1ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData2.v_sc * transformerData2.V1ph / transformerData2.I1ph) "primary impedance per phase";
//   parameter Real transformerData2.R1(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData2.P_sc * transformerData2.I1ph ^ -2.0 / 3.0) "warm primary resistance per phase";
//   parameter Real transformerData2.L1sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData2.Z1ph ^ 2.0 - transformerData2.R1 ^ 2.0) * 1.0 / transformerData2.f / 6.28318530717959 "primary stray inductance per phase";
//   parameter Real transformerData2.Z2ph(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData2.v_sc * transformerData2.V2ph / transformerData2.I2ph) "secondary impedance per phase";
//   parameter Real transformerData2.R2(quantity = "Resistance", unit = "Ohm") = 0.5 * (transformerData2.P_sc * transformerData2.I2ph ^ -2.0 / 3.0) "warm secondary resistance per phase";
//   parameter Real transformerData2.L2sigma(quantity = "Inductance", unit = "H") = sqrt(transformerData2.Z2ph ^ 2.0 - transformerData2.R2 ^ 2.0) * 1.0 / transformerData2.f / 6.28318530717959 "secondary stray inductance per phase";
// equation
//   source.sineVoltage[1].signalSource.y = source.sineVoltage[1].signalSource.offset + (if time < source.sineVoltage[1].signalSource.startTime then 0.0 else source.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[1].signalSource.freqHz * (time - source.sineVoltage[1].signalSource.startTime)) + source.sineVoltage[1].signalSource.phase));
//   source.sineVoltage[1].v = source.sineVoltage[1].signalSource.y;
//   source.sineVoltage[1].v = source.sineVoltage[1].p.v - source.sineVoltage[1].n.v;
//   0.0 = source.sineVoltage[1].p.i + source.sineVoltage[1].n.i;
//   source.sineVoltage[1].i = source.sineVoltage[1].p.i;
//   source.sineVoltage[2].signalSource.y = source.sineVoltage[2].signalSource.offset + (if time < source.sineVoltage[2].signalSource.startTime then 0.0 else source.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[2].signalSource.freqHz * (time - source.sineVoltage[2].signalSource.startTime)) + source.sineVoltage[2].signalSource.phase));
//   source.sineVoltage[2].v = source.sineVoltage[2].signalSource.y;
//   source.sineVoltage[2].v = source.sineVoltage[2].p.v - source.sineVoltage[2].n.v;
//   0.0 = source.sineVoltage[2].p.i + source.sineVoltage[2].n.i;
//   source.sineVoltage[2].i = source.sineVoltage[2].p.i;
//   source.sineVoltage[3].signalSource.y = source.sineVoltage[3].signalSource.offset + (if time < source.sineVoltage[3].signalSource.startTime then 0.0 else source.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (source.sineVoltage[3].signalSource.freqHz * (time - source.sineVoltage[3].signalSource.startTime)) + source.sineVoltage[3].signalSource.phase));
//   source.sineVoltage[3].v = source.sineVoltage[3].signalSource.y;
//   source.sineVoltage[3].v = source.sineVoltage[3].p.v - source.sineVoltage[3].n.v;
//   0.0 = source.sineVoltage[3].p.i + source.sineVoltage[3].n.i;
//   source.sineVoltage[3].i = source.sineVoltage[3].p.i;
//   source.v[1] = source.plug_p.pin[1].v - source.plug_n.pin[1].v;
//   source.v[2] = source.plug_p.pin[2].v - source.plug_n.pin[2].v;
//   source.v[3] = source.plug_p.pin[3].v - source.plug_n.pin[3].v;
//   source.i[1] = source.plug_p.pin[1].i;
//   source.i[2] = source.plug_p.pin[2].i;
//   source.i[3] = source.plug_p.pin[3].i;
//   groundAC.p.v = 0.0;
//   currentQuasiRMSSensor.currentSensor[1].p.v = currentQuasiRMSSensor.currentSensor[1].n.v;
//   currentQuasiRMSSensor.currentSensor[1].p.i = currentQuasiRMSSensor.currentSensor[1].i;
//   currentQuasiRMSSensor.currentSensor[1].n.i = -currentQuasiRMSSensor.currentSensor[1].i;
//   currentQuasiRMSSensor.currentSensor[2].p.v = currentQuasiRMSSensor.currentSensor[2].n.v;
//   currentQuasiRMSSensor.currentSensor[2].p.i = currentQuasiRMSSensor.currentSensor[2].i;
//   currentQuasiRMSSensor.currentSensor[2].n.i = -currentQuasiRMSSensor.currentSensor[2].i;
//   currentQuasiRMSSensor.currentSensor[3].p.v = currentQuasiRMSSensor.currentSensor[3].n.v;
//   currentQuasiRMSSensor.currentSensor[3].p.i = currentQuasiRMSSensor.currentSensor[3].i;
//   currentQuasiRMSSensor.currentSensor[3].n.i = -currentQuasiRMSSensor.currentSensor[3].i;
//   diode1.idealDiode[1].off = diode1.idealDiode[1].s < 0.0;
//   diode1.idealDiode[1].v = diode1.idealDiode[1].s * (if diode1.idealDiode[1].off then 1.0 else diode1.idealDiode[1].Ron) + diode1.idealDiode[1].Vknee;
//   diode1.idealDiode[1].i = diode1.idealDiode[1].s * (if diode1.idealDiode[1].off then diode1.idealDiode[1].Goff else 1.0) + diode1.idealDiode[1].Goff * diode1.idealDiode[1].Vknee;
//   diode1.idealDiode[1].LossPower = diode1.idealDiode[1].v * diode1.idealDiode[1].i;
//   diode1.idealDiode[1].i = diode1.idealDiode[1].p.i;
//   0.0 = diode1.idealDiode[1].p.i + diode1.idealDiode[1].n.i;
//   diode1.idealDiode[1].v = diode1.idealDiode[1].p.v - diode1.idealDiode[1].n.v;
//   diode1.idealDiode[1].T_heatPort = diode1.idealDiode[1].T;
//   diode1.idealDiode[2].off = diode1.idealDiode[2].s < 0.0;
//   diode1.idealDiode[2].v = diode1.idealDiode[2].s * (if diode1.idealDiode[2].off then 1.0 else diode1.idealDiode[2].Ron) + diode1.idealDiode[2].Vknee;
//   diode1.idealDiode[2].i = diode1.idealDiode[2].s * (if diode1.idealDiode[2].off then diode1.idealDiode[2].Goff else 1.0) + diode1.idealDiode[2].Goff * diode1.idealDiode[2].Vknee;
//   diode1.idealDiode[2].LossPower = diode1.idealDiode[2].v * diode1.idealDiode[2].i;
//   diode1.idealDiode[2].i = diode1.idealDiode[2].p.i;
//   0.0 = diode1.idealDiode[2].p.i + diode1.idealDiode[2].n.i;
//   diode1.idealDiode[2].v = diode1.idealDiode[2].p.v - diode1.idealDiode[2].n.v;
//   diode1.idealDiode[2].T_heatPort = diode1.idealDiode[2].T;
//   diode1.idealDiode[3].off = diode1.idealDiode[3].s < 0.0;
//   diode1.idealDiode[3].v = diode1.idealDiode[3].s * (if diode1.idealDiode[3].off then 1.0 else diode1.idealDiode[3].Ron) + diode1.idealDiode[3].Vknee;
//   diode1.idealDiode[3].i = diode1.idealDiode[3].s * (if diode1.idealDiode[3].off then diode1.idealDiode[3].Goff else 1.0) + diode1.idealDiode[3].Goff * diode1.idealDiode[3].Vknee;
//   diode1.idealDiode[3].LossPower = diode1.idealDiode[3].v * diode1.idealDiode[3].i;
//   diode1.idealDiode[3].i = diode1.idealDiode[3].p.i;
//   0.0 = diode1.idealDiode[3].p.i + diode1.idealDiode[3].n.i;
//   diode1.idealDiode[3].v = diode1.idealDiode[3].p.v - diode1.idealDiode[3].n.v;
//   diode1.idealDiode[3].T_heatPort = diode1.idealDiode[3].T;
//   diode1.v[1] = diode1.plug_p.pin[1].v - diode1.plug_n.pin[1].v;
//   diode1.v[2] = diode1.plug_p.pin[2].v - diode1.plug_n.pin[2].v;
//   diode1.v[3] = diode1.plug_p.pin[3].v - diode1.plug_n.pin[3].v;
//   diode1.i[1] = diode1.plug_p.pin[1].i;
//   diode1.i[2] = diode1.plug_p.pin[2].i;
//   diode1.i[3] = diode1.plug_p.pin[3].i;
//   diode2.idealDiode[1].off = diode2.idealDiode[1].s < 0.0;
//   diode2.idealDiode[1].v = diode2.idealDiode[1].s * (if diode2.idealDiode[1].off then 1.0 else diode2.idealDiode[1].Ron) + diode2.idealDiode[1].Vknee;
//   diode2.idealDiode[1].i = diode2.idealDiode[1].s * (if diode2.idealDiode[1].off then diode2.idealDiode[1].Goff else 1.0) + diode2.idealDiode[1].Goff * diode2.idealDiode[1].Vknee;
//   diode2.idealDiode[1].LossPower = diode2.idealDiode[1].v * diode2.idealDiode[1].i;
//   diode2.idealDiode[1].i = diode2.idealDiode[1].p.i;
//   0.0 = diode2.idealDiode[1].p.i + diode2.idealDiode[1].n.i;
//   diode2.idealDiode[1].v = diode2.idealDiode[1].p.v - diode2.idealDiode[1].n.v;
//   diode2.idealDiode[1].T_heatPort = diode2.idealDiode[1].T;
//   diode2.idealDiode[2].off = diode2.idealDiode[2].s < 0.0;
//   diode2.idealDiode[2].v = diode2.idealDiode[2].s * (if diode2.idealDiode[2].off then 1.0 else diode2.idealDiode[2].Ron) + diode2.idealDiode[2].Vknee;
//   diode2.idealDiode[2].i = diode2.idealDiode[2].s * (if diode2.idealDiode[2].off then diode2.idealDiode[2].Goff else 1.0) + diode2.idealDiode[2].Goff * diode2.idealDiode[2].Vknee;
//   diode2.idealDiode[2].LossPower = diode2.idealDiode[2].v * diode2.idealDiode[2].i;
//   diode2.idealDiode[2].i = diode2.idealDiode[2].p.i;
//   0.0 = diode2.idealDiode[2].p.i + diode2.idealDiode[2].n.i;
//   diode2.idealDiode[2].v = diode2.idealDiode[2].p.v - diode2.idealDiode[2].n.v;
//   diode2.idealDiode[2].T_heatPort = diode2.idealDiode[2].T;
//   diode2.idealDiode[3].off = diode2.idealDiode[3].s < 0.0;
//   diode2.idealDiode[3].v = diode2.idealDiode[3].s * (if diode2.idealDiode[3].off then 1.0 else diode2.idealDiode[3].Ron) + diode2.idealDiode[3].Vknee;
//   diode2.idealDiode[3].i = diode2.idealDiode[3].s * (if diode2.idealDiode[3].off then diode2.idealDiode[3].Goff else 1.0) + diode2.idealDiode[3].Goff * diode2.idealDiode[3].Vknee;
//   diode2.idealDiode[3].LossPower = diode2.idealDiode[3].v * diode2.idealDiode[3].i;
//   diode2.idealDiode[3].i = diode2.idealDiode[3].p.i;
//   0.0 = diode2.idealDiode[3].p.i + diode2.idealDiode[3].n.i;
//   diode2.idealDiode[3].v = diode2.idealDiode[3].p.v - diode2.idealDiode[3].n.v;
//   diode2.idealDiode[3].T_heatPort = diode2.idealDiode[3].T;
//   diode2.v[1] = diode2.plug_p.pin[1].v - diode2.plug_n.pin[1].v;
//   diode2.v[2] = diode2.plug_p.pin[2].v - diode2.plug_n.pin[2].v;
//   diode2.v[3] = diode2.plug_p.pin[3].v - diode2.plug_n.pin[3].v;
//   diode2.i[1] = diode2.plug_p.pin[1].i;
//   diode2.i[2] = diode2.plug_p.pin[2].i;
//   diode2.i[3] = diode2.plug_p.pin[3].i;
//   assert(1.0 + load.alpha * (load.T_heatPort - load.T_ref) >= 1e-15,"Temperature outside scope of model!");
//   load.R_actual = load.R * (1.0 + load.alpha * (load.T_heatPort - load.T_ref));
//   load.v = load.R_actual * load.i;
//   load.LossPower = load.v * load.i;
//   load.i = load.p.i;
//   0.0 = load.p.i + load.n.i;
//   load.v = load.p.v - load.n.v;
//   load.T_heatPort = load.T;
//   cDC1.i = cDC1.C * der(cDC1.v);
//   cDC1.v = cDC1.p.v - cDC1.n.v;
//   0.0 = cDC1.p.i + cDC1.n.i;
//   cDC1.i = cDC1.p.i;
//   cDC2.i = cDC2.C * der(cDC2.v);
//   cDC2.v = cDC2.p.v - cDC2.n.v;
//   0.0 = cDC2.p.i + cDC2.n.i;
//   cDC2.i = cDC2.p.i;
//   groundDC.p.v = 0.0;
//   assert(1.0 + transformer1.r1.resistor[1].alpha * (transformer1.r1.resistor[1].T_heatPort - transformer1.r1.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r1.resistor[1].R_actual = transformer1.r1.resistor[1].R * (1.0 + transformer1.r1.resistor[1].alpha * (transformer1.r1.resistor[1].T_heatPort - transformer1.r1.resistor[1].T_ref));
//   transformer1.r1.resistor[1].v = transformer1.r1.resistor[1].R_actual * transformer1.r1.resistor[1].i;
//   transformer1.r1.resistor[1].LossPower = transformer1.r1.resistor[1].v * transformer1.r1.resistor[1].i;
//   transformer1.r1.resistor[1].i = transformer1.r1.resistor[1].p.i;
//   0.0 = transformer1.r1.resistor[1].p.i + transformer1.r1.resistor[1].n.i;
//   transformer1.r1.resistor[1].v = transformer1.r1.resistor[1].p.v - transformer1.r1.resistor[1].n.v;
//   transformer1.r1.resistor[1].T_heatPort = transformer1.r1.resistor[1].T;
//   assert(1.0 + transformer1.r1.resistor[2].alpha * (transformer1.r1.resistor[2].T_heatPort - transformer1.r1.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r1.resistor[2].R_actual = transformer1.r1.resistor[2].R * (1.0 + transformer1.r1.resistor[2].alpha * (transformer1.r1.resistor[2].T_heatPort - transformer1.r1.resistor[2].T_ref));
//   transformer1.r1.resistor[2].v = transformer1.r1.resistor[2].R_actual * transformer1.r1.resistor[2].i;
//   transformer1.r1.resistor[2].LossPower = transformer1.r1.resistor[2].v * transformer1.r1.resistor[2].i;
//   transformer1.r1.resistor[2].i = transformer1.r1.resistor[2].p.i;
//   0.0 = transformer1.r1.resistor[2].p.i + transformer1.r1.resistor[2].n.i;
//   transformer1.r1.resistor[2].v = transformer1.r1.resistor[2].p.v - transformer1.r1.resistor[2].n.v;
//   transformer1.r1.resistor[2].T_heatPort = transformer1.r1.resistor[2].T;
//   assert(1.0 + transformer1.r1.resistor[3].alpha * (transformer1.r1.resistor[3].T_heatPort - transformer1.r1.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r1.resistor[3].R_actual = transformer1.r1.resistor[3].R * (1.0 + transformer1.r1.resistor[3].alpha * (transformer1.r1.resistor[3].T_heatPort - transformer1.r1.resistor[3].T_ref));
//   transformer1.r1.resistor[3].v = transformer1.r1.resistor[3].R_actual * transformer1.r1.resistor[3].i;
//   transformer1.r1.resistor[3].LossPower = transformer1.r1.resistor[3].v * transformer1.r1.resistor[3].i;
//   transformer1.r1.resistor[3].i = transformer1.r1.resistor[3].p.i;
//   0.0 = transformer1.r1.resistor[3].p.i + transformer1.r1.resistor[3].n.i;
//   transformer1.r1.resistor[3].v = transformer1.r1.resistor[3].p.v - transformer1.r1.resistor[3].n.v;
//   transformer1.r1.resistor[3].T_heatPort = transformer1.r1.resistor[3].T;
//   transformer1.r1.v[1] = transformer1.r1.plug_p.pin[1].v - transformer1.r1.plug_n.pin[1].v;
//   transformer1.r1.v[2] = transformer1.r1.plug_p.pin[2].v - transformer1.r1.plug_n.pin[2].v;
//   transformer1.r1.v[3] = transformer1.r1.plug_p.pin[3].v - transformer1.r1.plug_n.pin[3].v;
//   transformer1.r1.i[1] = transformer1.r1.plug_p.pin[1].i;
//   transformer1.r1.i[2] = transformer1.r1.plug_p.pin[2].i;
//   transformer1.r1.i[3] = transformer1.r1.plug_p.pin[3].i;
//   transformer1.l1sigma.inductor[1].L * der(transformer1.l1sigma.inductor[1].i) = transformer1.l1sigma.inductor[1].v;
//   transformer1.l1sigma.inductor[1].v = transformer1.l1sigma.inductor[1].p.v - transformer1.l1sigma.inductor[1].n.v;
//   0.0 = transformer1.l1sigma.inductor[1].p.i + transformer1.l1sigma.inductor[1].n.i;
//   transformer1.l1sigma.inductor[1].i = transformer1.l1sigma.inductor[1].p.i;
//   transformer1.l1sigma.inductor[2].L * der(transformer1.l1sigma.inductor[2].i) = transformer1.l1sigma.inductor[2].v;
//   transformer1.l1sigma.inductor[2].v = transformer1.l1sigma.inductor[2].p.v - transformer1.l1sigma.inductor[2].n.v;
//   0.0 = transformer1.l1sigma.inductor[2].p.i + transformer1.l1sigma.inductor[2].n.i;
//   transformer1.l1sigma.inductor[2].i = transformer1.l1sigma.inductor[2].p.i;
//   transformer1.l1sigma.inductor[3].L * der(transformer1.l1sigma.inductor[3].i) = transformer1.l1sigma.inductor[3].v;
//   transformer1.l1sigma.inductor[3].v = transformer1.l1sigma.inductor[3].p.v - transformer1.l1sigma.inductor[3].n.v;
//   0.0 = transformer1.l1sigma.inductor[3].p.i + transformer1.l1sigma.inductor[3].n.i;
//   transformer1.l1sigma.inductor[3].i = transformer1.l1sigma.inductor[3].p.i;
//   transformer1.l1sigma.v[1] = transformer1.l1sigma.plug_p.pin[1].v - transformer1.l1sigma.plug_n.pin[1].v;
//   transformer1.l1sigma.v[2] = transformer1.l1sigma.plug_p.pin[2].v - transformer1.l1sigma.plug_n.pin[2].v;
//   transformer1.l1sigma.v[3] = transformer1.l1sigma.plug_p.pin[3].v - transformer1.l1sigma.plug_n.pin[3].v;
//   transformer1.l1sigma.i[1] = transformer1.l1sigma.plug_p.pin[1].i;
//   transformer1.l1sigma.i[2] = transformer1.l1sigma.plug_p.pin[2].i;
//   transformer1.l1sigma.i[3] = transformer1.l1sigma.plug_p.pin[3].i;
//   assert(1.0 + transformer1.r2.resistor[1].alpha * (transformer1.r2.resistor[1].T_heatPort - transformer1.r2.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r2.resistor[1].R_actual = transformer1.r2.resistor[1].R * (1.0 + transformer1.r2.resistor[1].alpha * (transformer1.r2.resistor[1].T_heatPort - transformer1.r2.resistor[1].T_ref));
//   transformer1.r2.resistor[1].v = transformer1.r2.resistor[1].R_actual * transformer1.r2.resistor[1].i;
//   transformer1.r2.resistor[1].LossPower = transformer1.r2.resistor[1].v * transformer1.r2.resistor[1].i;
//   transformer1.r2.resistor[1].i = transformer1.r2.resistor[1].p.i;
//   0.0 = transformer1.r2.resistor[1].p.i + transformer1.r2.resistor[1].n.i;
//   transformer1.r2.resistor[1].v = transformer1.r2.resistor[1].p.v - transformer1.r2.resistor[1].n.v;
//   transformer1.r2.resistor[1].T_heatPort = transformer1.r2.resistor[1].T;
//   assert(1.0 + transformer1.r2.resistor[2].alpha * (transformer1.r2.resistor[2].T_heatPort - transformer1.r2.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r2.resistor[2].R_actual = transformer1.r2.resistor[2].R * (1.0 + transformer1.r2.resistor[2].alpha * (transformer1.r2.resistor[2].T_heatPort - transformer1.r2.resistor[2].T_ref));
//   transformer1.r2.resistor[2].v = transformer1.r2.resistor[2].R_actual * transformer1.r2.resistor[2].i;
//   transformer1.r2.resistor[2].LossPower = transformer1.r2.resistor[2].v * transformer1.r2.resistor[2].i;
//   transformer1.r2.resistor[2].i = transformer1.r2.resistor[2].p.i;
//   0.0 = transformer1.r2.resistor[2].p.i + transformer1.r2.resistor[2].n.i;
//   transformer1.r2.resistor[2].v = transformer1.r2.resistor[2].p.v - transformer1.r2.resistor[2].n.v;
//   transformer1.r2.resistor[2].T_heatPort = transformer1.r2.resistor[2].T;
//   assert(1.0 + transformer1.r2.resistor[3].alpha * (transformer1.r2.resistor[3].T_heatPort - transformer1.r2.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer1.r2.resistor[3].R_actual = transformer1.r2.resistor[3].R * (1.0 + transformer1.r2.resistor[3].alpha * (transformer1.r2.resistor[3].T_heatPort - transformer1.r2.resistor[3].T_ref));
//   transformer1.r2.resistor[3].v = transformer1.r2.resistor[3].R_actual * transformer1.r2.resistor[3].i;
//   transformer1.r2.resistor[3].LossPower = transformer1.r2.resistor[3].v * transformer1.r2.resistor[3].i;
//   transformer1.r2.resistor[3].i = transformer1.r2.resistor[3].p.i;
//   0.0 = transformer1.r2.resistor[3].p.i + transformer1.r2.resistor[3].n.i;
//   transformer1.r2.resistor[3].v = transformer1.r2.resistor[3].p.v - transformer1.r2.resistor[3].n.v;
//   transformer1.r2.resistor[3].T_heatPort = transformer1.r2.resistor[3].T;
//   transformer1.r2.v[1] = transformer1.r2.plug_p.pin[1].v - transformer1.r2.plug_n.pin[1].v;
//   transformer1.r2.v[2] = transformer1.r2.plug_p.pin[2].v - transformer1.r2.plug_n.pin[2].v;
//   transformer1.r2.v[3] = transformer1.r2.plug_p.pin[3].v - transformer1.r2.plug_n.pin[3].v;
//   transformer1.r2.i[1] = transformer1.r2.plug_p.pin[1].i;
//   transformer1.r2.i[2] = transformer1.r2.plug_p.pin[2].i;
//   transformer1.r2.i[3] = transformer1.r2.plug_p.pin[3].i;
//   transformer1.l2sigma.inductor[1].L * der(transformer1.l2sigma.inductor[1].i) = transformer1.l2sigma.inductor[1].v;
//   transformer1.l2sigma.inductor[1].v = transformer1.l2sigma.inductor[1].p.v - transformer1.l2sigma.inductor[1].n.v;
//   0.0 = transformer1.l2sigma.inductor[1].p.i + transformer1.l2sigma.inductor[1].n.i;
//   transformer1.l2sigma.inductor[1].i = transformer1.l2sigma.inductor[1].p.i;
//   transformer1.l2sigma.inductor[2].L * der(transformer1.l2sigma.inductor[2].i) = transformer1.l2sigma.inductor[2].v;
//   transformer1.l2sigma.inductor[2].v = transformer1.l2sigma.inductor[2].p.v - transformer1.l2sigma.inductor[2].n.v;
//   0.0 = transformer1.l2sigma.inductor[2].p.i + transformer1.l2sigma.inductor[2].n.i;
//   transformer1.l2sigma.inductor[2].i = transformer1.l2sigma.inductor[2].p.i;
//   transformer1.l2sigma.inductor[3].L * der(transformer1.l2sigma.inductor[3].i) = transformer1.l2sigma.inductor[3].v;
//   transformer1.l2sigma.inductor[3].v = transformer1.l2sigma.inductor[3].p.v - transformer1.l2sigma.inductor[3].n.v;
//   0.0 = transformer1.l2sigma.inductor[3].p.i + transformer1.l2sigma.inductor[3].n.i;
//   transformer1.l2sigma.inductor[3].i = transformer1.l2sigma.inductor[3].p.i;
//   transformer1.l2sigma.v[1] = transformer1.l2sigma.plug_p.pin[1].v - transformer1.l2sigma.plug_n.pin[1].v;
//   transformer1.l2sigma.v[2] = transformer1.l2sigma.plug_p.pin[2].v - transformer1.l2sigma.plug_n.pin[2].v;
//   transformer1.l2sigma.v[3] = transformer1.l2sigma.plug_p.pin[3].v - transformer1.l2sigma.plug_n.pin[3].v;
//   transformer1.l2sigma.i[1] = transformer1.l2sigma.plug_p.pin[1].i;
//   transformer1.l2sigma.i[2] = transformer1.l2sigma.plug_p.pin[2].i;
//   transformer1.l2sigma.i[3] = transformer1.l2sigma.plug_p.pin[3].i;
//   transformer1.core.im[1] = 0.0;
//   transformer1.core.im[2] = 0.0;
//   transformer1.core.im[3] = 0.0;
//   transformer1.core.v1[1] = transformer1.core.n12 * transformer1.core.v2[1];
//   transformer1.core.v1[2] = transformer1.core.n12 * transformer1.core.v2[2];
//   transformer1.core.v1[3] = transformer1.core.n12 * transformer1.core.v2[3];
//   transformer1.core.v1[1] = transformer1.core.n13 * transformer1.core.v3[1];
//   transformer1.core.v1[2] = transformer1.core.n13 * transformer1.core.v3[2];
//   transformer1.core.v1[3] = transformer1.core.n13 * transformer1.core.v3[3];
//   transformer1.core.plug_p1.pin[1].i + transformer1.core.plug_n1.pin[1].i = 0.0;
//   transformer1.core.plug_p1.pin[2].i + transformer1.core.plug_n1.pin[2].i = 0.0;
//   transformer1.core.plug_p1.pin[3].i + transformer1.core.plug_n1.pin[3].i = 0.0;
//   transformer1.core.plug_p2.pin[1].i + transformer1.core.plug_n2.pin[1].i = 0.0;
//   transformer1.core.plug_p2.pin[2].i + transformer1.core.plug_n2.pin[2].i = 0.0;
//   transformer1.core.plug_p2.pin[3].i + transformer1.core.plug_n2.pin[3].i = 0.0;
//   transformer1.core.plug_p3.pin[1].i + transformer1.core.plug_n3.pin[1].i = 0.0;
//   transformer1.core.plug_p3.pin[2].i + transformer1.core.plug_n3.pin[2].i = 0.0;
//   transformer1.core.plug_p3.pin[3].i + transformer1.core.plug_n3.pin[3].i = 0.0;
//   assert(transformer1.l2sigma.plug_p.m == transformer1.Rot2.plug_p.m,"automatically generated from connect");
//   assert(transformer1.Delta1.plug_p.m == transformer1.r1.plug_p.m,"automatically generated from connect");
//   assert(transformer1.Delta1.plug_n.m == transformer1.core.plug_n1.m,"automatically generated from connect");
//   assert(transformer1.l1sigma.plug_n.m == transformer1.core.plug_p1.m,"automatically generated from connect");
//   assert(transformer1.core.plug_n2.m == transformer1.core.plug_p3.m,"automatically generated from connect");
//   assert(transformer1.core.plug_n3.m == transformer1.Rot2.plug_n.m,"automatically generated from connect");
//   assert(transformer1.core.plug_p2.m == transformer1.star2.plug_p.m,"automatically generated from connect");
//   assert(transformer1.r1.plug_n.m == transformer1.l1sigma.plug_p.m,"automatically generated from connect");
//   assert(transformer1.l2sigma.plug_n.m == transformer1.r2.plug_p.m,"automatically generated from connect");
//   assert(transformer1.plug1.m == transformer1.r1.plug_p.m,"automatically generated from connect");
//   assert(transformer1.r2.plug_n.m == transformer1.plug2.m,"automatically generated from connect");
//   diode3.idealDiode[1].off = diode3.idealDiode[1].s < 0.0;
//   diode3.idealDiode[1].v = diode3.idealDiode[1].s * (if diode3.idealDiode[1].off then 1.0 else diode3.idealDiode[1].Ron) + diode3.idealDiode[1].Vknee;
//   diode3.idealDiode[1].i = diode3.idealDiode[1].s * (if diode3.idealDiode[1].off then diode3.idealDiode[1].Goff else 1.0) + diode3.idealDiode[1].Goff * diode3.idealDiode[1].Vknee;
//   diode3.idealDiode[1].LossPower = diode3.idealDiode[1].v * diode3.idealDiode[1].i;
//   diode3.idealDiode[1].i = diode3.idealDiode[1].p.i;
//   0.0 = diode3.idealDiode[1].p.i + diode3.idealDiode[1].n.i;
//   diode3.idealDiode[1].v = diode3.idealDiode[1].p.v - diode3.idealDiode[1].n.v;
//   diode3.idealDiode[1].T_heatPort = diode3.idealDiode[1].T;
//   diode3.idealDiode[2].off = diode3.idealDiode[2].s < 0.0;
//   diode3.idealDiode[2].v = diode3.idealDiode[2].s * (if diode3.idealDiode[2].off then 1.0 else diode3.idealDiode[2].Ron) + diode3.idealDiode[2].Vknee;
//   diode3.idealDiode[2].i = diode3.idealDiode[2].s * (if diode3.idealDiode[2].off then diode3.idealDiode[2].Goff else 1.0) + diode3.idealDiode[2].Goff * diode3.idealDiode[2].Vknee;
//   diode3.idealDiode[2].LossPower = diode3.idealDiode[2].v * diode3.idealDiode[2].i;
//   diode3.idealDiode[2].i = diode3.idealDiode[2].p.i;
//   0.0 = diode3.idealDiode[2].p.i + diode3.idealDiode[2].n.i;
//   diode3.idealDiode[2].v = diode3.idealDiode[2].p.v - diode3.idealDiode[2].n.v;
//   diode3.idealDiode[2].T_heatPort = diode3.idealDiode[2].T;
//   diode3.idealDiode[3].off = diode3.idealDiode[3].s < 0.0;
//   diode3.idealDiode[3].v = diode3.idealDiode[3].s * (if diode3.idealDiode[3].off then 1.0 else diode3.idealDiode[3].Ron) + diode3.idealDiode[3].Vknee;
//   diode3.idealDiode[3].i = diode3.idealDiode[3].s * (if diode3.idealDiode[3].off then diode3.idealDiode[3].Goff else 1.0) + diode3.idealDiode[3].Goff * diode3.idealDiode[3].Vknee;
//   diode3.idealDiode[3].LossPower = diode3.idealDiode[3].v * diode3.idealDiode[3].i;
//   diode3.idealDiode[3].i = diode3.idealDiode[3].p.i;
//   0.0 = diode3.idealDiode[3].p.i + diode3.idealDiode[3].n.i;
//   diode3.idealDiode[3].v = diode3.idealDiode[3].p.v - diode3.idealDiode[3].n.v;
//   diode3.idealDiode[3].T_heatPort = diode3.idealDiode[3].T;
//   diode3.v[1] = diode3.plug_p.pin[1].v - diode3.plug_n.pin[1].v;
//   diode3.v[2] = diode3.plug_p.pin[2].v - diode3.plug_n.pin[2].v;
//   diode3.v[3] = diode3.plug_p.pin[3].v - diode3.plug_n.pin[3].v;
//   diode3.i[1] = diode3.plug_p.pin[1].i;
//   diode3.i[2] = diode3.plug_p.pin[2].i;
//   diode3.i[3] = diode3.plug_p.pin[3].i;
//   diode4.idealDiode[1].off = diode4.idealDiode[1].s < 0.0;
//   diode4.idealDiode[1].v = diode4.idealDiode[1].s * (if diode4.idealDiode[1].off then 1.0 else diode4.idealDiode[1].Ron) + diode4.idealDiode[1].Vknee;
//   diode4.idealDiode[1].i = diode4.idealDiode[1].s * (if diode4.idealDiode[1].off then diode4.idealDiode[1].Goff else 1.0) + diode4.idealDiode[1].Goff * diode4.idealDiode[1].Vknee;
//   diode4.idealDiode[1].LossPower = diode4.idealDiode[1].v * diode4.idealDiode[1].i;
//   diode4.idealDiode[1].i = diode4.idealDiode[1].p.i;
//   0.0 = diode4.idealDiode[1].p.i + diode4.idealDiode[1].n.i;
//   diode4.idealDiode[1].v = diode4.idealDiode[1].p.v - diode4.idealDiode[1].n.v;
//   diode4.idealDiode[1].T_heatPort = diode4.idealDiode[1].T;
//   diode4.idealDiode[2].off = diode4.idealDiode[2].s < 0.0;
//   diode4.idealDiode[2].v = diode4.idealDiode[2].s * (if diode4.idealDiode[2].off then 1.0 else diode4.idealDiode[2].Ron) + diode4.idealDiode[2].Vknee;
//   diode4.idealDiode[2].i = diode4.idealDiode[2].s * (if diode4.idealDiode[2].off then diode4.idealDiode[2].Goff else 1.0) + diode4.idealDiode[2].Goff * diode4.idealDiode[2].Vknee;
//   diode4.idealDiode[2].LossPower = diode4.idealDiode[2].v * diode4.idealDiode[2].i;
//   diode4.idealDiode[2].i = diode4.idealDiode[2].p.i;
//   0.0 = diode4.idealDiode[2].p.i + diode4.idealDiode[2].n.i;
//   diode4.idealDiode[2].v = diode4.idealDiode[2].p.v - diode4.idealDiode[2].n.v;
//   diode4.idealDiode[2].T_heatPort = diode4.idealDiode[2].T;
//   diode4.idealDiode[3].off = diode4.idealDiode[3].s < 0.0;
//   diode4.idealDiode[3].v = diode4.idealDiode[3].s * (if diode4.idealDiode[3].off then 1.0 else diode4.idealDiode[3].Ron) + diode4.idealDiode[3].Vknee;
//   diode4.idealDiode[3].i = diode4.idealDiode[3].s * (if diode4.idealDiode[3].off then diode4.idealDiode[3].Goff else 1.0) + diode4.idealDiode[3].Goff * diode4.idealDiode[3].Vknee;
//   diode4.idealDiode[3].LossPower = diode4.idealDiode[3].v * diode4.idealDiode[3].i;
//   diode4.idealDiode[3].i = diode4.idealDiode[3].p.i;
//   0.0 = diode4.idealDiode[3].p.i + diode4.idealDiode[3].n.i;
//   diode4.idealDiode[3].v = diode4.idealDiode[3].p.v - diode4.idealDiode[3].n.v;
//   diode4.idealDiode[3].T_heatPort = diode4.idealDiode[3].T;
//   diode4.v[1] = diode4.plug_p.pin[1].v - diode4.plug_n.pin[1].v;
//   diode4.v[2] = diode4.plug_p.pin[2].v - diode4.plug_n.pin[2].v;
//   diode4.v[3] = diode4.plug_p.pin[3].v - diode4.plug_n.pin[3].v;
//   diode4.i[1] = diode4.plug_p.pin[1].i;
//   diode4.i[2] = diode4.plug_p.pin[2].i;
//   diode4.i[3] = diode4.plug_p.pin[3].i;
//   assert(1.0 + transformer2.r1.resistor[1].alpha * (transformer2.r1.resistor[1].T_heatPort - transformer2.r1.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer2.r1.resistor[1].R_actual = transformer2.r1.resistor[1].R * (1.0 + transformer2.r1.resistor[1].alpha * (transformer2.r1.resistor[1].T_heatPort - transformer2.r1.resistor[1].T_ref));
//   transformer2.r1.resistor[1].v = transformer2.r1.resistor[1].R_actual * transformer2.r1.resistor[1].i;
//   transformer2.r1.resistor[1].LossPower = transformer2.r1.resistor[1].v * transformer2.r1.resistor[1].i;
//   transformer2.r1.resistor[1].i = transformer2.r1.resistor[1].p.i;
//   0.0 = transformer2.r1.resistor[1].p.i + transformer2.r1.resistor[1].n.i;
//   transformer2.r1.resistor[1].v = transformer2.r1.resistor[1].p.v - transformer2.r1.resistor[1].n.v;
//   transformer2.r1.resistor[1].T_heatPort = transformer2.r1.resistor[1].T;
//   assert(1.0 + transformer2.r1.resistor[2].alpha * (transformer2.r1.resistor[2].T_heatPort - transformer2.r1.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer2.r1.resistor[2].R_actual = transformer2.r1.resistor[2].R * (1.0 + transformer2.r1.resistor[2].alpha * (transformer2.r1.resistor[2].T_heatPort - transformer2.r1.resistor[2].T_ref));
//   transformer2.r1.resistor[2].v = transformer2.r1.resistor[2].R_actual * transformer2.r1.resistor[2].i;
//   transformer2.r1.resistor[2].LossPower = transformer2.r1.resistor[2].v * transformer2.r1.resistor[2].i;
//   transformer2.r1.resistor[2].i = transformer2.r1.resistor[2].p.i;
//   0.0 = transformer2.r1.resistor[2].p.i + transformer2.r1.resistor[2].n.i;
//   transformer2.r1.resistor[2].v = transformer2.r1.resistor[2].p.v - transformer2.r1.resistor[2].n.v;
//   transformer2.r1.resistor[2].T_heatPort = transformer2.r1.resistor[2].T;
//   assert(1.0 + transformer2.r1.resistor[3].alpha * (transformer2.r1.resistor[3].T_heatPort - transformer2.r1.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer2.r1.resistor[3].R_actual = transformer2.r1.resistor[3].R * (1.0 + transformer2.r1.resistor[3].alpha * (transformer2.r1.resistor[3].T_heatPort - transformer2.r1.resistor[3].T_ref));
//   transformer2.r1.resistor[3].v = transformer2.r1.resistor[3].R_actual * transformer2.r1.resistor[3].i;
//   transformer2.r1.resistor[3].LossPower = transformer2.r1.resistor[3].v * transformer2.r1.resistor[3].i;
//   transformer2.r1.resistor[3].i = transformer2.r1.resistor[3].p.i;
//   0.0 = transformer2.r1.resistor[3].p.i + transformer2.r1.resistor[3].n.i;
//   transformer2.r1.resistor[3].v = transformer2.r1.resistor[3].p.v - transformer2.r1.resistor[3].n.v;
//   transformer2.r1.resistor[3].T_heatPort = transformer2.r1.resistor[3].T;
//   transformer2.r1.v[1] = transformer2.r1.plug_p.pin[1].v - transformer2.r1.plug_n.pin[1].v;
//   transformer2.r1.v[2] = transformer2.r1.plug_p.pin[2].v - transformer2.r1.plug_n.pin[2].v;
//   transformer2.r1.v[3] = transformer2.r1.plug_p.pin[3].v - transformer2.r1.plug_n.pin[3].v;
//   transformer2.r1.i[1] = transformer2.r1.plug_p.pin[1].i;
//   transformer2.r1.i[2] = transformer2.r1.plug_p.pin[2].i;
//   transformer2.r1.i[3] = transformer2.r1.plug_p.pin[3].i;
//   transformer2.l1sigma.inductor[1].L * der(transformer2.l1sigma.inductor[1].i) = transformer2.l1sigma.inductor[1].v;
//   transformer2.l1sigma.inductor[1].v = transformer2.l1sigma.inductor[1].p.v - transformer2.l1sigma.inductor[1].n.v;
//   0.0 = transformer2.l1sigma.inductor[1].p.i + transformer2.l1sigma.inductor[1].n.i;
//   transformer2.l1sigma.inductor[1].i = transformer2.l1sigma.inductor[1].p.i;
//   transformer2.l1sigma.inductor[2].L * der(transformer2.l1sigma.inductor[2].i) = transformer2.l1sigma.inductor[2].v;
//   transformer2.l1sigma.inductor[2].v = transformer2.l1sigma.inductor[2].p.v - transformer2.l1sigma.inductor[2].n.v;
//   0.0 = transformer2.l1sigma.inductor[2].p.i + transformer2.l1sigma.inductor[2].n.i;
//   transformer2.l1sigma.inductor[2].i = transformer2.l1sigma.inductor[2].p.i;
//   transformer2.l1sigma.inductor[3].L * der(transformer2.l1sigma.inductor[3].i) = transformer2.l1sigma.inductor[3].v;
//   transformer2.l1sigma.inductor[3].v = transformer2.l1sigma.inductor[3].p.v - transformer2.l1sigma.inductor[3].n.v;
//   0.0 = transformer2.l1sigma.inductor[3].p.i + transformer2.l1sigma.inductor[3].n.i;
//   transformer2.l1sigma.inductor[3].i = transformer2.l1sigma.inductor[3].p.i;
//   transformer2.l1sigma.v[1] = transformer2.l1sigma.plug_p.pin[1].v - transformer2.l1sigma.plug_n.pin[1].v;
//   transformer2.l1sigma.v[2] = transformer2.l1sigma.plug_p.pin[2].v - transformer2.l1sigma.plug_n.pin[2].v;
//   transformer2.l1sigma.v[3] = transformer2.l1sigma.plug_p.pin[3].v - transformer2.l1sigma.plug_n.pin[3].v;
//   transformer2.l1sigma.i[1] = transformer2.l1sigma.plug_p.pin[1].i;
//   transformer2.l1sigma.i[2] = transformer2.l1sigma.plug_p.pin[2].i;
//   transformer2.l1sigma.i[3] = transformer2.l1sigma.plug_p.pin[3].i;
//   assert(1.0 + transformer2.r2.resistor[1].alpha * (transformer2.r2.resistor[1].T_heatPort - transformer2.r2.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer2.r2.resistor[1].R_actual = transformer2.r2.resistor[1].R * (1.0 + transformer2.r2.resistor[1].alpha * (transformer2.r2.resistor[1].T_heatPort - transformer2.r2.resistor[1].T_ref));
//   transformer2.r2.resistor[1].v = transformer2.r2.resistor[1].R_actual * transformer2.r2.resistor[1].i;
//   transformer2.r2.resistor[1].LossPower = transformer2.r2.resistor[1].v * transformer2.r2.resistor[1].i;
//   transformer2.r2.resistor[1].i = transformer2.r2.resistor[1].p.i;
//   0.0 = transformer2.r2.resistor[1].p.i + transformer2.r2.resistor[1].n.i;
//   transformer2.r2.resistor[1].v = transformer2.r2.resistor[1].p.v - transformer2.r2.resistor[1].n.v;
//   transformer2.r2.resistor[1].T_heatPort = transformer2.r2.resistor[1].T;
//   assert(1.0 + transformer2.r2.resistor[2].alpha * (transformer2.r2.resistor[2].T_heatPort - transformer2.r2.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer2.r2.resistor[2].R_actual = transformer2.r2.resistor[2].R * (1.0 + transformer2.r2.resistor[2].alpha * (transformer2.r2.resistor[2].T_heatPort - transformer2.r2.resistor[2].T_ref));
//   transformer2.r2.resistor[2].v = transformer2.r2.resistor[2].R_actual * transformer2.r2.resistor[2].i;
//   transformer2.r2.resistor[2].LossPower = transformer2.r2.resistor[2].v * transformer2.r2.resistor[2].i;
//   transformer2.r2.resistor[2].i = transformer2.r2.resistor[2].p.i;
//   0.0 = transformer2.r2.resistor[2].p.i + transformer2.r2.resistor[2].n.i;
//   transformer2.r2.resistor[2].v = transformer2.r2.resistor[2].p.v - transformer2.r2.resistor[2].n.v;
//   transformer2.r2.resistor[2].T_heatPort = transformer2.r2.resistor[2].T;
//   assert(1.0 + transformer2.r2.resistor[3].alpha * (transformer2.r2.resistor[3].T_heatPort - transformer2.r2.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   transformer2.r2.resistor[3].R_actual = transformer2.r2.resistor[3].R * (1.0 + transformer2.r2.resistor[3].alpha * (transformer2.r2.resistor[3].T_heatPort - transformer2.r2.resistor[3].T_ref));
//   transformer2.r2.resistor[3].v = transformer2.r2.resistor[3].R_actual * transformer2.r2.resistor[3].i;
//   transformer2.r2.resistor[3].LossPower = transformer2.r2.resistor[3].v * transformer2.r2.resistor[3].i;
//   transformer2.r2.resistor[3].i = transformer2.r2.resistor[3].p.i;
//   0.0 = transformer2.r2.resistor[3].p.i + transformer2.r2.resistor[3].n.i;
//   transformer2.r2.resistor[3].v = transformer2.r2.resistor[3].p.v - transformer2.r2.resistor[3].n.v;
//   transformer2.r2.resistor[3].T_heatPort = transformer2.r2.resistor[3].T;
//   transformer2.r2.v[1] = transformer2.r2.plug_p.pin[1].v - transformer2.r2.plug_n.pin[1].v;
//   transformer2.r2.v[2] = transformer2.r2.plug_p.pin[2].v - transformer2.r2.plug_n.pin[2].v;
//   transformer2.r2.v[3] = transformer2.r2.plug_p.pin[3].v - transformer2.r2.plug_n.pin[3].v;
//   transformer2.r2.i[1] = transformer2.r2.plug_p.pin[1].i;
//   transformer2.r2.i[2] = transformer2.r2.plug_p.pin[2].i;
//   transformer2.r2.i[3] = transformer2.r2.plug_p.pin[3].i;
//   transformer2.l2sigma.inductor[1].L * der(transformer2.l2sigma.inductor[1].i) = transformer2.l2sigma.inductor[1].v;
//   transformer2.l2sigma.inductor[1].v = transformer2.l2sigma.inductor[1].p.v - transformer2.l2sigma.inductor[1].n.v;
//   0.0 = transformer2.l2sigma.inductor[1].p.i + transformer2.l2sigma.inductor[1].n.i;
//   transformer2.l2sigma.inductor[1].i = transformer2.l2sigma.inductor[1].p.i;
//   transformer2.l2sigma.inductor[2].L * der(transformer2.l2sigma.inductor[2].i) = transformer2.l2sigma.inductor[2].v;
//   transformer2.l2sigma.inductor[2].v = transformer2.l2sigma.inductor[2].p.v - transformer2.l2sigma.inductor[2].n.v;
//   0.0 = transformer2.l2sigma.inductor[2].p.i + transformer2.l2sigma.inductor[2].n.i;
//   transformer2.l2sigma.inductor[2].i = transformer2.l2sigma.inductor[2].p.i;
//   transformer2.l2sigma.inductor[3].L * der(transformer2.l2sigma.inductor[3].i) = transformer2.l2sigma.inductor[3].v;
//   transformer2.l2sigma.inductor[3].v = transformer2.l2sigma.inductor[3].p.v - transformer2.l2sigma.inductor[3].n.v;
//   0.0 = transformer2.l2sigma.inductor[3].p.i + transformer2.l2sigma.inductor[3].n.i;
//   transformer2.l2sigma.inductor[3].i = transformer2.l2sigma.inductor[3].p.i;
//   transformer2.l2sigma.v[1] = transformer2.l2sigma.plug_p.pin[1].v - transformer2.l2sigma.plug_n.pin[1].v;
//   transformer2.l2sigma.v[2] = transformer2.l2sigma.plug_p.pin[2].v - transformer2.l2sigma.plug_n.pin[2].v;
//   transformer2.l2sigma.v[3] = transformer2.l2sigma.plug_p.pin[3].v - transformer2.l2sigma.plug_n.pin[3].v;
//   transformer2.l2sigma.i[1] = transformer2.l2sigma.plug_p.pin[1].i;
//   transformer2.l2sigma.i[2] = transformer2.l2sigma.plug_p.pin[2].i;
//   transformer2.l2sigma.i[3] = transformer2.l2sigma.plug_p.pin[3].i;
//   transformer2.core.im[1] = 0.0;
//   transformer2.core.im[2] = 0.0;
//   transformer2.core.im[3] = 0.0;
//   transformer2.core.v1[1] = transformer2.core.n12 * transformer2.core.v2[1];
//   transformer2.core.v1[2] = transformer2.core.n12 * transformer2.core.v2[2];
//   transformer2.core.v1[3] = transformer2.core.n12 * transformer2.core.v2[3];
//   transformer2.core.v1[1] = transformer2.core.n13 * transformer2.core.v3[1];
//   transformer2.core.v1[2] = transformer2.core.n13 * transformer2.core.v3[2];
//   transformer2.core.v1[3] = transformer2.core.n13 * transformer2.core.v3[3];
//   transformer2.core.plug_p1.pin[1].i + transformer2.core.plug_n1.pin[1].i = 0.0;
//   transformer2.core.plug_p1.pin[2].i + transformer2.core.plug_n1.pin[2].i = 0.0;
//   transformer2.core.plug_p1.pin[3].i + transformer2.core.plug_n1.pin[3].i = 0.0;
//   transformer2.core.plug_p2.pin[1].i + transformer2.core.plug_n2.pin[1].i = 0.0;
//   transformer2.core.plug_p2.pin[2].i + transformer2.core.plug_n2.pin[2].i = 0.0;
//   transformer2.core.plug_p2.pin[3].i + transformer2.core.plug_n2.pin[3].i = 0.0;
//   transformer2.core.plug_p3.pin[1].i + transformer2.core.plug_n3.pin[1].i = 0.0;
//   transformer2.core.plug_p3.pin[2].i + transformer2.core.plug_n3.pin[2].i = 0.0;
//   transformer2.core.plug_p3.pin[3].i + transformer2.core.plug_n3.pin[3].i = 0.0;
//   assert(transformer2.r1.plug_p.m == transformer2.Delta1.plug_p.m,"automatically generated from connect");
//   assert(transformer2.Delta2.plug_p.m == transformer2.r2.plug_n.m,"automatically generated from connect");
//   assert(transformer2.l1sigma.plug_n.m == transformer2.core.plug_p1.m,"automatically generated from connect");
//   assert(transformer2.Delta1.plug_n.m == transformer2.core.plug_n1.m,"automatically generated from connect");
//   assert(transformer2.core.plug_n2.m == transformer2.core.plug_p3.m,"automatically generated from connect");
//   assert(transformer2.core.plug_p2.m == transformer2.l2sigma.plug_p.m,"automatically generated from connect");
//   assert(transformer2.core.plug_n3.m == transformer2.Delta2.plug_n.m,"automatically generated from connect");
//   assert(transformer2.r1.plug_n.m == transformer2.l1sigma.plug_p.m,"automatically generated from connect");
//   assert(transformer2.l2sigma.plug_n.m == transformer2.r2.plug_p.m,"automatically generated from connect");
//   assert(transformer2.plug1.m == transformer2.r1.plug_p.m,"automatically generated from connect");
//   assert(transformer2.r2.plug_n.m == transformer2.plug2.m,"automatically generated from connect");
//   assert(diode3.plug_n.m == star3.plug_p.m,"automatically generated from connect");
//   assert(diode4.plug_p.m == star4.plug_p.m,"automatically generated from connect");
//   assert(diode4.plug_n.m == diode3.plug_p.m,"automatically generated from connect");
//   assert(transformer2.plug2.m == diode4.plug_n.m,"automatically generated from connect");
//   assert(transformer2.plug1.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(starAC.plug_p.m == source.plug_n.m,"automatically generated from connect");
//   assert(diode1.plug_n.m == star1.plug_p.m,"automatically generated from connect");
//   assert(diode2.plug_p.m == star2.plug_p.m,"automatically generated from connect");
//   assert(diode2.plug_n.m == diode1.plug_p.m,"automatically generated from connect");
//   assert(source.plug_p.m == currentQuasiRMSSensor.plug_p.m,"automatically generated from connect");
//   assert(transformer1.plug1.m == currentQuasiRMSSensor.plug_n.m,"automatically generated from connect");
//   assert(transformer1.plug2.m == diode1.plug_p.m,"automatically generated from connect");
//   transformer1.plug2.pin[3].i + (diode2.plug_n.pin[3].i + diode1.plug_p.pin[3].i) = 0.0;
//   diode1.plug_p.pin[3].v = diode2.plug_n.pin[3].v;
//   diode1.plug_p.pin[3].v = transformer1.plug2.pin[3].v;
//   transformer1.plug2.pin[2].i + (diode2.plug_n.pin[2].i + diode1.plug_p.pin[2].i) = 0.0;
//   diode1.plug_p.pin[2].v = diode2.plug_n.pin[2].v;
//   diode1.plug_p.pin[2].v = transformer1.plug2.pin[2].v;
//   transformer1.plug2.pin[1].i + (diode2.plug_n.pin[1].i + diode1.plug_p.pin[1].i) = 0.0;
//   diode1.plug_p.pin[1].v = diode2.plug_n.pin[1].v;
//   diode1.plug_p.pin[1].v = transformer1.plug2.pin[1].v;
//   transformer1.plug1.pin[3].i + (transformer2.plug1.pin[3].i + currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[3].v = transformer1.plug1.pin[3].v;
//   currentQuasiRMSSensor.plug_n.pin[3].v = transformer2.plug1.pin[3].v;
//   transformer1.plug1.pin[2].i + (transformer2.plug1.pin[2].i + currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[2].v = transformer1.plug1.pin[2].v;
//   currentQuasiRMSSensor.plug_n.pin[2].v = transformer2.plug1.pin[2].v;
//   transformer1.plug1.pin[1].i + (transformer2.plug1.pin[1].i + currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.plug_n.pin[1].v = transformer1.plug1.pin[1].v;
//   currentQuasiRMSSensor.plug_n.pin[1].v = transformer2.plug1.pin[1].v;
//   star2.pin_n.i + (load.n.i + (star4.pin_n.i + cDC2.n.i)) = 0.0;
//   cDC2.n.v = load.n.v;
//   cDC2.n.v = star2.pin_n.v;
//   cDC2.n.v = star4.pin_n.v;
//   star1.pin_n.i + (load.p.i + (star3.pin_n.i + cDC1.p.i)) = 0.0;
//   cDC1.p.v = load.p.v;
//   cDC1.p.v = star1.pin_n.v;
//   cDC1.p.v = star3.pin_n.v;
//   source.plug_p.pin[3].i + currentQuasiRMSSensor.plug_p.pin[3].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[3].v = source.plug_p.pin[3].v;
//   source.plug_p.pin[2].i + currentQuasiRMSSensor.plug_p.pin[2].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[2].v = source.plug_p.pin[2].v;
//   source.plug_p.pin[1].i + currentQuasiRMSSensor.plug_p.pin[1].i = 0.0;
//   currentQuasiRMSSensor.plug_p.pin[1].v = source.plug_p.pin[1].v;
//   starAC.pin_n.i + groundAC.p.i = 0.0;
//   groundAC.p.v = starAC.pin_n.v;
//   diode2.plug_p.pin[3].i + star2.plug_p.pin[3].i = 0.0;
//   diode2.plug_p.pin[3].v = star2.plug_p.pin[3].v;
//   diode2.plug_p.pin[2].i + star2.plug_p.pin[2].i = 0.0;
//   diode2.plug_p.pin[2].v = star2.plug_p.pin[2].v;
//   diode2.plug_p.pin[1].i + star2.plug_p.pin[1].i = 0.0;
//   diode2.plug_p.pin[1].v = star2.plug_p.pin[1].v;
//   diode1.plug_n.pin[3].i + star1.plug_p.pin[3].i = 0.0;
//   diode1.plug_n.pin[3].v = star1.plug_p.pin[3].v;
//   diode1.plug_n.pin[2].i + star1.plug_p.pin[2].i = 0.0;
//   diode1.plug_n.pin[2].v = star1.plug_p.pin[2].v;
//   diode1.plug_n.pin[1].i + star1.plug_p.pin[1].i = 0.0;
//   diode1.plug_n.pin[1].v = star1.plug_p.pin[1].v;
//   starAC.plug_p.pin[3].i + source.plug_n.pin[3].i = 0.0;
//   source.plug_n.pin[3].v = starAC.plug_p.pin[3].v;
//   starAC.plug_p.pin[2].i + source.plug_n.pin[2].i = 0.0;
//   source.plug_n.pin[2].v = starAC.plug_p.pin[2].v;
//   starAC.plug_p.pin[1].i + source.plug_n.pin[1].i = 0.0;
//   source.plug_n.pin[1].v = starAC.plug_p.pin[1].v;
//   cDC1.n.i + (cDC2.p.i + groundDC.p.i) = 0.0;
//   cDC1.n.v = cDC2.p.v;
//   cDC1.n.v = groundDC.p.v;
//   transformer2.plug2.pin[3].i + (diode4.plug_n.pin[3].i + diode3.plug_p.pin[3].i) = 0.0;
//   diode3.plug_p.pin[3].v = diode4.plug_n.pin[3].v;
//   diode3.plug_p.pin[3].v = transformer2.plug2.pin[3].v;
//   transformer2.plug2.pin[2].i + (diode4.plug_n.pin[2].i + diode3.plug_p.pin[2].i) = 0.0;
//   diode3.plug_p.pin[2].v = diode4.plug_n.pin[2].v;
//   diode3.plug_p.pin[2].v = transformer2.plug2.pin[2].v;
//   transformer2.plug2.pin[1].i + (diode4.plug_n.pin[1].i + diode3.plug_p.pin[1].i) = 0.0;
//   diode3.plug_p.pin[1].v = diode4.plug_n.pin[1].v;
//   diode3.plug_p.pin[1].v = transformer2.plug2.pin[1].v;
//   diode4.plug_p.pin[3].i + star4.plug_p.pin[3].i = 0.0;
//   diode4.plug_p.pin[3].v = star4.plug_p.pin[3].v;
//   diode4.plug_p.pin[2].i + star4.plug_p.pin[2].i = 0.0;
//   diode4.plug_p.pin[2].v = star4.plug_p.pin[2].v;
//   diode4.plug_p.pin[1].i + star4.plug_p.pin[1].i = 0.0;
//   diode4.plug_p.pin[1].v = star4.plug_p.pin[1].v;
//   diode3.plug_n.pin[3].i + star3.plug_p.pin[3].i = 0.0;
//   diode3.plug_n.pin[3].v = star3.plug_p.pin[3].v;
//   diode3.plug_n.pin[2].i + star3.plug_p.pin[2].i = 0.0;
//   diode3.plug_n.pin[2].v = star3.plug_p.pin[2].v;
//   diode3.plug_n.pin[1].i + star3.plug_p.pin[1].i = 0.0;
//   diode3.plug_n.pin[1].v = star3.plug_p.pin[1].v;
//   transformer2.Delta2.plug_p.pin[3].i + (transformer2.r2.plug_n.pin[3].i + (-transformer2.plug2.pin[3].i)) = 0.0;
//   transformer2.Delta2.plug_p.pin[3].v = transformer2.plug2.pin[3].v;
//   transformer2.Delta2.plug_p.pin[3].v = transformer2.r2.plug_n.pin[3].v;
//   transformer2.Delta2.plug_p.pin[2].i + (transformer2.r2.plug_n.pin[2].i + (-transformer2.plug2.pin[2].i)) = 0.0;
//   transformer2.Delta2.plug_p.pin[2].v = transformer2.plug2.pin[2].v;
//   transformer2.Delta2.plug_p.pin[2].v = transformer2.r2.plug_n.pin[2].v;
//   transformer2.Delta2.plug_p.pin[1].i + (transformer2.r2.plug_n.pin[1].i + (-transformer2.plug2.pin[1].i)) = 0.0;
//   transformer2.Delta2.plug_p.pin[1].v = transformer2.plug2.pin[1].v;
//   transformer2.Delta2.plug_p.pin[1].v = transformer2.r2.plug_n.pin[1].v;
//   (-transformer2.plug1.pin[3].i) + (transformer2.r1.plug_p.pin[3].i + transformer2.Delta1.plug_p.pin[3].i) = 0.0;
//   transformer2.Delta1.plug_p.pin[3].v = transformer2.plug1.pin[3].v;
//   transformer2.Delta1.plug_p.pin[3].v = transformer2.r1.plug_p.pin[3].v;
//   (-transformer2.plug1.pin[2].i) + (transformer2.r1.plug_p.pin[2].i + transformer2.Delta1.plug_p.pin[2].i) = 0.0;
//   transformer2.Delta1.plug_p.pin[2].v = transformer2.plug1.pin[2].v;
//   transformer2.Delta1.plug_p.pin[2].v = transformer2.r1.plug_p.pin[2].v;
//   (-transformer2.plug1.pin[1].i) + (transformer2.r1.plug_p.pin[1].i + transformer2.Delta1.plug_p.pin[1].i) = 0.0;
//   transformer2.Delta1.plug_p.pin[1].v = transformer2.plug1.pin[1].v;
//   transformer2.Delta1.plug_p.pin[1].v = transformer2.r1.plug_p.pin[1].v;
//   transformer2.l2sigma.plug_n.pin[3].i + transformer2.r2.plug_p.pin[3].i = 0.0;
//   transformer2.l2sigma.plug_n.pin[3].v = transformer2.r2.plug_p.pin[3].v;
//   transformer2.l2sigma.plug_n.pin[2].i + transformer2.r2.plug_p.pin[2].i = 0.0;
//   transformer2.l2sigma.plug_n.pin[2].v = transformer2.r2.plug_p.pin[2].v;
//   transformer2.l2sigma.plug_n.pin[1].i + transformer2.r2.plug_p.pin[1].i = 0.0;
//   transformer2.l2sigma.plug_n.pin[1].v = transformer2.r2.plug_p.pin[1].v;
//   transformer2.r1.plug_n.pin[3].i + transformer2.l1sigma.plug_p.pin[3].i = 0.0;
//   transformer2.l1sigma.plug_p.pin[3].v = transformer2.r1.plug_n.pin[3].v;
//   transformer2.r1.plug_n.pin[2].i + transformer2.l1sigma.plug_p.pin[2].i = 0.0;
//   transformer2.l1sigma.plug_p.pin[2].v = transformer2.r1.plug_n.pin[2].v;
//   transformer2.r1.plug_n.pin[1].i + transformer2.l1sigma.plug_p.pin[1].i = 0.0;
//   transformer2.l1sigma.plug_p.pin[1].v = transformer2.r1.plug_n.pin[1].v;
//   transformer2.core.plug_n3.pin[3].i + transformer2.Delta2.plug_n.pin[3].i = 0.0;
//   transformer2.Delta2.plug_n.pin[3].v = transformer2.core.plug_n3.pin[3].v;
//   transformer2.core.plug_n3.pin[2].i + transformer2.Delta2.plug_n.pin[2].i = 0.0;
//   transformer2.Delta2.plug_n.pin[2].v = transformer2.core.plug_n3.pin[2].v;
//   transformer2.core.plug_n3.pin[1].i + transformer2.Delta2.plug_n.pin[1].i = 0.0;
//   transformer2.Delta2.plug_n.pin[1].v = transformer2.core.plug_n3.pin[1].v;
//   transformer2.core.plug_p2.pin[3].i + transformer2.l2sigma.plug_p.pin[3].i = 0.0;
//   transformer2.core.plug_p2.pin[3].v = transformer2.l2sigma.plug_p.pin[3].v;
//   transformer2.core.plug_p2.pin[2].i + transformer2.l2sigma.plug_p.pin[2].i = 0.0;
//   transformer2.core.plug_p2.pin[2].v = transformer2.l2sigma.plug_p.pin[2].v;
//   transformer2.core.plug_p2.pin[1].i + transformer2.l2sigma.plug_p.pin[1].i = 0.0;
//   transformer2.core.plug_p2.pin[1].v = transformer2.l2sigma.plug_p.pin[1].v;
//   transformer2.core.plug_n2.pin[3].i + transformer2.core.plug_p3.pin[3].i = 0.0;
//   transformer2.core.plug_n2.pin[3].v = transformer2.core.plug_p3.pin[3].v;
//   transformer2.core.plug_n2.pin[2].i + transformer2.core.plug_p3.pin[2].i = 0.0;
//   transformer2.core.plug_n2.pin[2].v = transformer2.core.plug_p3.pin[2].v;
//   transformer2.core.plug_n2.pin[1].i + transformer2.core.plug_p3.pin[1].i = 0.0;
//   transformer2.core.plug_n2.pin[1].v = transformer2.core.plug_p3.pin[1].v;
//   transformer2.Delta1.plug_n.pin[3].i + transformer2.core.plug_n1.pin[3].i = 0.0;
//   transformer2.Delta1.plug_n.pin[3].v = transformer2.core.plug_n1.pin[3].v;
//   transformer2.Delta1.plug_n.pin[2].i + transformer2.core.plug_n1.pin[2].i = 0.0;
//   transformer2.Delta1.plug_n.pin[2].v = transformer2.core.plug_n1.pin[2].v;
//   transformer2.Delta1.plug_n.pin[1].i + transformer2.core.plug_n1.pin[1].i = 0.0;
//   transformer2.Delta1.plug_n.pin[1].v = transformer2.core.plug_n1.pin[1].v;
//   transformer2.l1sigma.plug_n.pin[3].i + transformer2.core.plug_p1.pin[3].i = 0.0;
//   transformer2.core.plug_p1.pin[3].v = transformer2.l1sigma.plug_n.pin[3].v;
//   transformer2.l1sigma.plug_n.pin[2].i + transformer2.core.plug_p1.pin[2].i = 0.0;
//   transformer2.core.plug_p1.pin[2].v = transformer2.l1sigma.plug_n.pin[2].v;
//   transformer2.l1sigma.plug_n.pin[1].i + transformer2.core.plug_p1.pin[1].i = 0.0;
//   transformer2.core.plug_p1.pin[1].v = transformer2.l1sigma.plug_n.pin[1].v;
//   (-transformer2.Delta2.plug_n.pin[3].i) + (-transformer2.Delta2.plug_p.pin[1].i) = 0.0;
//   transformer2.Delta2.plug_n.pin[3].v = transformer2.Delta2.plug_p.pin[1].v;
//   (-transformer2.Delta2.plug_n.pin[2].i) + (-transformer2.Delta2.plug_p.pin[3].i) = 0.0;
//   transformer2.Delta2.plug_n.pin[2].v = transformer2.Delta2.plug_p.pin[3].v;
//   (-transformer2.Delta2.plug_n.pin[1].i) + (-transformer2.Delta2.plug_p.pin[2].i) = 0.0;
//   transformer2.Delta2.plug_n.pin[1].v = transformer2.Delta2.plug_p.pin[2].v;
//   (-transformer2.Delta1.plug_n.pin[3].i) + (-transformer2.Delta1.plug_p.pin[1].i) = 0.0;
//   transformer2.Delta1.plug_n.pin[3].v = transformer2.Delta1.plug_p.pin[1].v;
//   (-transformer2.Delta1.plug_n.pin[2].i) + (-transformer2.Delta1.plug_p.pin[3].i) = 0.0;
//   transformer2.Delta1.plug_n.pin[2].v = transformer2.Delta1.plug_p.pin[3].v;
//   (-transformer2.Delta1.plug_n.pin[1].i) + (-transformer2.Delta1.plug_p.pin[2].i) = 0.0;
//   transformer2.Delta1.plug_n.pin[1].v = transformer2.Delta1.plug_p.pin[2].v;
//   transformer2.l2sigma.inductor[3].n.i + (-transformer2.l2sigma.plug_n.pin[3].i) = 0.0;
//   transformer2.l2sigma.inductor[3].n.v = transformer2.l2sigma.plug_n.pin[3].v;
//   transformer2.l2sigma.inductor[2].n.i + (-transformer2.l2sigma.plug_n.pin[2].i) = 0.0;
//   transformer2.l2sigma.inductor[2].n.v = transformer2.l2sigma.plug_n.pin[2].v;
//   transformer2.l2sigma.inductor[1].n.i + (-transformer2.l2sigma.plug_n.pin[1].i) = 0.0;
//   transformer2.l2sigma.inductor[1].n.v = transformer2.l2sigma.plug_n.pin[1].v;
//   transformer2.l2sigma.inductor[3].p.i + (-transformer2.l2sigma.plug_p.pin[3].i) = 0.0;
//   transformer2.l2sigma.inductor[3].p.v = transformer2.l2sigma.plug_p.pin[3].v;
//   transformer2.l2sigma.inductor[2].p.i + (-transformer2.l2sigma.plug_p.pin[2].i) = 0.0;
//   transformer2.l2sigma.inductor[2].p.v = transformer2.l2sigma.plug_p.pin[2].v;
//   transformer2.l2sigma.inductor[1].p.i + (-transformer2.l2sigma.plug_p.pin[1].i) = 0.0;
//   transformer2.l2sigma.inductor[1].p.v = transformer2.l2sigma.plug_p.pin[1].v;
//   transformer2.r2.resistor[3].n.i + (-transformer2.r2.plug_n.pin[3].i) = 0.0;
//   transformer2.r2.plug_n.pin[3].v = transformer2.r2.resistor[3].n.v;
//   transformer2.r2.resistor[2].n.i + (-transformer2.r2.plug_n.pin[2].i) = 0.0;
//   transformer2.r2.plug_n.pin[2].v = transformer2.r2.resistor[2].n.v;
//   transformer2.r2.resistor[1].n.i + (-transformer2.r2.plug_n.pin[1].i) = 0.0;
//   transformer2.r2.plug_n.pin[1].v = transformer2.r2.resistor[1].n.v;
//   transformer2.r2.resistor[3].p.i + (-transformer2.r2.plug_p.pin[3].i) = 0.0;
//   transformer2.r2.plug_p.pin[3].v = transformer2.r2.resistor[3].p.v;
//   transformer2.r2.resistor[2].p.i + (-transformer2.r2.plug_p.pin[2].i) = 0.0;
//   transformer2.r2.plug_p.pin[2].v = transformer2.r2.resistor[2].p.v;
//   transformer2.r2.resistor[1].p.i + (-transformer2.r2.plug_p.pin[1].i) = 0.0;
//   transformer2.r2.plug_p.pin[1].v = transformer2.r2.resistor[1].p.v;
//   transformer2.l1sigma.inductor[3].n.i + (-transformer2.l1sigma.plug_n.pin[3].i) = 0.0;
//   transformer2.l1sigma.inductor[3].n.v = transformer2.l1sigma.plug_n.pin[3].v;
//   transformer2.l1sigma.inductor[2].n.i + (-transformer2.l1sigma.plug_n.pin[2].i) = 0.0;
//   transformer2.l1sigma.inductor[2].n.v = transformer2.l1sigma.plug_n.pin[2].v;
//   transformer2.l1sigma.inductor[1].n.i + (-transformer2.l1sigma.plug_n.pin[1].i) = 0.0;
//   transformer2.l1sigma.inductor[1].n.v = transformer2.l1sigma.plug_n.pin[1].v;
//   transformer2.l1sigma.inductor[3].p.i + (-transformer2.l1sigma.plug_p.pin[3].i) = 0.0;
//   transformer2.l1sigma.inductor[3].p.v = transformer2.l1sigma.plug_p.pin[3].v;
//   transformer2.l1sigma.inductor[2].p.i + (-transformer2.l1sigma.plug_p.pin[2].i) = 0.0;
//   transformer2.l1sigma.inductor[2].p.v = transformer2.l1sigma.plug_p.pin[2].v;
//   transformer2.l1sigma.inductor[1].p.i + (-transformer2.l1sigma.plug_p.pin[1].i) = 0.0;
//   transformer2.l1sigma.inductor[1].p.v = transformer2.l1sigma.plug_p.pin[1].v;
//   transformer2.r1.resistor[3].n.i + (-transformer2.r1.plug_n.pin[3].i) = 0.0;
//   transformer2.r1.plug_n.pin[3].v = transformer2.r1.resistor[3].n.v;
//   transformer2.r1.resistor[2].n.i + (-transformer2.r1.plug_n.pin[2].i) = 0.0;
//   transformer2.r1.plug_n.pin[2].v = transformer2.r1.resistor[2].n.v;
//   transformer2.r1.resistor[1].n.i + (-transformer2.r1.plug_n.pin[1].i) = 0.0;
//   transformer2.r1.plug_n.pin[1].v = transformer2.r1.resistor[1].n.v;
//   transformer2.r1.resistor[3].p.i + (-transformer2.r1.plug_p.pin[3].i) = 0.0;
//   transformer2.r1.plug_p.pin[3].v = transformer2.r1.resistor[3].p.v;
//   transformer2.r1.resistor[2].p.i + (-transformer2.r1.plug_p.pin[2].i) = 0.0;
//   transformer2.r1.plug_p.pin[2].v = transformer2.r1.resistor[2].p.v;
//   transformer2.r1.resistor[1].p.i + (-transformer2.r1.plug_p.pin[1].i) = 0.0;
//   transformer2.r1.plug_p.pin[1].v = transformer2.r1.resistor[1].p.v;
//   (-star4.plug_p.pin[3].i) + ((-star4.plug_p.pin[2].i) + ((-star4.plug_p.pin[1].i) + (-star4.pin_n.i))) = 0.0;
//   star4.pin_n.v = star4.plug_p.pin[1].v;
//   star4.pin_n.v = star4.plug_p.pin[2].v;
//   star4.pin_n.v = star4.plug_p.pin[3].v;
//   diode4.idealDiode[3].n.i + (-diode4.plug_n.pin[3].i) = 0.0;
//   diode4.idealDiode[3].n.v = diode4.plug_n.pin[3].v;
//   diode4.idealDiode[2].n.i + (-diode4.plug_n.pin[2].i) = 0.0;
//   diode4.idealDiode[2].n.v = diode4.plug_n.pin[2].v;
//   diode4.idealDiode[1].n.i + (-diode4.plug_n.pin[1].i) = 0.0;
//   diode4.idealDiode[1].n.v = diode4.plug_n.pin[1].v;
//   (-diode4.plug_p.pin[3].i) + diode4.idealDiode[3].p.i = 0.0;
//   diode4.idealDiode[3].p.v = diode4.plug_p.pin[3].v;
//   (-diode4.plug_p.pin[2].i) + diode4.idealDiode[2].p.i = 0.0;
//   diode4.idealDiode[2].p.v = diode4.plug_p.pin[2].v;
//   (-diode4.plug_p.pin[1].i) + diode4.idealDiode[1].p.i = 0.0;
//   diode4.idealDiode[1].p.v = diode4.plug_p.pin[1].v;
//   (-star3.plug_p.pin[3].i) + ((-star3.plug_p.pin[2].i) + ((-star3.plug_p.pin[1].i) + (-star3.pin_n.i))) = 0.0;
//   star3.pin_n.v = star3.plug_p.pin[1].v;
//   star3.pin_n.v = star3.plug_p.pin[2].v;
//   star3.pin_n.v = star3.plug_p.pin[3].v;
//   diode3.idealDiode[3].n.i + (-diode3.plug_n.pin[3].i) = 0.0;
//   diode3.idealDiode[3].n.v = diode3.plug_n.pin[3].v;
//   diode3.idealDiode[2].n.i + (-diode3.plug_n.pin[2].i) = 0.0;
//   diode3.idealDiode[2].n.v = diode3.plug_n.pin[2].v;
//   diode3.idealDiode[1].n.i + (-diode3.plug_n.pin[1].i) = 0.0;
//   diode3.idealDiode[1].n.v = diode3.plug_n.pin[1].v;
//   (-diode3.plug_p.pin[3].i) + diode3.idealDiode[3].p.i = 0.0;
//   diode3.idealDiode[3].p.v = diode3.plug_p.pin[3].v;
//   (-diode3.plug_p.pin[2].i) + diode3.idealDiode[2].p.i = 0.0;
//   diode3.idealDiode[2].p.v = diode3.plug_p.pin[2].v;
//   (-diode3.plug_p.pin[1].i) + diode3.idealDiode[1].p.i = 0.0;
//   diode3.idealDiode[1].p.v = diode3.plug_p.pin[1].v;
//   transformer1.r2.plug_n.pin[3].i + (-transformer1.plug2.pin[3].i) = 0.0;
//   transformer1.plug2.pin[3].v = transformer1.r2.plug_n.pin[3].v;
//   transformer1.r2.plug_n.pin[2].i + (-transformer1.plug2.pin[2].i) = 0.0;
//   transformer1.plug2.pin[2].v = transformer1.r2.plug_n.pin[2].v;
//   transformer1.r2.plug_n.pin[1].i + (-transformer1.plug2.pin[1].i) = 0.0;
//   transformer1.plug2.pin[1].v = transformer1.r2.plug_n.pin[1].v;
//   (-transformer1.plug1.pin[3].i) + (transformer1.Delta1.plug_p.pin[3].i + transformer1.r1.plug_p.pin[3].i) = 0.0;
//   transformer1.Delta1.plug_p.pin[3].v = transformer1.plug1.pin[3].v;
//   transformer1.Delta1.plug_p.pin[3].v = transformer1.r1.plug_p.pin[3].v;
//   (-transformer1.plug1.pin[2].i) + (transformer1.Delta1.plug_p.pin[2].i + transformer1.r1.plug_p.pin[2].i) = 0.0;
//   transformer1.Delta1.plug_p.pin[2].v = transformer1.plug1.pin[2].v;
//   transformer1.Delta1.plug_p.pin[2].v = transformer1.r1.plug_p.pin[2].v;
//   (-transformer1.plug1.pin[1].i) + (transformer1.Delta1.plug_p.pin[1].i + transformer1.r1.plug_p.pin[1].i) = 0.0;
//   transformer1.Delta1.plug_p.pin[1].v = transformer1.plug1.pin[1].v;
//   transformer1.Delta1.plug_p.pin[1].v = transformer1.r1.plug_p.pin[1].v;
//   transformer1.l2sigma.plug_n.pin[3].i + transformer1.r2.plug_p.pin[3].i = 0.0;
//   transformer1.l2sigma.plug_n.pin[3].v = transformer1.r2.plug_p.pin[3].v;
//   transformer1.l2sigma.plug_n.pin[2].i + transformer1.r2.plug_p.pin[2].i = 0.0;
//   transformer1.l2sigma.plug_n.pin[2].v = transformer1.r2.plug_p.pin[2].v;
//   transformer1.l2sigma.plug_n.pin[1].i + transformer1.r2.plug_p.pin[1].i = 0.0;
//   transformer1.l2sigma.plug_n.pin[1].v = transformer1.r2.plug_p.pin[1].v;
//   transformer1.r1.plug_n.pin[3].i + transformer1.l1sigma.plug_p.pin[3].i = 0.0;
//   transformer1.l1sigma.plug_p.pin[3].v = transformer1.r1.plug_n.pin[3].v;
//   transformer1.r1.plug_n.pin[2].i + transformer1.l1sigma.plug_p.pin[2].i = 0.0;
//   transformer1.l1sigma.plug_p.pin[2].v = transformer1.r1.plug_n.pin[2].v;
//   transformer1.r1.plug_n.pin[1].i + transformer1.l1sigma.plug_p.pin[1].i = 0.0;
//   transformer1.l1sigma.plug_p.pin[1].v = transformer1.r1.plug_n.pin[1].v;
//   transformer1.core.plug_p2.pin[3].i + transformer1.star2.plug_p.pin[3].i = 0.0;
//   transformer1.core.plug_p2.pin[3].v = transformer1.star2.plug_p.pin[3].v;
//   transformer1.core.plug_p2.pin[2].i + transformer1.star2.plug_p.pin[2].i = 0.0;
//   transformer1.core.plug_p2.pin[2].v = transformer1.star2.plug_p.pin[2].v;
//   transformer1.core.plug_p2.pin[1].i + transformer1.star2.plug_p.pin[1].i = 0.0;
//   transformer1.core.plug_p2.pin[1].v = transformer1.star2.plug_p.pin[1].v;
//   transformer1.core.plug_n3.pin[3].i + transformer1.Rot2.plug_n.pin[3].i = 0.0;
//   transformer1.Rot2.plug_n.pin[3].v = transformer1.core.plug_n3.pin[3].v;
//   transformer1.core.plug_n3.pin[2].i + transformer1.Rot2.plug_n.pin[2].i = 0.0;
//   transformer1.Rot2.plug_n.pin[2].v = transformer1.core.plug_n3.pin[2].v;
//   transformer1.core.plug_n3.pin[1].i + transformer1.Rot2.plug_n.pin[1].i = 0.0;
//   transformer1.Rot2.plug_n.pin[1].v = transformer1.core.plug_n3.pin[1].v;
//   transformer1.core.plug_n2.pin[3].i + transformer1.core.plug_p3.pin[3].i = 0.0;
//   transformer1.core.plug_n2.pin[3].v = transformer1.core.plug_p3.pin[3].v;
//   transformer1.core.plug_n2.pin[2].i + transformer1.core.plug_p3.pin[2].i = 0.0;
//   transformer1.core.plug_n2.pin[2].v = transformer1.core.plug_p3.pin[2].v;
//   transformer1.core.plug_n2.pin[1].i + transformer1.core.plug_p3.pin[1].i = 0.0;
//   transformer1.core.plug_n2.pin[1].v = transformer1.core.plug_p3.pin[1].v;
//   transformer1.l1sigma.plug_n.pin[3].i + transformer1.core.plug_p1.pin[3].i = 0.0;
//   transformer1.core.plug_p1.pin[3].v = transformer1.l1sigma.plug_n.pin[3].v;
//   transformer1.l1sigma.plug_n.pin[2].i + transformer1.core.plug_p1.pin[2].i = 0.0;
//   transformer1.core.plug_p1.pin[2].v = transformer1.l1sigma.plug_n.pin[2].v;
//   transformer1.l1sigma.plug_n.pin[1].i + transformer1.core.plug_p1.pin[1].i = 0.0;
//   transformer1.core.plug_p1.pin[1].v = transformer1.l1sigma.plug_n.pin[1].v;
//   transformer1.Delta1.plug_n.pin[3].i + transformer1.core.plug_n1.pin[3].i = 0.0;
//   transformer1.Delta1.plug_n.pin[3].v = transformer1.core.plug_n1.pin[3].v;
//   transformer1.Delta1.plug_n.pin[2].i + transformer1.core.plug_n1.pin[2].i = 0.0;
//   transformer1.Delta1.plug_n.pin[2].v = transformer1.core.plug_n1.pin[2].v;
//   transformer1.Delta1.plug_n.pin[1].i + transformer1.core.plug_n1.pin[1].i = 0.0;
//   transformer1.Delta1.plug_n.pin[1].v = transformer1.core.plug_n1.pin[1].v;
//   transformer1.l2sigma.plug_p.pin[3].i + transformer1.Rot2.plug_p.pin[3].i = 0.0;
//   transformer1.Rot2.plug_p.pin[3].v = transformer1.l2sigma.plug_p.pin[3].v;
//   transformer1.l2sigma.plug_p.pin[2].i + transformer1.Rot2.plug_p.pin[2].i = 0.0;
//   transformer1.Rot2.plug_p.pin[2].v = transformer1.l2sigma.plug_p.pin[2].v;
//   transformer1.l2sigma.plug_p.pin[1].i + transformer1.Rot2.plug_p.pin[1].i = 0.0;
//   transformer1.Rot2.plug_p.pin[1].v = transformer1.l2sigma.plug_p.pin[1].v;
//   transformer1.star2.pin_n.i + (-transformer1.starpoint2.i) = 0.0;
//   transformer1.star2.pin_n.v = transformer1.starpoint2.v;
//   (-transformer1.Rot2.plug_n.pin[3].i) + (-transformer1.Rot2.plug_p.pin[1].i) = 0.0;
//   transformer1.Rot2.plug_n.pin[3].v = transformer1.Rot2.plug_p.pin[1].v;
//   (-transformer1.Rot2.plug_n.pin[2].i) + (-transformer1.Rot2.plug_p.pin[3].i) = 0.0;
//   transformer1.Rot2.plug_n.pin[2].v = transformer1.Rot2.plug_p.pin[3].v;
//   (-transformer1.Rot2.plug_n.pin[1].i) + (-transformer1.Rot2.plug_p.pin[2].i) = 0.0;
//   transformer1.Rot2.plug_n.pin[1].v = transformer1.Rot2.plug_p.pin[2].v;
//   (-transformer1.Delta1.plug_n.pin[3].i) + (-transformer1.Delta1.plug_p.pin[1].i) = 0.0;
//   transformer1.Delta1.plug_n.pin[3].v = transformer1.Delta1.plug_p.pin[1].v;
//   (-transformer1.Delta1.plug_n.pin[2].i) + (-transformer1.Delta1.plug_p.pin[3].i) = 0.0;
//   transformer1.Delta1.plug_n.pin[2].v = transformer1.Delta1.plug_p.pin[3].v;
//   (-transformer1.Delta1.plug_n.pin[1].i) + (-transformer1.Delta1.plug_p.pin[2].i) = 0.0;
//   transformer1.Delta1.plug_n.pin[1].v = transformer1.Delta1.plug_p.pin[2].v;
//   transformer1.starpoint2.i = 0.0;
//   (-transformer1.star2.plug_p.pin[3].i) + ((-transformer1.star2.plug_p.pin[2].i) + ((-transformer1.star2.plug_p.pin[1].i) + (-transformer1.star2.pin_n.i))) = 0.0;
//   transformer1.star2.pin_n.v = transformer1.star2.plug_p.pin[1].v;
//   transformer1.star2.pin_n.v = transformer1.star2.plug_p.pin[2].v;
//   transformer1.star2.pin_n.v = transformer1.star2.plug_p.pin[3].v;
//   transformer1.l2sigma.inductor[3].n.i + (-transformer1.l2sigma.plug_n.pin[3].i) = 0.0;
//   transformer1.l2sigma.inductor[3].n.v = transformer1.l2sigma.plug_n.pin[3].v;
//   transformer1.l2sigma.inductor[2].n.i + (-transformer1.l2sigma.plug_n.pin[2].i) = 0.0;
//   transformer1.l2sigma.inductor[2].n.v = transformer1.l2sigma.plug_n.pin[2].v;
//   transformer1.l2sigma.inductor[1].n.i + (-transformer1.l2sigma.plug_n.pin[1].i) = 0.0;
//   transformer1.l2sigma.inductor[1].n.v = transformer1.l2sigma.plug_n.pin[1].v;
//   transformer1.l2sigma.inductor[3].p.i + (-transformer1.l2sigma.plug_p.pin[3].i) = 0.0;
//   transformer1.l2sigma.inductor[3].p.v = transformer1.l2sigma.plug_p.pin[3].v;
//   transformer1.l2sigma.inductor[2].p.i + (-transformer1.l2sigma.plug_p.pin[2].i) = 0.0;
//   transformer1.l2sigma.inductor[2].p.v = transformer1.l2sigma.plug_p.pin[2].v;
//   transformer1.l2sigma.inductor[1].p.i + (-transformer1.l2sigma.plug_p.pin[1].i) = 0.0;
//   transformer1.l2sigma.inductor[1].p.v = transformer1.l2sigma.plug_p.pin[1].v;
//   transformer1.r2.resistor[3].n.i + (-transformer1.r2.plug_n.pin[3].i) = 0.0;
//   transformer1.r2.plug_n.pin[3].v = transformer1.r2.resistor[3].n.v;
//   transformer1.r2.resistor[2].n.i + (-transformer1.r2.plug_n.pin[2].i) = 0.0;
//   transformer1.r2.plug_n.pin[2].v = transformer1.r2.resistor[2].n.v;
//   transformer1.r2.resistor[1].n.i + (-transformer1.r2.plug_n.pin[1].i) = 0.0;
//   transformer1.r2.plug_n.pin[1].v = transformer1.r2.resistor[1].n.v;
//   transformer1.r2.resistor[3].p.i + (-transformer1.r2.plug_p.pin[3].i) = 0.0;
//   transformer1.r2.plug_p.pin[3].v = transformer1.r2.resistor[3].p.v;
//   transformer1.r2.resistor[2].p.i + (-transformer1.r2.plug_p.pin[2].i) = 0.0;
//   transformer1.r2.plug_p.pin[2].v = transformer1.r2.resistor[2].p.v;
//   transformer1.r2.resistor[1].p.i + (-transformer1.r2.plug_p.pin[1].i) = 0.0;
//   transformer1.r2.plug_p.pin[1].v = transformer1.r2.resistor[1].p.v;
//   transformer1.l1sigma.inductor[3].n.i + (-transformer1.l1sigma.plug_n.pin[3].i) = 0.0;
//   transformer1.l1sigma.inductor[3].n.v = transformer1.l1sigma.plug_n.pin[3].v;
//   transformer1.l1sigma.inductor[2].n.i + (-transformer1.l1sigma.plug_n.pin[2].i) = 0.0;
//   transformer1.l1sigma.inductor[2].n.v = transformer1.l1sigma.plug_n.pin[2].v;
//   transformer1.l1sigma.inductor[1].n.i + (-transformer1.l1sigma.plug_n.pin[1].i) = 0.0;
//   transformer1.l1sigma.inductor[1].n.v = transformer1.l1sigma.plug_n.pin[1].v;
//   transformer1.l1sigma.inductor[3].p.i + (-transformer1.l1sigma.plug_p.pin[3].i) = 0.0;
//   transformer1.l1sigma.inductor[3].p.v = transformer1.l1sigma.plug_p.pin[3].v;
//   transformer1.l1sigma.inductor[2].p.i + (-transformer1.l1sigma.plug_p.pin[2].i) = 0.0;
//   transformer1.l1sigma.inductor[2].p.v = transformer1.l1sigma.plug_p.pin[2].v;
//   transformer1.l1sigma.inductor[1].p.i + (-transformer1.l1sigma.plug_p.pin[1].i) = 0.0;
//   transformer1.l1sigma.inductor[1].p.v = transformer1.l1sigma.plug_p.pin[1].v;
//   transformer1.r1.resistor[3].n.i + (-transformer1.r1.plug_n.pin[3].i) = 0.0;
//   transformer1.r1.plug_n.pin[3].v = transformer1.r1.resistor[3].n.v;
//   transformer1.r1.resistor[2].n.i + (-transformer1.r1.plug_n.pin[2].i) = 0.0;
//   transformer1.r1.plug_n.pin[2].v = transformer1.r1.resistor[2].n.v;
//   transformer1.r1.resistor[1].n.i + (-transformer1.r1.plug_n.pin[1].i) = 0.0;
//   transformer1.r1.plug_n.pin[1].v = transformer1.r1.resistor[1].n.v;
//   transformer1.r1.resistor[3].p.i + (-transformer1.r1.plug_p.pin[3].i) = 0.0;
//   transformer1.r1.plug_p.pin[3].v = transformer1.r1.resistor[3].p.v;
//   transformer1.r1.resistor[2].p.i + (-transformer1.r1.plug_p.pin[2].i) = 0.0;
//   transformer1.r1.plug_p.pin[2].v = transformer1.r1.resistor[2].p.v;
//   transformer1.r1.resistor[1].p.i + (-transformer1.r1.plug_p.pin[1].i) = 0.0;
//   transformer1.r1.plug_p.pin[1].v = transformer1.r1.resistor[1].p.v;
//   (-star2.plug_p.pin[3].i) + ((-star2.plug_p.pin[2].i) + ((-star2.plug_p.pin[1].i) + (-star2.pin_n.i))) = 0.0;
//   star2.pin_n.v = star2.plug_p.pin[1].v;
//   star2.pin_n.v = star2.plug_p.pin[2].v;
//   star2.pin_n.v = star2.plug_p.pin[3].v;
//   diode2.idealDiode[3].n.i + (-diode2.plug_n.pin[3].i) = 0.0;
//   diode2.idealDiode[3].n.v = diode2.plug_n.pin[3].v;
//   diode2.idealDiode[2].n.i + (-diode2.plug_n.pin[2].i) = 0.0;
//   diode2.idealDiode[2].n.v = diode2.plug_n.pin[2].v;
//   diode2.idealDiode[1].n.i + (-diode2.plug_n.pin[1].i) = 0.0;
//   diode2.idealDiode[1].n.v = diode2.plug_n.pin[1].v;
//   (-diode2.plug_p.pin[3].i) + diode2.idealDiode[3].p.i = 0.0;
//   diode2.idealDiode[3].p.v = diode2.plug_p.pin[3].v;
//   (-diode2.plug_p.pin[2].i) + diode2.idealDiode[2].p.i = 0.0;
//   diode2.idealDiode[2].p.v = diode2.plug_p.pin[2].v;
//   (-diode2.plug_p.pin[1].i) + diode2.idealDiode[1].p.i = 0.0;
//   diode2.idealDiode[1].p.v = diode2.plug_p.pin[1].v;
//   (-star1.plug_p.pin[3].i) + ((-star1.plug_p.pin[2].i) + ((-star1.plug_p.pin[1].i) + (-star1.pin_n.i))) = 0.0;
//   star1.pin_n.v = star1.plug_p.pin[1].v;
//   star1.pin_n.v = star1.plug_p.pin[2].v;
//   star1.pin_n.v = star1.plug_p.pin[3].v;
//   diode1.idealDiode[3].n.i + (-diode1.plug_n.pin[3].i) = 0.0;
//   diode1.idealDiode[3].n.v = diode1.plug_n.pin[3].v;
//   diode1.idealDiode[2].n.i + (-diode1.plug_n.pin[2].i) = 0.0;
//   diode1.idealDiode[2].n.v = diode1.plug_n.pin[2].v;
//   diode1.idealDiode[1].n.i + (-diode1.plug_n.pin[1].i) = 0.0;
//   diode1.idealDiode[1].n.v = diode1.plug_n.pin[1].v;
//   (-diode1.plug_p.pin[3].i) + diode1.idealDiode[3].p.i = 0.0;
//   diode1.idealDiode[3].p.v = diode1.plug_p.pin[3].v;
//   (-diode1.plug_p.pin[2].i) + diode1.idealDiode[2].p.i = 0.0;
//   diode1.idealDiode[2].p.v = diode1.plug_p.pin[2].v;
//   (-diode1.plug_p.pin[1].i) + diode1.idealDiode[1].p.i = 0.0;
//   diode1.idealDiode[1].p.v = diode1.plug_p.pin[1].v;
//   currentQuasiRMSSensor.currentSensor[1].i = currentQuasiRMSSensor.i[1];
//   currentQuasiRMSSensor.currentSensor[2].i = currentQuasiRMSSensor.i[2];
//   currentQuasiRMSSensor.currentSensor[3].i = currentQuasiRMSSensor.i[3];
//   currentQuasiRMSSensor.currentSensor[3].n.i + (-currentQuasiRMSSensor.plug_n.pin[3].i) = 0.0;
//   currentQuasiRMSSensor.currentSensor[3].n.v = currentQuasiRMSSensor.plug_n.pin[3].v;
//   currentQuasiRMSSensor.currentSensor[2].n.i + (-currentQuasiRMSSensor.plug_n.pin[2].i) = 0.0;
//   currentQuasiRMSSensor.currentSensor[2].n.v = currentQuasiRMSSensor.plug_n.pin[2].v;
//   currentQuasiRMSSensor.currentSensor[1].n.i + (-currentQuasiRMSSensor.plug_n.pin[1].i) = 0.0;
//   currentQuasiRMSSensor.currentSensor[1].n.v = currentQuasiRMSSensor.plug_n.pin[1].v;
//   (-currentQuasiRMSSensor.plug_p.pin[3].i) + currentQuasiRMSSensor.currentSensor[3].p.i = 0.0;
//   currentQuasiRMSSensor.currentSensor[3].p.v = currentQuasiRMSSensor.plug_p.pin[3].v;
//   (-currentQuasiRMSSensor.plug_p.pin[2].i) + currentQuasiRMSSensor.currentSensor[2].p.i = 0.0;
//   currentQuasiRMSSensor.currentSensor[2].p.v = currentQuasiRMSSensor.plug_p.pin[2].v;
//   (-currentQuasiRMSSensor.plug_p.pin[1].i) + currentQuasiRMSSensor.currentSensor[1].p.i = 0.0;
//   currentQuasiRMSSensor.currentSensor[1].p.v = currentQuasiRMSSensor.plug_p.pin[1].v;
//   (-starAC.plug_p.pin[3].i) + ((-starAC.plug_p.pin[2].i) + ((-starAC.plug_p.pin[1].i) + (-starAC.pin_n.i))) = 0.0;
//   starAC.pin_n.v = starAC.plug_p.pin[1].v;
//   starAC.pin_n.v = starAC.plug_p.pin[2].v;
//   starAC.pin_n.v = starAC.plug_p.pin[3].v;
//   source.sineVoltage[3].n.i + (-source.plug_n.pin[3].i) = 0.0;
//   source.plug_n.pin[3].v = source.sineVoltage[3].n.v;
//   source.sineVoltage[2].n.i + (-source.plug_n.pin[2].i) = 0.0;
//   source.plug_n.pin[2].v = source.sineVoltage[2].n.v;
//   source.sineVoltage[1].n.i + (-source.plug_n.pin[1].i) = 0.0;
//   source.plug_n.pin[1].v = source.sineVoltage[1].n.v;
//   source.sineVoltage[3].p.i + (-source.plug_p.pin[3].i) = 0.0;
//   source.plug_p.pin[3].v = source.sineVoltage[3].p.v;
//   source.sineVoltage[2].p.i + (-source.plug_p.pin[2].i) = 0.0;
//   source.plug_p.pin[2].v = source.sineVoltage[2].p.v;
//   source.sineVoltage[1].p.i + (-source.plug_p.pin[1].i) = 0.0;
//   source.plug_p.pin[1].v = source.sineVoltage[1].p.v;
// end Modelica.Electrical.Machines.Examples.Rectifier12pulse;
// "
// 
// "Check of Modelica.Electrical.Machines.Examples.Rectifier12pulse completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.Rectifier12pulse has 870 equation(s) and 870 variable(s).
// 622 of these are trivial equation(s).
// "
// 
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_Steinmetz
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "start time";
//   parameter Real Cr(quantity = "Capacitance", unit = "F", min = 0.0) = 0.0035 "motor's running capacitor";
//   parameter Real Cs(quantity = "Capacitance", unit = "F", min = 0.0) = 5.0 * Cr "motor's (additional) starting capacitor";
//   parameter Real wSwitch(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 141.371669411541 "speed for switching off the starting capacitor";
//   parameter Real TLoad(quantity = "Torque", unit = "N.m") = 107.6 "nominal load torque";
//   parameter Real wLoad(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = 153.152641862502 "nominal load speed";
//   parameter Real JLoad(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Real aimc.pi(quantity = "Angle", unit = "rad", displayUnit = "deg") = 3.14159265358979;
//   parameter Real aimc.Jr(quantity = "MomentOfInertia", unit = "kg.m2", start = 0.29) "rotor's moment of inertia";
//   parameter Boolean aimc.useSupport = true "enable / disable (=fixed stator) support";
//   parameter Real aimc.Js(quantity = "MomentOfInertia", unit = "kg.m2", start = aimc.Jr) "stator's moment of inertia";
//   output Real aimc.phiMechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = aimc.flange.phi - aimc.internalSupport.phi "mechanical angle of rotor against stator";
//   output Real aimc.wMechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min") = der(aimc.phiMechanical) "mechanical angular velocity of rotor against stator";
//   output Real aimc.tauElectrical(quantity = "Torque", unit = "N.m") = aimc.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real aimc.tauShaft(quantity = "Torque", unit = "N.m") = -aimc.flange.tau "shaft torque";
//   Real aimc.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Jr "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaRotor.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real aimc.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of the support/housing";
//   Real aimc.internalSupport.tau(quantity = "Torque", unit = "N.m") "Reaction torque in the support/housing";
//   constant Integer aimc.m = 3 "number of phases";
//   parameter Integer aimc.p(min = 1, start = 2) "number of pole pairs (Integer)";
//   parameter Real aimc.fsNominal(quantity = "Frequency", unit = "Hz", start = 50.0) "nominal frequency";
//   parameter Real aimc.Rs(quantity = "Resistance", unit = "Ohm", start = 0.03) "warm stator resistance per phase";
//   parameter Real aimc.Lssigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "stator stray inductance per phase";
//   output Real aimc.vs[1](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[1].v - aimc.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real aimc.vs[2](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[2].v - aimc.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real aimc.vs[3](quantity = "ElectricPotential", unit = "V") = aimc.plug_sp.pin[3].v - aimc.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real aimc.is[1](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real aimc.is[2](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real aimc.is[3](quantity = "ElectricCurrent", unit = "A") = aimc.plug_sp.pin[3].i "stator instantaneous currents";
//   output Real aimc.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.spacePhasorS.zero.i "stator zero-sequence current";
//   input Real aimc.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   input Real aimc.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   input Real aimc.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = aimc.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   input Real aimc.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   input Real aimc.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = aimc.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer aimc.plug_sp.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.plug_sn.m(min = 1) = 3 "number of phases";
//   Real aimc.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.m(min = 1) = 3 "number of phases";
//   Real aimc.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.rs.plug_p.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.plug_n.m(min = 1) = aimc.rs.m "number of phases";
//   Real aimc.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.rs.mh(min = 1) = aimc.rs.m "Number of heatPorts=number of phases";
//   parameter Boolean aimc.rs.useHeatPort = false "=true, if all HeatPorts are enabled";
//   parameter Real aimc.rs.T[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.T[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Fixed device temperatures if useHeatPort = false";
//   parameter Real aimc.rs.R[1](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[2](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.R[3](quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.Rs "Resistances R_ref at temperatures T_ref";
//   parameter Real aimc.rs.T_ref[1](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[2](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.T_ref[3](quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperatures";
//   parameter Real aimc.rs.alpha[1](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[2](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   parameter Real aimc.rs.alpha[3](quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficients of resistances at reference temperatures";
//   Real aimc.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[1].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[1].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[1] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[1].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[1].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[1] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[1].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[1] "Reference temperature";
//   parameter Real aimc.rs.resistor[1].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[1] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[1].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[2].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[2].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[2] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[2].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[2].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[2] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[2].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[2] "Reference temperature";
//   parameter Real aimc.rs.resistor[2].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[2] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[2].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean aimc.rs.resistor[3].useHeatPort = aimc.rs.useHeatPort "=true, if HeatPort is enabled";
//   parameter Real aimc.rs.resistor[3].T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T[3] "Fixed device temperature if useHeatPort = false";
//   Real aimc.rs.resistor[3].LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real aimc.rs.resistor[3].T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real aimc.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm", start = 1.0) = aimc.rs.R[3] "Resistance at temperature T_ref";
//   parameter Real aimc.rs.resistor[3].T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = aimc.rs.T_ref[3] "Reference temperature";
//   parameter Real aimc.rs.resistor[3].alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = aimc.rs.alpha[3] "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
//   Real aimc.rs.resistor[3].R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
//   parameter Integer aimc.lssigma.m(min = 1) = 3 "number of phases";
//   Real aimc.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real aimc.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real aimc.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer aimc.lssigma.plug_p.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.lssigma.plug_n.m(min = 1) = aimc.lssigma.m "number of phases";
//   Real aimc.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.L[1](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[2](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   parameter Real aimc.lssigma.L[3](quantity = "Inductance", unit = "H", start = 1.0) = aimc.Lssigma "Inductance";
//   Real aimc.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[1].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[1] "Inductance";
//   Real aimc.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[2].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[2] "Inductance";
//   Real aimc.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real aimc.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real aimc.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real aimc.lssigma.inductor[3].L(quantity = "Inductance", unit = "H", start = 1.0) = aimc.lssigma.L[3] "Inductance";
//   constant Integer aimc.spacePhasorS.m = 3 "number of phases";
//   constant Real aimc.spacePhasorS.pi = 3.14159265358979;
//   parameter Real aimc.spacePhasorS.turnsRatio = 1.0;
//   Real aimc.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real aimc.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real aimc.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real aimc.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer aimc.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer aimc.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real aimc.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real aimc.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real aimc.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Integer aimc.airGapS.m = 3 "number of phases";
//   parameter Integer aimc.airGapS.p(min = 1) = aimc.p "number of pole pairs";
//   output Real aimc.airGapS.tauElectrical(quantity = "Torque", unit = "N.m");
//   Real aimc.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real aimc.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real aimc.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real aimc.airGapS.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   parameter Real aimc.airGapS.Lm(quantity = "Inductance", unit = "H") = aimc.Lm "main field inductance";
//   Real aimc.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real aimc.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   protected parameter Real aimc.airGapS.L[1,1](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   protected parameter Real aimc.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real aimc.airGapS.L[2,2](quantity = "Inductance", unit = "H") = aimc.airGapS.Lm "inductance matrix";
//   parameter Real aimc.Lm(quantity = "Inductance", unit = "H", start = 2.89822359385883 * 1.0 / aimc.fsNominal / 6.28318530717959) "main field inductance";
//   parameter Real aimc.Lrsigma(quantity = "Inductance", unit = "H", start = 0.101776406141169 * 1.0 / aimc.fsNominal / 6.28318530717959) "rotor stray inductance (equivalent three phase winding)";
//   parameter Real aimc.Rr(quantity = "Resistance", unit = "Ohm", start = 0.04) "warm rotor resistance (equivalent three phase winding)";
//   parameter Real aimc.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = aimc.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real aimc.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = aimc.Rr "warm rotor resistance per phase translated to stator";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
//   Real aimc.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaStator.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaStator.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real aimc.inertiaStator.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real aimc.inertiaStator.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real aimc.inertiaStator.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = aimc.Js "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) aimc.inertiaStator.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real aimc.inertiaStator.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real aimc.inertiaStator.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real aimc.inertiaStator.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   Real sineVoltage.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real sineVoltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real sineVoltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real sineVoltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real sineVoltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real sineVoltage.offset(quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offset";
//   parameter Real sineVoltage.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
//   output Real sineVoltage.signalSource.y "Connector of Real output signal";
//   parameter Real sineVoltage.signalSource.amplitude = sineVoltage.V "Amplitude of sine wave";
//   parameter Real sineVoltage.signalSource.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = sineVoltage.freqHz "Frequency of sine wave";
//   parameter Real sineVoltage.signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = sineVoltage.phase "Phase of sine wave";
//   parameter Real sineVoltage.signalSource.offset = sineVoltage.offset "Offset of output signal";
//   parameter Real sineVoltage.signalSource.startTime(quantity = "Time", unit = "s") = sineVoltage.startTime "Output = offset for time < startTime";
//   protected constant Real sineVoltage.signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.V(quantity = "ElectricPotential", unit = "V", start = 1.0) = 1.4142135623731 * VNominal "Amplitude of sine wave";
//   parameter Real sineVoltage.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phase of sine wave";
//   parameter Real sineVoltage.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = fNominal "Frequency of sine wave";
//   Real ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Boolean booleanStep.y "Connector of Boolean output signal";
//   parameter Real booleanStep.startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
//   parameter Boolean booleanStep.startValue = false "Output before startTime";
//   Real idealCloser.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealCloser.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealCloser.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealCloser.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealCloser.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealCloser.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real idealCloser.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealCloser.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealCloser.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealCloser.Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
//   parameter Real idealCloser.Goff(quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
//   input Boolean idealCloser.control "true => p--n connected, false => switch open";
//   protected Real idealCloser.s(unit = "1") "Auxiliary variable";
//   protected constant Real idealCloser.unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealCloser.unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   Real loadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real loadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real loadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real loadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = JLoad "Moment of inertia";
//   parameter enumeration(never, avoid, default, prefer, always) loadInertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
//   Real loadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", StateSelect = StateSelect.default) "Absolute rotation angle of component";
//   Real loadInertia.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
//   Real loadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
//   parameter Boolean quadraticLoadTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real quadraticLoadTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real quadraticLoadTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real quadraticLoadTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real quadraticLoadTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real quadraticLoadTorque.tau_nominal(quantity = "Torque", unit = "N.m") = -TLoad "Nominal torque (if negative, torque is acting as load)";
//   parameter Boolean quadraticLoadTorque.TorqueDirection = false "Same direction of torque in both directions of rotation";
//   parameter Real quadraticLoadTorque.w_nominal(quantity = "AngularVelocity", unit = "rad/s", min = 1e-15) = wLoad "Nominal speed";
//   Real quadraticLoadTorque.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange with respect to support (= der(phi))";
//   Real quadraticLoadTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   constant Integer TerminalBox1.m = 3 "number of phases";
//   parameter String TerminalBox1.terminalConnection(start = "Y") = "D" "choose Y=star/D=delta";
//   parameter Integer TerminalBox1.plug_sp.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plug_sn.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plugSupply.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plugSupply.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugSupply.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugSupply.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugSupply.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.delta.m(min = 2) = 3 "number of phases";
//   parameter Integer TerminalBox1.delta.plug_p.m(min = 1) = TerminalBox1.delta.m "number of phases";
//   Real TerminalBox1.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.delta.plug_n.m(min = 1) = TerminalBox1.delta.m "number of phases";
//   Real TerminalBox1.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer plugToPin_p3.m(min = 1) = 3 "number of phases";
//   parameter Integer plugToPin_p3.k(min = 1, max = plugToPin_p3.m, start = 1) = 3 "phase index";
//   parameter Integer plugToPin_p3.plug_p.m(min = 1) = plugToPin_p3.m "number of phases";
//   Real plugToPin_p3.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p3.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p3.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p3.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p3.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p3.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p3.pin_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p3.pin_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer plugToPin_p2.m(min = 1) = 3 "number of phases";
//   parameter Integer plugToPin_p2.k(min = 1, max = plugToPin_p2.m, start = 1) = 2 "phase index";
//   parameter Integer plugToPin_p2.plug_p.m(min = 1) = plugToPin_p2.m "number of phases";
//   Real plugToPin_p2.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p2.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p2.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p2.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p2.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p2.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p2.pin_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p2.pin_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer plugToPin_p1.m(min = 1) = 3 "number of phases";
//   parameter Integer plugToPin_p1.k(min = 1, max = plugToPin_p1.m, start = 1) = 1 "phase index";
//   parameter Integer plugToPin_p1.plug_p.m(min = 1) = plugToPin_p1.m "number of phases";
//   Real plugToPin_p1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real plugToPin_p1.pin_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real plugToPin_p1.pin_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cRun.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real cRun.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real cRun.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cRun.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cRun.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cRun.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real cRun.C(quantity = "Capacitance", unit = "F", min = 0.0, start = 1.0) = Cr "Capacitance";
//   Real cStart.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real cStart.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real cStart.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cStart.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real cStart.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real cStart.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real cStart.C(quantity = "Capacitance", unit = "F", min = 0.0, start = 1.0) = Cs "Capacitance";
//   Real idealOpener.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real idealOpener.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real idealOpener.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealOpener.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real idealOpener.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real idealOpener.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Boolean idealOpener.useHeatPort = false "=true, if HeatPort is enabled";
//   parameter Real idealOpener.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Fixed device temperature if useHeatPort = false";
//   Real idealOpener.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via HeatPort";
//   Real idealOpener.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Temperature of HeatPort";
//   parameter Real idealOpener.Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
//   parameter Real idealOpener.Goff(quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
//   input Boolean idealOpener.control "true => switch open, false => p--n connected";
//   protected Real idealOpener.s(unit = "1") "Auxiliary variable";
//   protected constant Real idealOpener.unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
//   protected constant Real idealOpener.unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
//   parameter Real greaterThreshold.threshold = wSwitch "Comparison with respect to threshold";
//   input Real greaterThreshold.u "Connector of Boolean input signal";
//   output Boolean greaterThreshold.y "Connector of Boolean output signal";
//   parameter Real fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real relSpeedSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real relSpeedSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real relSpeedSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real relSpeedSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real relSpeedSensor.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg") "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//   output Real relSpeedSensor.w_rel "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi))";
// equation
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.inertiaRotor.phi = aimc.inertiaRotor.flange_b.phi;
//   aimc.inertiaRotor.w = der(aimc.inertiaRotor.phi);
//   aimc.inertiaRotor.a = der(aimc.inertiaRotor.w);
//   aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.inertiaRotor.flange_a.tau + aimc.inertiaRotor.flange_b.tau;
//   assert(1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[1].R_actual = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (aimc.rs.resistor[1].T_heatPort - aimc.rs.resistor[1].T_ref));
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * aimc.rs.resistor[1].i;
//   aimc.rs.resistor[1].i = aimc.rs.resistor[1].p.i;
//   0.0 = aimc.rs.resistor[1].p.i + aimc.rs.resistor[1].n.i;
//   aimc.rs.resistor[1].v = aimc.rs.resistor[1].p.v - aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[1].T_heatPort = aimc.rs.resistor[1].T;
//   assert(1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[2].R_actual = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (aimc.rs.resistor[2].T_heatPort - aimc.rs.resistor[2].T_ref));
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * aimc.rs.resistor[2].i;
//   aimc.rs.resistor[2].i = aimc.rs.resistor[2].p.i;
//   0.0 = aimc.rs.resistor[2].p.i + aimc.rs.resistor[2].n.i;
//   aimc.rs.resistor[2].v = aimc.rs.resistor[2].p.v - aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[2].T_heatPort = aimc.rs.resistor[2].T;
//   assert(1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref) >= 1e-15,"Temperature outside scope of model!");
//   aimc.rs.resistor[3].R_actual = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (aimc.rs.resistor[3].T_heatPort - aimc.rs.resistor[3].T_ref));
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * aimc.rs.resistor[3].i;
//   aimc.rs.resistor[3].i = aimc.rs.resistor[3].p.i;
//   0.0 = aimc.rs.resistor[3].p.i + aimc.rs.resistor[3].n.i;
//   aimc.rs.resistor[3].v = aimc.rs.resistor[3].p.v - aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[3].T_heatPort = aimc.rs.resistor[3].T;
//   aimc.rs.v[1] = aimc.rs.plug_p.pin[1].v - aimc.rs.plug_n.pin[1].v;
//   aimc.rs.v[2] = aimc.rs.plug_p.pin[2].v - aimc.rs.plug_n.pin[2].v;
//   aimc.rs.v[3] = aimc.rs.plug_p.pin[3].v - aimc.rs.plug_n.pin[3].v;
//   aimc.rs.i[1] = aimc.rs.plug_p.pin[1].i;
//   aimc.rs.i[2] = aimc.rs.plug_p.pin[2].i;
//   aimc.rs.i[3] = aimc.rs.plug_p.pin[3].i;
//   aimc.lssigma.inductor[1].L * der(aimc.lssigma.inductor[1].i) = aimc.lssigma.inductor[1].v;
//   aimc.lssigma.inductor[1].v = aimc.lssigma.inductor[1].p.v - aimc.lssigma.inductor[1].n.v;
//   0.0 = aimc.lssigma.inductor[1].p.i + aimc.lssigma.inductor[1].n.i;
//   aimc.lssigma.inductor[1].i = aimc.lssigma.inductor[1].p.i;
//   aimc.lssigma.inductor[2].L * der(aimc.lssigma.inductor[2].i) = aimc.lssigma.inductor[2].v;
//   aimc.lssigma.inductor[2].v = aimc.lssigma.inductor[2].p.v - aimc.lssigma.inductor[2].n.v;
//   0.0 = aimc.lssigma.inductor[2].p.i + aimc.lssigma.inductor[2].n.i;
//   aimc.lssigma.inductor[2].i = aimc.lssigma.inductor[2].p.i;
//   aimc.lssigma.inductor[3].L * der(aimc.lssigma.inductor[3].i) = aimc.lssigma.inductor[3].v;
//   aimc.lssigma.inductor[3].v = aimc.lssigma.inductor[3].p.v - aimc.lssigma.inductor[3].n.v;
//   0.0 = aimc.lssigma.inductor[3].p.i + aimc.lssigma.inductor[3].n.i;
//   aimc.lssigma.inductor[3].i = aimc.lssigma.inductor[3].p.i;
//   aimc.lssigma.v[1] = aimc.lssigma.plug_p.pin[1].v - aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.v[2] = aimc.lssigma.plug_p.pin[2].v - aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.v[3] = aimc.lssigma.plug_p.pin[3].v - aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.i[1] = aimc.lssigma.plug_p.pin[1].i;
//   aimc.lssigma.i[2] = aimc.lssigma.plug_p.pin[2].i;
//   aimc.lssigma.i[3] = aimc.lssigma.plug_p.pin[3].i;
//   aimc.spacePhasorS.gnd.p.v = 0.0;
//   aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[1].v - aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[2].v - aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.spacePhasorS.plug_p.pin[3].v - aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = aimc.spacePhasorS.plug_p.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = aimc.spacePhasorS.plug_p.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = aimc.spacePhasorS.plug_p.pin[3].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[1] = -aimc.spacePhasorS.plug_n.pin[1].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[2] = -aimc.spacePhasorS.plug_n.pin[2].i;
//   aimc.spacePhasorS.turnsRatio * aimc.spacePhasorS.i[3] = -aimc.spacePhasorS.plug_n.pin[3].i;
//   aimc.spacePhasorS.zero.v = 0.333333333333333 * (aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]));
//   aimc.spacePhasorS.spacePhasor.v_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.v[3]);
//   aimc.spacePhasorS.spacePhasor.v_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.v[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.v[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.v[3]);
//   -aimc.spacePhasorS.zero.i = 0.333333333333333 * (aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]));
//   -aimc.spacePhasorS.spacePhasor.i_[1] = aimc.spacePhasorS.TransformationMatrix[1,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[1,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[1,3] * aimc.spacePhasorS.i[3]);
//   -aimc.spacePhasorS.spacePhasor.i_[2] = aimc.spacePhasorS.TransformationMatrix[2,1] * aimc.spacePhasorS.i[1] + (aimc.spacePhasorS.TransformationMatrix[2,2] * aimc.spacePhasorS.i[2] + aimc.spacePhasorS.TransformationMatrix[2,3] * aimc.spacePhasorS.i[3]);
//   aimc.airGapS.i_ms[1] = aimc.airGapS.i_ss[1] + aimc.airGapS.i_rs[1];
//   aimc.airGapS.i_ms[2] = aimc.airGapS.i_ss[2] + aimc.airGapS.i_rs[2];
//   aimc.airGapS.psi_ms[1] = aimc.airGapS.L[1,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[1,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_ms[2] = aimc.airGapS.L[2,1] * aimc.airGapS.i_ms[1] + aimc.airGapS.L[2,2] * aimc.airGapS.i_ms[2];
//   aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2];
//   aimc.airGapS.gamma = Real(aimc.airGapS.p) * (aimc.airGapS.flange.phi - aimc.airGapS.support.phi);
//   aimc.airGapS.RotationMatrix[1,1] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[1,2] = -sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,1] = sin(aimc.airGapS.gamma);
//   aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma);
//   aimc.airGapS.i_ss[1] = aimc.airGapS.spacePhasor_s.i_[1];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.spacePhasor_s.i_[2];
//   aimc.airGapS.i_ss[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_ss[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_sr[2];
//   aimc.airGapS.i_rr[1] = aimc.airGapS.spacePhasor_r.i_[1];
//   aimc.airGapS.i_rr[2] = aimc.airGapS.spacePhasor_r.i_[2];
//   aimc.airGapS.i_rs[1] = aimc.airGapS.RotationMatrix[1,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[1,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.i_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.i_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.i_rr[2];
//   aimc.airGapS.spacePhasor_s.v_[1] = der(aimc.airGapS.psi_ms[1]);
//   aimc.airGapS.spacePhasor_s.v_[2] = der(aimc.airGapS.psi_ms[2]);
//   aimc.airGapS.spacePhasor_r.v_[1] = der(aimc.airGapS.psi_mr[1]);
//   aimc.airGapS.spacePhasor_r.v_[2] = der(aimc.airGapS.psi_mr[2]);
//   aimc.airGapS.tauElectrical = Real(aimc.airGapS.m) * (Real(aimc.airGapS.p) * (aimc.airGapS.spacePhasor_s.i_[2] * aimc.airGapS.psi_ms[1] - aimc.airGapS.spacePhasor_s.i_[1] * aimc.airGapS.psi_ms[2]) / 2.0);
//   aimc.airGapS.flange.tau = -aimc.airGapS.tauElectrical;
//   aimc.airGapS.support.tau = aimc.airGapS.tauElectrical;
//   aimc.squirrelCageR.spacePhasor_r.v_[1] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[1] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[1]);
//   aimc.squirrelCageR.spacePhasor_r.v_[2] = aimc.squirrelCageR.Rr * aimc.squirrelCageR.spacePhasor_r.i_[2] + aimc.squirrelCageR.Lrsigma * der(aimc.squirrelCageR.spacePhasor_r.i_[2]);
//   aimc.inertiaStator.phi = aimc.inertiaStator.flange_a.phi;
//   aimc.inertiaStator.phi = aimc.inertiaStator.flange_b.phi;
//   aimc.inertiaStator.w = der(aimc.inertiaStator.phi);
//   aimc.inertiaStator.a = der(aimc.inertiaStator.w);
//   aimc.inertiaStator.J * aimc.inertiaStator.a = aimc.inertiaStator.flange_a.tau + aimc.inertiaStator.flange_b.tau;
//   assert(aimc.spacePhasorS.plug_n.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(aimc.lssigma.plug_n.m == aimc.spacePhasorS.plug_p.m,"automatically generated from connect");
//   assert(aimc.rs.plug_n.m == aimc.lssigma.plug_p.m,"automatically generated from connect");
//   assert(aimc.plug_sp.m == aimc.rs.plug_p.m,"automatically generated from connect");
//   sineVoltage.signalSource.y = sineVoltage.signalSource.offset + (if time < sineVoltage.signalSource.startTime then 0.0 else sineVoltage.signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.signalSource.freqHz * (time - sineVoltage.signalSource.startTime)) + sineVoltage.signalSource.phase));
//   sineVoltage.v = sineVoltage.signalSource.y;
//   sineVoltage.v = sineVoltage.p.v - sineVoltage.n.v;
//   0.0 = sineVoltage.p.i + sineVoltage.n.i;
//   sineVoltage.i = sineVoltage.p.i;
//   ground.p.v = 0.0;
//   booleanStep.y = if time >= booleanStep.startTime then  NOT booleanStep.startValue else booleanStep.startValue;
//   idealCloser.v = idealCloser.s * (if idealCloser.control then idealCloser.Ron else 1.0);
//   idealCloser.i = idealCloser.s * (if idealCloser.control then 1.0 else idealCloser.Goff);
//   idealCloser.LossPower = idealCloser.v * idealCloser.i;
//   idealCloser.i = idealCloser.p.i;
//   0.0 = idealCloser.p.i + idealCloser.n.i;
//   idealCloser.v = idealCloser.p.v - idealCloser.n.v;
//   idealCloser.T_heatPort = idealCloser.T;
//   loadInertia.phi = loadInertia.flange_a.phi;
//   loadInertia.phi = loadInertia.flange_b.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.J * loadInertia.a = loadInertia.flange_a.tau + loadInertia.flange_b.tau;
//   quadraticLoadTorque.w = der(quadraticLoadTorque.phi);
//   quadraticLoadTorque.tau = -quadraticLoadTorque.flange.tau;
//   quadraticLoadTorque.tau = quadraticLoadTorque.tau_nominal * smooth(1,if quadraticLoadTorque.w >= 0.0 then (quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0 else -(quadraticLoadTorque.w / quadraticLoadTorque.w_nominal) ^ 2.0);
//   quadraticLoadTorque.phi = quadraticLoadTorque.flange.phi - quadraticLoadTorque.phi_support;
//   quadraticLoadTorque.phi_support = 0.0;
//   assert(TerminalBox1.plug_sn.m == TerminalBox1.delta.plug_n.m,"automatically generated from connect");
//   assert(TerminalBox1.delta.plug_p.m == TerminalBox1.plug_sp.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sp.m == TerminalBox1.plugSupply.m,"automatically generated from connect");
//   plugToPin_p3.pin_p.v = plugToPin_p3.plug_p.pin[3].v;
//   plugToPin_p3.plug_p.pin[1].i = if 1 == plugToPin_p3.k then -plugToPin_p3.pin_p.i else 0.0;
//   plugToPin_p3.plug_p.pin[2].i = if 2 == plugToPin_p3.k then -plugToPin_p3.pin_p.i else 0.0;
//   plugToPin_p3.plug_p.pin[3].i = if 3 == plugToPin_p3.k then -plugToPin_p3.pin_p.i else 0.0;
//   plugToPin_p2.pin_p.v = plugToPin_p2.plug_p.pin[2].v;
//   plugToPin_p2.plug_p.pin[1].i = if 1 == plugToPin_p2.k then -plugToPin_p2.pin_p.i else 0.0;
//   plugToPin_p2.plug_p.pin[2].i = if 2 == plugToPin_p2.k then -plugToPin_p2.pin_p.i else 0.0;
//   plugToPin_p2.plug_p.pin[3].i = if 3 == plugToPin_p2.k then -plugToPin_p2.pin_p.i else 0.0;
//   plugToPin_p1.pin_p.v = plugToPin_p1.plug_p.pin[1].v;
//   plugToPin_p1.plug_p.pin[1].i = if 1 == plugToPin_p1.k then -plugToPin_p1.pin_p.i else 0.0;
//   plugToPin_p1.plug_p.pin[2].i = if 2 == plugToPin_p1.k then -plugToPin_p1.pin_p.i else 0.0;
//   plugToPin_p1.plug_p.pin[3].i = if 3 == plugToPin_p1.k then -plugToPin_p1.pin_p.i else 0.0;
//   cRun.i = cRun.C * der(cRun.v);
//   cRun.v = cRun.p.v - cRun.n.v;
//   0.0 = cRun.p.i + cRun.n.i;
//   cRun.i = cRun.p.i;
//   cStart.i = cStart.C * der(cStart.v);
//   cStart.v = cStart.p.v - cStart.n.v;
//   0.0 = cStart.p.i + cStart.n.i;
//   cStart.i = cStart.p.i;
//   idealOpener.v = idealOpener.s * (if idealOpener.control then 1.0 else idealOpener.Ron);
//   idealOpener.i = idealOpener.s * (if idealOpener.control then idealOpener.Goff else 1.0);
//   idealOpener.LossPower = idealOpener.v * idealOpener.i;
//   idealOpener.i = idealOpener.p.i;
//   0.0 = idealOpener.p.i + idealOpener.n.i;
//   idealOpener.v = idealOpener.p.v - idealOpener.n.v;
//   idealOpener.T_heatPort = idealOpener.T;
//   greaterThreshold.y = greaterThreshold.u > greaterThreshold.threshold;
//   fixed.flange.phi = fixed.phi0;
//   relSpeedSensor.phi_rel = relSpeedSensor.flange_b.phi - relSpeedSensor.flange_a.phi;
//   relSpeedSensor.w_rel = der(relSpeedSensor.phi_rel);
//   0.0 = relSpeedSensor.flange_a.tau;
//   0.0 = relSpeedSensor.flange_a.tau + relSpeedSensor.flange_b.tau;
//   assert(TerminalBox1.plug_sn.m == aimc.plug_sn.m,"automatically generated from connect");
//   assert(TerminalBox1.plug_sp.m == aimc.plug_sp.m,"automatically generated from connect");
//   assert(TerminalBox1.plugSupply.m == plugToPin_p2.plug_p.m,"automatically generated from connect");
//   assert(TerminalBox1.plugSupply.m == plugToPin_p3.plug_p.m,"automatically generated from connect");
//   assert(TerminalBox1.plugSupply.m == plugToPin_p1.plug_p.m,"automatically generated from connect");
//   aimc.flange.tau + (relSpeedSensor.flange_b.tau + loadInertia.flange_a.tau) = 0.0;
//   aimc.flange.phi = loadInertia.flange_a.phi;
//   aimc.flange.phi = relSpeedSensor.flange_b.phi;
//   aimc.support.tau + (relSpeedSensor.flange_a.tau + fixed.flange.tau) = 0.0;
//   aimc.support.phi = fixed.flange.phi;
//   aimc.support.phi = relSpeedSensor.flange_a.phi;
//   greaterThreshold.u = relSpeedSensor.w_rel;
//   TerminalBox1.plugSupply.pin[3].i + (plugToPin_p2.plug_p.pin[3].i + (plugToPin_p3.plug_p.pin[3].i + plugToPin_p1.plug_p.pin[3].i)) = 0.0;
//   TerminalBox1.plugSupply.pin[3].v = plugToPin_p1.plug_p.pin[3].v;
//   TerminalBox1.plugSupply.pin[3].v = plugToPin_p2.plug_p.pin[3].v;
//   TerminalBox1.plugSupply.pin[3].v = plugToPin_p3.plug_p.pin[3].v;
//   TerminalBox1.plugSupply.pin[2].i + (plugToPin_p2.plug_p.pin[2].i + (plugToPin_p3.plug_p.pin[2].i + plugToPin_p1.plug_p.pin[2].i)) = 0.0;
//   TerminalBox1.plugSupply.pin[2].v = plugToPin_p1.plug_p.pin[2].v;
//   TerminalBox1.plugSupply.pin[2].v = plugToPin_p2.plug_p.pin[2].v;
//   TerminalBox1.plugSupply.pin[2].v = plugToPin_p3.plug_p.pin[2].v;
//   TerminalBox1.plugSupply.pin[1].i + (plugToPin_p2.plug_p.pin[1].i + (plugToPin_p3.plug_p.pin[1].i + plugToPin_p1.plug_p.pin[1].i)) = 0.0;
//   TerminalBox1.plugSupply.pin[1].v = plugToPin_p1.plug_p.pin[1].v;
//   TerminalBox1.plugSupply.pin[1].v = plugToPin_p2.plug_p.pin[1].v;
//   TerminalBox1.plugSupply.pin[1].v = plugToPin_p3.plug_p.pin[1].v;
//   TerminalBox1.plug_sp.pin[3].i + aimc.plug_sp.pin[3].i = 0.0;
//   TerminalBox1.plug_sp.pin[3].v = aimc.plug_sp.pin[3].v;
//   TerminalBox1.plug_sp.pin[2].i + aimc.plug_sp.pin[2].i = 0.0;
//   TerminalBox1.plug_sp.pin[2].v = aimc.plug_sp.pin[2].v;
//   TerminalBox1.plug_sp.pin[1].i + aimc.plug_sp.pin[1].i = 0.0;
//   TerminalBox1.plug_sp.pin[1].v = aimc.plug_sp.pin[1].v;
//   TerminalBox1.plug_sn.pin[3].i + aimc.plug_sn.pin[3].i = 0.0;
//   TerminalBox1.plug_sn.pin[3].v = aimc.plug_sn.pin[3].v;
//   TerminalBox1.plug_sn.pin[2].i + aimc.plug_sn.pin[2].i = 0.0;
//   TerminalBox1.plug_sn.pin[2].v = aimc.plug_sn.pin[2].v;
//   TerminalBox1.plug_sn.pin[1].i + aimc.plug_sn.pin[1].i = 0.0;
//   TerminalBox1.plug_sn.pin[1].v = aimc.plug_sn.pin[1].v;
//   greaterThreshold.y = idealOpener.control;
//   idealOpener.p.i + (cRun.p.i + (idealCloser.n.i + plugToPin_p2.pin_p.i)) = 0.0;
//   cRun.p.v = idealCloser.n.v;
//   cRun.p.v = idealOpener.p.v;
//   cRun.p.v = plugToPin_p2.pin_p.v;
//   idealOpener.n.i + cStart.p.i = 0.0;
//   cStart.p.v = idealOpener.n.v;
//   cRun.n.i + (plugToPin_p1.pin_p.i + cStart.n.i) = 0.0;
//   cRun.n.v = cStart.n.v;
//   cRun.n.v = plugToPin_p1.pin_p.v;
//   loadInertia.flange_b.tau + quadraticLoadTorque.flange.tau = 0.0;
//   loadInertia.flange_b.phi = quadraticLoadTorque.flange.phi;
//   plugToPin_p3.pin_p.i + (ground.p.i + sineVoltage.n.i) = 0.0;
//   ground.p.v = plugToPin_p3.pin_p.v;
//   ground.p.v = sineVoltage.n.v;
//   booleanStep.y = idealCloser.control;
//   sineVoltage.p.i + idealCloser.p.i = 0.0;
//   idealCloser.p.v = sineVoltage.p.v;
//   TerminalBox1.delta.plug_p.pin[3].i + ((-TerminalBox1.plug_sp.pin[3].i) + (-TerminalBox1.plugSupply.pin[3].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[3].v = TerminalBox1.plugSupply.pin[3].v;
//   TerminalBox1.delta.plug_p.pin[3].v = TerminalBox1.plug_sp.pin[3].v;
//   TerminalBox1.delta.plug_p.pin[2].i + ((-TerminalBox1.plug_sp.pin[2].i) + (-TerminalBox1.plugSupply.pin[2].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[2].v = TerminalBox1.plugSupply.pin[2].v;
//   TerminalBox1.delta.plug_p.pin[2].v = TerminalBox1.plug_sp.pin[2].v;
//   TerminalBox1.delta.plug_p.pin[1].i + ((-TerminalBox1.plug_sp.pin[1].i) + (-TerminalBox1.plugSupply.pin[1].i)) = 0.0;
//   TerminalBox1.delta.plug_p.pin[1].v = TerminalBox1.plugSupply.pin[1].v;
//   TerminalBox1.delta.plug_p.pin[1].v = TerminalBox1.plug_sp.pin[1].v;
//   (-TerminalBox1.plug_sn.pin[3].i) + TerminalBox1.delta.plug_n.pin[3].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.plug_sn.pin[3].v;
//   (-TerminalBox1.plug_sn.pin[2].i) + TerminalBox1.delta.plug_n.pin[2].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.plug_sn.pin[2].v;
//   (-TerminalBox1.plug_sn.pin[1].i) + TerminalBox1.delta.plug_n.pin[1].i = 0.0;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.plug_sn.pin[1].v;
//   (-TerminalBox1.delta.plug_n.pin[3].i) + (-TerminalBox1.delta.plug_p.pin[1].i) = 0.0;
//   TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.delta.plug_p.pin[1].v;
//   (-TerminalBox1.delta.plug_n.pin[2].i) + (-TerminalBox1.delta.plug_p.pin[3].i) = 0.0;
//   TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.delta.plug_p.pin[3].v;
//   (-TerminalBox1.delta.plug_n.pin[1].i) + (-TerminalBox1.delta.plug_p.pin[2].i) = 0.0;
//   TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.delta.plug_p.pin[2].v;
//   aimc.airGapS.support.tau + ((-aimc.internalSupport.tau) + aimc.inertiaStator.flange_a.tau) = 0.0;
//   aimc.airGapS.support.phi = aimc.inertiaStator.flange_a.phi;
//   aimc.airGapS.support.phi = aimc.internalSupport.phi;
//   aimc.inertiaStator.flange_b.tau + (-aimc.support.tau) = 0.0;
//   aimc.inertiaStator.flange_b.phi = aimc.support.phi;
//   aimc.inertiaRotor.flange_b.tau + (-aimc.flange.tau) = 0.0;
//   aimc.flange.phi = aimc.inertiaRotor.flange_b.phi;
//   (-aimc.plug_sp.pin[3].i) + aimc.rs.plug_p.pin[3].i = 0.0;
//   aimc.plug_sp.pin[3].v = aimc.rs.plug_p.pin[3].v;
//   (-aimc.plug_sp.pin[2].i) + aimc.rs.plug_p.pin[2].i = 0.0;
//   aimc.plug_sp.pin[2].v = aimc.rs.plug_p.pin[2].v;
//   (-aimc.plug_sp.pin[1].i) + aimc.rs.plug_p.pin[1].i = 0.0;
//   aimc.plug_sp.pin[1].v = aimc.rs.plug_p.pin[1].v;
//   aimc.rs.plug_n.pin[3].i + aimc.lssigma.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_p.pin[3].v = aimc.rs.plug_n.pin[3].v;
//   aimc.rs.plug_n.pin[2].i + aimc.lssigma.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_p.pin[2].v = aimc.rs.plug_n.pin[2].v;
//   aimc.rs.plug_n.pin[1].i + aimc.lssigma.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_p.pin[1].v = aimc.rs.plug_n.pin[1].v;
//   aimc.lssigma.plug_n.pin[3].i + aimc.spacePhasorS.plug_p.pin[3].i = 0.0;
//   aimc.lssigma.plug_n.pin[3].v = aimc.spacePhasorS.plug_p.pin[3].v;
//   aimc.lssigma.plug_n.pin[2].i + aimc.spacePhasorS.plug_p.pin[2].i = 0.0;
//   aimc.lssigma.plug_n.pin[2].v = aimc.spacePhasorS.plug_p.pin[2].v;
//   aimc.lssigma.plug_n.pin[1].i + aimc.spacePhasorS.plug_p.pin[1].i = 0.0;
//   aimc.lssigma.plug_n.pin[1].v = aimc.spacePhasorS.plug_p.pin[1].v;
//   aimc.spacePhasorS.plug_n.pin[3].i + (-aimc.plug_sn.pin[3].i) = 0.0;
//   aimc.plug_sn.pin[3].v = aimc.spacePhasorS.plug_n.pin[3].v;
//   aimc.spacePhasorS.plug_n.pin[2].i + (-aimc.plug_sn.pin[2].i) = 0.0;
//   aimc.plug_sn.pin[2].v = aimc.spacePhasorS.plug_n.pin[2].v;
//   aimc.spacePhasorS.plug_n.pin[1].i + (-aimc.plug_sn.pin[1].i) = 0.0;
//   aimc.plug_sn.pin[1].v = aimc.spacePhasorS.plug_n.pin[1].v;
//   aimc.spacePhasorS.ground.i + aimc.spacePhasorS.zero.i = 0.0;
//   aimc.spacePhasorS.ground.v = aimc.spacePhasorS.zero.v;
//   aimc.airGapS.flange.tau + aimc.inertiaRotor.flange_a.tau = 0.0;
//   aimc.airGapS.flange.phi = aimc.inertiaRotor.flange_a.phi;
//   aimc.spacePhasorS.spacePhasor.i_[1] + aimc.airGapS.spacePhasor_s.i_[1] = 0.0;
//   aimc.spacePhasorS.spacePhasor.i_[2] + aimc.airGapS.spacePhasor_s.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_s.v_[1] = aimc.spacePhasorS.spacePhasor.v_[1];
//   aimc.airGapS.spacePhasor_s.v_[2] = aimc.spacePhasorS.spacePhasor.v_[2];
//   aimc.airGapS.spacePhasor_r.i_[1] + aimc.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   aimc.airGapS.spacePhasor_r.i_[2] + aimc.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   aimc.airGapS.spacePhasor_r.v_[1] = aimc.squirrelCageR.spacePhasor_r.v_[1];
//   aimc.airGapS.spacePhasor_r.v_[2] = aimc.squirrelCageR.spacePhasor_r.v_[2];
//   aimc.spacePhasorS.gnd.p.i + (-aimc.spacePhasorS.ground.i) = 0.0;
//   aimc.spacePhasorS.gnd.p.v = aimc.spacePhasorS.ground.v;
//   aimc.lssigma.inductor[3].n.i + (-aimc.lssigma.plug_n.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].n.v = aimc.lssigma.plug_n.pin[3].v;
//   aimc.lssigma.inductor[2].n.i + (-aimc.lssigma.plug_n.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].n.v = aimc.lssigma.plug_n.pin[2].v;
//   aimc.lssigma.inductor[1].n.i + (-aimc.lssigma.plug_n.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].n.v = aimc.lssigma.plug_n.pin[1].v;
//   aimc.lssigma.inductor[3].p.i + (-aimc.lssigma.plug_p.pin[3].i) = 0.0;
//   aimc.lssigma.inductor[3].p.v = aimc.lssigma.plug_p.pin[3].v;
//   aimc.lssigma.inductor[2].p.i + (-aimc.lssigma.plug_p.pin[2].i) = 0.0;
//   aimc.lssigma.inductor[2].p.v = aimc.lssigma.plug_p.pin[2].v;
//   aimc.lssigma.inductor[1].p.i + (-aimc.lssigma.plug_p.pin[1].i) = 0.0;
//   aimc.lssigma.inductor[1].p.v = aimc.lssigma.plug_p.pin[1].v;
//   aimc.rs.resistor[3].n.i + (-aimc.rs.plug_n.pin[3].i) = 0.0;
//   aimc.rs.plug_n.pin[3].v = aimc.rs.resistor[3].n.v;
//   aimc.rs.resistor[2].n.i + (-aimc.rs.plug_n.pin[2].i) = 0.0;
//   aimc.rs.plug_n.pin[2].v = aimc.rs.resistor[2].n.v;
//   aimc.rs.resistor[1].n.i + (-aimc.rs.plug_n.pin[1].i) = 0.0;
//   aimc.rs.plug_n.pin[1].v = aimc.rs.resistor[1].n.v;
//   aimc.rs.resistor[3].p.i + (-aimc.rs.plug_p.pin[3].i) = 0.0;
//   aimc.rs.plug_p.pin[3].v = aimc.rs.resistor[3].p.v;
//   aimc.rs.resistor[2].p.i + (-aimc.rs.plug_p.pin[2].i) = 0.0;
//   aimc.rs.plug_p.pin[2].v = aimc.rs.resistor[2].p.v;
//   aimc.rs.resistor[1].p.i + (-aimc.rs.plug_p.pin[1].i) = 0.0;
//   aimc.rs.plug_p.pin[1].v = aimc.rs.resistor[1].p.v;
//   aimc.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_Steinmetz;
// "
// 
// "Check of Modelica.Electrical.Machines.Examples.AIMC_Steinmetz completed successfully.
// 
// 
// Class Modelica.Electrical.Machines.Examples.AIMC_Steinmetz has 315 equation(s) and 315 variable(s).
// 197 of these are trivial equation(s).
// "
// 
// endResult
