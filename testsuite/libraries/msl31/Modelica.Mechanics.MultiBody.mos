//name:        Modelica.Mechanics.MultiBody [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Mechanics.MultiBody
//status:      correct
//env: OPENMODELICALIBRARY=../../../libraries/msl31/
//
// instantiate/check model example
//

loadModel(Modelica); getErrorString();
loadModel(ModelicaServices); // Needed for PartialLineForce
getErrorString(); 

checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Types.RotationSequence); 
getErrorString();

// more checks here:
instantiateModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();

// even more checks here:
checkModel(Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines); getErrorString();

// Result:
// true
// ""
// true
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce completed successfully.
// 
// [Interfaces.mo:580:3-664:23:writable] Warning: Forcing full instantiation of partial class PartialLineForce during checkModel.
// Warning: No corresponding 'inner' declaration found for component world declared as 'outer '.
//   The existing 'inner' components are: 
//     There are no 'inner' components defined in the model in the any of the parent scopes of 'outer' component's scope: Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce.
//   Check if you have not misspelled the 'outer' component name.
//   Please declare an 'inner' component with the same name in the top scope.
//   Continuing flattening by only considering the 'outer' component declaration.
// 
// Class Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce has 1112 equation(s) and 1119 variable(s).
// 1099 of these are trivial equation(s).
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Types.RotationSequence completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Types.RotationSequence has 0 equation(s) and 0 variable(s).
// 0 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
// input Real[3, 3] T;
// input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
// output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*REAL*/(100000 * integer(mod(100.0 * cc1 - 0.5,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*REAL*/(1000 * integer(mod(100.0 * cc2 - 0.5,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*REAL*/(10 * integer(mod(100.0 * cc3 - 0.5,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*REAL*/(integer(mod(10.0 * csc - 0.5,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
//   parameter String shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real length(quantity = \"Length\", unit = \"m\") = 0.0 \"Length of visual object\";
//   input Real width(quantity = \"Length\", unit = \"m\") = 0.0 \"Width of visual object\";
//   input Real height(quantity = \"Length\", unit = \"m\") = 0.0 \"Height of visual object\";
//   input Real extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real color[1] = 255.0 \"Color of shape\";
//   input Real color[2] = 0.0 \"Color of shape\";
//   input Real color[3] = 0.0 \"Color of shape\";
//   input Real specularCoefficient = 0.7 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({lengthDirection[1],lengthDirection[2],lengthDirection[3]});
//   protected Real e_x[1](unit = \"1\") = if noEvent(abs_n_x < 1e-10) then 1.0 else lengthDirection[1] / abs_n_x;
//   protected Real e_x[2](unit = \"1\") = if noEvent(abs_n_x < 1e-10) then 0.0 else lengthDirection[2] / abs_n_x;
//   protected Real e_x[3](unit = \"1\") = if noEvent(abs_n_x < 1e-10) then 0.0 else lengthDirection[3] / abs_n_x;
//   protected Real n_z_aux[1](unit = \"1\") = e_x[2] * widthDirection[3] - e_x[3] * widthDirection[2];
//   protected Real n_z_aux[2](unit = \"1\") = e_x[3] * widthDirection[1] - e_x[1] * widthDirection[3];
//   protected Real n_z_aux[3](unit = \"1\") = e_x[1] * widthDirection[2] - e_x[2] * widthDirection[1];
//   protected Real e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{e_x[1],e_x[2],e_x[3]})[1];
//   protected Real e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{e_x[1],e_x[2],e_x[3]})[2];
//   protected Real e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{e_x[1],e_x[2],e_x[3]})[3];
//   protected output Real Form;
//   output Real rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Material;
//   protected output Real Extra;
// equation
//   Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(shapeType);
//   rxvisobj[1] = R.T[1,1] * e_x[1] + R.T[2,1] * e_x[2] + R.T[3,1] * e_x[3];
//   rxvisobj[2] = R.T[1,2] * e_x[1] + R.T[2,2] * e_x[2] + R.T[3,2] * e_x[3];
//   rxvisobj[3] = R.T[1,3] * e_x[1] + R.T[2,3] * e_x[2] + R.T[3,3] * e_x[3];
//   ryvisobj[1] = R.T[1,1] * e_y[1] + R.T[2,1] * e_y[2] + R.T[3,1] * e_y[3];
//   ryvisobj[2] = R.T[1,2] * e_y[1] + R.T[2,2] * e_y[2] + R.T[3,2] * e_y[3];
//   ryvisobj[3] = R.T[1,3] * e_y[1] + R.T[2,3] * e_y[2] + R.T[3,3] * e_y[3];
//   rvisobj = r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{R.T[1,1],R.T[1,2],R.T[1,3]},{R.T[2,1],R.T[2,2],R.T[2,3]},{R.T[3,1],R.T[3,2],R.T[3,3]}},{r_shape[1],r_shape[2],r_shape[3]});
//   size[1] = length;
//   size[2] = width;
//   size[3] = height;
//   Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(color[1] / 255.0,color[2] / 255.0,color[3] / 255.0,specularCoefficient);
//   Extra = extra;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape has 37 equation(s) and 37 variable(s).
// 19 of these are trivial equation(s).
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines has 33 equation(s) and 33 variable(s).
// 21 of these are trivial equation(s).
// "
// ""
// endResult
