//name:        Modelica.Mechanics [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Mechanics
//status:      correct
//env: OPENMODELICALIBRARY=../../../libraries/msl31/
//
// instantiate/check model example
//

loadModel(Modelica); getErrorString();
getErrorString(); 

instantiateModel(Modelica.Mechanics.Translational.Examples.Friction); getErrorString();
checkModel(Modelica.Mechanics.Translational.Examples.Friction); getErrorString();

// Result:
// true
// ""
// ""
// "function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Math.tempInterpol1
//   input Real u "input value (first column of table)";
//   input Real[:, :] table "table to be interpolated";
//   input Integer icol "column of table to be interpolated";
//   output Real y "interpolated input value (icol column of table)";
//   protected Integer i;
//   protected Integer n "number of rows of table";
//   protected Real u1;
//   protected Real u2;
//   protected Real y1;
//   protected Real y2;
// algorithm
//   n := size(table,1);
//   if n <= 1 then
//     y := table[1, icol];
//   else
//     if u <= table[1,1] then
//       i := 1;
//     else
//       i := 2;
//       while i < n AND u >= table[i, 1] loop
//         i := 1 + i;
//       end while;
//       i := i - 1;
//     end if;
//     u1 := table[i, 1];
//     u2 := table[1 + i, 1];
//     y1 := table[i, icol];
//     y2 := table[1 + i, icol];
//     assert( u2 > u1, "Table index must be increasing");
//     y := y1 + (y2 - y1) * (u - u1) / (u2 - u1);
//   end if;
// end Modelica.Math.tempInterpol1;
// 
// function Modelica.Mechanics.Translational.Examples.Utilities.GenerateStribeckFrictionTable
//   input Real F_prop(unit = "N.s/m", min = 0.0) "Velocity dependent friction coefficient";
//   input Real F_Coulomb(quantity = "Force", unit = "N") "Constant friction: Coulomb force";
//   input Real F_Stribeck(quantity = "Force", unit = "N") "Stribeck effect";
//   input Real fexp(unit = "s/m", min = 0.0) "Exponential decay";
//   input Real v_max "Generate table from v=0 ... v_max";
//   input Integer nTable(min = 2) = 100 "Number of table points";
//   output Real[nTable, 2] table "Friction table";
// algorithm
//   for i in 1:nTable loop
//     table[i, 1] := v_max * /*REAL*/(i - 1) / /*REAL*/(nTable - 1);
//     table[i, 2] := F_Coulomb + F_prop * table[i, 1] + F_Stribeck * exp(-fexp * table[i, 1]);
//   end for;
// end Modelica.Mechanics.Translational.Examples.Utilities.GenerateStribeckFrictionTable;
// 
// class Modelica.Mechanics.Translational.Examples.Friction
//   parameter Real stop1.smax(quantity = "Length", unit = "m", start = 25.0) = 25.0 "Right stop for (right end of) sliding mass";
//   parameter Real stop1.smin(quantity = "Length", unit = "m", start = -25.0) = -25.0 "Left stop for (left end of) sliding mass";
//   parameter Real stop1.v_small(quantity = "Velocity", unit = "m/s") = 0.001 "Relative velocity near to zero (see model info text)";
//   Real stop1.v_relfric(quantity = "Velocity", unit = "m/s") "Relative velocity between frictional surfaces";
//   Real stop1.a_relfric(quantity = "Acceleration", unit = "m/s2") "Relative acceleration between frictional surfaces";
//   Real stop1.f(quantity = "Force", unit = "N") "Friction force (positive, if directed in opposite direction of v_rel)";
//   Real stop1.f0(quantity = "Force", unit = "N") "Friction force for v=0 and forward sliding";
//   Real stop1.f0_max(quantity = "Force", unit = "N") "Maximum friction force for v=0 and locked";
//   Boolean stop1.free "true, if frictional element is not active";
//   Real stop1.sa(unit = "1") "Path parameter of friction characteristic f = f(a_relfric)";
//   Boolean stop1.startForward(start = false, fixed = true) "= true, if v_rel=0 and start of forward sliding or v_rel > v_small";
//   Boolean stop1.startBackward(start = false, fixed = true) "= true, if v_rel=0 and start of backward sliding or v_rel < -v_small";
//   Boolean stop1.locked(start = false) "true, if v_rel=0 and not sliding";
//   Real stop1.s(quantity = "Length", unit = "m", start = 0.0, fixed = true, StateSelect = StateSelect.always) "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
//   parameter Real stop1.L(quantity = "Length", unit = "m", start = 0.0) = 1.0 "Length of component, from left flange to right flange (= flange_b.s - flange_a.s)";
//   Real stop1.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real stop1.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real stop1.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real stop1.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   constant Integer stop1.Unknown = 3 "Value of mode is not known";
//   constant Integer stop1.Free = 2 "Element is not active";
//   constant Integer stop1.Forward = 1 "v_rel > 0 (forward sliding)";
//   constant Integer stop1.Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
//   constant Integer stop1.Backward = -1 "v_rel < 0 (backward sliding)";
//   Integer stop1.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real stop1.unitAcceleration(quantity = "Acceleration", unit = "m/s2") = 1.0;
//   protected constant Real stop1.unitForce(quantity = "Force", unit = "N") = 1.0;
//   Real stop1.v(quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true, StateSelect = StateSelect.always) "Absolute velocity of flange_a and flange_b";
//   Real stop1.a(quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of flange_a and flange_b";
//   parameter Real stop1.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "mass";
//   parameter Real stop1.F_prop(unit = "N.s/m", min = 0.0, start = 1.0) = 1.0 "Velocity dependent friction";
//   parameter Real stop1.F_Coulomb(quantity = "Force", unit = "N", start = 5.0) = 5.0 "Constant friction: Coulomb force";
//   parameter Real stop1.F_Stribeck(quantity = "Force", unit = "N", start = 10.0) = 10.0 "Stribeck effect";
//   parameter Real stop1.fexp(unit = "s/m", min = 0.0, start = 2.0) = 2.0 "Exponential decay";
//   Integer stop1.stopped = if stop1.s <= stop1.smin + stop1.L / 2.0 then -1 else if stop1.s >= stop1.smax - stop1.L / 2.0 then 1 else 0;
//   parameter Boolean force.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real force.s(quantity = "Length", unit = "m") = force.flange.s - force.s_support "distance between flange and support (= flange.s - support.s)";
//   Real force.flange.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real force.flange.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   protected Real force.s_support(quantity = "Length", unit = "m") "Absolute position of support flange";
//   input Real force.f "driving force as input signal";
//   output Real sineForce.y "Connector of Real output signal";
//   parameter Real sineForce.amplitude = 25.0 "Amplitude of sine wave";
//   parameter Real sineForce.freqHz(quantity = "Frequency", unit = "Hz", start = 1.0) = 0.25 "Frequency of sine wave";
//   parameter Real sineForce.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phase of sine wave";
//   parameter Real sineForce.offset = 0.0 "Offset of output signal";
//   parameter Real sineForce.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
//   protected constant Real sineForce.pi = 3.14159265358979;
//   parameter Real stop2.smax(quantity = "Length", unit = "m", start = 25.0) = 0.9 "Right stop for (right end of) sliding mass";
//   parameter Real stop2.smin(quantity = "Length", unit = "m", start = -25.0) = -0.9 "Left stop for (left end of) sliding mass";
//   parameter Real stop2.v_small(quantity = "Velocity", unit = "m/s") = 0.001 "Relative velocity near to zero (see model info text)";
//   Real stop2.v_relfric(quantity = "Velocity", unit = "m/s") "Relative velocity between frictional surfaces";
//   Real stop2.a_relfric(quantity = "Acceleration", unit = "m/s2") "Relative acceleration between frictional surfaces";
//   Real stop2.f(quantity = "Force", unit = "N") "Friction force (positive, if directed in opposite direction of v_rel)";
//   Real stop2.f0(quantity = "Force", unit = "N") "Friction force for v=0 and forward sliding";
//   Real stop2.f0_max(quantity = "Force", unit = "N") "Maximum friction force for v=0 and locked";
//   Boolean stop2.free "true, if frictional element is not active";
//   Real stop2.sa(unit = "1") "Path parameter of friction characteristic f = f(a_relfric)";
//   Boolean stop2.startForward(start = false, fixed = true) "= true, if v_rel=0 and start of forward sliding or v_rel > v_small";
//   Boolean stop2.startBackward(start = false, fixed = true) "= true, if v_rel=0 and start of backward sliding or v_rel < -v_small";
//   Boolean stop2.locked(start = false) "true, if v_rel=0 and not sliding";
//   Real stop2.s(quantity = "Length", unit = "m", start = 0.0, fixed = true, StateSelect = StateSelect.always) "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
//   parameter Real stop2.L(quantity = "Length", unit = "m", start = 0.0) = 1.0 "Length of component, from left flange to right flange (= flange_b.s - flange_a.s)";
//   Real stop2.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real stop2.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real stop2.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real stop2.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   constant Integer stop2.Unknown = 3 "Value of mode is not known";
//   constant Integer stop2.Free = 2 "Element is not active";
//   constant Integer stop2.Forward = 1 "v_rel > 0 (forward sliding)";
//   constant Integer stop2.Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
//   constant Integer stop2.Backward = -1 "v_rel < 0 (backward sliding)";
//   Integer stop2.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real stop2.unitAcceleration(quantity = "Acceleration", unit = "m/s2") = 1.0;
//   protected constant Real stop2.unitForce(quantity = "Force", unit = "N") = 1.0;
//   Real stop2.v(quantity = "Velocity", unit = "m/s", start = -5.0, fixed = true, StateSelect = StateSelect.always) "Absolute velocity of flange_a and flange_b";
//   Real stop2.a(quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of flange_a and flange_b";
//   parameter Real stop2.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "mass";
//   parameter Real stop2.F_prop(unit = "N.s/m", min = 0.0, start = 1.0) = 1.0 "Velocity dependent friction";
//   parameter Real stop2.F_Coulomb(quantity = "Force", unit = "N", start = 5.0) = 3.0 "Constant friction: Coulomb force";
//   parameter Real stop2.F_Stribeck(quantity = "Force", unit = "N", start = 10.0) = 5.0 "Stribeck effect";
//   parameter Real stop2.fexp(unit = "s/m", min = 0.0, start = 2.0) = 2.0 "Exponential decay";
//   Integer stop2.stopped = if stop2.s <= stop2.smin + stop2.L / 2.0 then -1 else if stop2.s >= stop2.smax - stop2.L / 2.0 then 1 else 0;
//   Real spring.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real spring.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real spring.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real spring.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real spring.s_rel(quantity = "Length", unit = "m", min = 0.0, start = 0.0) "relative distance (= flange_b.s - flange_a.s)";
//   Real spring.f(quantity = "Force", unit = "N") "force between flanges (positive in direction of flange axis R)";
//   parameter Real spring.c(quantity = "TranslationalSpringConstant", unit = "N/m", min = 0.0, start = 1.0) = 500.0 "spring constant ";
//   parameter Real spring.s_rel0(quantity = "Length", unit = "m", min = 0.0) = 1.0 "unstretched spring length";
//   parameter Real fixed2.s0(quantity = "Length", unit = "m") = -1.75 "fixed offset position of housing";
//   Real fixed2.flange.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real fixed2.flange.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   parameter Boolean force2.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real force2.s(quantity = "Length", unit = "m") = force2.flange.s - force2.s_support "distance between flange and support (= flange.s - support.s)";
//   Real force2.flange.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real force2.flange.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   protected Real force2.s_support(quantity = "Length", unit = "m") "Absolute position of support flange";
//   input Real force2.f "driving force as input signal";
//   Real mass.s(quantity = "Length", unit = "m", start = 0.0, fixed = true, StateSelect = StateSelect.default) "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
//   parameter Real mass.L(quantity = "Length", unit = "m", start = 0.0) = 1.0 "Length of component, from left flange to right flange (= flange_b.s - flange_a.s)";
//   Real mass.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real mass.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real mass.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real mass.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   parameter Real mass.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "mass of the sliding mass";
//   parameter enumeration(never, avoid, default, prefer, always) mass.stateSelect = StateSelect.default "Priority to use s and v as states";
//   Real mass.v(quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true, StateSelect = StateSelect.default) "absolute velocity of component";
//   Real mass.a(quantity = "Acceleration", unit = "m/s2", start = 0.0) "absolute acceleration of component";
//   parameter Boolean supportFriction.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real supportFriction.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real supportFriction.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real supportFriction.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real supportFriction.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real supportFriction.s_a(quantity = "Length", unit = "m") = supportFriction.flange_a.s - supportFriction.s_support "Distance between left flange and support";
//   Real supportFriction.s_b(quantity = "Length", unit = "m") = supportFriction.flange_b.s - supportFriction.s_support "Distance between right flange and support";
//   protected Real supportFriction.s_support(quantity = "Length", unit = "m") "Absolute position of support flange";
//   parameter Real supportFriction.v_small(quantity = "Velocity", unit = "m/s") = 0.001 "Relative velocity near to zero (see model info text)";
//   Real supportFriction.v_relfric(quantity = "Velocity", unit = "m/s") "Relative velocity between frictional surfaces";
//   Real supportFriction.a_relfric(quantity = "Acceleration", unit = "m/s2") "Relative acceleration between frictional surfaces";
//   Real supportFriction.f0(quantity = "Force", unit = "N") "Friction force for v=0 and forward sliding";
//   Real supportFriction.f0_max(quantity = "Force", unit = "N") "Maximum friction force for v=0 and locked";
//   Boolean supportFriction.free "true, if frictional element is not active";
//   Real supportFriction.sa(unit = "1") "Path parameter of friction characteristic f = f(a_relfric)";
//   Boolean supportFriction.startForward(start = false, fixed = true) "true, if v_rel=0 and start of forward sliding";
//   Boolean supportFriction.startBackward(start = false, fixed = true) "true, if v_rel=0 and start of backward sliding";
//   Boolean supportFriction.locked(start = false) "true, if v_rel=0 and not sliding";
//   constant Integer supportFriction.Unknown = 3 "Value of mode is not known";
//   constant Integer supportFriction.Free = 2 "Element is not active";
//   constant Integer supportFriction.Forward = 1 "v_rel > 0 (forward sliding)";
//   constant Integer supportFriction.Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
//   constant Integer supportFriction.Backward = -1 "v_rel < 0 (backward sliding)";
//   Integer supportFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real supportFriction.unitAcceleration(quantity = "Acceleration", unit = "m/s2") = 1.0;
//   protected constant Real supportFriction.unitForce(quantity = "Force", unit = "N") = 1.0;
//   parameter Real supportFriction.f_pos[1,1] = 0.0 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[1,2] = 15.0 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[2,1] = 0.244897959183673 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[2,2] = 11.3724122865612 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[3,1] = 0.489795918367347 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[3,2] = 9.24443910158899 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[4,1] = 0.73469387755102 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[4,2] = 8.03535686748911 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[5,1] = 0.979591836734694 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[5,2] = 7.38932638006597 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[6,1] = 1.22448979591837 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[6,2] = 7.08830665712451 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[7,1] = 1.46938775510204 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[7,2] = 6.99869277442913 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[8,1] = 1.71428571428571 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[8,2] = 7.03861812323367 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[9,1] = 1.95918367346939 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[9,2] = 7.15791882173553 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[10,1] = 2.20408163265306 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[10,2] = 7.32585687948849 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[11,1] = 2.44897959183673 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[11,2] = 7.52359754880714 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[12,1] = 2.69387755102041 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[12,2] = 7.73959981106199 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[13,1] = 2.93877551020408 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[13,2] = 7.96679189055257 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[14,1] = 3.18367346938776 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[14,2] = 8.20084054658641 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[15,1] = 3.42857142857143 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[15,2] = 8.43909057972083 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[16,1] = 3.6734693877551 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[16,2] = 8.67991501269308 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[17,1] = 3.91836734693878 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[17,2] = 8.92231691285441 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[18,1] = 4.16326530612245 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[18,2] = 9.16568540829595 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[19,1] = 4.40816326530612 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[19,2] = 9.40964618638031 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[20,1] = 4.6530612244898 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[20,2] = 9.65396988650264 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[21,1] = 4.89795918367347 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[21,2] = 9.89851596762371 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[22,1] = 5.14285714285714 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[22,2] = 10.1431983130204 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[23,1] = 5.38775510204082 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[23,2] = 10.3879641545471 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[24,1] = 5.63265306122449 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[24,2] = 10.6327811584473 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[25,1] = 5.87755102040816 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[25,2] = 10.8776295121649 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[26,1] = 6.12244897959184 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[26,2] = 11.1224970755283 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[27,1] = 6.36734693877551 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[27,2] = 11.3673764096295 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[28,1] = 6.61224489795918 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[28,2] = 11.6122629562672 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[29,1] = 6.85714285714286 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[29,2] = 11.8571539223969 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[30,1] = 7.10204081632653 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[30,2] = 12.1020475965768 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[31,1] = 7.3469387755102 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[31,2] = 12.3469429301183 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[32,1] = 7.59183673469388 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[32,2] = 12.5918392804359 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[33,1] = 7.83673469387755 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[33,2] = 12.8367362537846 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[34,1] = 8.08163265306122 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[34,2] = 13.0816336088965 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[35,1] = 8.3265306122449 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[35,2] = 13.3265311979344 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[36,1] = 8.57142857142857 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[36,2] = 13.5714289303106 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[37,1] = 8.81632653061225 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[37,2] = 13.8163267505177 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[38,1] = 9.06122448979592 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[38,2] = 14.0612246245433 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[39,1] = 9.30612244897959 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[39,2] = 14.3061225315463 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[40,1] = 9.55102040816326 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[40,2] = 14.5510204587561 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[41,1] = 9.79591836734694 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[41,2] = 14.7959183983478 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[42,1] = 10.0408163265306 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[42,2] = 15.0408163455264 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[43,1] = 10.2857142857143 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[43,2] = 15.285714297354 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[44,1] = 10.530612244898 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[44,2] = 15.5306122520302 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[45,1] = 10.7755102040816 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[45,2] = 15.7755102084519 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[46,1] = 11.0204081632653 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[46,2] = 16.0204081659432 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[47,1] = 11.265306122449 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[47,2] = 16.2653061240899 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[48,1] = 11.5102040816327 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[48,2] = 16.5102040826381 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[49,1] = 11.7551020408163 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[49,2] = 16.7551020414324 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[50,1] = 12.0 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.f_pos[50,2] = 17.0000000003775 "[v, f] Positive sliding friction characteristic (v>=0)";
//   parameter Real supportFriction.peak(min = 1.0) = 1.0 "peak*f_pos[1,2] = Maximum friction force for v==0";
//   Real supportFriction.s(quantity = "Length", unit = "m");
//   Real supportFriction.f(quantity = "Force", unit = "N") "Friction force";
//   Real supportFriction.v(quantity = "Velocity", unit = "m/s") "Absolute velocity of flange_a and flange_b";
//   Real supportFriction.a(quantity = "Acceleration", unit = "m/s2") "Absolute acceleration of flange_a and flange_b";
// equation
//   stop1.f0 = stop1.F_Coulomb + stop1.F_Stribeck;
//   stop1.f0_max = 1.001 * stop1.f0;
//   stop1.free = stop1.f0 <= 0.0 AND stop1.F_prop <= 0.0 AND stop1.s > stop1.smin + stop1.L / 2.0 AND stop1.s < stop1.smax - stop1.L / 2.0;
//   stop1.v = der(stop1.s);
//   stop1.a = der(stop1.v);
//   stop1.v_relfric = stop1.v;
//   stop1.a_relfric = stop1.a;
//   0.0 = stop1.flange_a.f + stop1.flange_b.f - stop1.f - stop1.m * der(stop1.v);
//   stop1.f = if stop1.locked then stop1.sa else if stop1.free then 0.0 else if stop1.startForward then stop1.F_prop * stop1.v + (stop1.F_Coulomb + stop1.F_Stribeck) else if stop1.startBackward then stop1.F_prop * stop1.v - stop1.F_Coulomb - stop1.F_Stribeck else if pre(stop1.mode) == 1 then stop1.F_prop * stop1.v + (stop1.F_Coulomb + stop1.F_Stribeck * exp((-stop1.fexp) * abs(stop1.v))) else stop1.F_prop * stop1.v - stop1.F_Coulomb - stop1.F_Stribeck * exp((-stop1.fexp) * abs(stop1.v));
//   stop1.mode = if stop1.free then 2 else if (pre(stop1.mode) == 1 OR pre(stop1.mode) == 2 OR stop1.startForward) AND stop1.v_relfric > 0.0 AND stop1.s < stop1.smax - stop1.L / 2.0 then 1 else if (pre(stop1.mode) == -1 OR pre(stop1.mode) == 2 OR stop1.startBackward) AND stop1.v_relfric < 0.0 AND stop1.s > stop1.smin + stop1.L / 2.0 then -1 else 0;
//   stop1.a_relfric = if stop1.locked then 0.0 else if stop1.free then stop1.sa else if stop1.startForward then stop1.sa - stop1.f0_max else if stop1.startBackward then stop1.sa + stop1.f0_max else if pre(stop1.mode) == 1 then stop1.sa - stop1.f0_max else stop1.sa + stop1.f0_max;
//   stop1.locked =  NOT stop1.free AND  NOT (pre(stop1.mode) == 1 OR stop1.startForward OR pre(stop1.mode) == -1 OR stop1.startBackward);
//   stop1.startBackward = pre(stop1.mode) == 0 AND (stop1.sa < -stop1.f0_max AND stop1.s > stop1.smin + stop1.L / 2.0 OR pre(stop1.startBackward) AND stop1.sa < -stop1.f0 AND stop1.s > stop1.smin + stop1.L / 2.0) OR pre(stop1.mode) == 1 AND stop1.v_relfric < -stop1.v_small OR initial() AND stop1.v_relfric < 0.0;
//   stop1.startForward = pre(stop1.mode) == 0 AND (stop1.sa > stop1.f0_max AND stop1.s < stop1.smax - stop1.L / 2.0 OR pre(stop1.startForward) AND stop1.sa > stop1.f0 AND stop1.s < stop1.smax - stop1.L / 2.0) OR pre(stop1.mode) == -1 AND stop1.v_relfric > stop1.v_small OR initial() AND stop1.v_relfric > 0.0;
//   stop1.flange_a.s = stop1.s - stop1.L / 2.0;
//   stop1.flange_b.s = stop1.s + stop1.L / 2.0;
//   force.flange.f = -force.f;
//   force.s_support = 0.0;
//   sineForce.y = sineForce.offset + (if time < sineForce.startTime then 0.0 else sineForce.amplitude * Modelica.Math.sin(6.28318530717959 * (sineForce.freqHz * (time - sineForce.startTime)) + sineForce.phase));
//   stop2.f0 = stop2.F_Coulomb + stop2.F_Stribeck;
//   stop2.f0_max = 1.001 * stop2.f0;
//   stop2.free = stop2.f0 <= 0.0 AND stop2.F_prop <= 0.0 AND stop2.s > stop2.smin + stop2.L / 2.0 AND stop2.s < stop2.smax - stop2.L / 2.0;
//   stop2.v = der(stop2.s);
//   stop2.a = der(stop2.v);
//   stop2.v_relfric = stop2.v;
//   stop2.a_relfric = stop2.a;
//   0.0 = stop2.flange_a.f + stop2.flange_b.f - stop2.f - stop2.m * der(stop2.v);
//   stop2.f = if stop2.locked then stop2.sa else if stop2.free then 0.0 else if stop2.startForward then stop2.F_prop * stop2.v + (stop2.F_Coulomb + stop2.F_Stribeck) else if stop2.startBackward then stop2.F_prop * stop2.v - stop2.F_Coulomb - stop2.F_Stribeck else if pre(stop2.mode) == 1 then stop2.F_prop * stop2.v + (stop2.F_Coulomb + stop2.F_Stribeck * exp((-stop2.fexp) * abs(stop2.v))) else stop2.F_prop * stop2.v - stop2.F_Coulomb - stop2.F_Stribeck * exp((-stop2.fexp) * abs(stop2.v));
//   stop2.mode = if stop2.free then 2 else if (pre(stop2.mode) == 1 OR pre(stop2.mode) == 2 OR stop2.startForward) AND stop2.v_relfric > 0.0 AND stop2.s < stop2.smax - stop2.L / 2.0 then 1 else if (pre(stop2.mode) == -1 OR pre(stop2.mode) == 2 OR stop2.startBackward) AND stop2.v_relfric < 0.0 AND stop2.s > stop2.smin + stop2.L / 2.0 then -1 else 0;
//   stop2.a_relfric = if stop2.locked then 0.0 else if stop2.free then stop2.sa else if stop2.startForward then stop2.sa - stop2.f0_max else if stop2.startBackward then stop2.sa + stop2.f0_max else if pre(stop2.mode) == 1 then stop2.sa - stop2.f0_max else stop2.sa + stop2.f0_max;
//   stop2.locked =  NOT stop2.free AND  NOT (pre(stop2.mode) == 1 OR stop2.startForward OR pre(stop2.mode) == -1 OR stop2.startBackward);
//   stop2.startBackward = pre(stop2.mode) == 0 AND (stop2.sa < -stop2.f0_max AND stop2.s > stop2.smin + stop2.L / 2.0 OR pre(stop2.startBackward) AND stop2.sa < -stop2.f0 AND stop2.s > stop2.smin + stop2.L / 2.0) OR pre(stop2.mode) == 1 AND stop2.v_relfric < -stop2.v_small OR initial() AND stop2.v_relfric < 0.0;
//   stop2.startForward = pre(stop2.mode) == 0 AND (stop2.sa > stop2.f0_max AND stop2.s < stop2.smax - stop2.L / 2.0 OR pre(stop2.startForward) AND stop2.sa > stop2.f0 AND stop2.s < stop2.smax - stop2.L / 2.0) OR pre(stop2.mode) == -1 AND stop2.v_relfric > stop2.v_small OR initial() AND stop2.v_relfric > 0.0;
//   stop2.flange_a.s = stop2.s - stop2.L / 2.0;
//   stop2.flange_b.s = stop2.s + stop2.L / 2.0;
//   spring.f = spring.c * (spring.s_rel - spring.s_rel0);
//   spring.s_rel = spring.flange_b.s - spring.flange_a.s;
//   spring.flange_b.f = spring.f;
//   spring.flange_a.f = -spring.f;
//   fixed2.flange.s = fixed2.s0;
//   force2.flange.f = -force2.f;
//   force2.s_support = 0.0;
//   mass.v = der(mass.s);
//   mass.a = der(mass.v);
//   mass.m * mass.a = mass.flange_a.f + mass.flange_b.f;
//   mass.flange_a.s = mass.s - mass.L / 2.0;
//   mass.flange_b.s = mass.s + mass.L / 2.0;
//   supportFriction.f0 = Modelica.Math.tempInterpol1(0.0,supportFriction.f_pos,2);
//   supportFriction.f0_max = supportFriction.peak * supportFriction.f0;
//   supportFriction.free = false;
//   supportFriction.s = supportFriction.s_a - supportFriction.s_support;
//   supportFriction.s_a = supportFriction.s_b;
//   supportFriction.v = der(supportFriction.s);
//   supportFriction.a = der(supportFriction.v);
//   supportFriction.v_relfric = supportFriction.v;
//   supportFriction.a_relfric = supportFriction.a;
//   supportFriction.flange_a.f + supportFriction.flange_b.f - supportFriction.f = 0.0;
//   supportFriction.f = if supportFriction.locked then supportFriction.sa else if supportFriction.startForward then Modelica.Math.tempInterpol1(supportFriction.v,supportFriction.f_pos,2) else if supportFriction.startBackward then -Modelica.Math.tempInterpol1(-supportFriction.v,supportFriction.f_pos,2) else if pre(supportFriction.mode) == 1 then Modelica.Math.tempInterpol1(supportFriction.v,supportFriction.f_pos,2) else -Modelica.Math.tempInterpol1(-supportFriction.v,supportFriction.f_pos,2);
//   supportFriction.s_support = 0.0;
//   supportFriction.startForward = pre(supportFriction.mode) == 0 AND (supportFriction.sa > supportFriction.f0_max OR pre(supportFriction.startForward) AND supportFriction.sa > supportFriction.f0) OR pre(supportFriction.mode) == -1 AND supportFriction.v_relfric > supportFriction.v_small OR initial() AND supportFriction.v_relfric > 0.0;
//   supportFriction.startBackward = pre(supportFriction.mode) == 0 AND (supportFriction.sa < -supportFriction.f0_max OR pre(supportFriction.startBackward) AND supportFriction.sa < -supportFriction.f0) OR pre(supportFriction.mode) == 1 AND supportFriction.v_relfric < -supportFriction.v_small OR initial() AND supportFriction.v_relfric < 0.0;
//   supportFriction.locked =  NOT supportFriction.free AND  NOT (pre(supportFriction.mode) == 1 OR supportFriction.startForward OR pre(supportFriction.mode) == -1 OR supportFriction.startBackward);
//   supportFriction.a_relfric = if supportFriction.locked then 0.0 else if supportFriction.free then supportFriction.sa else if supportFriction.startForward then supportFriction.sa - supportFriction.f0_max else if supportFriction.startBackward then supportFriction.sa + supportFriction.f0_max else if pre(supportFriction.mode) == 1 then supportFriction.sa - supportFriction.f0_max else supportFriction.sa + supportFriction.f0_max;
//   supportFriction.mode = if supportFriction.free then 2 else if (pre(supportFriction.mode) == 1 OR pre(supportFriction.mode) == 2 OR supportFriction.startForward) AND supportFriction.v_relfric > 0.0 then 1 else if (pre(supportFriction.mode) == -1 OR pre(supportFriction.mode) == 2 OR supportFriction.startBackward) AND supportFriction.v_relfric < 0.0 then -1 else 0;
//   force.f = force2.f;
//   force.f = sineForce.y;
//   mass.flange_b.f + supportFriction.flange_a.f = 0.0;
//   mass.flange_b.s = supportFriction.flange_a.s;
//   force2.flange.f + mass.flange_a.f = 0.0;
//   force2.flange.s = mass.flange_a.s;
//   force.flange.f + stop1.flange_a.f = 0.0;
//   force.flange.s = stop1.flange_a.s;
//   spring.flange_a.f + fixed2.flange.f = 0.0;
//   fixed2.flange.s = spring.flange_a.s;
//   spring.flange_b.f + stop2.flange_a.f = 0.0;
//   spring.flange_b.s = stop2.flange_a.s;
//   supportFriction.flange_b.f = 0.0;
//   stop2.flange_b.f = 0.0;
//   stop1.flange_b.f = 0.0;
// algorithm
//   when initial() then
//     assert(stop1.s > stop1.smin + stop1.L / 2.0 OR stop1.s >= stop1.smin + stop1.L / 2.0 AND stop1.v >= 0.0, "Error in initialization of hard stop. (s - L/2) must be >= smin ");
//     assert(stop1.s < stop1.smax - stop1.L / 2.0 OR stop1.s <= stop1.smax - stop1.L / 2.0 AND stop1.v <= 0.0, "Error in initialization of hard stop. (s + L/2) must be <= smax ");
//   end when;
//   when stop1.stopped <> 0 then
//     reinit(stop1.s, if stop1.stopped < 0 then stop1.smin + stop1.L / 2.0 else stop1.smax - stop1.L / 2.0);
//     if  NOT initial() OR Real(stop1.stopped) * stop1.v > 0.0 then
//       reinit(stop1.v, 0.0);
//     end if;
//   end when;
//   when initial() then
//     assert(stop2.s > stop2.smin + stop2.L / 2.0 OR stop2.s >= stop2.smin + stop2.L / 2.0 AND stop2.v >= 0.0, "Error in initialization of hard stop. (s - L/2) must be >= smin ");
//     assert(stop2.s < stop2.smax - stop2.L / 2.0 OR stop2.s <= stop2.smax - stop2.L / 2.0 AND stop2.v <= 0.0, "Error in initialization of hard stop. (s + L/2) must be <= smax ");
//   end when;
//   when stop2.stopped <> 0 then
//     reinit(stop2.s, if stop2.stopped < 0 then stop2.smin + stop2.L / 2.0 else stop2.smax - stop2.L / 2.0);
//     if  NOT initial() OR Real(stop2.stopped) * stop2.v > 0.0 then
//       reinit(stop2.v, 0.0);
//     end if;
//   end when;
// end Modelica.Mechanics.Translational.Examples.Friction;
// "
// ""
// "Check of Modelica.Mechanics.Translational.Examples.Friction completed successfully.
// 
// 
// Class Modelica.Mechanics.Translational.Examples.Friction has 85 equation(s) and 85 variable(s).
// 31 of these are trivial equation(s).
// "
// ""
// endResult
