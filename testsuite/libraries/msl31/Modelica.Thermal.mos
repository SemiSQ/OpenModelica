//name:        Modelica.Thermal [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Thermal
//status:      correct
//
// instantiate/check model example
//

loadModel(Modelica,{"3.1"}); getErrorString();

instantiateModel(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();
checkModel(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();

// Result:
// true
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.log
//   input Real u;
//   output Real y;
// 
//   external \"C\" y = log(u);
// end Modelica.Math.log;
// 
// function Modelica.Thermal.FluidHeatFlow.Media.Medium \"Automatically generated record constructor for Modelica.Thermal.FluidHeatFlow.Media.Medium\"
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.0) rho = 1.0;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp = 1.0;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv = 1.0;
//   input Real(quantity=\"ThermalConductivity\", unit=\"W/(m.K)\") lamda = 1.0;
//   input Real(quantity=\"KinematicViscosity\", unit=\"m2/s\", min=0.0) nue = 1.0;
//   output Medium res;
// end Modelica.Thermal.FluidHeatFlow.Media.Medium;
// 
// class Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve
//   parameter Real medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 1 \"Density\";
//   parameter Real medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = 1 \"Specific heat capacity at constant pressure\";
//   parameter Real medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = 1 \"Specific heat capacity at constant volume\";
//   parameter Real medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = 1 \"Thermal conductivity\";
//   parameter Real medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = 1 \"kinematic viscosity\";
//   parameter Real TAmb(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Ambient temperature\";
//   output Real dTSource(quantity = \"ThermodynamicTemperature\", unit = \"K\") = prescribedHeatFlow.port.T - TAmb \"Source over Ambient\";
//   output Real dTtoPipe(quantity = \"ThermodynamicTemperature\", unit = \"K\") = prescribedHeatFlow.port.T - pipe.heatPort.T \"Source over Coolant\";
//   output Real dTCoolant(quantity = \"ThermodynamicTemperature\", unit = \"K\") = pipe.dT \"Coolant's temperature increase\";
//   parameter Real prescribedHeatFlow.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Reference temperature\";
//   parameter Real prescribedHeatFlow.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of heat flow rate\";
//   input Real prescribedHeatFlow.Q_flow;
//   Real prescribedHeatFlow.port.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real prescribedHeatFlow.port.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   output Real heatFlow.y \"Connector of Real output signal\";
//   parameter Real heatFlow.k(start = 1.0) = 10.0 \"Constant output value\";
//   Real convection.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate from solid -> fluid\";
//   Real convection.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\") \"= solid.T - fluid.T\";
//   input Real convection.Gc \"Signal representing the convective thermal conductance in [W/K]\";
//   Real convection.solid.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real convection.solid.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real convection.fluid.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real convection.fluid.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   output Real thermalConductance.y \"Connector of Real output signal\";
//   parameter Real thermalConductance.k(start = 1.0) = 1.0 \"Constant output value\";
//   parameter Boolean speed.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real speed.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Boolean speed.exact = true \"true/false exact treatment/filtering the input signal\";
//   parameter Real speed.f_crit(quantity = \"Frequency\", unit = \"Hz\") = 50.0 \"if exact=false, critical frequency of filter to filter input signal\";
//   Real speed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"Rotation angle of flange with respect to support\";
//   Real speed.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Angular velocity of flange with respect to support\";
//   Real speed.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"If exact=false, angular acceleration of flange with respect to support else dummy\";
//   input Real speed.w_ref \"Reference angular velocity of flange with respect to support as input signal\";
//   protected parameter Real speed.w_crit(quantity = \"AngularFrequency\", unit = \"rad/s\") = 6.28318530717959 * speed.f_crit \"Critical frequency\";
//   output Real speedRamp.y \"Connector of Real output signal\";
//   parameter Real speedRamp.height = 0.5 \"Height of ramps\";
//   parameter Real speedRamp.duration(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 2.0) = 0.1 \"Durations of ramp\";
//   parameter Real speedRamp.offset = 0.5 \"Offset of output signal\";
//   parameter Real speedRamp.startTime(quantity = \"Time\", unit = \"s\") = 0.4 \"Output = offset for time < startTime\";
//   output Real valveRamp.y \"Connector of Real output signal\";
//   parameter Real valveRamp.height = 0.5 \"Height of ramps\";
//   parameter Real valveRamp.duration(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 2.0) = 0.1 \"Durations of ramp\";
//   parameter Real valveRamp.offset = 0.5 \"Offset of output signal\";
//   parameter Real valveRamp.startTime(quantity = \"Time\", unit = \"s\") = 0.9 \"Output = offset for time < startTime\";
//   parameter Real ambient1.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = medium.rho \"Density\";
//   parameter Real ambient1.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real ambient1.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real ambient1.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = medium.lamda \"Thermal conductivity\";
//   parameter Real ambient1.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = medium.nue \"kinematic viscosity\";
//   output Real ambient1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Outlet temperature of medium\";
//   output Real ambient1.T_port(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = ambient1.flowPort.h / ambient1.medium.cp \"Temperature at flowPort_a\";
//   protected Real ambient1.h(quantity = \"SpecificEnergy\", unit = \"J/kg\") = ambient1.medium.cp * ambient1.T;
//   parameter Boolean ambient1.usePressureInput = false \"enable / disable pressure input\";
//   parameter Real ambient1.constantAmbientPressure(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = 0.0) \"Ambient pressure\";
//   parameter Boolean ambient1.useTemperatureInput = false \"enable / disable temperature input\";
//   parameter Real ambient1.constantAmbientTemperature(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 293.15) = TAmb \"Ambient temperature\";
//   protected input Real ambient1.pAmbient;
//   protected input Real ambient1.TAmbient;
//   parameter Real ambient1.flowPort.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = ambient1.medium.rho \"Density\";
//   parameter Real ambient1.flowPort.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ambient1.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real ambient1.flowPort.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ambient1.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real ambient1.flowPort.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ambient1.medium.lamda \"Thermal conductivity\";
//   parameter Real ambient1.flowPort.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = ambient1.medium.nue \"kinematic viscosity\";
//   Real ambient1.flowPort.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real ambient1.flowPort.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real ambient1.flowPort.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real ambient1.flowPort.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   output Real ambient1.constPressure.y \"Connector of Real output signal\";
//   parameter Real ambient1.constPressure.k(start = 1.0) = ambient1.constantAmbientPressure \"Constant output value\";
//   output Real ambient1.constTemperature.y \"Connector of Real output signal\";
//   parameter Real ambient1.constTemperature.k(start = 1.0) = ambient1.constantAmbientTemperature \"Constant output value\";
//   parameter Real idealPump.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = medium.rho \"Density\";
//   parameter Real idealPump.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real idealPump.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real idealPump.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = medium.lamda \"Thermal conductivity\";
//   parameter Real idealPump.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = medium.nue \"kinematic viscosity\";
//   parameter Real idealPump.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 0.0 \"Mass of medium\";
//   parameter Real idealPump.T0(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 293.15) = TAmb \"Initial temperature of medium\";
//   parameter Real idealPump.tapT(min = 0.0, max = 1.0) = 1.0 \"Defines temperature of heatPort between inlet and outlet temperature\";
//   Real idealPump.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = idealPump.flowPort_a.p - idealPump.flowPort_b.p \"Pressure drop a->b\";
//   Real idealPump.V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = idealPump.flowPort_a.m_flow / idealPump.medium.rho \"Volume flow a->b\";
//   Real idealPump.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat exchange with ambient\";
//   output Real idealPump.T_a(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = idealPump.flowPort_a.h / idealPump.medium.cp \"Temperature at flowPort_a\";
//   output Real idealPump.T_b(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = idealPump.flowPort_b.h / idealPump.medium.cp \"Temperature at flowPort_b\";
//   output Real idealPump.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\") = if noEvent(idealPump.V_flow >= 0.0) then idealPump.T - idealPump.T_a else idealPump.T_b - idealPump.T \"Temperature increase of coolant in flow direction\";
//   protected Real idealPump.h(quantity = \"SpecificEnergy\", unit = \"J/kg\") = idealPump.medium.cp * idealPump.T \"Medium's specific enthalpy\";
//   protected Real idealPump.T_q(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = idealPump.T - Real(sign(idealPump.V_flow)) * ((1.0 - idealPump.tapT) * idealPump.dT) \"Temperature relevant for heat exchange with ambient\";
//   parameter Real idealPump.wNominal(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"1/min\", start = 1.0) \"Nominal speed\";
//   parameter Real idealPump.dp0(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = 2.0) \"Max. pressure increase @ V_flow=0\";
//   parameter Real idealPump.V_flow0(quantity = \"VolumeFlowRate\", unit = \"m3/s\", start = 2.0) \"Max. volume flow rate @ dp=0\";
//   Real idealPump.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(idealPump.flange_a.phi) \"Speed\";
//   protected Real idealPump.dp1(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   protected Real idealPump.V_flow1(quantity = \"VolumeFlowRate\", unit = \"m3/s\");
//   Real idealPump.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealPump.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealPump.flowPort_a.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = idealPump.medium.rho \"Density\";
//   parameter Real idealPump.flowPort_a.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = idealPump.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real idealPump.flowPort_a.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = idealPump.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real idealPump.flowPort_a.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = idealPump.medium.lamda \"Thermal conductivity\";
//   parameter Real idealPump.flowPort_a.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = idealPump.medium.nue \"kinematic viscosity\";
//   Real idealPump.flowPort_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real idealPump.flowPort_a.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real idealPump.flowPort_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real idealPump.flowPort_a.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   parameter Real idealPump.flowPort_b.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = idealPump.medium.rho \"Density\";
//   parameter Real idealPump.flowPort_b.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = idealPump.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real idealPump.flowPort_b.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = idealPump.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real idealPump.flowPort_b.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = idealPump.medium.lamda \"Thermal conductivity\";
//   parameter Real idealPump.flowPort_b.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = idealPump.medium.nue \"kinematic viscosity\";
//   Real idealPump.flowPort_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real idealPump.flowPort_b.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real idealPump.flowPort_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real idealPump.flowPort_b.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   output Real idealPump.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = idealPump.T0) \"Outlet temperature of medium\";
//   parameter Real valve.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = medium.rho \"Density\";
//   parameter Real valve.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real valve.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real valve.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = medium.lamda \"Thermal conductivity\";
//   parameter Real valve.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = medium.nue \"kinematic viscosity\";
//   parameter Real valve.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 0.0) \"Mass of medium\";
//   parameter Real valve.T0(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 293.15) = TAmb \"Initial temperature of medium\";
//   parameter Real valve.tapT(min = 0.0, max = 1.0) = 1.0 \"Defines temperature of heatPort between inlet and outlet temperature\";
//   Real valve.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = valve.flowPort_a.p - valve.flowPort_b.p \"Pressure drop a->b\";
//   Real valve.V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = valve.flowPort_a.m_flow / valve.medium.rho \"Volume flow a->b\";
//   Real valve.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat exchange with ambient\";
//   output Real valve.T_a(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = valve.flowPort_a.h / valve.medium.cp \"Temperature at flowPort_a\";
//   output Real valve.T_b(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = valve.flowPort_b.h / valve.medium.cp \"Temperature at flowPort_b\";
//   output Real valve.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\") = if noEvent(valve.V_flow >= 0.0) then valve.T - valve.T_a else valve.T_b - valve.T \"Temperature increase of coolant in flow direction\";
//   protected Real valve.h(quantity = \"SpecificEnergy\", unit = \"J/kg\") = valve.medium.cp * valve.T \"Medium's specific enthalpy\";
//   protected Real valve.T_q(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = valve.T - Real(sign(valve.V_flow)) * ((1.0 - valve.tapT) * valve.dT) \"Temperature relevant for heat exchange with ambient\";
//   parameter Boolean valve.LinearCharacteristic(start = true) = false \"Type of characteristic\";
//   parameter Real valve.dp0(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = 1.0) \"Standard pressure drop\";
//   parameter Real valve.rho0(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, start = 10.0) \"Standard medium's density\";
//   parameter Real valve.frictionLoss(min = 0.0, max = 1.0, start = 0.0) \"Part of friction losses fed to medium\";
//   protected constant Real valve.unitVolumeFlowRate(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = 1.0;
//   protected constant Real valve.small = 1e-60;
//   protected constant Real valve.eps = 1e-15;
//   protected Real valve.yLim = max(min(valve.y,valve.y1),0.0) \"Limited valve opening\";
//   protected Real valve.Kv(quantity = \"VolumeFlowRate\", unit = \"m3/s\") \"Standard flow rate\";
//   input Real valve.y;
//   parameter Real valve.flowPort_a.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = valve.medium.rho \"Density\";
//   parameter Real valve.flowPort_a.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = valve.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real valve.flowPort_a.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = valve.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real valve.flowPort_a.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = valve.medium.lamda \"Thermal conductivity\";
//   parameter Real valve.flowPort_a.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = valve.medium.nue \"kinematic viscosity\";
//   Real valve.flowPort_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real valve.flowPort_a.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real valve.flowPort_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real valve.flowPort_a.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   parameter Real valve.flowPort_b.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = valve.medium.rho \"Density\";
//   parameter Real valve.flowPort_b.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = valve.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real valve.flowPort_b.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = valve.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real valve.flowPort_b.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = valve.medium.lamda \"Thermal conductivity\";
//   parameter Real valve.flowPort_b.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = valve.medium.nue \"kinematic viscosity\";
//   Real valve.flowPort_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real valve.flowPort_b.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real valve.flowPort_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real valve.flowPort_b.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   output Real valve.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = valve.T0) \"Outlet temperature of medium\";
//   parameter Real valve.y1(min = 1e-60, start = 1.0) \"Max. valve opening\";
//   parameter Real valve.Kv1(quantity = \"VolumeFlowRate\", unit = \"m3/s\", min = 1e-60, start = 1.0) \"Max. flow @ y = y1\";
//   protected constant Real valve.smallVolumeFlowRate(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = 1e-15;
//   parameter Real valve.kv0(min = 1e-60, max = 1.0, start = 0.01) \"Leakage flow / max.flow @ y = 0\";
//   parameter Real pipe.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = medium.rho \"Density\";
//   parameter Real pipe.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real pipe.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real pipe.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = medium.lamda \"Thermal conductivity\";
//   parameter Real pipe.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = medium.nue \"kinematic viscosity\";
//   parameter Real pipe.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 0.1 \"Mass of medium\";
//   parameter Real pipe.T0(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 293.15) = TAmb \"Initial temperature of medium\";
//   parameter Real pipe.tapT(min = 0.0, max = 1.0) = 1.0 \"Defines temperature of heatPort between inlet and outlet temperature\";
//   Real pipe.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = pipe.flowPort_a.p - pipe.flowPort_b.p \"Pressure drop a->b\";
//   Real pipe.V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = pipe.flowPort_a.m_flow / pipe.medium.rho \"Volume flow a->b\";
//   Real pipe.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat exchange with ambient\";
//   output Real pipe.T_a(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = pipe.flowPort_a.h / pipe.medium.cp \"Temperature at flowPort_a\";
//   output Real pipe.T_b(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = pipe.flowPort_b.h / pipe.medium.cp \"Temperature at flowPort_b\";
//   output Real pipe.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\") = if noEvent(pipe.V_flow >= 0.0) then pipe.T - pipe.T_a else pipe.T_b - pipe.T \"Temperature increase of coolant in flow direction\";
//   protected Real pipe.h(quantity = \"SpecificEnergy\", unit = \"J/kg\") = pipe.medium.cp * pipe.T \"Medium's specific enthalpy\";
//   protected Real pipe.T_q(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = pipe.T - Real(sign(pipe.V_flow)) * ((1.0 - pipe.tapT) * pipe.dT) \"Temperature relevant for heat exchange with ambient\";
//   parameter Real pipe.V_flowLaminar(quantity = \"VolumeFlowRate\", unit = \"m3/s\", min = 1e-60, start = 0.1) \"Laminar volume flow\";
//   parameter Real pipe.dpLaminar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = 0.1) \"Laminar pressure drop\";
//   parameter Real pipe.V_flowNominal(quantity = \"VolumeFlowRate\", unit = \"m3/s\", start = 1.0) \"Nominal volume flow\";
//   parameter Real pipe.dpNominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = 1.0) \"Nominal pressure drop\";
//   parameter Real pipe.frictionLoss(min = 0.0, max = 1.0) = 0.0 \"Part of friction losses fed to medium\";
//   Real pipe.pressureDrop(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real pipe.volumeFlow(quantity = \"VolumeFlowRate\", unit = \"m3/s\");
//   Real pipe.Q_friction(quantity = \"Power\", unit = \"W\");
//   protected parameter Real pipe.k(unit = \"Pa.s2/m6\", fixed = false);
//   parameter Real pipe.h_g(quantity = \"Length\", unit = \"m\", start = 0.0) \"Geodetic height (heigth difference from flowPort_a to flowPort_b)\";
//   Real pipe.heatPort.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real pipe.heatPort.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real pipe.flowPort_a.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = pipe.medium.rho \"Density\";
//   parameter Real pipe.flowPort_a.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = pipe.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real pipe.flowPort_a.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = pipe.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real pipe.flowPort_a.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = pipe.medium.lamda \"Thermal conductivity\";
//   parameter Real pipe.flowPort_a.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = pipe.medium.nue \"kinematic viscosity\";
//   Real pipe.flowPort_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real pipe.flowPort_a.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real pipe.flowPort_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real pipe.flowPort_a.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   parameter Real pipe.flowPort_b.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = pipe.medium.rho \"Density\";
//   parameter Real pipe.flowPort_b.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = pipe.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real pipe.flowPort_b.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = pipe.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real pipe.flowPort_b.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = pipe.medium.lamda \"Thermal conductivity\";
//   parameter Real pipe.flowPort_b.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = pipe.medium.nue \"kinematic viscosity\";
//   Real pipe.flowPort_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real pipe.flowPort_b.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real pipe.flowPort_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real pipe.flowPort_b.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   output Real pipe.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = pipe.T0) \"Outlet temperature of medium\";
//   protected parameter Real pipe.dpNomMin(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = (pipe.V_flowNominal * pipe.dpLaminar) / pipe.V_flowLaminar;
//   parameter Real ambient2.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = medium.rho \"Density\";
//   parameter Real ambient2.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real ambient2.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real ambient2.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = medium.lamda \"Thermal conductivity\";
//   parameter Real ambient2.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = medium.nue \"kinematic viscosity\";
//   output Real ambient2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Outlet temperature of medium\";
//   output Real ambient2.T_port(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = ambient2.flowPort.h / ambient2.medium.cp \"Temperature at flowPort_a\";
//   protected Real ambient2.h(quantity = \"SpecificEnergy\", unit = \"J/kg\") = ambient2.medium.cp * ambient2.T;
//   parameter Boolean ambient2.usePressureInput = false \"enable / disable pressure input\";
//   parameter Real ambient2.constantAmbientPressure(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = 0.0) \"Ambient pressure\";
//   parameter Boolean ambient2.useTemperatureInput = false \"enable / disable temperature input\";
//   parameter Real ambient2.constantAmbientTemperature(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 293.15) = TAmb \"Ambient temperature\";
//   protected input Real ambient2.pAmbient;
//   protected input Real ambient2.TAmbient;
//   parameter Real ambient2.flowPort.medium.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = ambient2.medium.rho \"Density\";
//   parameter Real ambient2.flowPort.medium.cp(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ambient2.medium.cp \"Specific heat capacity at constant pressure\";
//   parameter Real ambient2.flowPort.medium.cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = ambient2.medium.cv \"Specific heat capacity at constant volume\";
//   parameter Real ambient2.flowPort.medium.lamda(quantity = \"ThermalConductivity\", unit = \"W/(m.K)\") = ambient2.medium.lamda \"Thermal conductivity\";
//   parameter Real ambient2.flowPort.medium.nue(quantity = \"KinematicViscosity\", unit = \"m2/s\", min = 0.0) = ambient2.medium.nue \"kinematic viscosity\";
//   Real ambient2.flowPort.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   Real ambient2.flowPort.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\");
//   Real ambient2.flowPort.h(quantity = \"SpecificEnergy\", unit = \"J/kg\");
//   Real ambient2.flowPort.H_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\");
//   output Real ambient2.constPressure.y \"Connector of Real output signal\";
//   parameter Real ambient2.constPressure.k(start = 1.0) = ambient2.constantAmbientPressure \"Constant output value\";
//   output Real ambient2.constTemperature.y \"Connector of Real output signal\";
//   parameter Real ambient2.constTemperature.k(start = 1.0) = ambient2.constantAmbientTemperature \"Constant output value\";
//   parameter Real heatCapacitor.C(quantity = \"HeatCapacity\", unit = \"J/K\") = 0.1 \"Heat capacity of element (= cp*m)\";
//   Real heatCapacitor.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = TAmb) \"Temperature of element\";
//   Real heatCapacitor.der_T(quantity = \"TemperatureSlope\", unit = \"K/s\", start = 0.0) \"Time derivative of temperature (= der(T))\";
//   Real heatCapacitor.port.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real heatCapacitor.port.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
// initial algorithm
//   assert(valve.y1 > 1e-60, \"Valve characteristic: y1 has to be > 0 !\");
//   assert(valve.Kv1 > 1e-15, \"Valve characteristic: Kv1 has to be > 0 !\");
//   assert(valve.kv0 > 1e-60, \"Valve characteristic: kv0 has to be > 0 !\");
//   assert(valve.kv0 < 0.999999999999999, \"Valve characteristic: kv0 has to be < 1 !\");
//   assert(pipe.V_flowNominal > pipe.V_flowLaminar, \"SimpleFriction: V_flowNominal has to be > V_flowLaminar!\");
//   assert(pipe.dpNominal >= pipe.dpNomMin, \"SimpleFriction: dpNominal has to be > dpLaminar/V_flowLaminar*V_flowNominal!\");
//   pipe.k := (pipe.dpNominal - pipe.dpNomMin) / (pipe.V_flowNominal - pipe.V_flowLaminar) ^ 2.0;
// equation
//   prescribedHeatFlow.port.Q_flow = (-prescribedHeatFlow.Q_flow) * (1.0 + prescribedHeatFlow.alpha * (prescribedHeatFlow.port.T - prescribedHeatFlow.T_ref));
//   heatFlow.y = heatFlow.k;
//   convection.dT = convection.solid.T - convection.fluid.T;
//   convection.solid.Q_flow = convection.Q_flow;
//   convection.fluid.Q_flow = -convection.Q_flow;
//   convection.Q_flow = convection.Gc * convection.dT;
//   thermalConductance.y = thermalConductance.k;
//   speed.phi = speed.flange.phi - speed.phi_support;
//   speed.w = der(speed.phi);
//   speed.w = speed.w_ref;
//   speed.a = 0.0;
//   speed.phi_support = 0.0;
//   speedRamp.y = speedRamp.offset + (if time < speedRamp.startTime then 0.0 else if time < speedRamp.startTime + speedRamp.duration then ((time - speedRamp.startTime) * speedRamp.height) / speedRamp.duration else speedRamp.height);
//   valveRamp.y = valveRamp.offset + (if time < valveRamp.startTime then 0.0 else if time < valveRamp.startTime + valveRamp.duration then ((time - valveRamp.startTime) * valveRamp.height) / valveRamp.duration else valveRamp.height);
//   ambient1.constPressure.y = ambient1.constPressure.k;
//   ambient1.constTemperature.y = ambient1.constTemperature.k;
//   ambient1.flowPort.p = ambient1.pAmbient;
//   ambient1.T = ambient1.TAmbient;
//   ambient1.flowPort.H_flow = semiLinear(ambient1.flowPort.m_flow,ambient1.flowPort.h,ambient1.h);
//   idealPump.dp1 = idealPump.dp0 * (Real(sign(idealPump.w / idealPump.wNominal)) * (idealPump.w / idealPump.wNominal) ^ 2.0);
//   idealPump.V_flow1 = (idealPump.V_flow0 * idealPump.w) / idealPump.wNominal;
//   if noEvent(abs(idealPump.w) < 1e-60) then
//   idealPump.dp = 0.0;
//   idealPump.flange_a.tau = 0.0;
//   else
//   idealPump.dp = (-idealPump.dp1) * (1.0 - abs(idealPump.V_flow / idealPump.V_flow1));
//   idealPump.flange_a.tau * idealPump.w = (-idealPump.dp) * idealPump.V_flow;
//   end if;
//   idealPump.Q_flow = 0.0;
//   idealPump.flowPort_a.m_flow + idealPump.flowPort_b.m_flow = 0.0;
//   idealPump.flowPort_a.H_flow + (idealPump.flowPort_b.H_flow + idealPump.Q_flow) = 0.0;
//   idealPump.flowPort_a.H_flow = semiLinear(idealPump.flowPort_a.m_flow,idealPump.flowPort_a.h,idealPump.h);
//   idealPump.flowPort_b.H_flow = semiLinear(idealPump.flowPort_b.m_flow,idealPump.flowPort_b.h,idealPump.h);
//   valve.Kv / valve.Kv1 = if valve.LinearCharacteristic then valve.kv0 + ((1.0 - valve.kv0) * valve.yLim) / valve.y1 else valve.kv0 * exp((log(1.0 / valve.kv0) * valve.yLim) / valve.y1);
//   valve.dp / valve.dp0 = (abs(valve.V_flow / valve.Kv) * (valve.V_flow * valve.medium.rho)) / (valve.rho0 * valve.Kv);
//   valve.Q_flow = valve.frictionLoss * (valve.V_flow * valve.dp);
//   valve.flowPort_a.m_flow + valve.flowPort_b.m_flow = 0.0;
//   valve.flowPort_a.H_flow + (valve.flowPort_b.H_flow + valve.Q_flow) = 0.0;
//   valve.flowPort_a.H_flow = semiLinear(valve.flowPort_a.m_flow,valve.flowPort_a.h,valve.h);
//   valve.flowPort_b.H_flow = semiLinear(valve.flowPort_b.m_flow,valve.flowPort_b.h,valve.h);
//   pipe.volumeFlow = pipe.V_flow;
//   pipe.dp = pipe.pressureDrop + 9.80665 * (pipe.medium.rho * pipe.h_g);
//   pipe.Q_flow = pipe.heatPort.Q_flow + pipe.Q_friction;
//   pipe.heatPort.T = pipe.T_q;
//   pipe.flowPort_a.m_flow + pipe.flowPort_b.m_flow = 0.0;
//   pipe.flowPort_a.H_flow + (pipe.flowPort_b.H_flow + pipe.Q_flow) = pipe.m * (pipe.medium.cv * der(pipe.T));
//   pipe.flowPort_a.H_flow = semiLinear(pipe.flowPort_a.m_flow,pipe.flowPort_a.h,pipe.h);
//   pipe.flowPort_b.H_flow = semiLinear(pipe.flowPort_b.m_flow,pipe.flowPort_b.h,pipe.h);
//   if pipe.volumeFlow > pipe.V_flowLaminar then
//   pipe.pressureDrop = (pipe.volumeFlow * pipe.dpLaminar) / pipe.V_flowLaminar + pipe.k * (pipe.volumeFlow - pipe.V_flowLaminar) ^ 2.0;
//   elseif pipe.volumeFlow < -pipe.V_flowLaminar then
//   pipe.pressureDrop = (pipe.volumeFlow * pipe.dpLaminar) / pipe.V_flowLaminar - pipe.k * (pipe.volumeFlow + pipe.V_flowLaminar) ^ 2.0;
//   else
//   pipe.pressureDrop = (pipe.volumeFlow * pipe.dpLaminar) / pipe.V_flowLaminar;
//   end if;
//   pipe.Q_friction = pipe.frictionLoss * (pipe.volumeFlow * pipe.pressureDrop);
//   ambient2.constPressure.y = ambient2.constPressure.k;
//   ambient2.constTemperature.y = ambient2.constTemperature.k;
//   ambient2.flowPort.p = ambient2.pAmbient;
//   ambient2.T = ambient2.TAmbient;
//   ambient2.flowPort.H_flow = semiLinear(ambient2.flowPort.m_flow,ambient2.flowPort.h,ambient2.h);
//   heatCapacitor.T = heatCapacitor.port.T;
//   heatCapacitor.der_T = der(heatCapacitor.T);
//   heatCapacitor.C * der(heatCapacitor.T) = heatCapacitor.port.Q_flow;
//   assert(pipe.flowPort_b.medium.rho == ambient2.flowPort.medium.rho,\"automatically generated from connect\");
//   assert(pipe.flowPort_b.medium.cp == ambient2.flowPort.medium.cp,\"automatically generated from connect\");
//   assert(pipe.flowPort_b.medium.cv == ambient2.flowPort.medium.cv,\"automatically generated from connect\");
//   assert(pipe.flowPort_b.medium.lamda == ambient2.flowPort.medium.lamda,\"automatically generated from connect\");
//   assert(pipe.flowPort_b.medium.nue == ambient2.flowPort.medium.nue,\"automatically generated from connect\");
//   assert(ambient1.flowPort.medium.rho == idealPump.flowPort_a.medium.rho,\"automatically generated from connect\");
//   assert(ambient1.flowPort.medium.cp == idealPump.flowPort_a.medium.cp,\"automatically generated from connect\");
//   assert(ambient1.flowPort.medium.cv == idealPump.flowPort_a.medium.cv,\"automatically generated from connect\");
//   assert(ambient1.flowPort.medium.lamda == idealPump.flowPort_a.medium.lamda,\"automatically generated from connect\");
//   assert(ambient1.flowPort.medium.nue == idealPump.flowPort_a.medium.nue,\"automatically generated from connect\");
//   assert(idealPump.flowPort_b.medium.rho == valve.flowPort_a.medium.rho,\"automatically generated from connect\");
//   assert(idealPump.flowPort_b.medium.cp == valve.flowPort_a.medium.cp,\"automatically generated from connect\");
//   assert(idealPump.flowPort_b.medium.cv == valve.flowPort_a.medium.cv,\"automatically generated from connect\");
//   assert(idealPump.flowPort_b.medium.lamda == valve.flowPort_a.medium.lamda,\"automatically generated from connect\");
//   assert(idealPump.flowPort_b.medium.nue == valve.flowPort_a.medium.nue,\"automatically generated from connect\");
//   assert(valve.flowPort_b.medium.rho == pipe.flowPort_a.medium.rho,\"automatically generated from connect\");
//   assert(valve.flowPort_b.medium.cp == pipe.flowPort_a.medium.cp,\"automatically generated from connect\");
//   assert(valve.flowPort_b.medium.cv == pipe.flowPort_a.medium.cv,\"automatically generated from connect\");
//   assert(valve.flowPort_b.medium.lamda == pipe.flowPort_a.medium.lamda,\"automatically generated from connect\");
//   assert(valve.flowPort_b.medium.nue == pipe.flowPort_a.medium.nue,\"automatically generated from connect\");
//   prescribedHeatFlow.port.Q_flow + convection.solid.Q_flow + heatCapacitor.port.Q_flow = 0.0;
//   convection.fluid.Q_flow + pipe.heatPort.Q_flow = 0.0;
//   speed.flange.tau + idealPump.flange_a.tau = 0.0;
//   ambient1.flowPort.H_flow + idealPump.flowPort_a.H_flow = 0.0;
//   ambient1.flowPort.m_flow + idealPump.flowPort_a.m_flow = 0.0;
//   ambient1.constPressure.y = ambient1.pAmbient;
//   ambient1.TAmbient = ambient1.constTemperature.y;
//   idealPump.flowPort_b.H_flow + valve.flowPort_a.H_flow = 0.0;
//   idealPump.flowPort_b.m_flow + valve.flowPort_a.m_flow = 0.0;
//   valve.flowPort_b.H_flow + pipe.flowPort_a.H_flow = 0.0;
//   valve.flowPort_b.m_flow + pipe.flowPort_a.m_flow = 0.0;
//   pipe.flowPort_b.H_flow + ambient2.flowPort.H_flow = 0.0;
//   pipe.flowPort_b.m_flow + ambient2.flowPort.m_flow = 0.0;
//   ambient2.constPressure.y = ambient2.pAmbient;
//   ambient2.TAmbient = ambient2.constTemperature.y;
//   ambient2.flowPort.p = pipe.flowPort_b.p;
//   ambient2.flowPort.h = pipe.flowPort_b.h;
//   heatFlow.y = prescribedHeatFlow.Q_flow;
//   convection.solid.T = heatCapacitor.port.T;
//   convection.solid.T = prescribedHeatFlow.port.T;
//   convection.fluid.T = pipe.heatPort.T;
//   convection.Gc = thermalConductance.y;
//   ambient1.flowPort.p = idealPump.flowPort_a.p;
//   ambient1.flowPort.h = idealPump.flowPort_a.h;
//   idealPump.flowPort_b.p = valve.flowPort_a.p;
//   idealPump.flowPort_b.h = valve.flowPort_a.h;
//   pipe.flowPort_a.p = valve.flowPort_b.p;
//   pipe.flowPort_a.h = valve.flowPort_b.h;
//   speed.w_ref = speedRamp.y;
//   valve.y = valveRamp.y;
//   idealPump.flange_a.phi = speed.flange.phi;
// end Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve;
// "
// ""
// "Check of Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve completed successfully.
// 
// 
// Class Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve has 114 equation(s) and 114 variable(s).
// 72 of these are trivial equation(s).
// "
// ""
// endResult
