//name:        Modelica.Blocks.Examples.Filter [version 3.2]
//keyword:     instantiating MSL 3.2 Modelica.Blocks
//status:      correct
//
// instantiate/check model example
//

loadModel(Modelica, {"3.2"});
getErrorString();
instantiateModel(Modelica.Blocks.Examples.Filter);
getErrorString();

// Result:
// true
// ""
// "function Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients \"Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB\"
//   input Integer order \"Order of filter in the range 1..41\";
//   output Real[mod(order,2)] c1 \"[p] coefficients of Bessel denominator polynomials (a*p + 1)\";
//   output Real[integer(Real(order) / 2.0), 2] c2 \"[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)\";
//   output Real alpha \"Normalization factor\";
// algorithm
//   if order == 1 then
//     alpha := 1.002377293007601;
//     c1[1] := 0.9976283451109835;
//   elseif order == 2 then
//     alpha := 0.7356641785819585;
//     c2[1,1] := 0.6159132201783791;
//     c2[1,2] := 1.359315879600889;
//   elseif order == 3 then
//     alpha := 0.5704770156982641;
//     c1[1] := 0.7548574865985344;
//     c2[1,1] := 0.4756958028827457;
//     c2[1,2] := 0.9980615136104388;
//   elseif order == 4 then
//     alpha := 0.4737978580281427;
//     c2[1,1] := 0.4873729247240677;
//     c2[1,2] := 1.337564170455762;
//     c2[2,1] := 0.3877724315741958;
//     c2[2,2] := 0.7730405590839861;
//   elseif order == 5 then
//     alpha := 0.4126226974763408;
//     c1[1] := 0.6645723262620757;
//     c2[1,1] := 0.4115231900614016;
//     c2[1,2] := 1.138349926728708;
//     c2[2,1] := 0.3234938702877912;
//     c2[2,2] := 0.6205992985771313;
//   elseif order == 6 then
//     alpha := 0.3705098000736233;
//     c2[1,1] := 0.387450864909896;
//     c2[1,2] := 1.219740879520741;
//     c2[2,1] := 0.3493298843155746;
//     c2[2,2] := 0.9670265529381366;
//     c2[3,1] := 0.2747419229514599;
//     c2[3,2] := 0.51221650751057;
//   elseif order == 7 then
//     alpha := 0.339345262358635;
//     c1[1] := 0.5927147125821411;
//     c2[1,1] := 0.3383379423919174;
//     c2[1,2] := 1.09263081643803;
//     c2[2,1] := 0.3001025788696046;
//     c2[2,2] := 0.8289928256598657;
//     c2[3,1] := 0.2372867471539579;
//     c2[3,2] := 0.4325128641920154;
//   elseif order == 8 then
//     alpha := 0.3150267393795002;
//     c2[1,1] := 0.3151115975207653;
//     c2[1,2] := 1.10940301546019;
//     c2[2,1] := 0.2969344839572762;
//     c2[2,2] := 0.97374558122227;
//     c2[3,1] := 0.2612545921889538;
//     c2[3,2] := 0.7190394712068573;
//     c2[4,1] := 0.2080523342974281;
//     c2[4,2] := 0.3721456473047434;
//   elseif order == 9 then
//     alpha := 0.2953310177184124;
//     c1[1] := 0.5377196679501423;
//     c2[1,1] := 0.2824689124281034;
//     c2[1,2] := 1.022646191567475;
//     c2[2,1] := 0.2626824161383468;
//     c2[2,2] := 0.8695626454762596;
//     c2[3,1] := 0.2302781917677917;
//     c2[3,2] := 0.630904755344852;
//     c2[4,1] := 0.1847991729757028;
//     c2[4,2] := 0.3251978031287202;
//   elseif order == 10 then
//     alpha := 0.2789426890619463;
//     c2[1,1] := 0.2640769908255582;
//     c2[1,2] := 1.019788132875305;
//     c2[2,1] := 0.2540802639216947;
//     c2[2,2] := 0.9377020417760623;
//     c2[3,1] := 0.2343577229427963;
//     c2[3,2] := 0.7802229808216112;
//     c2[4,1] := 0.2052193139338624;
//     c2[4,2] := 0.5594176813008133;
//     c2[5,1] := 0.1659546953748916;
//     c2[5,2] := 0.2878349616233292;
//   elseif order == 11 then
//     alpha := 0.2650227766037203;
//     c1[1] := 0.4950265498954191;
//     c2[1,1] := 0.2411858478546218;
//     c2[1,2] := 0.9567800996387417;
//     c2[2,1] := 0.2296849355380925;
//     c2[2,2] := 0.8592523717113126;
//     c2[3,1] := 0.2107851705677406;
//     c2[3,2] := 0.7040216048898129;
//     c2[4,1] := 0.1846461385164021;
//     c2[4,2] := 0.5006729207276717;
//     c2[5,1] := 0.1504217970817433;
//     c2[5,2] := 0.2575070491320295;
//   elseif order == 12 then
//     alpha := 0.2530051198547209;
//     c2[1,1] := 0.2268294941204543;
//     c2[1,2] := 0.9473116570034052;
//     c2[2,1] := 0.2207657387793729;
//     c2[2,2] := 0.8933728946287606;
//     c2[3,1] := 0.2087600700376653;
//     c2[3,2] := 0.7886236252756229;
//     c2[4,1] := 0.190995910149276;
//     c2[4,2] := 0.6389263649257017;
//     c2[5,1] := 0.1675208146048472;
//     c2[5,2] := 0.4517847275162215;
//     c2[6,1] := 0.1374257286372761;
//     c2[6,2] := 0.232469915747468;
//   elseif order == 13 then
//     alpha := 0.2424910397561007;
//     c1[1] := 0.460884836992804;
//     c2[1,1] := 0.209981305027478;
//     c2[1,2] := 0.899247882379066;
//     c2[2,1] := 0.2027250423101359;
//     c2[2,2] := 0.8328117484224146;
//     c2[3,1] := 0.1907635894058731;
//     c2[3,2] := 0.7257379204691213;
//     c2[4,1] := 0.1742280397887686;
//     c2[4,2] := 0.5830640944868014;
//     c2[5,1] := 0.1530858190490478;
//     c2[5,2] := 0.4106192089751885;
//     c2[6,1] := 0.1264090712880446;
//     c2[6,2] := 0.2114980230156001;
//   elseif order == 14 then
//     alpha := 0.2331902368695848;
//     c2[1,1] := 0.1986162311411235;
//     c2[1,2] := 0.8876961808055535;
//     c2[2,1] := 0.1946683341271615;
//     c2[2,2] := 0.8500754229171967;
//     c2[3,1] := 0.1868331332895056;
//     c2[3,2] := 0.7764629313723603;
//     c2[4,1] := 0.1752118757862992;
//     c2[4,2] := 0.6699720402924552;
//     c2[5,1] := 0.1598906457908402;
//     c2[5,2] := 0.5348446712848934;
//     c2[6,1] := 0.1407810153019944;
//     c2[6,2] := 0.3755841316563539;
//     c2[7,1] := 0.1169627966707339;
//     c2[7,2] := 0.1937088226304455;
//   elseif order == 15 then
//     alpha := 0.2248854870552422;
//     c1[1] := 0.4328492272335646;
//     c2[1,1] := 0.1857292591004588;
//     c2[1,2] := 0.8496337061962563;
//     c2[2,1] := 0.1808644178280136;
//     c2[2,2] := 0.8020517898136011;
//     c2[3,1] := 0.1728264404199081;
//     c2[3,2] := 0.7247449729331105;
//     c2[4,1] := 0.1616970125901954;
//     c2[4,2] := 0.6205369315943097;
//     c2[5,1] := 0.1475257264578426;
//     c2[5,2] := 0.4929612162355906;
//     c2[6,1] := 0.1301861023357119;
//     c2[6,2] := 0.3454770708040735;
//     c2[7,1] := 0.1087810777120188;
//     c2[7,2] := 0.1784526655428406;
//   elseif order == 16 then
//     alpha := 0.2174105053474761;
//     c2[1,1] := 0.1765637967473151;
//     c2[1,2] := 0.8377453068635511;
//     c2[2,1] := 0.1738525357503125;
//     c2[2,2] := 0.8102988957433199;
//     c2[3,1] := 0.1684627004613343;
//     c2[3,2] := 0.7563265923413258;
//     c2[4,1] := 0.1604519074815815;
//     c2[4,2] := 0.6776082294687619;
//     c2[5,1] := 0.1498828607802206;
//     c2[5,2] := 0.576641703402768;
//     c2[6,1] := 0.1367764717792823;
//     c2[6,2] := 0.4563528264410489;
//     c2[7,1] := 0.1209810465419295;
//     c2[7,2] := 0.3193782657322374;
//     c2[8,1] := 0.1016312648007554;
//     c2[8,2] := 0.1652419227369036;
//   elseif order == 17 then
//     alpha := 0.2106355148193306;
//     c1[1] := 0.4093223608497299;
//     c2[1,1] := 0.1664014345826274;
//     c2[1,2] := 0.8067173752345952;
//     c2[2,1] := 0.1629839591538256;
//     c2[2,2] := 0.7712924931447541;
//     c2[3,1] := 0.1573277802512491;
//     c2[3,2] := 0.7134213666303411;
//     c2[4,1] := 0.1494828185148637;
//     c2[4,2] := 0.6347841731714884;
//     c2[5,1] := 0.1394948812681826;
//     c2[5,2] := 0.5375594414619047;
//     c2[6,1] := 0.1273627583380806;
//     c2[6,2] := 0.4241608926375478;
//     c2[7,1] := 0.112918725846129;
//     c2[7,2] := 0.2965752009703245;
//     c2[8,1] := 0.09533357359908858;
//     c2[8,2] := 0.1537041700889585;
//   elseif order == 18 then
//     alpha := 0.2044575288651841;
//     c2[1,1] := 0.1588768571976356;
//     c2[1,2] := 0.7951914263212913;
//     c2[2,1] := 0.1569357024981854;
//     c2[2,2] := 0.7744529690772538;
//     c2[3,1] := 0.153072220635881;
//     c2[3,2] := 0.733530442599208;
//     c2[4,1] := 0.1473206710524167;
//     c2[4,2] := 0.6735038935387268;
//     c2[5,1] := 0.139722542033152;
//     c2[5,2] := 0.595915154262159;
//     c2[6,1] := 0.1303092459809849;
//     c2[6,2] := 0.5026483447894845;
//     c2[7,1] := 0.1190627367060072;
//     c2[7,2] := 0.395689382458715;
//     c2[8,1] := 0.1058058030798994;
//     c2[8,2] := 0.276509183073065;
//     c2[9,1] := 0.08974708108800873;
//     c2[9,2] := 0.1435505288284833;
//   elseif order == 19 then
//     alpha := 0.1987936248083529;
//     c1[1] := 0.3892259966869526;
//     c2[1,1] := 0.1506640012172225;
//     c2[1,2] := 0.769312173377426;
//     c2[2,1] := 0.1481728062796673;
//     c2[2,2] := 0.742113358674155;
//     c2[3,1] := 0.1440444668388838;
//     c2[3,2] := 0.69750753862148;
//     c2[4,1] := 0.1383101628540374;
//     c2[4,2] := 0.6365464378910025;
//     c2[5,1] := 0.1310032283190998;
//     c2[5,2] := 0.5606211948462122;
//     c2[6,1] := 0.122143116640533;
//     c2[6,2] := 0.4713530424221445;
//     c2[7,1] := 0.1116991161103884;
//     c2[7,2] := 0.3703717538617073;
//     c2[8,1] := 0.09948917351196349;
//     c2[8,2] := 0.2587371155559744;
//     c2[9,1] := 0.08475989238107368;
//     c2[9,2] := 0.1345537894555993;
//   elseif order == 20 then
//     alpha := 0.1935761760416219;
//     c2[1,1] := 0.1443871348337404;
//     c2[1,2] := 0.7584165598446141;
//     c2[2,1] := 0.1429501891353184;
//     c2[2,2] := 0.7423000962318863;
//     c2[3,1] := 0.1400877384920004;
//     c2[3,2] := 0.7104185332215555;
//     c2[4,1] := 0.1358210369491446;
//     c2[4,2] := 0.663459978327263;
//     c2[5,1] := 0.130177370303429;
//     c2[5,2] := 0.6024175491895959;
//     c2[6,1] := 0.1231826501439148;
//     c2[6,2] := 0.5285332736326852;
//     c2[7,1] := 0.1148465498575254;
//     c2[7,2] := 0.4431977385498628;
//     c2[8,1] := 0.1051289462376788;
//     c2[8,2] := 0.3477444062821162;
//     c2[9,1] := 0.0938462279748512;
//     c2[9,2] := 0.2429038300327729;
//     c2[10,1] := 0.08028211612831444;
//     c2[10,2] := 0.1265329974009533;
//   elseif order == 21 then
//     alpha := 0.1887494014766075;
//     c1[1] := 0.3718070668941645;
//     c2[1,1] := 0.1376151928386445;
//     c2[1,2] := 0.7364290859445481;
//     c2[2,1] := 0.1357438914390695;
//     c2[2,2] := 0.7150167318935022;
//     c2[3,1] := 0.1326398453462415;
//     c2[3,2] := 0.6798001808470175;
//     c2[4,1] := 0.1283231214897678;
//     c2[4,2] := 0.6314663440439816;
//     c2[5,1] := 0.1228169159777534;
//     c2[5,2] := 0.5709353626166905;
//     c2[6,1] := 0.1161406100773184;
//     c2[6,2] := 0.4993087153571335;
//     c2[7,1] := 0.1082959649233524;
//     c2[7,2] := 0.4177766148584385;
//     c2[8,1] := 0.09923596957485722;
//     c2[8,2] := 0.3274257287232124;
//     c2[9,1] := 0.08877776108724852;
//     c2[9,2] := 0.2287218166767916;
//     c2[10,1] := 0.07624076527736326;
//     c2[10,2] := 0.1193423971506988;
//   elseif order == 22 then
//     alpha := 0.1842668221199706;
//     c2[1,1] := 0.1323053462701543;
//     c2[1,2] := 0.7262446126765204;
//     c2[2,1] := 0.1312121721769772;
//     c2[2,2] := 0.7134286088450948;
//     c2[3,1] := 0.1290330911166814;
//     c2[3,2] := 0.6880287870435514;
//     c2[4,1] := 0.1257817990372067;
//     c2[4,2] := 0.6505015800059301;
//     c2[5,1] := 0.1214765261983008;
//     c2[5,2] := 0.6015107185211451;
//     c2[6,1] := 0.1161365140967959;
//     c2[6,2] := 0.5418983553698413;
//     c2[7,1] := 0.10977551715331;
//     c2[7,2] := 0.4726370779831614;
//     c2[8,1] := 0.1023889478519956;
//     c2[8,2] := 0.3947439506537486;
//     c2[9,1] := 0.093924858612538;
//     c2[9,2] := 0.3090996703083202;
//     c2[10,1] := 0.08420273775456455;
//     c2[10,2] := 0.2159561978556017;
//     c2[11,1] := 0.07257600023938263;
//     c2[11,2] := 0.1128633732721116;
//   elseif order == 23 then
//     alpha := 0.1800893554453722;
//     c1[1] := 0.356523267392928;
//     c2[1,1] := 0.1266275171652706;
//     c2[1,2] := 0.7072778066734162;
//     c2[2,1] := 0.1251865227648538;
//     c2[2,2] := 0.6900676345785905;
//     c2[3,1] := 0.1227944815236645;
//     c2[3,2] := 0.6617011100576023;
//     c2[4,1] := 0.1194647013077667;
//     c2[4,2] := 0.6226432315773119;
//     c2[5,1] := 0.1152132989252356;
//     c2[5,2] := 0.5735222810625359;
//     c2[6,1] := 0.1100558598478487;
//     c2[6,2] := 0.5151027978024605;
//     c2[7,1] := 0.1040013558214886;
//     c2[7,2] := 0.4482410942032739;
//     c2[8,1] := 0.09704014176512626;
//     c2[8,2] := 0.3738049984631116;
//     c2[9,1] := 0.08911683905758054;
//     c2[9,2] := 0.292502869258841;
//     c2[10,1] := 0.08005438265072296;
//     c2[10,2] := 0.2044134600278901;
//     c2[11,1] := 0.06923832296800832;
//     c2[11,2] := 0.1069984887283394;
//   elseif order == 24 then
//     alpha := 0.1761838665838427;
//     c2[1,1] := 0.1220804912720132;
//     c2[1,2] := 0.6978026874156062;
//     c2[2,1] := 0.1212296762358897;
//     c2[2,2] := 0.6874139794926736;
//     c2[3,1] := 0.1195328372961027;
//     c2[3,2] := 0.6667954259551859;
//     c2[4,1] := 0.1169990987333593;
//     c2[4,2] := 0.6362602049901176;
//     c2[5,1] := 0.113640904048013;
//     c2[5,2] := 0.5962662188435554;
//     c2[6,1] := 0.1094722001757955;
//     c2[6,2] := 0.5474001634109253;
//     c2[7,1] := 0.1045052832229087;
//     c2[7,2] := 0.4903523180249535;
//     c2[8,1] := 0.09874509806025906;
//     c2[8,2] := 0.4258751523524645;
//     c2[9,1] := 0.09217799943472177;
//     c2[9,2] := 0.3547079765396403;
//     c2[10,1] := 0.08474633796250476;
//     c2[10,2] := 0.2774145482392767;
//     c2[11,1] := 0.07627722381240495;
//     c2[11,2] := 0.1939329108084139;
//     c2[12,1] := 0.06618645465422746;
//     c2[12,2] := 0.1016670147947242;
//   elseif order == 25 then
//     alpha := 0.1725220521949266;
//     c1[1] := 0.3429735385896;
//     c2[1,1] := 0.1172525033170618;
//     c2[1,2] := 0.6812327932576614;
//     c2[2,1] := 0.1161194585333535;
//     c2[2,2] := 0.6671566071153211;
//     c2[3,1] := 0.1142375145794466;
//     c2[3,2] := 0.6439167855053158;
//     c2[4,1] := 0.1116157454252308;
//     c2[4,2] := 0.6118378416180135;
//     c2[5,1] := 0.1082654809459177;
//     c2[5,2] := 0.5713609763370088;
//     c2[6,1] := 0.1041985674230918;
//     c2[6,2] := 0.5230289949762722;
//     c2[7,1] := 0.09942439308123559;
//     c2[7,2] := 0.4674627926041906;
//     c2[8,1] := 0.09394453593830893;
//     c2[8,2] := 0.4053226688298811;
//     c2[9,1] := 0.08774221237222533;
//     c2[9,2] := 0.3372372276379071;
//     c2[10,1] := 0.08075839512216483;
//     c2[10,2] := 0.2636485508005428;
//     c2[11,1] := 0.07282483286646764;
//     c2[11,2] := 0.1843801345273085;
//     c2[12,1] := 0.06338571166846652;
//     c2[12,2] := 0.09680153764737714;
//   elseif order == 26 then
//     alpha := 0.1690795702796737;
//     c2[1,1] := 0.113316869579603;
//     c2[1,2] := 0.6724297955493932;
//     c2[2,1] := 0.1126417845769961;
//     c2[2,2] := 0.663870951979054;
//     c2[3,1] := 0.1112948749545606;
//     c2[3,2] := 0.6468652038763624;
//     c2[4,1] := 0.1092823986944244;
//     c2[4,2] := 0.6216337070799265;
//     c2[5,1] := 0.1066130386697976;
//     c2[5,2] := 0.588501141399219;
//     c2[6,1] := 0.1032969057045413;
//     c2[6,2] := 0.5478864278297548;
//     c2[7,1] := 0.09934388184210716;
//     c2[7,2] := 0.5002885306054287;
//     c2[8,1] := 0.09476081523436283;
//     c2[8,2] := 0.4462644847551711;
//     c2[9,1] := 0.08954648464575576;
//     c2[9,2] := 0.3863930785049522;
//     c2[10,1] := 0.08368166847159916;
//     c2[10,2] := 0.3212074592527143;
//     c2[11,1] := 0.07710664731701103;
//     c2[11,2] := 0.2510470347119383;
//     c2[12,1] := 0.06965807988411425;
//     c2[12,2] := 0.1756419294111342;
//     c2[13,1] := 0.06080674930548766;
//     c2[13,2] := 0.09234535279274277;
//   elseif order == 27 then
//     alpha := 0.1658353543067995;
//     c1[1] := 0.3308543720638957;
//     c2[1,1] := 0.1091618578712746;
//     c2[1,2] := 0.6577977071169651;
//     c2[2,1] := 0.1082549561495043;
//     c2[2,2] := 0.6461121666520275;
//     c2[3,1] := 0.1067479247890451;
//     c2[3,2] := 0.6267937760991321;
//     c2[4,1] := 0.1046471079537577;
//     c2[4,2] := 0.6000750116745808;
//     c2[5,1] := 0.1019605976654259;
//     c2[5,2] := 0.566273418304932;
//     c2[6,1] := 0.0986972695443371;
//     c2[6,2] := 0.5257827234948534;
//     c2[7,1] := 0.09486520934132484;
//     c2[7,2] := 0.4790595019077763;
//     c2[8,1] := 0.09046906518775348;
//     c2[8,2] := 0.4266025862147336;
//     c2[9,1] := 0.08550529998276152;
//     c2[9,2] := 0.3689188223512328;
//     c2[10,1] := 0.0799528223930602;
//     c2[10,2] := 0.3064589322702932;
//     c2[11,1] := 0.07375174596252881;
//     c2[11,2] := 0.239475450466731;
//     c2[12,1] := 0.06674377263329041;
//     c2[12,2] := 0.1676223546666024;
//     c2[13,1] := 0.05842458027529246;
//     c2[13,2] := 0.08825044329219431;
//   elseif order == 28 then
//     alpha := 0.1627710671942929;
//     c2[1,1] := 0.1057232656113488;
//     c2[1,2] := 0.6496161226860832;
//     c2[2,1] := 0.1051786825724864;
//     c2[2,2] := 0.6424661279909941;
//     c2[3,1] := 0.1040917964935006;
//     c2[3,2] := 0.6282470268918791;
//     c2[4,1] := 0.1024670101953951;
//     c2[4,2] := 0.6071189030701136;
//     c2[5,1] := 0.1003105109519892;
//     c2[5,2] := 0.5793175191747016;
//     c2[6,1] := 0.09762969425430802;
//     c2[6,2] := 0.5451486608855443;
//     c2[7,1] := 0.094432238030584;
//     c2[7,2] := 0.5049796971628137;
//     c2[8,1] := 0.09072460982036488;
//     c2[8,2] := 0.4592270546572523;
//     c2[9,1] := 0.0865095642325328;
//     c2[9,2] := 0.4083368605952977;
//     c2[10,1] := 0.08178165740374893;
//     c2[10,2] := 0.3527525188880655;
//     c2[11,1] := 0.0765183888586802;
//     c2[11,2] := 0.2928534570013572;
//     c2[12,1] := 0.0706601053244749;
//     c2[12,2] := 0.2288185204390681;
//     c2[13,1] := 0.0640535859614579;
//     c2[13,2] := 0.160239617258819;
//     c2[14,1] := 0.05621780070227172;
//     c2[14,2] := 0.08447589564915071;
//   elseif order == 29 then
//     alpha := 0.1598706626277596;
//     c1[1] := 0.3199314513011623;
//     c2[1,1] := 0.1021101032532951;
//     c2[1,2] := 0.6365758882240111;
//     c2[2,1] := 0.1013729819392774;
//     c2[2,2] := 0.6267495975736321;
//     c2[3,1] := 0.1001476175660628;
//     c2[3,2] := 0.6104876178266819;
//     c2[4,1] := 0.09843854640428316;
//     c2[4,2] := 0.5879603139195113;
//     c2[5,1] := 0.09625164534591696;
//     c2[5,2] := 0.559401229105021;
//     c2[6,1] := 0.09359356960417668;
//     c2[6,2] := 0.5251016150410664;
//     c2[7,1] := 0.09047086748649986;
//     c2[7,2] := 0.4854024475590397;
//     c2[8,1] := 0.08688856407189167;
//     c2[8,2] := 0.4406826457109709;
//     c2[9,1] := 0.08284779224069856;
//     c2[9,2] := 0.3913408089298914;
//     c2[10,1] := 0.07834154620997182;
//     c2[10,2] := 0.3377643999400627;
//     c2[11,1] := 0.07334628941928766;
//     c2[11,2] := 0.2802710651919946;
//     c2[12,1] := 0.06780290487362146;
//     c2[12,2] := 0.2189770008083379;
//     c2[13,1] := 0.06156321231528423;
//     c2[13,2] := 0.153423599930607;
//     c2[14,1] := 0.05416797446761512;
//     c2[14,2] := 0.08098664736760292;
//   elseif order == 30 then
//     alpha := 0.157120029625245;
//     c2[1,1] := 0.09908074847842124;
//     c2[1,2] := 0.6289618807831557;
//     c2[2,1] := 0.09863509708328196;
//     c2[2,2] := 0.6229164525571278;
//     c2[3,1] := 0.09774542692037148;
//     c2[3,2] := 0.6108853364240036;
//     c2[4,1] := 0.09641490581986484;
//     c2[4,2] := 0.5929869253412513;
//     c2[5,1] := 0.09464802912225441;
//     c2[5,2] := 0.569396017554755;
//     c2[6,1] := 0.09245027206218041;
//     c2[6,2] := 0.5403402396359503;
//     c2[7,1] := 0.08982754584112941;
//     c2[7,2] := 0.5060948065875106;
//     c2[8,1] := 0.08678535291732599;
//     c2[8,2] := 0.4669749797983789;
//     c2[9,1] := 0.083327442420522;
//     c2[9,2] := 0.4233249626334694;
//     c2[10,1] := 0.07945356393775309;
//     c2[10,2] := 0.3755006094498054;
//     c2[11,1] := 0.07515543969833788;
//     c2[11,2] := 0.32384003392927;
//     c2[12,1] := 0.07040879901685639;
//     c2[12,2] := 0.2686072427439079;
//     c2[13,1] := 0.0651552885401054;
//     c2[13,2] := 0.2098650589782619;
//     c2[14,1] := 0.05925168237177876;
//     c2[14,2] := 0.1471138832654873;
//     c2[15,1] := 0.05225913954211672;
//     c2[15,2] := 0.07775248839507864;
//   elseif order == 31 then
//     alpha := 0.1545067022920929;
//     c1[1] := 0.3100206996451866;
//     c2[1,1] := 0.09591020358831669;
//     c2[1,2] := 0.6172474793293397;
//     c2[2,1] := 0.09530301275601202;
//     c2[2,2] := 0.6088916323460413;
//     c2[3,1] := 0.09429332655402368;
//     c2[3,2] := 0.5950511595503025;
//     c2[4,1] := 0.09288445429894548;
//     c2[4,2] := 0.5758534119053522;
//     c2[5,1] := 0.09108073420087422;
//     c2[5,2] := 0.5514734636081183;
//     c2[6,1] := 0.0888871913753687;
//     c2[6,2] := 0.5221306199481831;
//     c2[7,1] := 0.0863090144023965;
//     c2[7,2] := 0.4880834248148061;
//     c2[8,1] := 0.08335074993373294;
//     c2[8,2] := 0.449622535849677;
//     c2[9,1] := 0.08001502494376102;
//     c2[9,2] := 0.4070602306679052;
//     c2[10,1] := 0.07630041338037624;
//     c2[10,2] := 0.3607139804818122;
//     c2[11,1] := 0.0721976088574492;
//     c2[11,2] := 0.310878330122955;
//     c2[12,1] := 0.06768185077153345;
//     c2[12,2] := 0.2577706252514497;
//     c2[13,1] := 0.06269571766328638;
//     c2[13,2] := 0.2014081375889921;
//     c2[14,1] := 0.05710081766945065;
//     c2[14,2] := 0.1412581515841926;
//     c2[15,1] := 0.05047740914807019;
//     c2[15,2] := 0.07474725873250158;
//   elseif order == 32 then
//     alpha := 0.152019621084821;
//     c2[1,1] := 0.09322163554339406;
//     c2[1,2] := 0.610148869050605;
//     c2[2,1] := 0.09285233997694042;
//     c2[2,2] := 0.6049832320721265;
//     c2[3,1] := 0.09211494244473163;
//     c2[3,2] := 0.5946969295569035;
//     c2[4,1] := 0.09101176786042449;
//     c2[4,2] := 0.5793791854364477;
//     c2[5,1] := 0.08954614071360517;
//     c2[5,2] := 0.5591619969234026;
//     c2[6,1] := 0.08772216763680164;
//     c2[6,2] := 0.5342177994699602;
//     c2[7,1] := 0.08554440426912734;
//     c2[7,2] := 0.5047560942986598;
//     c2[8,1] := 0.08301735302045588;
//     c2[8,2] := 0.4710187048140929;
//     c2[9,1] := 0.08014469519188161;
//     c2[9,2] := 0.4332730387207936;
//     c2[10,1] := 0.07692807528893225;
//     c2[10,2] := 0.3918021436411035;
//     c2[11,1] := 0.07336507157284898;
//     c2[11,2] := 0.346889052147125;
//     c2[12,1] := 0.06944555312763458;
//     c2[12,2] := 0.298789802905046;
//     c2[13,1] := 0.0651444666942057;
//     c2[13,2] := 0.2476810747407199;
//     c2[14,1] := 0.06040544477732702;
//     c2[14,2] := 0.1935412053397663;
//     c2[15,1] := 0.05509478650672775;
//     c2[15,2] := 0.1358108994174911;
//     c2[16,1] := 0.04881064725720192;
//     c2[16,2] := 0.07194819894416506;
//   elseif order == 33 then
//     alpha := 0.1496489351138032;
//     c1[1] := 0.3009752799176432;
//     c2[1,1] := 0.09041725460994506;
//     c2[1,2] := 0.5995521047364046;
//     c2[2,1] := 0.08991117804113002;
//     c2[2,2] := 0.5923764112099495;
//     c2[3,1] := 0.08906941547422532;
//     c2[3,2] := 0.5804822013853129;
//     c2[4,1] := 0.08789442491445575;
//     c2[4,2] := 0.5639663528946501;
//     c2[5,1] := 0.08638945831033774;
//     c2[5,2] := 0.5429623519607796;
//     c2[6,1] := 0.08455834602616358;
//     c2[6,2] := 0.5176379938389326;
//     c2[7,1] := 0.08240517431382334;
//     c2[7,2] := 0.4881921474066189;
//     c2[8,1] := 0.07993380417355075;
//     c2[8,2] := 0.4548502528082586;
//     c2[9,1] := 0.07714713890732801;
//     c2[9,2] := 0.4178579388038483;
//     c2[10,1] := 0.07404596598181128;
//     c2[10,2] := 0.3774715722484659;
//     c2[11,1] := 0.07062702339160462;
//     c2[11,2] := 0.3339432938810453;
//     c2[12,1] := 0.06687952672391508;
//     c2[12,2] := 0.2874950693388235;
//     c2[13,1] := 0.06277828912909766;
//     c2[13,2] := 0.2382680702894708;
//     c2[14,1] := 0.05826808305383988;
//     c2[14,2] := 0.1862073169968455;
//     c2[15,1] := 0.05321974125363517;
//     c2[15,2] := 0.1307323751236313;
//     c2[16,1] := 0.0472482028203278;
//     c2[16,2] := 0.06933542082177094;
//   elseif order == 34 then
//     alpha := 0.1473858373968463;
//     c2[1,1] := 0.08801537152275983;
//     c2[1,2] := 0.5929204288972172;
//     c2[2,1] := 0.08770594341007476;
//     c2[2,2] := 0.5884653382247518;
//     c2[3,1] := 0.08708797598072095;
//     c2[3,2] := 0.5795895850253119;
//     c2[4,1] := 0.08616320590689187;
//     c2[4,2] := 0.566361538364717;
//     c2[5,1] := 0.08493413175570858;
//     c2[5,2] := 0.5488825092350877;
//     c2[6,1] := 0.08340387368687513;
//     c2[6,2] := 0.5272851839324592;
//     c2[7,1] := 0.08157596213131521;
//     c2[7,2] := 0.5017313864372913;
//     c2[8,1] := 0.0794540267083427;
//     c2[8,2] := 0.4724089864574216;
//     c2[9,1] := 0.0770413355955643;
//     c2[9,2] := 0.4395276256463053;
//     c2[10,1] := 0.07434009635219704;
//     c2[10,2] := 0.4033126590648964;
//     c2[11,1] := 0.07135035113853376;
//     c2[11,2] := 0.3639961488919042;
//     c2[12,1] := 0.06806813160738834;
//     c2[12,2] := 0.3218025212900124;
//     c2[13,1] := 0.06448214312000863;
//     c2[13,2] := 0.2769235521088158;
//     c2[14,1] := 0.0605671931843053;
//     c2[14,2] := 0.2294693573271038;
//     c2[15,1] := 0.0562692519692504;
//     c2[15,2] := 0.1793564218840015;
//     c2[16,1] := 0.05146352031547277;
//     c2[16,2] := 0.1259877129326412;
//     c2[17,1] := 0.04578069074410591;
//     c2[17,2] := 0.06689147319568768;
//   elseif order == 35 then
//     alpha := 0.1452224267615486;
//     c1[1] := 0.2926764667564367;
//     c2[1,1] := 0.0855173129926728;
//     c2[1,2] := 0.5832758214629523;
//     c2[2,1] := 0.0850910973285306;
//     c2[2,2] := 0.5770596582643844;
//     c2[3,1] := 0.08438201446671953;
//     c2[3,2] := 0.5667497616665494;
//     c2[4,1] := 0.08339191981579831;
//     c2[4,2] := 0.5524209816238369;
//     c2[5,1] := 0.08212328610083384;
//     c2[5,2] := 0.5341766459916322;
//     c2[6,1] := 0.08057906332198853;
//     c2[6,2] := 0.512147005351275;
//     c2[7,1] := 0.07876247299954955;
//     c2[7,2] := 0.4864870722254752;
//     c2[8,1] := 0.07667670879950268;
//     c2[8,2] := 0.4573736721705665;
//     c2[9,1] := 0.07432449556218945;
//     c2[9,2] := 0.4250013835198991;
//     c2[10,1] := 0.07170742126011576;
//     c2[10,2] := 0.3895767735915445;
//     c2[11,1] := 0.06882488171701313;
//     c2[11,2] := 0.3513097926737368;
//     c2[12,1] := 0.06567231746957568;
//     c2[12,2] := 0.3103999917596611;
//     c2[13,1] := 0.06223804362223595;
//     c2[13,2] := 0.2670123611280899;
//     c2[14,1] := 0.0584969646078291;
//     c2[14,2] := 0.2212298104867592;
//     c2[15,1] := 0.05439628409499822;
//     c2[15,2] := 0.1729443731341637;
//     c2[16,1] := 0.0498154017913692;
//     c2[16,2] := 0.121546215713493;
//     c2[17,1] := 0.04439981033536435;
//     c2[17,2] := 0.06460098363520966;
//   elseif order == 36 then
//     alpha := 0.143151591445858;
//     c2[1,1] := 0.08335881847130301;
//     c2[1,2] := 0.5770670512160201;
//     c2[2,1] := 0.08309698922852211;
//     c2[2,2] := 0.5731929100172432;
//     c2[3,1] := 0.08257400347039723;
//     c2[3,2] := 0.5654713811993058;
//     c2[4,1] := 0.08179117911600137;
//     c2[4,2] := 0.553955634360302;
//     c2[5,1] := 0.08075042173126963;
//     c2[5,2] := 0.5387245649546684;
//     c2[6,1] := 0.07945413151258206;
//     c2[6,2] := 0.5198817177723069;
//     c2[7,1] := 0.07790506514288865;
//     c2[7,2] := 0.4975537629595409;
//     c2[8,1] := 0.0761061363533948;
//     c2[8,2] := 0.4718884193866789;
//     c2[9,1] := 0.07406012816626426;
//     c2[9,2] := 0.4430516443136726;
//     c2[10,1] := 0.0717692706020563;
//     c2[10,2] := 0.4112237708115829;
//     c2[11,1] := 0.0692346017250425;
//     c2[11,2] := 0.376594011638973;
//     c2[12,1] := 0.06645495833489556;
//     c2[12,2] := 0.3393522147815403;
//     c2[13,1] := 0.06342528888937093;
//     c2[13,2] := 0.2996755899575573;
//     c2[14,1] := 0.06013361864949449;
//     c2[14,2] := 0.257705329405383;
//     c2[15,1] := 0.05655503081322404;
//     c2[15,2] := 0.2135004731531631;
//     c2[16,1] := 0.05263798119559069;
//     c2[16,2] := 0.1669320999865636;
//     c2[17,1] := 0.04826589873626196;
//     c2[17,2] := 0.1173807590715484;
//     c2[18,1] := 0.04309819397289806;
//     c2[18,2] := 0.06245036108880222;
//   elseif order == 37 then
//     alpha := 0.1411669104782917;
//     c1[1] := 0.2850271036215707;
//     c2[1,1] := 0.08111958235023328;
//     c2[1,2] := 0.568241261056397;
//     c2[2,1] := 0.08075727567979578;
//     c2[2,2] := 0.5628142923227016;
//     c2[3,1] := 0.08015440554413301;
//     c2[3,2] := 0.553808769687993;
//     c2[4,1] := 0.07931239302677386;
//     c2[4,2] := 0.541283332330446;
//     c2[5,1] := 0.07823314328639347;
//     c2[5,2] := 0.5253190555393968;
//     c2[6,1] := 0.07691895211595101;
//     c2[6,2] := 0.5060183741977191;
//     c2[7,1] := 0.07537237072011853;
//     c2[7,2] := 0.4835036020049034;
//     c2[8,1] := 0.07359601294804538;
//     c2[8,2] := 0.4579149413954837;
//     c2[9,1] := 0.071592278848493;
//     c2[9,2] := 0.4294078049978829;
//     c2[10,1] := 0.06936295002846032;
//     c2[10,2] := 0.3981491350382047;
//     c2[11,1] := 0.06690857785828917;
//     c2[11,2] := 0.3643121502867948;
//     c2[12,1] := 0.06422751692085542;
//     c2[12,2] := 0.3280684291406284;
//     c2[13,1] := 0.06131430866206096;
//     c2[13,2] := 0.2895750997170303;
//     c2[14,1] := 0.0581567724957092;
//     c2[14,2] := 0.248952181480572;
//     c2[15,1] := 0.0547302352794798;
//     c2[15,2] := 0.2062377435955363;
//     c2[16,1] := 0.05098441033167034;
//     c2[16,2] := 0.1612849131645336;
//     c2[17,1] := 0.04680658811093562;
//     c2[17,2] := 0.1134672937045305;
//     c2[18,1] := 0.04186928031694695;
//     c2[18,2] := 0.06042754777339966;
//   elseif order == 38 then
//     alpha := 0.139262569714003;
//     c2[1,1] := 0.07916943373658329;
//     c2[1,2] := 0.5624158631591745;
//     c2[2,1] := 0.0789459225025784;
//     c2[2,2] := 0.5590219398777304;
//     c2[3,1] := 0.0784994167238493;
//     c2[3,2] := 0.5522551628416841;
//     c2[4,1] := 0.07783093084875645;
//     c2[4,2] := 0.542157432580838;
//     c2[5,1] := 0.0769419377048269;
//     c2[5,2] := 0.5287909941093643;
//     c2[6,1] := 0.07583430534712884;
//     c2[6,2] := 0.512237681402988;
//     c2[7,1] := 0.07451020436122947;
//     c2[7,2] := 0.4925978555548549;
//     c2[8,1] := 0.07297197617673508;
//     c2[8,2] := 0.4699889739625235;
//     c2[9,1] := 0.07122194706992953;
//     c2[9,2] := 0.4445436860615774;
//     c2[10,1] := 0.06926216260386817;
//     c2[10,2] := 0.4164072786327193;
//     c2[11,1] := 0.06709399961255504;
//     c2[11,2] := 0.3857341621868851;
//     c2[12,1] := 0.06471757977022456;
//     c2[12,2] := 0.3526828388476838;
//     c2[13,1] := 0.06213084287116965;
//     c2[13,2] := 0.3174082831364342;
//     c2[14,1] := 0.05932799638550641;
//     c2[14,2] := 0.2800495563550299;
//     c2[15,1] := 0.05629672408524944;
//     c2[15,2] := 0.2407078154782509;
//     c2[16,1] := 0.05301264751544952;
//     c2[16,2] := 0.1994026830553859;
//     c2[17,1] := 0.04942673259817896;
//     c2[17,2] := 0.1559719194038917;
//     c2[18,1] := 0.04542996716979947;
//     c2[18,2] := 0.109784427787847;
//     c2[19,1] := 0.04070720755433961;
//     c2[19,2] := 0.05852181110523043;
//   elseif order == 39 then
//     alpha := 0.1374332900196804;
//     c1[1] := 0.2779468246419593;
//     c2[1,1] := 0.07715084161825772;
//     c2[1,2] := 0.5543001331300056;
//     c2[2,1] := 0.07684028301163326;
//     c2[2,2] := 0.5495289890712267;
//     c2[3,1] := 0.07632343924866024;
//     c2[3,2] := 0.5416083298429741;
//     c2[4,1] := 0.07560141319808483;
//     c2[4,2] := 0.5305846713929198;
//     c2[5,1] := 0.07467569064745969;
//     c2[5,2] := 0.5165224112570647;
//     c2[6,1] := 0.07354807648551347;
//     c2[6,2] := 0.4995030679271456;
//     c2[7,1] := 0.07222060351121388;
//     c2[7,2] := 0.4796242430956156;
//     c2[8,1] := 0.07069540462458584;
//     c2[8,2] := 0.4569982440368368;
//     c2[9,1] := 0.0689745335349238;
//     c2[9,2] := 0.4317502624832354;
//     c2[10,1] := 0.06705970959388781;
//     c2[10,2] := 0.4040159353969854;
//     c2[11,1] := 0.06495194541066725;
//     c2[11,2] := 0.3739379843169939;
//     c2[12,1] := 0.0626509841241761;
//     c2[12,2] := 0.3416613843816217;
//     c2[13,1] := 0.0601544098495593;
//     c2[13,2] := 0.3073260166338746;
//     c2[14,1] := 0.05745615876877304;
//     c2[14,2] := 0.2710546723961181;
//     c2[15,1] := 0.05454383762391338;
//     c2[15,2] := 0.232931682406117;
//     c2[16,1] := 0.05139340231935751;
//     c2[16,2] := 0.1929604256043231;
//     c2[17,1] := 0.04795705862458131;
//     c2[17,2] := 0.1509655259246037;
//     c2[18,1] := 0.04412933231935506;
//     c2[18,2] := 0.1063130748962878;
//     c2[19,1] := 0.03960672309405603;
//     c2[19,2] := 0.05672356837211527;
//   elseif order == 40 then
//     alpha := 0.1356742655825434;
//     c2[1,1] := 0.07538038374294594;
//     c2[1,2] := 0.5488228264329617;
//     c2[2,1] := 0.07518806529402738;
//     c2[2,2] := 0.5458297722483311;
//     c2[3,1] := 0.07480383050347118;
//     c2[3,2] := 0.539860457673054;
//     c2[4,1] := 0.07422847031965465;
//     c2[4,2] := 0.5309482987446206;
//     c2[5,1] := 0.07346313704205006;
//     c2[5,2] := 0.5191429845322307;
//     c2[6,1] := 0.07250930053201401;
//     c2[6,2] := 0.5045099368431007;
//     c2[7,1] := 0.0713686845687962;
//     c2[7,2] := 0.4871295553902607;
//     c2[8,1] := 0.07004317764946634;
//     c2[8,2] := 0.4670962098860498;
//     c2[9,1] := 0.06853470921527828;
//     c2[9,2] := 0.4445169164956202;
//     c2[10,1] := 0.06684507689945471;
//     c2[10,2] := 0.4195095960479698;
//     c2[11,1] := 0.0649757012341263;
//     c2[11,2] := 0.3922007419030645;
//     c2[12,1] := 0.06292726794917847;
//     c2[12,2] := 0.3627221993494397;
//     c2[13,1] := 0.06069918741663154;
//     c2[13,2] := 0.3312065181294388;
//     c2[14,1] := 0.0582887398376941;
//     c2[14,2] := 0.2977798532686911;
//     c2[15,1] := 0.05568964389813015;
//     c2[15,2] := 0.2625503293999835;
//     c2[16,1] := 0.05288947816690705;
//     c2[16,2] := 0.2255872486520188;
//     c2[17,1] := 0.04986456327645859;
//     c2[17,2] := 0.1868796731919594;
//     c2[18,1] := 0.04656832613054458;
//     c2[18,2] := 0.1462410193532463;
//     c2[19,1] := 0.04289867647614935;
//     c2[19,2] := 0.1030361558710747;
//     c2[20,1] := 0.03856310684054106;
//     c2[20,2] := 0.05502423832293889;
//   elseif order == 41 then
//     alpha := 0.1339811106984253;
//     c1[1] := 0.2713685065531391;
//     c2[1,1] := 0.07355140275160985;
//     c2[1,2] := 0.541327477828286;
//     c2[2,1] := 0.07328319082267173;
//     c2[2,2] := 0.537106408829427;
//     c2[3,1] := 0.07283676160772547;
//     c2[3,2] := 0.530096343727077;
//     c2[4,1] := 0.07221298133014344;
//     c2[4,2] := 0.520334599837149;
//     c2[5,1] := 0.07141302173623396;
//     c2[5,2] := 0.5078728971879841;
//     c2[6,1] := 0.07043831559982149;
//     c2[6,2] := 0.4927768111819803;
//     c2[7,1] := 0.06929049381827268;
//     c2[7,2] := 0.4751250308594139;
//     c2[8,1] := 0.06797129849758392;
//     c2[8,2] := 0.4550083840638406;
//     c2[9,1] := 0.06648246325101609;
//     c2[9,2] := 0.4325285673076087;
//     c2[10,1] := 0.06482554675958525;
//     c2[10,2] := 0.4077964789091151;
//     c2[11,1] := 0.06300169683004558;
//     c2[11,2] := 0.3809299858742483;
//     c2[12,1] := 0.06101130648543355;
//     c2[12,2] := 0.3520508315700898;
//     c2[13,1] := 0.05885349417435808;
//     c2[13,2] := 0.3212801560701271;
//     c2[14,1] := 0.05652528148656809;
//     c2[14,2] := 0.2887316252774887;
//     c2[15,1] := 0.05402021575818373;
//     c2[15,2] := 0.2545001287790888;
//     c2[16,1] := 0.05132588802608274;
//     c2[16,2] := 0.2186415296842951;
//     c2[17,1] := 0.04841900639702602;
//     c2[17,2] := 0.181132262229606;
//     c2[18,1] := 0.04525419574485134;
//     c2[18,2] := 0.1417762065404688;
//     c2[19,1] := 0.04173260173087802;
//     c2[19,2] := 0.0999383453096651;
//     c2[20,1] := 0.03757210572966463;
//     c2[20,2] := 0.05341611499960143;
//   else
//     Modelica.Utilities.Streams.error(\"Input argument order (= \" + String(order,0,true) + \") of Bessel filter is not in the range 1..41\");
//   end if;
// end Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor \"Compute correction factor of low pass filter such that amplitude at cut-off frequency is -3db (=10^(-3/20) = 0.70794...)\"
//   input Real[:] c1 \"[p] coefficients of denominator polynomials (c1[i}*p + 1)\";
//   input Real[:, 2] c2 \"[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)\";
//   output Real alpha \"Correction factor (replace p by alpha*p)\";
//   protected Real alpha_min;
//   protected Real alpha_max;
// algorithm
//   (alpha_min, alpha_max) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval(c1,c2);
//   alpha := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation(c1,c2,alpha_min,alpha_max,0.0000000000001);
// end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval \"Find interval for the root\"
//   input Real[:] c1 \"[p] coefficients of denominator polynomials (a*p + 1)\";
//   input Real[:, 2] c2 \"[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)\";
//   output Real alpha_min;
//   output Real alpha_max;
//   protected Real alpha = 1.0;
//   protected Real residue;
// algorithm
//   alpha_min := 0.0;
//   residue := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1,c2,alpha);
//   if residue < 0.0 then
//     alpha_max := alpha;
//   else
//     while residue >= 0.0 loop
//       alpha := 1.1 * alpha;
//       residue := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1,c2,alpha);
//     end while;
//     alpha_max := alpha;
//   end if;
// end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue \"Residue of correction factor computation\"
//   input Real[:] c1 \"[p] coefficients of denominator polynomials (c1[i]*p + 1)\";
//   input Real[:, 2] c2 \"[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)\";
//   input Real alpha;
//   output Real residue;
//   protected constant Real beta = 0.7079457843841379 \"Amplitude of -3db required, i.e., -3db = 20*log(beta)\";
//   protected Real cc1;
//   protected Real cc2;
//   protected Real p;
//   protected Real alpha2 = alpha ^ 2.0;
//   protected Real alpha4 = alpha2 ^ 2.0;
//   protected Real A2 = 1.0;
// algorithm
//   assert( size(c1,1) <= 1, \"Internal error 2 (should not occur)\");
//   if size(c1,1) == 1 then
//     cc1 := c1[1] ^ 2.0;
//     p := 1.0 + cc1 * alpha2;
//     A2 := A2 * p;
//   end if;
//   for i in 1:size(c2,1) loop
//     cc1 := c2[i,2] ^ 2.0 + -2.0 * c2[i,1];
//     cc2 := c2[i,1] ^ 2.0;
//     p := 1.0 + cc1 * alpha2 + cc2 * alpha4;
//     A2 := A2 * p;
//   end for;
//   residue := 1.0 / sqrt(A2) + -0.7079457843841379;
// end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation \"Solve f(u) = 0; f(u_min) and f(u_max) must have different signs\"
//   input Real[:] c1 \"[p] coefficients of denominator polynomials (c1[i]*p + 1)\";
//   input Real[:, 2] c2 \"[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)\";
//   input Real u_min \"Lower bound of search intervall\";
//   input Real u_max \"Upper bound of search intervall\";
//   input Real tolerance = 0.0000000000001 \"Relative tolerance of solution u\";
//   output Real u \"Value of independent variable so that f(u) = 0\";
//   protected constant Real eps = 0.000000000000001 \"machine epsilon\";
//   protected Real a = u_min \"Current best minimum interval value\";
//   protected Real b = u_max \"Current best maximum interval value\";
//   protected Real c \"Intermediate point a <= c <= b\";
//   protected Real d;
//   protected Real e \"b - a\";
//   protected Real m;
//   protected Real s;
//   protected Real p;
//   protected Real q;
//   protected Real r;
//   protected Real tol;
//   protected Real fa \"= f(a)\";
//   protected Real fb \"= f(b)\";
//   protected Real fc;
//   protected Boolean found = false;
// algorithm
//   fa := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1,c2,u_min);
//   fb := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1,c2,u_max);
//   fc := fb;
//   if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
//     Modelica.Utilities.Streams.error(\"The arguments u_min and u_max to solveOneNonlinearEquation(..)
// do not bracket the root of the single non-linear equation:
//   u_min  = \" + String(u_min,0,true,6) + \"
// \" + \"  u_max  = \" + String(u_max,0,true,6) + \"
// \" + \"  fa = f(u_min) = \" + String(fa,0,true,6) + \"
// \" + \"  fb = f(u_max) = \" + String(fb,0,true,6) + \"
// \" + \"fa and fb must have opposite sign which is not the case\");
//   end if;
//   c := a;
//   fc := fa;
//   e := b - a;
//   d := e;
//   while not found loop
//     if abs(fc) < abs(fb) then
//       a := b;
//       b := c;
//       c := a;
//       fa := fb;
//       fb := fc;
//       fc := fa;
//     end if;
//     tol := 0.000000000000002 * abs(b) + tolerance;
//     m := c / 2.0 + -b / 2.0;
//     if abs(m) <= tol or fb == 0.0 then
//       found := true;
//       u := b;
//     else
//       if abs(e) < tol or abs(fa) <= abs(fb) then
//         e := m;
//         d := e;
//       else
//         s := fb / fa;
//         if a == c then
//           p := 2.0 * m * s;
//           q := 1.0 - s;
//         else
//           q := fa / fc;
//           r := fb / fc;
//           p := s * (2.0 * m * q * (q - r) - (b - a) * (-1.0 + r));
//           q := (-1.0 + q) * (-1.0 + r) * (-1.0 + s);
//         end if;
//         if p > 0.0 then
//           q := -q;
//         else
//           p := -p;
//         end if;
//         s := e;
//         e := d;
//         if 2.0 * p < 3.0 * m * q - abs(tol * q) and p < abs(0.5 * s * q) then
//           d := p / q;
//         else
//           e := m;
//           d := e;
//         end if;
//       end if;
//       a := b;
//       fa := fb;
//       b := b + if abs(d) > tol then d else if m > 0.0 then tol else -tol;
//       fb := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1,c2,b);
//       if fb > 0.0 and fc > 0.0 or fb < 0.0 and fc < 0.0 then
//         c := a;
//         fc := fa;
//         e := b - a;
//         d := e;
//       end if;
//     end if;
//   end while;
// end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne \"Transform filter to form with highest power of s equal 1\"
//   input Real[:] den1 \"[s] coefficients of polynomials (den1[i]*s + 1)\";
//   input Real[:, 2] den2 \"[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)\";
//   output Real[size(den1,1)] cr \"[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])\";
//   output Real[size(den2,1)] c0 \"[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))\";
//   output Real[size(den2,1)] c1 \"[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))\";
// algorithm
//   for i in 1:size(den1,1) loop
//     cr[i] := 1.0 / den1[i];
//   end for;
//   for i in 1:size(den2,1) loop
//     c1[i] := den2[i,2] / den2[i,1];
//     c0[i] := 1.0 / den2[i,1];
//   end for;
// end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.base.Bessel \"Return base filter coefficients of Bessel filter (= low pass filter with w_cut = 1 rad/s)\"
//   input Integer order(min = 1) \"Order of filter\";
//   input Boolean normalized = true \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   output Real[mod(order,2)] cr \"Coefficient of real pole\";
//   output Real[integer(Real(order) / 2.0)] c0 \"Coefficients of s^0 term if conjugate complex pole\";
//   output Real[integer(Real(order) / 2.0)] c1 \"Coefficients of s^1 term if conjugate complex pole\";
//   protected Integer n_den2 = size(c0,1);
//   protected Real alpha = 1.0 \"Frequency correction factor\";
//   protected Real alpha2 \"= alpha*alpha\";
//   protected Real[size(cr,1)] den1 \"[p] coefficients of denominator first order polynomials (a*p + 1)\";
//   protected Real[n_den2, 2] den2 \"[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)\";
// algorithm
//   (den1, den2, alpha) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients(order);
//   if not normalized then
//     alpha2 := alpha ^ 2.0;
//     for i in 1:n_den2 loop
//       den2[i,1] := den2[i,1] * alpha2;
//       den2[i,2] := den2[i,2] * alpha;
//     end for;
//     if size(cr,1) == 1 then
//       den1[1] := den1[1] * alpha;
//     end if;
//   end if;
//   (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1,den2);
// end Modelica.Blocks.Continuous.Internal.Filter.base.Bessel;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth \"Return base filter coefficients of Butterwort filter (= low pass filter with w_cut = 1 rad/s)\"
//   input Integer order(min = 1) \"Order of filter\";
//   input Boolean normalized = true \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   output Real[mod(order,2)] cr \"Coefficient of real pole\";
//   output Real[integer(Real(order) / 2.0)] c0 \"Coefficients of s^0 term if conjugate complex pole\";
//   output Real[integer(Real(order) / 2.0)] c1 \"Coefficients of s^1 term if conjugate complex pole\";
//   protected Integer n_den2 = size(c0,1);
//   protected Real alpha = 1.0 \"Frequency correction factor\";
//   protected Real alpha2 \"= alpha*alpha\";
//   protected constant Real pi = 3.141592653589793;
//   protected Real[size(cr,1)] den1 \"[p] coefficients of denominator first order polynomials (a*p + 1)\";
//   protected Real[n_den2, 2] den2 \"[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)\";
// algorithm
//   for i in 1:n_den2 loop
//     den2[i,1] := 1.0;
//     den2[i,2] := -2.0 * cos(1.5707963267948966 + (-1.5707963267948966 + 3.141592653589793 * /*T_REAL*/(i)) / /*T_REAL*/(order));
//   end for;
//   if size(cr,1) == 1 then
//     den1[1] := 1.0;
//   end if;
//   (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1,den2);
// end Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI \"Return base filter coefficients of Chebyshev I filter (= low pass filter with w_cut = 1 rad/s)\"
//   input Integer order(min = 1) \"Order of filter\";
//   input Real A_ripple = 0.5 \"Pass band ripple in [dB]\";
//   input Boolean normalized = true \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   output Real[mod(order,2)] cr \"Coefficient of real pole\";
//   output Real[integer(Real(order) / 2.0)] c0 \"Coefficients of s^0 term if conjugate complex pole\";
//   output Real[integer(Real(order) / 2.0)] c1 \"Coefficients of s^1 term if conjugate complex pole\";
//   protected Real epsilon;
//   protected Real fac;
//   protected Integer n_den2 = size(c0,1);
//   protected Real alpha = 1.0 \"Frequency correction factor\";
//   protected Real alpha2 \"= alpha*alpha\";
//   protected constant Real pi = 3.141592653589793;
//   protected Real[size(cr,1)] den1 \"[p] coefficients of denominator first order polynomials (a*p + 1)\";
//   protected Real[n_den2, 2] den2 \"[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)\";
// algorithm
//   epsilon := sqrt(10.0 ^ (A_ripple / 10.0) + -1.0);
//   fac := Modelica.Math.asinh(1.0 / epsilon) / /*T_REAL*/(order);
//   if size(cr,1) == 0 then
//     for i in 1:n_den2 loop
//       den2[i,1] := 1.0 / (cosh(fac) ^ 2.0 - cos((3.141592653589793 * /*T_REAL*/(2 * i + -1)) / /*T_REAL*/(2 * order)) ^ 2.0);
//       den2[i,2] := 2.0 * den2[i,1] * sinh(fac) * cos((3.141592653589793 * /*T_REAL*/(2 * i + -1)) / /*T_REAL*/(2 * order));
//     end for;
//   else
//     den1[1] := 1.0 / sinh(fac);
//     for i in 1:n_den2 loop
//       den2[i,1] := 1.0 / (cosh(fac) ^ 2.0 - cos((3.141592653589793 * /*T_REAL*/(i)) / /*T_REAL*/(order)) ^ 2.0);
//       den2[i,2] := 2.0 * den2[i,1] * sinh(fac) * cos((3.141592653589793 * /*T_REAL*/(i)) / /*T_REAL*/(order));
//     end for;
//   end if;
//   if normalized then
//     alpha := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor(den1,den2);
//     alpha2 := alpha ^ 2.0;
//     for i in 1:n_den2 loop
//       den2[i,1] := den2[i,1] * alpha2;
//       den2[i,2] := den2[i,2] * alpha;
//     end for;
//     if size(cr,1) == 1 then
//       den1[1] := den1[1] * alpha;
//     end if;
//   end if;
//   (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1,den2);
// end Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping \"Return base filter coefficients of CriticalDamping filter (= low pass filter with w_cut = 1 rad/s)\"
//   input Integer order(min = 1) \"Order of filter\";
//   input Boolean normalized = true \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   output Real[order] cr \"Coefficients of real poles\";
//   protected Real alpha = 1.0 \"Frequency correction factor\";
//   protected Real alpha2 \"= alpha*alpha\";
//   protected Real[0, 2] den2 \"[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)\";
//   protected Real[0] c0 \"Coefficients of s^0 term if conjugate complex pole\";
//   protected Real[0] c1 \"Coefficients of s^1 term if conjugate complex pole\";
//   protected Real[order] den1 \"[p] coefficients of denominator first order polynomials (a*p + 1)\";
// algorithm
//   if normalized then
//     alpha := sqrt(10.0 ^ (0.3 / /*T_REAL*/(order)) + -1.0);
//   else
//     alpha := 1.0;
//   end if;
//   for i in 1:order loop
//     den1[i] := alpha;
//   end for;
//   (cr, {}, {}) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1,{{}});
// end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass \"Return low pass filter coefficients at given cut-off frequency\"
//   input Real[:] cr_in \"Coefficients of real poles\";
//   input Real[:] c0_in \"Coefficients of s^0 term if conjugate complex pole\";
//   input Real[size(c0_in,1)] c1_in \"Coefficients of s^1 term if conjugate complex pole\";
//   input Real f_cut(quantity = \"Frequency\", unit = \"Hz\") \"Cut-off frequency\";
//   output Real[size(cr_in,1)] cr \"Coefficient of real pole\";
//   output Real[size(c0_in,1)] c0 \"Coefficients of s^0 term if conjugate complex pole\";
//   output Real[size(c0_in,1)] c1 \"Coefficients of s^1 term if conjugate complex pole\";
//   protected constant Real pi = 3.141592653589793;
//   protected Real w_cut(quantity = \"AngularVelocity\", unit = \"rad/s\") = 6.283185307179586 * f_cut \"Cut-off angular frequency\";
//   protected Real w_cut2 = w_cut ^ 2.0;
// algorithm
//   assert( f_cut > 0.0, \"Cut-off frequency f_cut must be positive\");
//   cr := cr_in * w_cut;
//   c1 := c1_in * w_cut;
//   c0 := c0_in * w_cut2;
// end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;
// 
// function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass \"Return low pass filter roots as needed for block for given cut-off frequency\"
//   input Real[:] cr_in \"Coefficients of real poles of base filter\";
//   input Real[:] c0_in \"Coefficients of s^0 term of base filter if conjugate complex pole\";
//   input Real[size(c0_in,1)] c1_in \"Coefficients of s^1 term of base filter if conjugate complex pole\";
//   input Real f_cut(quantity = \"Frequency\", unit = \"Hz\") \"Cut-off frequency\";
//   output Real[size(cr_in,1)] r \"Real eigenvalues\";
//   output Real[size(c0_in,1)] a \"Real parts of complex conjugate eigenvalues\";
//   output Real[size(c0_in,1)] b \"Imaginary parts of complex conjugate eigenvalues\";
//   output Real[size(c0_in,1)] ku \"Input gain\";
//   protected Real[size(cr_in,1)] cr;
//   protected Real[size(c0_in,1)] c0;
//   protected Real[size(c0_in,1)] c1;
// algorithm
//   (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in,c0_in,c1_in,f_cut);
//   for i in 1:size(cr_in,1) loop
//     r[i] := -cr[i];
//   end for;
//   for i in 1:size(c0_in,1) loop
//     a[i] := -c1[i] / 2.0;
//     b[i] := sqrt(c0[i] - a[i] ^ 2.0);
//     ku[i] := c0[i] / b[i];
//   end for;
// end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;
// 
// function Modelica.Math.asinh \"Inverse of sinh (area hyperbolic sine)\"
//   input Real u;
//   output Real y;
// algorithm
//   y := log(u + sqrt(1.0 + u ^ 2.0));
// end Modelica.Math.asinh;
// 
// function Modelica.Utilities.Streams.error
//   input String string \"String to be printed to error message window\";
// 
//   external \"C\" ModelicaError(string);
// end Modelica.Utilities.Streams.error;
// 
// class Modelica.Blocks.Examples.Filter
//   parameter Integer order = 3;
//   parameter Real f_cut(quantity = \"Frequency\", unit = \"Hz\") = 2.0;
//   parameter enumeration(LowPass, HighPass, BandPass, BandStop) filterType = Modelica.Blocks.Types.FilterType.LowPass \"Type of filter (LowPass/HighPass)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) init = Modelica.Blocks.Types.Init.SteadyState \"Type of initialization (no init/steady state/initial state/initial output)\";
//   parameter Boolean normalized = true;
//   output Real step.y \"Connector of Real output signal\";
//   parameter Real step.offset = 0.1 \"Offset of output signal y\";
//   parameter Real step.startTime(quantity = \"Time\", unit = \"s\") = 0.1 \"Output y = offset for time < startTime\";
//   parameter Real step.height = 1.0 \"Height of step\";
//   input Real CriticalDamping.u \"Connector of Real input signal\";
//   output Real CriticalDamping.y \"Connector of Real output signal\";
//   parameter enumeration(CriticalDamping, Bessel, Butterworth, ChebyshevI) CriticalDamping.analogFilter = Modelica.Blocks.Types.AnalogFilter.CriticalDamping \"Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)\";
//   parameter enumeration(LowPass, HighPass, BandPass, BandStop) CriticalDamping.filterType = filterType \"Type of filter (LowPass/HighPass/BandPass/BandStop)\";
//   parameter Integer CriticalDamping.order(min = 1) = order \"Order of filter\";
//   parameter Real CriticalDamping.f_cut(quantity = \"Frequency\", unit = \"Hz\") = f_cut \"Cut-off frequency\";
//   parameter Real CriticalDamping.gain = 1.0 \"Gain (= amplitude of frequency response at zero frequency)\";
//   parameter Real CriticalDamping.A_ripple(unit = \"dB\") = 0.5 \"Pass band ripple for Chebyshev filter (otherwise not used); > 0 required\";
//   parameter Real CriticalDamping.f_min(quantity = \"Frequency\", unit = \"Hz\") = 0.8 * f_cut \"Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)\";
//   parameter Boolean CriticalDamping.normalized = normalized \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) CriticalDamping.init = init \"Type of initialization (no init/steady state/initial state/initial output)\";
//   final parameter Integer CriticalDamping.nx = if CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.LowPass or CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.HighPass then CriticalDamping.order else 2 * CriticalDamping.order;
//   parameter Real CriticalDamping.y_start = 0.0 \"Initial value of output\";
//   parameter Real CriticalDamping.u_nominal = 1.0 \"Nominal value of input (used for scaling the states)\";
//   protected parameter Integer CriticalDamping.ncr = if CriticalDamping.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then CriticalDamping.order else mod(CriticalDamping.order,2);
//   protected parameter Integer CriticalDamping.nc0 = if CriticalDamping.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(CriticalDamping.order) / 2.0);
//   protected parameter Integer CriticalDamping.na = if CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.BandPass or CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.BandStop then CriticalDamping.order else if CriticalDamping.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(CriticalDamping.order) / 2.0);
//   protected parameter Integer CriticalDamping.nr = if CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.BandPass or CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.BandStop then 0 else if CriticalDamping.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then CriticalDamping.order else mod(CriticalDamping.order,2);
//   output Real CriticalDamping.x[1] \"Filter states\";
//   output Real CriticalDamping.x[2] \"Filter states\";
//   output Real CriticalDamping.x[3] \"Filter states\";
//   protected parameter Real CriticalDamping.cr[1](fixed = false);
//   protected parameter Real CriticalDamping.cr[2](fixed = false);
//   protected parameter Real CriticalDamping.cr[3](fixed = false);
//   protected parameter Real CriticalDamping.r[1](fixed = false);
//   protected parameter Real CriticalDamping.r[2](fixed = false);
//   protected parameter Real CriticalDamping.r[3](fixed = false);
//   protected Real CriticalDamping.uu[1];
//   protected Real CriticalDamping.uu[2];
//   protected Real CriticalDamping.uu[3];
//   protected Real CriticalDamping.uu[4];
//   parameter Real CriticalDamping.x_start[1] = 0.0 \"Initial or guess values of states\";
//   parameter Real CriticalDamping.x_start[2] = 0.0 \"Initial or guess values of states\";
//   parameter Real CriticalDamping.x_start[3] = 0.0 \"Initial or guess values of states\";
//   input Real Bessel.u \"Connector of Real input signal\";
//   output Real Bessel.y \"Connector of Real output signal\";
//   parameter enumeration(CriticalDamping, Bessel, Butterworth, ChebyshevI) Bessel.analogFilter = Modelica.Blocks.Types.AnalogFilter.Bessel \"Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)\";
//   parameter enumeration(LowPass, HighPass, BandPass, BandStop) Bessel.filterType = filterType \"Type of filter (LowPass/HighPass/BandPass/BandStop)\";
//   parameter Integer Bessel.order(min = 1) = order \"Order of filter\";
//   parameter Real Bessel.f_cut(quantity = \"Frequency\", unit = \"Hz\") = f_cut \"Cut-off frequency\";
//   parameter Real Bessel.gain = 1.0 \"Gain (= amplitude of frequency response at zero frequency)\";
//   parameter Real Bessel.A_ripple(unit = \"dB\") = 0.5 \"Pass band ripple for Chebyshev filter (otherwise not used); > 0 required\";
//   parameter Real Bessel.f_min(quantity = \"Frequency\", unit = \"Hz\") = 0.8 * f_cut \"Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)\";
//   parameter Boolean Bessel.normalized = normalized \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) Bessel.init = init \"Type of initialization (no init/steady state/initial state/initial output)\";
//   final parameter Integer Bessel.nx = if Bessel.filterType == Modelica.Blocks.Types.FilterType.LowPass or Bessel.filterType == Modelica.Blocks.Types.FilterType.HighPass then Bessel.order else 2 * Bessel.order;
//   parameter Real Bessel.y_start = 0.0 \"Initial value of output\";
//   parameter Real Bessel.u_nominal = 1.0 \"Nominal value of input (used for scaling the states)\";
//   protected parameter Integer Bessel.ncr = if Bessel.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then Bessel.order else mod(Bessel.order,2);
//   protected parameter Integer Bessel.nc0 = if Bessel.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(Bessel.order) / 2.0);
//   protected parameter Integer Bessel.na = if Bessel.filterType == Modelica.Blocks.Types.FilterType.BandPass or Bessel.filterType == Modelica.Blocks.Types.FilterType.BandStop then Bessel.order else if Bessel.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(Bessel.order) / 2.0);
//   protected parameter Integer Bessel.nr = if Bessel.filterType == Modelica.Blocks.Types.FilterType.BandPass or Bessel.filterType == Modelica.Blocks.Types.FilterType.BandStop then 0 else if Bessel.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then Bessel.order else mod(Bessel.order,2);
//   output Real Bessel.x[1] \"Filter states\";
//   output Real Bessel.x[2] \"Filter states\";
//   output Real Bessel.x[3] \"Filter states\";
//   protected parameter Real Bessel.cr[1](fixed = false);
//   protected parameter Real Bessel.c0[1](fixed = false);
//   protected parameter Real Bessel.c1[1](fixed = false);
//   protected parameter Real Bessel.a[1](fixed = false);
//   protected parameter Real Bessel.b[1](fixed = false);
//   protected parameter Real Bessel.ku[1](fixed = false);
//   protected parameter Real Bessel.r[1](fixed = false);
//   protected Real Bessel.uu[1];
//   protected Real Bessel.uu[2];
//   protected Real Bessel.uu[3];
//   parameter Real Bessel.x_start[1] = 0.0 \"Initial or guess values of states\";
//   parameter Real Bessel.x_start[2] = 0.0 \"Initial or guess values of states\";
//   parameter Real Bessel.x_start[3] = 0.0 \"Initial or guess values of states\";
//   input Real Butterworth.u \"Connector of Real input signal\";
//   output Real Butterworth.y \"Connector of Real output signal\";
//   parameter enumeration(CriticalDamping, Bessel, Butterworth, ChebyshevI) Butterworth.analogFilter = Modelica.Blocks.Types.AnalogFilter.Butterworth \"Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)\";
//   parameter enumeration(LowPass, HighPass, BandPass, BandStop) Butterworth.filterType = filterType \"Type of filter (LowPass/HighPass/BandPass/BandStop)\";
//   parameter Integer Butterworth.order(min = 1) = order \"Order of filter\";
//   parameter Real Butterworth.f_cut(quantity = \"Frequency\", unit = \"Hz\") = f_cut \"Cut-off frequency\";
//   parameter Real Butterworth.gain = 1.0 \"Gain (= amplitude of frequency response at zero frequency)\";
//   parameter Real Butterworth.A_ripple(unit = \"dB\") = 0.5 \"Pass band ripple for Chebyshev filter (otherwise not used); > 0 required\";
//   parameter Real Butterworth.f_min(quantity = \"Frequency\", unit = \"Hz\") = 0.8 * f_cut \"Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)\";
//   parameter Boolean Butterworth.normalized = normalized \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) Butterworth.init = init \"Type of initialization (no init/steady state/initial state/initial output)\";
//   final parameter Integer Butterworth.nx = if Butterworth.filterType == Modelica.Blocks.Types.FilterType.LowPass or Butterworth.filterType == Modelica.Blocks.Types.FilterType.HighPass then Butterworth.order else 2 * Butterworth.order;
//   parameter Real Butterworth.y_start = 0.0 \"Initial value of output\";
//   parameter Real Butterworth.u_nominal = 1.0 \"Nominal value of input (used for scaling the states)\";
//   protected parameter Integer Butterworth.ncr = if Butterworth.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then Butterworth.order else mod(Butterworth.order,2);
//   protected parameter Integer Butterworth.nc0 = if Butterworth.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(Butterworth.order) / 2.0);
//   protected parameter Integer Butterworth.na = if Butterworth.filterType == Modelica.Blocks.Types.FilterType.BandPass or Butterworth.filterType == Modelica.Blocks.Types.FilterType.BandStop then Butterworth.order else if Butterworth.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(Butterworth.order) / 2.0);
//   protected parameter Integer Butterworth.nr = if Butterworth.filterType == Modelica.Blocks.Types.FilterType.BandPass or Butterworth.filterType == Modelica.Blocks.Types.FilterType.BandStop then 0 else if Butterworth.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then Butterworth.order else mod(Butterworth.order,2);
//   output Real Butterworth.x[1] \"Filter states\";
//   output Real Butterworth.x[2] \"Filter states\";
//   output Real Butterworth.x[3] \"Filter states\";
//   protected parameter Real Butterworth.cr[1](fixed = false);
//   protected parameter Real Butterworth.c0[1](fixed = false);
//   protected parameter Real Butterworth.c1[1](fixed = false);
//   protected parameter Real Butterworth.a[1](fixed = false);
//   protected parameter Real Butterworth.b[1](fixed = false);
//   protected parameter Real Butterworth.ku[1](fixed = false);
//   protected parameter Real Butterworth.r[1](fixed = false);
//   protected Real Butterworth.uu[1];
//   protected Real Butterworth.uu[2];
//   protected Real Butterworth.uu[3];
//   parameter Real Butterworth.x_start[1] = 0.0 \"Initial or guess values of states\";
//   parameter Real Butterworth.x_start[2] = 0.0 \"Initial or guess values of states\";
//   parameter Real Butterworth.x_start[3] = 0.0 \"Initial or guess values of states\";
//   input Real ChebyshevI.u \"Connector of Real input signal\";
//   output Real ChebyshevI.y \"Connector of Real output signal\";
//   parameter enumeration(CriticalDamping, Bessel, Butterworth, ChebyshevI) ChebyshevI.analogFilter = Modelica.Blocks.Types.AnalogFilter.ChebyshevI \"Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)\";
//   parameter enumeration(LowPass, HighPass, BandPass, BandStop) ChebyshevI.filterType = filterType \"Type of filter (LowPass/HighPass/BandPass/BandStop)\";
//   parameter Integer ChebyshevI.order(min = 1) = order \"Order of filter\";
//   parameter Real ChebyshevI.f_cut(quantity = \"Frequency\", unit = \"Hz\") = f_cut \"Cut-off frequency\";
//   parameter Real ChebyshevI.gain = 1.0 \"Gain (= amplitude of frequency response at zero frequency)\";
//   parameter Real ChebyshevI.A_ripple(unit = \"dB\") = 0.5 \"Pass band ripple for Chebyshev filter (otherwise not used); > 0 required\";
//   parameter Real ChebyshevI.f_min(quantity = \"Frequency\", unit = \"Hz\") = 0.8 * f_cut \"Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)\";
//   parameter Boolean ChebyshevI.normalized = normalized \"= true, if amplitude at f_cut = -3db, otherwise unmodified filter\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) ChebyshevI.init = init \"Type of initialization (no init/steady state/initial state/initial output)\";
//   final parameter Integer ChebyshevI.nx = if ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.LowPass or ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.HighPass then ChebyshevI.order else 2 * ChebyshevI.order;
//   parameter Real ChebyshevI.y_start = 0.0 \"Initial value of output\";
//   parameter Real ChebyshevI.u_nominal = 1.0 \"Nominal value of input (used for scaling the states)\";
//   protected parameter Integer ChebyshevI.ncr = if ChebyshevI.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then ChebyshevI.order else mod(ChebyshevI.order,2);
//   protected parameter Integer ChebyshevI.nc0 = if ChebyshevI.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(ChebyshevI.order) / 2.0);
//   protected parameter Integer ChebyshevI.na = if ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.BandPass or ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.BandStop then ChebyshevI.order else if ChebyshevI.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then 0 else integer(Real(ChebyshevI.order) / 2.0);
//   protected parameter Integer ChebyshevI.nr = if ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.BandPass or ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.BandStop then 0 else if ChebyshevI.analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then ChebyshevI.order else mod(ChebyshevI.order,2);
//   output Real ChebyshevI.x[1] \"Filter states\";
//   output Real ChebyshevI.x[2] \"Filter states\";
//   output Real ChebyshevI.x[3] \"Filter states\";
//   protected parameter Real ChebyshevI.cr[1](fixed = false);
//   protected parameter Real ChebyshevI.c0[1](fixed = false);
//   protected parameter Real ChebyshevI.c1[1](fixed = false);
//   protected parameter Real ChebyshevI.a[1](fixed = false);
//   protected parameter Real ChebyshevI.b[1](fixed = false);
//   protected parameter Real ChebyshevI.ku[1](fixed = false);
//   protected parameter Real ChebyshevI.r[1](fixed = false);
//   protected Real ChebyshevI.uu[1];
//   protected Real ChebyshevI.uu[2];
//   protected Real ChebyshevI.uu[3];
//   parameter Real ChebyshevI.x_start[1] = 0.0 \"Initial or guess values of states\";
//   parameter Real ChebyshevI.x_start[2] = 0.0 \"Initial or guess values of states\";
//   parameter Real ChebyshevI.x_start[3] = 0.0 \"Initial or guess values of states\";
// initial equation
//   CriticalDamping.cr = Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(CriticalDamping.order,CriticalDamping.normalized);
//   (CriticalDamping.r,{},{},{}) = Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass({CriticalDamping.cr[1],CriticalDamping.cr[2],CriticalDamping.cr[3]},{},{},CriticalDamping.f_cut);
//   der(CriticalDamping.x[1]) = 0.0;
//   der(CriticalDamping.x[2]) = 0.0;
//   der(CriticalDamping.x[3]) = 0.0;
//   (Bessel.cr,Bessel.c0,Bessel.c1) = Modelica.Blocks.Continuous.Internal.Filter.base.Bessel(Bessel.order,Bessel.normalized);
//   (Bessel.r,Bessel.a,Bessel.b,Bessel.ku) = Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass({Bessel.cr[1]},{Bessel.c0[1]},{Bessel.c1[1]},Bessel.f_cut);
//   der(Bessel.x[1]) = 0.0;
//   der(Bessel.x[2]) = 0.0;
//   der(Bessel.x[3]) = 0.0;
//   (Butterworth.cr,Butterworth.c0,Butterworth.c1) = Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth(Butterworth.order,Butterworth.normalized);
//   (Butterworth.r,Butterworth.a,Butterworth.b,Butterworth.ku) = Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass({Butterworth.cr[1]},{Butterworth.c0[1]},{Butterworth.c1[1]},Butterworth.f_cut);
//   der(Butterworth.x[1]) = 0.0;
//   der(Butterworth.x[2]) = 0.0;
//   der(Butterworth.x[3]) = 0.0;
//   (ChebyshevI.cr,ChebyshevI.c0,ChebyshevI.c1) = Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI(ChebyshevI.order,ChebyshevI.A_ripple,ChebyshevI.normalized);
//   (ChebyshevI.r,ChebyshevI.a,ChebyshevI.b,ChebyshevI.ku) = Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass({ChebyshevI.cr[1]},{ChebyshevI.c0[1]},{ChebyshevI.c1[1]},ChebyshevI.f_cut);
//   der(ChebyshevI.x[1]) = 0.0;
//   der(ChebyshevI.x[2]) = 0.0;
//   der(ChebyshevI.x[3]) = 0.0;
// equation
//   step.y = step.offset + (if time < step.startTime then 0.0 else step.height);
//   assert(CriticalDamping.u_nominal > 0.0,\"u_nominal > 0 required\");
//   assert(CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.LowPass or CriticalDamping.filterType == Modelica.Blocks.Types.FilterType.HighPass or CriticalDamping.f_min > 0.0,\"f_min > 0 required for band pass and band stop filter\");
//   assert(CriticalDamping.A_ripple > 0.0,\"A_ripple > 0 required\");
//   assert(CriticalDamping.f_cut > 0.0,\"f_cut > 0  required\");
//   CriticalDamping.uu[1] = CriticalDamping.u / CriticalDamping.u_nominal;
//   der(CriticalDamping.x[1]) = CriticalDamping.r[1] * (CriticalDamping.x[1] - CriticalDamping.uu[1]);
//   der(CriticalDamping.x[2]) = CriticalDamping.r[2] * (CriticalDamping.x[2] - CriticalDamping.uu[2]);
//   der(CriticalDamping.x[3]) = CriticalDamping.r[3] * (CriticalDamping.x[3] - CriticalDamping.uu[3]);
//   CriticalDamping.uu[2] = CriticalDamping.x[1];
//   CriticalDamping.uu[3] = CriticalDamping.x[2];
//   CriticalDamping.uu[4] = CriticalDamping.x[3];
//   CriticalDamping.y = CriticalDamping.gain * (CriticalDamping.u_nominal * CriticalDamping.uu[4]);
//   assert(Bessel.u_nominal > 0.0,\"u_nominal > 0 required\");
//   assert(Bessel.filterType == Modelica.Blocks.Types.FilterType.LowPass or Bessel.filterType == Modelica.Blocks.Types.FilterType.HighPass or Bessel.f_min > 0.0,\"f_min > 0 required for band pass and band stop filter\");
//   assert(Bessel.A_ripple > 0.0,\"A_ripple > 0 required\");
//   assert(Bessel.f_cut > 0.0,\"f_cut > 0  required\");
//   Bessel.uu[1] = Bessel.u / Bessel.u_nominal;
//   der(Bessel.x[1]) = Bessel.r[1] * (Bessel.x[1] - Bessel.uu[1]);
//   der(Bessel.x[2]) = Bessel.a[1] * Bessel.x[2] + (Bessel.ku[1] * Bessel.uu[2] - Bessel.b[1] * Bessel.x[3]);
//   der(Bessel.x[3]) = Bessel.b[1] * Bessel.x[2] + Bessel.a[1] * Bessel.x[3];
//   Bessel.uu[2] = Bessel.x[1];
//   Bessel.uu[3] = Bessel.x[3];
//   Bessel.y = Bessel.gain * (Bessel.u_nominal * Bessel.uu[3]);
//   assert(Butterworth.u_nominal > 0.0,\"u_nominal > 0 required\");
//   assert(Butterworth.filterType == Modelica.Blocks.Types.FilterType.LowPass or Butterworth.filterType == Modelica.Blocks.Types.FilterType.HighPass or Butterworth.f_min > 0.0,\"f_min > 0 required for band pass and band stop filter\");
//   assert(Butterworth.A_ripple > 0.0,\"A_ripple > 0 required\");
//   assert(Butterworth.f_cut > 0.0,\"f_cut > 0  required\");
//   Butterworth.uu[1] = Butterworth.u / Butterworth.u_nominal;
//   der(Butterworth.x[1]) = Butterworth.r[1] * (Butterworth.x[1] - Butterworth.uu[1]);
//   der(Butterworth.x[2]) = Butterworth.a[1] * Butterworth.x[2] + (Butterworth.ku[1] * Butterworth.uu[2] - Butterworth.b[1] * Butterworth.x[3]);
//   der(Butterworth.x[3]) = Butterworth.b[1] * Butterworth.x[2] + Butterworth.a[1] * Butterworth.x[3];
//   Butterworth.uu[2] = Butterworth.x[1];
//   Butterworth.uu[3] = Butterworth.x[3];
//   Butterworth.y = Butterworth.gain * (Butterworth.u_nominal * Butterworth.uu[3]);
//   assert(ChebyshevI.u_nominal > 0.0,\"u_nominal > 0 required\");
//   assert(ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.LowPass or ChebyshevI.filterType == Modelica.Blocks.Types.FilterType.HighPass or ChebyshevI.f_min > 0.0,\"f_min > 0 required for band pass and band stop filter\");
//   assert(ChebyshevI.A_ripple > 0.0,\"A_ripple > 0 required\");
//   assert(ChebyshevI.f_cut > 0.0,\"f_cut > 0  required\");
//   ChebyshevI.uu[1] = ChebyshevI.u / ChebyshevI.u_nominal;
//   der(ChebyshevI.x[1]) = ChebyshevI.r[1] * (ChebyshevI.x[1] - ChebyshevI.uu[1]);
//   der(ChebyshevI.x[2]) = ChebyshevI.a[1] * ChebyshevI.x[2] + (ChebyshevI.ku[1] * ChebyshevI.uu[2] - ChebyshevI.b[1] * ChebyshevI.x[3]);
//   der(ChebyshevI.x[3]) = ChebyshevI.b[1] * ChebyshevI.x[2] + ChebyshevI.a[1] * ChebyshevI.x[3];
//   ChebyshevI.uu[2] = ChebyshevI.x[1];
//   ChebyshevI.uu[3] = ChebyshevI.x[3];
//   ChebyshevI.y = ChebyshevI.gain * (ChebyshevI.u_nominal * ChebyshevI.uu[3]);
//   Bessel.u = Butterworth.u;
//   Bessel.u = ChebyshevI.u;
//   Bessel.u = CriticalDamping.u;
//   Bessel.u = step.y;
// end Modelica.Blocks.Examples.Filter;
// "
// "Warning: Parameter CriticalDamping.a has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.b has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.ku has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.c0 has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.c1 has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.a has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.b has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.ku has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.c0 has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter CriticalDamping.c1 has neither value nor start value, and is fixed during initialization (fixed=true)
// "
// endResult
