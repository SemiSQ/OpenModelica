// name:     Modelica3.x.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque
// keywords: multibody, balancing, instantiation
// status:   correct
// teardown_command: rm -f *.so *.dll *.log *.c* *.makefile *.libs
// 
//  Modelica MultiBody 3.x: instantiation and balance checking of the ForceAndTorque model
//

loadFile("_ElementaryTotal.mo");
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque);
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque);
getErrorString();

// Result:
// true
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v, 1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = atan2(u1, u2);
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der \"Inline before index reduction\" \"Derivative of function Frames.resolve1(..)\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector resolved in frame 2\";
//   input Real[3] v2_der \"= der(v2)\";
//   output Real[3] v1_der \"Derivative of vector v resolved in frame 1\";
// algorithm
//   v1_der := Modelica.Mechanics.MultiBody.Frames.resolve1(R, {v2_der[1] + R.w[2] * v2[3] - R.w[3] * v2[2], v2_der[2] + R.w[3] * v2[1] - R.w[1] * v2[3], v2_der[3] + R.w[1] * v2[2] - R.w[2] * v2[1]});
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der \"Inline before index reduction\" \"Derivative of function Frames.resolve2(..)\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector resolved in frame 1\";
//   input Real[3] v1_der \"= der(v1)\";
//   output Real[3] v2_der \"Derivative of vector v resolved in frame 2\";
// algorithm
//   v2_der := Modelica.Mechanics.MultiBody.Frames.resolve2(R, {v1_der[1], v1_der[2], v1_der[3]}) - cross({R.w[1], R.w[2], R.w[3]}, Modelica.Mechanics.MultiBody.Frames.resolve2(R, {v1[1], v1[2], v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint \"Inline before index reduction\" \"Return the constraint residues to express that two frames have the same orientation\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Real[3] residue \"The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)\";
// algorithm
//   residue := {atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3], R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]), atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3], R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]), atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3], R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2 \"Inline before index reduction\" \"Compute angular velocity resolved in frame 2 from quaternions orientation object and its derivative\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[4] der_Q(unit = \"1/s\") \"Derivative of Q\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {(Q[4] * der_Q[1] + Q[3] * der_Q[2] + (-Q[2]) * der_Q[3] + (-Q[1]) * der_Q[4]) * 2.0, ((-Q[3]) * der_Q[1] + Q[4] * der_Q[2] + Q[1] * der_Q[3] + (-Q[2]) * der_Q[4]) * 2.0, (Q[2] * der_Q[1] + (-Q[1]) * der_Q[2] + Q[4] * der_Q[3] + (-Q[3]) * der_Q[4]) * 2.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T \"Return quaternions orientation object Q from transformation matrix T\"
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[4] Q_guess = {0.0, 0.0, 0.0, 1.0} \"Guess value for Q (there are 2 solutions; the one close to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)\";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04000000000000001;
// algorithm
//   c1 := 1.0 + T[1,1] + (-T[2,2]) - T[3,3];
//   c2 := 1.0 + T[2,2] + (-T[1,1]) - T[3,3];
//   c3 := 1.0 + T[3,3] + (-T[1,1]) - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04000000000000001 or c4 > c1 and c4 > c2 and c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4, (T[3,1] - T[1,3]) / paux4, (T[1,2] - T[2,1]) / paux4, paux};
//   elseif c1 > c2 and c1 > c3 and c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux, (T[1,2] + T[2,1]) / paux4, (T[1,3] + T[3,1]) / paux4, (T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 and c2 > c3 and c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4, paux, (T[2,3] + T[3,2]) / paux4, (T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4, (T[2,3] + T[3,2]) / paux4, paux, (T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1], Q[2], Q[3], Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation \"Inline before index reduction\" \"Return quaternions orientation object that does not rotate a frame\"
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := {0.0, 0.0, 0.0, 1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint \"Inline before index reduction\" \"Return residues of orientation constraints (shall be zero)\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   output Real[1] residue \"Residue constraint (shall be zero)\";
// algorithm
//   residue := {Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0 + -1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation \"Inline before index reduction\" \"Return absolute orientation object from another absolute and a relative orientation object\"
//   input Real[3, 3] T1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Real[3, 3] T_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3, 3] T2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   T2 := {{T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1], T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2], T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3]}, {T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1], T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2], T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3]}, {T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1], T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2], T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]}};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation \"Inline before index reduction\" \"Return rotation object to rotate around one frame axis\"
//   input Integer axis(min = 1, max = 3) \"Rotate around 'axis' of frame 1\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := if axis == 1 then {{1.0, 0.0, 0.0}, {0.0, cos(angle), sin(angle)}, {0.0, -sin(angle), cos(angle)}} else if axis == 2 then {{cos(angle), 0.0, -sin(angle)}, {0.0, 1.0, 0.0}, {sin(angle), 0.0, cos(angle)}} else {{cos(angle), sin(angle), 0.0}, {-sin(angle), cos(angle), 0.0}, {0.0, 0.0, 1.0}};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy \"Return orientation object from n_x and n_y vectors\"
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + n_x[2] ^ 2.0 + n_x[3] ^ 2.0);
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 0.0000000001 then {1.0, 0.0, 0.0} else {n_x[1] / abs_n_x, n_x[2] / abs_n_x, n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2], e_x[3] * n_y[1] - e_x[1] * n_y[3], e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0 > 0.000001 then {n_y[1], n_y[2], n_y[3]} else if abs(e_x[1]) > 0.000001 then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0};
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2], e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3], e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0), e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0), e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)};
// algorithm
//   T := {{e_x[1], e_x[2], e_x[3]}, {e_z[2] * e_x[3] - e_z[3] * e_x[2], e_z[3] * e_x[1] - e_z[1] * e_x[3], e_z[1] * e_x[2] - e_z[2] * e_x[1]}, {e_z[1], e_z[2], e_z[3]}};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := {{e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle), e[1] * e[2] + (-e[1]) * e[2] * cos(angle) - (-e[3]) * sin(angle), e[1] * e[3] + (-e[1]) * e[3] * cos(angle) - e[2] * sin(angle)}, {e[2] * e[1] + (-e[2]) * e[1] * cos(angle) - e[3] * sin(angle), e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle), e[2] * e[3] + (-e[2]) * e[3] * cos(angle) - (-e[1]) * sin(angle)}, {e[3] * e[1] + (-e[3]) * e[1] * cos(angle) - (-e[2]) * sin(angle), e[3] * e[2] + (-e[3]) * e[2] * cos(angle) - e[1] * sin(angle), e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)}};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3], T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3], T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2 \"Inline before index reduction\" \"Transform vector from frame 1 to frame 2\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3], T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3], T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation \"Inline before index reduction\" \"Return absolute orientation object from another absolute and a relative orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation({{R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1], R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2], R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3]}, {R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1], R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2], R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3]}, {R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1], R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2], R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]}}, Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel, {R1.w[1], R1.w[2], R1.w[3]}) + {R_rel.w[1], R_rel.w[2], R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 \"Inline before index reduction\" \"Return angular velocity resolved in frame 2 from orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {R.w[1], R.w[2], R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations \"Inline before index reduction\" \"Return fixed rotation object to rotate in sequence around fixed angles along 3 axes\"
//   input Integer[3] sequence = {1, 2, 3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence'\";
//   input Real[3] der_angles(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angles)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3], angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2], angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1], angles[1]), Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3], angles[3]), Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3], angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2], angles[2]), Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles \"Return the 3 angles to rotate in sequence around 3 axes to construct the given orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Integer[3] sequence = {1, 2, 3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real guessAngle1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Select angles[1] such that |angles[1] - guessAngle1| is a minimum\";
//   output Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi\";
//   protected Real[3] e1_1(unit = \"1\") \"First rotation axis, resolved in frame 1\";
//   protected Real[3] e2_1a(unit = \"1\") \"Second rotation axis, resolved in frame 1a\";
//   protected Real[3] e3_1(unit = \"1\") \"Third rotation axis, resolved in frame 1\";
//   protected Real[3] e3_2(unit = \"1\") \"Third rotation axis, resolved in frame 2\";
//   protected Real A \"Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real B \"Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real angle_1a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 1 for angles[1]\";
//   protected Real angle_1b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 2 for angles[1]\";
//   protected Real[3, 3] T_1a \"Orientation object to rotate frame 1 into frame 1a\";
// algorithm
//   assert( sequence[1] <> sequence[2] and sequence[2] <> sequence[3], \"input argument 'sequence[1:3]' is not valid\");
//   e1_1 := if sequence[1] == 1 then {1.0, 0.0, 0.0} else if sequence[1] == 2 then {0.0, 1.0, 0.0} else {0.0, 0.0, 1.0};
//   e2_1a := if sequence[2] == 1 then {1.0, 0.0, 0.0} else if sequence[2] == 2 then {0.0, 1.0, 0.0} else {0.0, 0.0, 1.0};
//   e3_1 := {R.T[sequence[3],1], R.T[sequence[3],2], R.T[sequence[3],3]};
//   e3_2 := if sequence[3] == 1 then {1.0, 0.0, 0.0} else if sequence[3] == 2 then {0.0, 1.0, 0.0} else {0.0, 0.0, 1.0};
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 0.000000000001 and abs(B) <= 0.000000000001 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := atan2(A, -B);
//     angle_1b := atan2(-A, B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1], e1_1[2], e1_1[3]}, angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1], e2_1a[2], e2_1a[3]}, Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2({{T_1a[1,1], T_1a[1,2], T_1a[1,3]}, {T_1a[2,1], T_1a[2,2], T_1a[2,3]}, {T_1a[3,1], T_1a[3,2], T_1a[3,3]}}, {e3_1[1], e3_1[2], e3_1[3]}), {e3_2[1], e3_2[2], e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1], e3_2[2], e3_2[3]}, {e2_1a[1], e2_1a[2], e2_1a[3]}, Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2({{R.T[1,1], R.T[1,2], R.T[1,3]}, {R.T[2,1], R.T[2,2], R.T[2,3]}, {R.T[3,1], R.T[3,2], R.T[3,3]}}, Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{T_1a[1,1], T_1a[1,2], T_1a[1,3]}, {T_1a[2,1], T_1a[2,2], T_1a[2,3]}, {T_1a[3,1], T_1a[3,2], T_1a[3,3]}}, {e2_1a[1], e2_1a[2], e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis \"Inline before index reduction\" \"Return unit vector for x-, y-, or z-axis\"
//   input Integer axis(min = 1, max = 3) \"Axis vector to be returned\";
//   output Real[3] e(unit = \"1\") \"Unit axis vector\";
// algorithm
//   e := if axis == 1 then {1.0, 0.0, 0.0} else if axis == 2 then {0.0, 1.0, 0.0} else {0.0, 0.0, 1.0};
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q \"Inline before index reduction\" \"Return orientation object R from quaternion orientation object Q\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation({{2.0 * (Q[1] ^ 2.0 + Q[4] ^ 2.0) + -1.0, 2.0 * (Q[1] * Q[2] + Q[3] * Q[4]), 2.0 * (Q[1] * Q[3] - Q[2] * Q[4])}, {2.0 * (Q[2] * Q[1] - Q[3] * Q[4]), 2.0 * (Q[2] ^ 2.0 + Q[4] ^ 2.0) + -1.0, 2.0 * (Q[2] * Q[3] + Q[1] * Q[4])}, {2.0 * (Q[3] * Q[1] + Q[2] * Q[4]), 2.0 * (Q[3] * Q[2] - Q[1] * Q[4]), 2.0 * (Q[3] ^ 2.0 + Q[4] ^ 2.0) + -1.0}}, {w[1], w[2], w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_T \"Inline before index reduction\" \"Return orientation object R from transformation matrix T\"
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2 (skew(w)=T*der(transpose(T)))\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation({{T[1,1], T[1,2], T[1,3]}, {T[2,1], T[2,2], T[2,3]}, {T[3,1], T[3,2], T[3,3]}}, {w[1], w[2], w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_nxy \"Return fixed orientation object from n_x and n_y vectors\"
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + n_x[2] ^ 2.0 + n_x[3] ^ 2.0);
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 0.0000000001 then {1.0, 0.0, 0.0} else {n_x[1] / abs_n_x, n_x[2] / abs_n_x, n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2], e_x[3] * n_y[1] - e_x[1] * n_y[3], e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0 > 0.000001 then {n_y[1], n_y[2], n_y[3]} else if abs(e_x[1]) > 0.000001 then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0};
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2], e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3], e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0), e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0), e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)};
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation({{e_x[1], e_x[2], e_x[3]}, {e_z[2] * e_x[3] - e_z[3] * e_x[2], e_z[3] * e_x[1] - e_z[1] * e_x[3], e_z[1] * e_x[2] - e_z[2] * e_x[1]}, {e_z[1], e_z[2], e_z[3]}}, {0.0, 0.0, 0.0});
// end Modelica.Mechanics.MultiBody.Frames.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation({{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}}, {0.0, 0.0, 0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation({{e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle), e[1] * e[2] + (-e[1]) * e[2] * cos(angle) - (-e[3]) * sin(angle), e[1] * e[3] + (-e[1]) * e[3] * cos(angle) - e[2] * sin(angle)}, {e[2] * e[1] + (-e[2]) * e[1] * cos(angle) - e[3] * sin(angle), e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle), e[2] * e[3] + (-e[2]) * e[3] * cos(angle) - (-e[1]) * sin(angle)}, {e[3] * e[1] + (-e[3]) * e[1] * cos(angle) - (-e[2]) * sin(angle), e[3] * e[2] + (-e[3]) * e[2] * cos(angle) - e[1] * sin(angle), e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)}}, {e[1] * der_angle, e[2] * der_angle, e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle \"Inline before index reduction\" \"Return angle of a planar rotation, given the rotation axis and the representations of a vector in frame 1 and frame 2\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)\";
//   input Real[3] v1 \"A vector v resolved in frame 1 (shall not be parallel to e)\";
//   input Real[3] v2 \"Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)\";
//   output Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi\";
// algorithm
//   angle := atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3], v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3] - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1 \"Inline after index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3], R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3], R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2 \"Inline after index reduction\" \"Transform vector from frame 1 to frame 2\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3], R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3], R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolveDyade1 \"Inline before index reduction\" \"Transform second order tensor from frame 2 to frame 1\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3, 3] D2 \"Second order tensor resolved in frame 2\";
//   output Real[3, 3] D1 \"Second order tensor resolved in frame 1\";
// algorithm
//   D1 := {{(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,1] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,1] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,1], (R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,2] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,2] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,2], (R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,3] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,3] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,3]}, {(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,1] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,1] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,1], (R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,2] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,2] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,2], (R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,3] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,3] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,3]}, {(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,1] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,1] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,1], (R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,2] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,2] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,2], (R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,3] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,3] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,3]}};
// end Modelica.Mechanics.MultiBody.Frames.resolveDyade1;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q \"Inline before index reduction\" \"Return quaternion orientation object Q from orientation object R\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[4] Q_guess = {0.0, 0.0, 0.0, 1.0} \"Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T({{R.T[1,1], R.T[1,2], R.T[1,3]}, {R.T[2,1], R.T[2,2], R.T[2,3]}, {R.T[3,1], R.T[3,2], R.T[3,3]}}, {Q_guess[1], Q_guess[2], Q_guess[3], Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration \"Gravity field acceleration depending on field type and position\"
//   input Real[3] r(quantity = \"Length\", unit = \"m\") \"Position vector from world frame to actual point, resolved in world frame\";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType \"Type of gravity field\";
//   input Real[3] g(quantity = \"Acceleration\", unit = \"m/s2\") \"Constant gravity acceleration, resolved in world frame, if gravityType=1\";
//   input Real mue(unit = \"m3/s2\") \"Field constant of point gravity field, if gravityType=2\";
//   output Real[3] gravity(quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration at point r, resolved in world frame\";
// algorithm
//   gravity := if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then {g[1], g[2], g[3]} else if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity then -{mue * r[1] / (Modelica.Math.Vectors.length({r[1], r[2], r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)), mue * r[2] / (Modelica.Math.Vectors.length({r[1], r[2], r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)), mue * r[3] / (Modelica.Math.Vectors.length({r[1], r[2], r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0, 0.0, 0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real material1;
//   input Real material2;
//   input Real material3;
//   input Real sp;
//   output Real mat;
// algorithm
//   mat := material1 + material2 + material3 + sp;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function Modelica.SIunits.Conversions.from_deg \"Convert from degree to radian\"
//   input Real degree(quantity = \"Angle\", unit = \"deg\") \"degree value\";
//   output Real radian(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"radian value\";
// algorithm
//   radian := 0.017453292519943295 * degree;
// end Modelica.SIunits.Conversions.from_deg;
// 
// class Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque
//   Real world.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean world.enableAnimation = true \"= true, if animation of all components is enabled\";
//   parameter Boolean world.animateWorld = true \"= true, if world coordinate system shall be visualized\";
//   parameter Boolean world.animateGravity = false \"= true, if gravity field shall be visualized (acceleration vector or field center)\";
//   parameter String world.label1 = \"x\" \"Label of horizontal axis in icon\";
//   parameter String world.label2 = \"y\" \"Label of vertical axis in icon\";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity \"Type of gravity field\";
//   parameter Real world.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.81 \"Constant gravity acceleration\";
//   parameter Real world.n[1](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[2](unit = \"1\") = -1.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[3](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.mue(unit = \"m3/s2\", min = 0.0) = 398600000000000.0 \"Gravity field constant (default = field constant of earth)\";
//   parameter Boolean world.driveTrainMechanics3D = true \"= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account\";
//   parameter Boolean world.axisShowLabels = true \"= true, if labels shall be shown\";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of z-arrow\";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of z-arrow\";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of z-arrow\";
//   parameter Real world.gravityArrowTail[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   parameter Real world.gravitySphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 12742000.0 \"Diameter of sphere representing gravity center (default = mean diameter of earth)\";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   parameter Real world.nominalLength(quantity = \"Length\", unit = \"m\") = 1.0 \"\\\"Nominal\\\" length of multi-body system\";
//   parameter Real world.defaultWidthFraction = 20.0 \"Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)\";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 \"Default for arrow diameter of a coordinate system as a fraction of axis length\";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 \"Default reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real world.defaultN_to_m(unit = \"N/m\", min = 0.0) = 1000.0 \"Default scaling of force arrows (length = force/defaultN_to_m)\";
//   parameter Real world.defaultNm_to_m(unit = \"N.m/m\", min = 0.0) = 1000.0 \"Default scaling of torque arrows (length = torque/defaultNm_to_m)\";
//   protected parameter Integer world.ndim = if world.enableAnimation and world.animateWorld then 1 else 0;
//   protected parameter Integer world.ndim2 = if world.enableAnimation and world.animateWorld and world.axisShowLabels then 1 else 0;
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation and world.animateGravity and world.gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then 1 else 0;
//   parameter Real world.axisLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.nominalLength / 2.0 \"Length of world axes arrows\";
//   parameter Real world.defaultAxisLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 5.0 \"Default for length of a frame axis (but not world frame)\";
//   parameter Real world.defaultJointLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a joint\";
//   parameter Real world.defaultJointWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape representing a joint\";
//   parameter Real world.defaultForceLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a force (e.g. damper)\";
//   parameter Real world.defaultForceWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape represening a force (e.g. spring, bushing)\";
//   parameter Real world.defaultBodyDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 9.0 \"Default for diameter of sphere representing the center of mass of a body\";
//   parameter Real world.defaultArrowDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 40.0 \"Default for arrow diameter (e.g., of forces, torques, sensors)\";
//   parameter Real world.axisDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction \"Diameter of world axes arrows\";
//   parameter Real world.gravityArrowLength(quantity = \"Length\", unit = \"m\") = world.axisLength / 2.0 \"Length of gravity arrow\";
//   protected parameter Real world.labelStart(quantity = \"Length\", unit = \"m\") = 1.05 * world.axisLength;
//   protected parameter Real world.headLength(quantity = \"Length\", unit = \"m\") = min(world.axisLength, 5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineWidth(quantity = \"Length\", unit = \"m\") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   parameter Real world.gravityArrowDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction \"Diameter of gravity arrow\";
//   protected parameter Real world.lineLength(quantity = \"Length\", unit = \"m\") = max(0.0, world.axisLength - world.headLength);
//   input Real world.x_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r_lines[1](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[1](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of cylinders\";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of cylinders\";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of cylinders\";
//   input Real world.x_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[1, 1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[1, 2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[1, 3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[2, 1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[2, 2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[2, 3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[3, 1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[3, 2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1], world.x_label.n_x[2], world.x_label.n_x[3]}, {world.x_label.n_y[1], world.x_label.n_y[2], world.x_label.n_y[3]})[3, 3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[1, 1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[1, 2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[1, 3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[2, 1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[2, 2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[2, 3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[3, 1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[3, 2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}})[3, 3];
//   protected Real world.x_label.r_abs[1](quantity = \"Length\", unit = \"m\") = {world.x_label.r[1], world.x_label.r[2], world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {world.x_label.r_lines[1], world.x_label.r_lines[2], world.x_label.r_lines[3]})[1];
//   protected Real world.x_label.r_abs[2](quantity = \"Length\", unit = \"m\") = {world.x_label.r[1], world.x_label.r[2], world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {world.x_label.r_lines[1], world.x_label.r_lines[2], world.x_label.r_lines[3]})[2];
//   protected Real world.x_label.r_abs[3](quantity = \"Length\", unit = \"m\") = {world.x_label.r[1], world.x_label.r[2], world.x_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1], world.x_label.R.T[1,2], world.x_label.R.T[1,3]}, {world.x_label.R.T[2,1], world.x_label.R.T[2,2], world.x_label.R.T[2,3]}, {world.x_label.R.T[3,1], world.x_label.R.T[3,2], world.x_label.R.T[3,3]}}, {world.x_label.r_lines[1], world.x_label.r_lines[2], world.x_label.r_lines[3]})[3];
//   protected parameter Integer world.x_label.n = 2 \"Number of cylinders\";
//   parameter String world.x_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = {world.x_label.r_abs[1], world.x_label.r_abs[2], world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1], world.x_label.R_lines[1,2], world.x_label.R_lines[1,3]}, {world.x_label.R_lines[2,1], world.x_label.R_lines[2,2], world.x_label.R_lines[2,3]}, {world.x_label.R_lines[3,1], world.x_label.R_lines[3,2], world.x_label.R_lines[3,3]}}, {world.x_label.lines[1,1,1], world.x_label.lines[1,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = {world.x_label.r_abs[1], world.x_label.r_abs[2], world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1], world.x_label.R_lines[1,2], world.x_label.R_lines[1,3]}, {world.x_label.R_lines[2,1], world.x_label.R_lines[2,2], world.x_label.R_lines[2,3]}, {world.x_label.R_lines[3,1], world.x_label.R_lines[3,2], world.x_label.R_lines[3,3]}}, {world.x_label.lines[1,1,1], world.x_label.lines[1,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = {world.x_label.r_abs[1], world.x_label.r_abs[2], world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1], world.x_label.R_lines[1,2], world.x_label.R_lines[1,3]}, {world.x_label.R_lines[2,1], world.x_label.R_lines[2,2], world.x_label.R_lines[2,3]}, {world.x_label.R_lines[3,1], world.x_label.R_lines[3,2], world.x_label.R_lines[3,3]}}, {world.x_label.lines[1,1,1], world.x_label.lines[1,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}}, {world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1], world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}}, {world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1], world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}}, {world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1], world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1], world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1], world.x_label.cylinders[1].lengthDirection[2], world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 0.0000000001) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 0.0000000001) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 0.0000000001) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1], world.x_label.cylinders[1].e_x[2], world.x_label.cylinders[1].e_x[3]}, if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_label.cylinders[1].widthDirection[1], world.x_label.cylinders[1].widthDirection[2], world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_label.cylinders[1].e_x[1], world.x_label.cylinders[1].e_x[2], world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1], world.x_label.cylinders[1].e_x[2], world.x_label.cylinders[1].e_x[3]}, if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_label.cylinders[1].widthDirection[1], world.x_label.cylinders[1].widthDirection[2], world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_label.cylinders[1].e_x[1], world.x_label.cylinders[1].e_x[2], world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1], world.x_label.cylinders[1].e_x[2], world.x_label.cylinders[1].e_x[3]}, if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_label.cylinders[1].widthDirection[1], world.x_label.cylinders[1].widthDirection[2], world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_label.cylinders[1].e_x[1], world.x_label.cylinders[1].e_x[2], world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.x_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = {world.x_label.r_abs[1], world.x_label.r_abs[2], world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1], world.x_label.R_lines[1,2], world.x_label.R_lines[1,3]}, {world.x_label.R_lines[2,1], world.x_label.R_lines[2,2], world.x_label.R_lines[2,3]}, {world.x_label.R_lines[3,1], world.x_label.R_lines[3,2], world.x_label.R_lines[3,3]}}, {world.x_label.lines[2,1,1], world.x_label.lines[2,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = {world.x_label.r_abs[1], world.x_label.r_abs[2], world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1], world.x_label.R_lines[1,2], world.x_label.R_lines[1,3]}, {world.x_label.R_lines[2,1], world.x_label.R_lines[2,2], world.x_label.R_lines[2,3]}, {world.x_label.R_lines[3,1], world.x_label.R_lines[3,2], world.x_label.R_lines[3,3]}}, {world.x_label.lines[2,1,1], world.x_label.lines[2,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = {world.x_label.r_abs[1], world.x_label.r_abs[2], world.x_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1], world.x_label.R_lines[1,2], world.x_label.R_lines[1,3]}, {world.x_label.R_lines[2,1], world.x_label.R_lines[2,2], world.x_label.R_lines[2,3]}, {world.x_label.R_lines[3,1], world.x_label.R_lines[3,2], world.x_label.R_lines[3,3]}}, {world.x_label.lines[2,1,1], world.x_label.lines[2,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}}, {world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1], world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}}, {world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1], world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1], world.x_label.R_rel[1,2], world.x_label.R_rel[1,3]}, {world.x_label.R_rel[2,1], world.x_label.R_rel[2,2], world.x_label.R_rel[2,3]}, {world.x_label.R_rel[3,1], world.x_label.R_rel[3,2], world.x_label.R_rel[3,3]}}, {world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1], world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1], world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1], world.x_label.cylinders[2].lengthDirection[2], world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 0.0000000001) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 0.0000000001) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 0.0000000001) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1], world.x_label.cylinders[2].e_x[2], world.x_label.cylinders[2].e_x[3]}, if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_label.cylinders[2].widthDirection[1], world.x_label.cylinders[2].widthDirection[2], world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_label.cylinders[2].e_x[1], world.x_label.cylinders[2].e_x[2], world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1], world.x_label.cylinders[2].e_x[2], world.x_label.cylinders[2].e_x[3]}, if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_label.cylinders[2].widthDirection[1], world.x_label.cylinders[2].widthDirection[2], world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_label.cylinders[2].e_x[1], world.x_label.cylinders[2].e_x[2], world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1], world.x_label.cylinders[2].e_x[2], world.x_label.cylinders[2].e_x[3]}, if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_label.cylinders[2].widthDirection[1], world.x_label.cylinders[2].widthDirection[2], world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_label.cylinders[2].e_x[1], world.x_label.cylinders[2].e_x[2], world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   input Real world.y_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[2](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[2](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[1](unit = \"1\") = -1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[2](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = 0.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.75 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] \"Color of cylinders\";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] \"Color of cylinders\";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] \"Color of cylinders\";
//   input Real world.y_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[1, 1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[1, 2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[1, 3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[2, 1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[2, 2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[2, 3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[3, 1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[3, 2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1], world.y_label.n_x[2], world.y_label.n_x[3]}, {world.y_label.n_y[1], world.y_label.n_y[2], world.y_label.n_y[3]})[3, 3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[1, 1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[1, 2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[1, 3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[2, 1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[2, 2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[2, 3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[3, 1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[3, 2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}})[3, 3];
//   protected Real world.y_label.r_abs[1](quantity = \"Length\", unit = \"m\") = {world.y_label.r[1], world.y_label.r[2], world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {world.y_label.r_lines[1], world.y_label.r_lines[2], world.y_label.r_lines[3]})[1];
//   protected Real world.y_label.r_abs[2](quantity = \"Length\", unit = \"m\") = {world.y_label.r[1], world.y_label.r[2], world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {world.y_label.r_lines[1], world.y_label.r_lines[2], world.y_label.r_lines[3]})[2];
//   protected Real world.y_label.r_abs[3](quantity = \"Length\", unit = \"m\") = {world.y_label.r[1], world.y_label.r[2], world.y_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1], world.y_label.R.T[1,2], world.y_label.R.T[1,3]}, {world.y_label.R.T[2,1], world.y_label.R.T[2,2], world.y_label.R.T[2,3]}, {world.y_label.R.T[3,1], world.y_label.R.T[3,2], world.y_label.R.T[3,3]}}, {world.y_label.r_lines[1], world.y_label.r_lines[2], world.y_label.r_lines[3]})[3];
//   protected parameter Integer world.y_label.n = 2 \"Number of cylinders\";
//   parameter String world.y_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = {world.y_label.r_abs[1], world.y_label.r_abs[2], world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1], world.y_label.R_lines[1,2], world.y_label.R_lines[1,3]}, {world.y_label.R_lines[2,1], world.y_label.R_lines[2,2], world.y_label.R_lines[2,3]}, {world.y_label.R_lines[3,1], world.y_label.R_lines[3,2], world.y_label.R_lines[3,3]}}, {world.y_label.lines[1,1,1], world.y_label.lines[1,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = {world.y_label.r_abs[1], world.y_label.r_abs[2], world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1], world.y_label.R_lines[1,2], world.y_label.R_lines[1,3]}, {world.y_label.R_lines[2,1], world.y_label.R_lines[2,2], world.y_label.R_lines[2,3]}, {world.y_label.R_lines[3,1], world.y_label.R_lines[3,2], world.y_label.R_lines[3,3]}}, {world.y_label.lines[1,1,1], world.y_label.lines[1,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = {world.y_label.r_abs[1], world.y_label.r_abs[2], world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1], world.y_label.R_lines[1,2], world.y_label.R_lines[1,3]}, {world.y_label.R_lines[2,1], world.y_label.R_lines[2,2], world.y_label.R_lines[2,3]}, {world.y_label.R_lines[3,1], world.y_label.R_lines[3,2], world.y_label.R_lines[3,3]}}, {world.y_label.lines[1,1,1], world.y_label.lines[1,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}}, {world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1], world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}}, {world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1], world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}}, {world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1], world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1], world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1], world.y_label.cylinders[1].lengthDirection[2], world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 0.0000000001) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 0.0000000001) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 0.0000000001) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1], world.y_label.cylinders[1].e_x[2], world.y_label.cylinders[1].e_x[3]}, if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_label.cylinders[1].widthDirection[1], world.y_label.cylinders[1].widthDirection[2], world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_label.cylinders[1].e_x[1], world.y_label.cylinders[1].e_x[2], world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1], world.y_label.cylinders[1].e_x[2], world.y_label.cylinders[1].e_x[3]}, if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_label.cylinders[1].widthDirection[1], world.y_label.cylinders[1].widthDirection[2], world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_label.cylinders[1].e_x[1], world.y_label.cylinders[1].e_x[2], world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1], world.y_label.cylinders[1].e_x[2], world.y_label.cylinders[1].e_x[3]}, if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_label.cylinders[1].widthDirection[1], world.y_label.cylinders[1].widthDirection[2], world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_label.cylinders[1].e_x[1], world.y_label.cylinders[1].e_x[2], world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.y_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = {world.y_label.r_abs[1], world.y_label.r_abs[2], world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1], world.y_label.R_lines[1,2], world.y_label.R_lines[1,3]}, {world.y_label.R_lines[2,1], world.y_label.R_lines[2,2], world.y_label.R_lines[2,3]}, {world.y_label.R_lines[3,1], world.y_label.R_lines[3,2], world.y_label.R_lines[3,3]}}, {world.y_label.lines[2,1,1], world.y_label.lines[2,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = {world.y_label.r_abs[1], world.y_label.r_abs[2], world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1], world.y_label.R_lines[1,2], world.y_label.R_lines[1,3]}, {world.y_label.R_lines[2,1], world.y_label.R_lines[2,2], world.y_label.R_lines[2,3]}, {world.y_label.R_lines[3,1], world.y_label.R_lines[3,2], world.y_label.R_lines[3,3]}}, {world.y_label.lines[2,1,1], world.y_label.lines[2,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = {world.y_label.r_abs[1], world.y_label.r_abs[2], world.y_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1], world.y_label.R_lines[1,2], world.y_label.R_lines[1,3]}, {world.y_label.R_lines[2,1], world.y_label.R_lines[2,2], world.y_label.R_lines[2,3]}, {world.y_label.R_lines[3,1], world.y_label.R_lines[3,2], world.y_label.R_lines[3,3]}}, {world.y_label.lines[2,1,1], world.y_label.lines[2,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}}, {world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1], world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}}, {world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1], world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1], world.y_label.R_rel[1,2], world.y_label.R_rel[1,3]}, {world.y_label.R_rel[2,1], world.y_label.R_rel[2,2], world.y_label.R_rel[2,3]}, {world.y_label.R_rel[3,1], world.y_label.R_rel[3,2], world.y_label.R_rel[3,3]}}, {world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1], world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1], world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1], world.y_label.cylinders[2].lengthDirection[2], world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 0.0000000001) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 0.0000000001) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 0.0000000001) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1], world.y_label.cylinders[2].e_x[2], world.y_label.cylinders[2].e_x[3]}, if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_label.cylinders[2].widthDirection[1], world.y_label.cylinders[2].widthDirection[2], world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_label.cylinders[2].e_x[1], world.y_label.cylinders[2].e_x[2], world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1], world.y_label.cylinders[2].e_x[2], world.y_label.cylinders[2].e_x[3]}, if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_label.cylinders[2].widthDirection[1], world.y_label.cylinders[2].widthDirection[2], world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_label.cylinders[2].e_x[1], world.y_label.cylinders[2].e_x[2], world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1], world.y_label.cylinders[2].e_x[2], world.y_label.cylinders[2].e_x[3]}, if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_label.cylinders[2].widthDirection[1], world.y_label.cylinders[2].widthDirection[2], world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_label.cylinders[2].e_x[1], world.y_label.cylinders[2].e_x[2], world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   input Real world.z_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[3](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[3](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] \"Color of cylinders\";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] \"Color of cylinders\";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] \"Color of cylinders\";
//   input Real world.z_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[1, 1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[1, 2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[1, 3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[2, 1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[2, 2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[2, 3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[3, 1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[3, 2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1], world.z_label.n_x[2], world.z_label.n_x[3]}, {world.z_label.n_y[1], world.z_label.n_y[2], world.z_label.n_y[3]})[3, 3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[1, 1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[1, 2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[1, 3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[2, 1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[2, 2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[2, 3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[3, 1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[3, 2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}})[3, 3];
//   protected Real world.z_label.r_abs[1](quantity = \"Length\", unit = \"m\") = {world.z_label.r[1], world.z_label.r[2], world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {world.z_label.r_lines[1], world.z_label.r_lines[2], world.z_label.r_lines[3]})[1];
//   protected Real world.z_label.r_abs[2](quantity = \"Length\", unit = \"m\") = {world.z_label.r[1], world.z_label.r[2], world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {world.z_label.r_lines[1], world.z_label.r_lines[2], world.z_label.r_lines[3]})[2];
//   protected Real world.z_label.r_abs[3](quantity = \"Length\", unit = \"m\") = {world.z_label.r[1], world.z_label.r[2], world.z_label.r[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1], world.z_label.R.T[1,2], world.z_label.R.T[1,3]}, {world.z_label.R.T[2,1], world.z_label.R.T[2,2], world.z_label.R.T[2,3]}, {world.z_label.R.T[3,1], world.z_label.R.T[3,2], world.z_label.R.T[3,3]}}, {world.z_label.r_lines[1], world.z_label.r_lines[2], world.z_label.r_lines[3]})[3];
//   protected parameter Integer world.z_label.n = 3 \"Number of cylinders\";
//   parameter String world.z_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[1,1,1], world.z_label.lines[1,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[1,1,1], world.z_label.lines[1,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[1,1,1], world.z_label.lines[1,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1], world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1], world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1], world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1], world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1], world.z_label.cylinders[1].lengthDirection[2], world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 0.0000000001) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 0.0000000001) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 0.0000000001) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1], world.z_label.cylinders[1].e_x[2], world.z_label.cylinders[1].e_x[3]}, if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[1].widthDirection[1], world.z_label.cylinders[1].widthDirection[2], world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[1].e_x[1], world.z_label.cylinders[1].e_x[2], world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1], world.z_label.cylinders[1].e_x[2], world.z_label.cylinders[1].e_x[3]}, if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[1].widthDirection[1], world.z_label.cylinders[1].widthDirection[2], world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[1].e_x[1], world.z_label.cylinders[1].e_x[2], world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1], world.z_label.cylinders[1].e_x[2], world.z_label.cylinders[1].e_x[3]}, if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[1].widthDirection[1], world.z_label.cylinders[1].widthDirection[2], world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[1].e_x[1], world.z_label.cylinders[1].e_x[2], world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[2,1,1], world.z_label.lines[2,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[2,1,1], world.z_label.lines[2,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[2,1,1], world.z_label.lines[2,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1], world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1], world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1], world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1], world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1], world.z_label.cylinders[2].lengthDirection[2], world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 0.0000000001) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 0.0000000001) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 0.0000000001) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1], world.z_label.cylinders[2].e_x[2], world.z_label.cylinders[2].e_x[3]}, if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[2].widthDirection[1], world.z_label.cylinders[2].widthDirection[2], world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[2].e_x[1], world.z_label.cylinders[2].e_x[2], world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1], world.z_label.cylinders[2].e_x[2], world.z_label.cylinders[2].e_x[3]}, if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[2].widthDirection[1], world.z_label.cylinders[2].widthDirection[2], world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[2].e_x[1], world.z_label.cylinders[2].e_x[2], world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1], world.z_label.cylinders[2].e_x[2], world.z_label.cylinders[2].e_x[3]}, if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[2].widthDirection[1], world.z_label.cylinders[2].widthDirection[2], world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[2].e_x[1], world.z_label.cylinders[2].e_x[2], world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = world.z_label.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].r[1](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[3,1,1], world.z_label.lines[3,1,2], 0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[2](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[3,1,1], world.z_label.lines[3,1,2], 0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[3](quantity = \"Length\", unit = \"m\") = {world.z_label.r_abs[1], world.z_label.r_abs[2], world.z_label.r_abs[3]} + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1], world.z_label.R_lines[1,2], world.z_label.R_lines[1,3]}, {world.z_label.R_lines[2,1], world.z_label.R_lines[2,2], world.z_label.R_lines[2,3]}, {world.z_label.R_lines[3,1], world.z_label.R_lines[3,2], world.z_label.R_lines[3,3]}}, {world.z_label.lines[3,1,1], world.z_label.lines[3,1,2], 0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1], world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2], 0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1], world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2], 0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1], world.z_label.R_rel[1,2], world.z_label.R_rel[1,3]}, {world.z_label.R_rel[2,1], world.z_label.R_rel[2,2], world.z_label.R_rel[2,3]}, {world.z_label.R_rel[3,1], world.z_label.R_rel[3,2], world.z_label.R_rel[3,3]}}, {world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1], world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2], 0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1], world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[3].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[3].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[3].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1], world.z_label.cylinders[3].lengthDirection[2], world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 0.0000000001) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 0.0000000001) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 0.0000000001) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1], world.z_label.cylinders[3].e_x[2], world.z_label.cylinders[3].e_x[3]}, if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[3].widthDirection[1], world.z_label.cylinders[3].widthDirection[2], world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[3].e_x[1], world.z_label.cylinders[3].e_x[2], world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1], world.z_label.cylinders[3].e_x[2], world.z_label.cylinders[3].e_x[3]}, if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[3].widthDirection[1], world.z_label.cylinders[3].widthDirection[2], world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[3].e_x[1], world.z_label.cylinders[3].e_x[2], world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1], world.z_label.cylinders[3].e_x[2], world.z_label.cylinders[3].e_x[3]}, if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_label.cylinders[3].widthDirection[1], world.z_label.cylinders[3].widthDirection[2], world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_label.cylinders[3].e_x[1], world.z_label.cylinders[3].e_x[2], world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   protected parameter Real world.gravityHeadLength(quantity = \"Length\", unit = \"m\") = min(world.gravityArrowLength, 4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = \"Length\", unit = \"m\") = max(0.0, world.gravityArrowLength - world.gravityHeadLength);
//   parameter String world.x_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.x_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.x_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.x_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1], world.x_arrowLine.lengthDirection[2], world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 0.0000000001) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 0.0000000001) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 0.0000000001) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = \"1\") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = \"1\") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = \"1\") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1], world.x_arrowLine.e_x[2], world.x_arrowLine.e_x[3]}, if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_arrowLine.widthDirection[1], world.x_arrowLine.widthDirection[2], world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_arrowLine.e_x[1], world.x_arrowLine.e_x[2], world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1], world.x_arrowLine.e_x[2], world.x_arrowLine.e_x[3]}, if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_arrowLine.widthDirection[1], world.x_arrowLine.widthDirection[2], world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_arrowLine.e_x[1], world.x_arrowLine.e_x[2], world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1], world.x_arrowLine.e_x[2], world.x_arrowLine.e_x[3]}, if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_arrowLine.widthDirection[1], world.x_arrowLine.widthDirection[2], world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_arrowLine.e_x[1], world.x_arrowLine.e_x[2], world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.x_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.x_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.x_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1], world.x_arrowHead.lengthDirection[2], world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 0.0000000001) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 0.0000000001) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 0.0000000001) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = \"1\") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = \"1\") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = \"1\") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1], world.x_arrowHead.e_x[2], world.x_arrowHead.e_x[3]}, if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_arrowHead.widthDirection[1], world.x_arrowHead.widthDirection[2], world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_arrowHead.e_x[1], world.x_arrowHead.e_x[2], world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1], world.x_arrowHead.e_x[2], world.x_arrowHead.e_x[3]}, if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_arrowHead.widthDirection[1], world.x_arrowHead.widthDirection[2], world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_arrowHead.e_x[1], world.x_arrowHead.e_x[2], world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1], world.x_arrowHead.e_x[2], world.x_arrowHead.e_x[3]}, if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.x_arrowHead.widthDirection[1], world.x_arrowHead.widthDirection[2], world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.x_arrowHead.e_x[1], world.x_arrowHead.e_x[2], world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   parameter String world.y_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.y_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.y_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.y_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1], world.y_arrowLine.lengthDirection[2], world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 0.0000000001) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 0.0000000001) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 0.0000000001) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = \"1\") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = \"1\") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = \"1\") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1], world.y_arrowLine.e_x[2], world.y_arrowLine.e_x[3]}, if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_arrowLine.widthDirection[1], world.y_arrowLine.widthDirection[2], world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_arrowLine.e_x[1], world.y_arrowLine.e_x[2], world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1], world.y_arrowLine.e_x[2], world.y_arrowLine.e_x[3]}, if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_arrowLine.widthDirection[1], world.y_arrowLine.widthDirection[2], world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_arrowLine.e_x[1], world.y_arrowLine.e_x[2], world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1], world.y_arrowLine.e_x[2], world.y_arrowLine.e_x[3]}, if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_arrowLine.widthDirection[1], world.y_arrowLine.widthDirection[2], world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_arrowLine.e_x[1], world.y_arrowLine.e_x[2], world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.y_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.y_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.y_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1], world.y_arrowHead.lengthDirection[2], world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 0.0000000001) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 0.0000000001) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 0.0000000001) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = \"1\") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = \"1\") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = \"1\") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1], world.y_arrowHead.e_x[2], world.y_arrowHead.e_x[3]}, if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_arrowHead.widthDirection[1], world.y_arrowHead.widthDirection[2], world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_arrowHead.e_x[1], world.y_arrowHead.e_x[2], world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1], world.y_arrowHead.e_x[2], world.y_arrowHead.e_x[3]}, if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_arrowHead.widthDirection[1], world.y_arrowHead.widthDirection[2], world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_arrowHead.e_x[1], world.y_arrowHead.e_x[2], world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1], world.y_arrowHead.e_x[2], world.y_arrowHead.e_x[3]}, if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.y_arrowHead.widthDirection[1], world.y_arrowHead.widthDirection[2], world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.y_arrowHead.e_x[1], world.y_arrowHead.e_x[2], world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   parameter String world.z_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.z_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.z_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.z_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1], world.z_arrowLine.lengthDirection[2], world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 0.0000000001) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 0.0000000001) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 0.0000000001) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = \"1\") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = \"1\") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = \"1\") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1], world.z_arrowLine.e_x[2], world.z_arrowLine.e_x[3]}, if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_arrowLine.widthDirection[1], world.z_arrowLine.widthDirection[2], world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_arrowLine.e_x[1], world.z_arrowLine.e_x[2], world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1], world.z_arrowLine.e_x[2], world.z_arrowLine.e_x[3]}, if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_arrowLine.widthDirection[1], world.z_arrowLine.widthDirection[2], world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_arrowLine.e_x[1], world.z_arrowLine.e_x[2], world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1], world.z_arrowLine.e_x[2], world.z_arrowLine.e_x[3]}, if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_arrowLine.widthDirection[1], world.z_arrowLine.widthDirection[2], world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_arrowLine.e_x[1], world.z_arrowLine.e_x[2], world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.z_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.z_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.z_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1], world.z_arrowHead.lengthDirection[2], world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 0.0000000001) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 0.0000000001) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 0.0000000001) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = \"1\") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = \"1\") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = \"1\") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1], world.z_arrowHead.e_x[2], world.z_arrowHead.e_x[3]}, if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_arrowHead.widthDirection[1], world.z_arrowHead.widthDirection[2], world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_arrowHead.e_x[1], world.z_arrowHead.e_x[2], world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1], world.z_arrowHead.e_x[2], world.z_arrowHead.e_x[3]}, if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_arrowHead.widthDirection[1], world.z_arrowHead.widthDirection[2], world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_arrowHead.e_x[1], world.z_arrowHead.e_x[2], world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1], world.z_arrowHead.e_x[2], world.z_arrowHead.e_x[3]}, if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {world.z_arrowHead.widthDirection[1], world.z_arrowHead.widthDirection[2], world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {world.z_arrowHead.e_x[1], world.z_arrowHead.e_x[2], world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   Real body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean body.animation = true \"= true, if animation shall be enabled (show cylinder between frame_a and frame_b)\";
//   parameter Real body.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 1.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real body.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real body.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real body.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real body.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real body.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real body.innerDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Inner diameter of cylinder (0 <= innerDiameter <= Diameter)\";
//   parameter Real body.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer body.color[1](min = 0, max = 255) = 0 \"Color of cylinder\";
//   input Integer body.color[2](min = 0, max = 255) = 128 \"Color of cylinder\";
//   input Integer body.color[3](min = 0, max = 255) = 255 \"Color of cylinder\";
//   input Real body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean body.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer body.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean body.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean body.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean body.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean body.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer body.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   constant Real body.pi = 3.141592653589793;
//   final parameter Real body.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real body.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real body.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body.lengthDirection[1](unit = \"1\") = body.r[1] - body.r_shape[1] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real body.lengthDirection[2](unit = \"1\") = body.r[2] - body.r_shape[2] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real body.lengthDirection[3](unit = \"1\") = body.r[3] - body.r_shape[3] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real body.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({body.r[1] - body.r_shape[1], body.r[2] - body.r_shape[2], body.r[3] - body.r_shape[3]}) \"Length of cylinder\";
//   final parameter Real body.innerRadius(quantity = \"Length\", unit = \"m\", min = 0.0) = body.innerDiameter / 2.0 \"Inner-Radius of cylinder\";
//   parameter Real body.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = body.length / world.defaultWidthFraction \"Diameter of cylinder\";
//   final parameter Real body.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({body.r[1], body.r[2], body.r[3]}, 0.0000000000001) * body.length / 2.0[1] \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   final parameter Real body.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({body.r[1], body.r[2], body.r[3]}, 0.0000000000001) * body.length / 2.0[2] \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   final parameter Real body.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({body.r[1], body.r[2], body.r[3]}, 0.0000000000001) * body.length / 2.0[3] \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   final parameter Real body.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.141592653589793 * body.density * body.length * body.innerRadius ^ 2.0 \"Mass of hole of cylinder\";
//   final parameter Real body.radius(quantity = \"Length\", unit = \"m\", min = 0.0) = body.diameter / 2.0 \"Radius of cylinder\";
//   final parameter Real body.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.141592653589793 * body.density * body.length * body.radius ^ 2.0 \"Mass of cylinder without hole\";
//   final parameter Real body.I22(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.mo * (body.length ^ 2.0 / 12.0 + 0.25 * body.radius ^ 2.0) - body.mi * (body.length ^ 2.0 / 12.0 + 0.25 * body.innerRadius ^ 2.0) \"Inertia with respect to axis through center of mass, perpendicular to cylinder axis\";
//   final parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = body.mo - body.mi \"Mass of cylinder\";
//   final parameter Real body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[1, 1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[1, 2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[1, 3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[2, 1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[2, 2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[2, 3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[3, 1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[3, 2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   final parameter Real body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(body.R, {{body.mo * body.radius ^ 2.0 / 2.0 + (-body.mi) * body.innerRadius ^ 2.0 / 2.0, 0.0, 0.0}, {0.0, body.I22, 0.0}, {0.0, 0.0, body.I22}})[3, 3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   Real body.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean body.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real body.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = body.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = body.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = body.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = body.m \"Mass of rigid body\";
//   parameter Real body.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = body.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real body.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = body.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real body.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = body.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real body.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = body.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real body.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = body.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real body.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = body.I[3,2] \" (3,2) element of inertia tensor\";
//   Real body.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean body.body.angles_fixed = body.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real body.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = body.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = body.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = body.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer body.body.sequence_start[1](min = 1, max = 3) = body.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body.body.sequence_start[2](min = 1, max = 3) = body.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body.body.sequence_start[3](min = 1, max = 3) = body.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean body.body.w_0_fixed = body.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real body.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = body.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = body.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = body.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean body.body.z_0_fixed = body.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real body.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = body.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = body.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = body.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer body.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer body.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer body.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer body.body.cylinderColor[1](min = 0, max = 255) = body.body.sphereColor[1] \"Color of cylinder\";
//   input Integer body.body.cylinderColor[2](min = 0, max = 255) = body.body.sphereColor[2] \"Color of cylinder\";
//   input Integer body.body.cylinderColor[3](min = 0, max = 255) = body.body.sphereColor[3] \"Color of cylinder\";
//   input Real body.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean body.body.enforceStates = body.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean body.body.useQuaternions = body.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer body.body.sequence_angleStates[1](min = 1, max = 3) = body.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body.body.sequence_angleStates[2](min = 1, max = 3) = body.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body.body.sequence_angleStates[3](min = 1, max = 3) = body.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real body.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.w_0_start[1], body.body.w_0_start[2], body.body.w_0_start[3]})[1], fixed = body.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.w_0_start[1], body.body.w_0_start[2], body.body.w_0_start[3]})[2], fixed = body.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.w_0_start[1], body.body.w_0_start[2], body.body.w_0_start[3]})[3], fixed = body.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real body.body.Q[1](start = body.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body.body.Q[2](start = body.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body.body.Q[3](start = body.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body.body.Q[4](start = body.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real body.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body.body.sequence_start[1] == body.body.sequence_angleStates[1] and body.body.sequence_start[2] == body.body.sequence_angleStates[2] and body.body.sequence_start[3] == body.body.sequence_angleStates[3] then body.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body.body.R_start, {body.body.sequence_angleStates[1], body.body.sequence_angleStates[2], body.body.sequence_angleStates[3]}, 0)[1] \"Potential angle states at initial time\";
//   protected parameter Real body.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body.body.sequence_start[1] == body.body.sequence_angleStates[1] and body.body.sequence_start[2] == body.body.sequence_angleStates[2] and body.body.sequence_start[3] == body.body.sequence_angleStates[3] then body.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body.body.R_start, {body.body.sequence_angleStates[1], body.body.sequence_angleStates[2], body.body.sequence_angleStates[3]}, 0)[2] \"Potential angle states at initial time\";
//   protected parameter Real body.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body.body.sequence_start[1] == body.body.sequence_angleStates[1] and body.body.sequence_start[2] == body.body.sequence_angleStates[2] and body.body.sequence_start[3] == body.body.sequence_angleStates[3] then body.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body.body.R_start, {body.body.sequence_angleStates[1], body.body.sequence_angleStates[2], body.body.sequence_angleStates[3]}, 0)[3] \"Potential angle states at initial time\";
//   protected Real body.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real body.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_11 \"inertia tensor\";
//   final parameter Real body.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_21 \"inertia tensor\";
//   final parameter Real body.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_31 \"inertia tensor\";
//   final parameter Real body.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_21 \"inertia tensor\";
//   final parameter Real body.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_22 \"inertia tensor\";
//   final parameter Real body.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_32 \"inertia tensor\";
//   final parameter Real body.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_31 \"inertia tensor\";
//   final parameter Real body.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_32 \"inertia tensor\";
//   final parameter Real body.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body.body.I_33 \"inertia tensor\";
//   final parameter Real body.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real body.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real body.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real body.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = body.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real body.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.z_0_start[1], body.body.z_0_start[2], body.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real body.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.z_0_start[1], body.body.z_0_start[2], body.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real body.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.z_0_start[1], body.body.z_0_start[2], body.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real body.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.z_0_start[1], body.body.z_0_start[2], body.body.z_0_start[3]})[1], fixed = body.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.z_0_start[1], body.body.z_0_start[2], body.body.z_0_start[3]})[2], fixed = body.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.R_start, {body.body.z_0_start[1], body.body.z_0_start[2], body.body.z_0_start[3]})[3], fixed = body.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   protected parameter Real body.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(body.body.R_start, {0.0, 0.0, 0.0, 1.0})[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(body.body.R_start, {0.0, 0.0, 0.0, 1.0})[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(body.body.R_start, {0.0, 0.0, 0.0, 1.0})[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(body.body.R_start, {0.0, 0.0, 0.0, 1.0})[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   Real body.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean body.frameTranslation.animation = body.animation \"= true, if animation shall be enabled\";
//   parameter Real body.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = body.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real body.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = body.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real body.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = body.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String body.frameTranslation.shapeType = \"pipecylinder\" \" Type of shape\";
//   parameter Real body.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = body.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real body.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = body.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real body.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = body.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real body.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real body.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real body.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real body.frameTranslation.extra = body.innerDiameter / body.diameter \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer body.frameTranslation.color[1](min = 0, max = 255) = body.color[1] \" Color of shape\";
//   input Integer body.frameTranslation.color[2](min = 0, max = 255) = body.color[2] \" Color of shape\";
//   input Integer body.frameTranslation.color[3](min = 0, max = 255) = body.color[3] \" Color of shape\";
//   input Real body.frameTranslation.specularCoefficient = body.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real body.frameTranslation.lengthDirection[1](unit = \"1\") = body.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real body.frameTranslation.lengthDirection[2](unit = \"1\") = body.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real body.frameTranslation.lengthDirection[3](unit = \"1\") = body.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real body.frameTranslation.length(quantity = \"Length\", unit = \"m\") = body.length \" Length of shape\";
//   parameter Real body.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = body.diameter \" Width of shape\";
//   parameter Real body.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = body.diameter \" Height of shape.\";
//   parameter String body.frameTranslation.shape.shapeType = body.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.frameTranslation.shape.R.T[1,1] = body.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[1,2] = body.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[1,3] = body.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[2,1] = body.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[2,2] = body.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[2,3] = body.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[3,1] = body.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[3,2] = body.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.T[3,3] = body.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = body.frameTranslation.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = body.frameTranslation.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = body.frameTranslation.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = body.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = body.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = body.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = body.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = body.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = body.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.frameTranslation.shape.lengthDirection[1](unit = \"1\") = body.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real body.frameTranslation.shape.lengthDirection[2](unit = \"1\") = body.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real body.frameTranslation.shape.lengthDirection[3](unit = \"1\") = body.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real body.frameTranslation.shape.widthDirection[1](unit = \"1\") = body.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real body.frameTranslation.shape.widthDirection[2](unit = \"1\") = body.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real body.frameTranslation.shape.widthDirection[3](unit = \"1\") = body.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real body.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = body.frameTranslation.length \"Length of visual object\";
//   input Real body.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = body.frameTranslation.width \"Width of visual object\";
//   input Real body.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = body.frameTranslation.height \"Height of visual object\";
//   input Real body.frameTranslation.shape.extra = body.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real body.frameTranslation.shape.color[1] = Real(body.frameTranslation.color[1]) \"Color of shape\";
//   input Real body.frameTranslation.shape.color[2] = Real(body.frameTranslation.color[2]) \"Color of shape\";
//   input Real body.frameTranslation.shape.color[3] = Real(body.frameTranslation.color[3]) \"Color of shape\";
//   input Real body.frameTranslation.shape.specularCoefficient = body.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.frameTranslation.shape.lengthDirection[1], body.frameTranslation.shape.lengthDirection[2], body.frameTranslation.shape.lengthDirection[3]});
//   protected Real body.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(body.frameTranslation.shape.abs_n_x < 0.0000000001) then 1.0 else body.frameTranslation.shape.lengthDirection[1] / body.frameTranslation.shape.abs_n_x;
//   protected Real body.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(body.frameTranslation.shape.abs_n_x < 0.0000000001) then 0.0 else body.frameTranslation.shape.lengthDirection[2] / body.frameTranslation.shape.abs_n_x;
//   protected Real body.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(body.frameTranslation.shape.abs_n_x < 0.0000000001) then 0.0 else body.frameTranslation.shape.lengthDirection[3] / body.frameTranslation.shape.abs_n_x;
//   protected Real body.frameTranslation.shape.n_z_aux[1](unit = \"1\") = body.frameTranslation.shape.e_x[2] * body.frameTranslation.shape.widthDirection[3] - body.frameTranslation.shape.e_x[3] * body.frameTranslation.shape.widthDirection[2];
//   protected Real body.frameTranslation.shape.n_z_aux[2](unit = \"1\") = body.frameTranslation.shape.e_x[3] * body.frameTranslation.shape.widthDirection[1] - body.frameTranslation.shape.e_x[1] * body.frameTranslation.shape.widthDirection[3];
//   protected Real body.frameTranslation.shape.n_z_aux[3](unit = \"1\") = body.frameTranslation.shape.e_x[1] * body.frameTranslation.shape.widthDirection[2] - body.frameTranslation.shape.e_x[2] * body.frameTranslation.shape.widthDirection[1];
//   protected Real body.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.frameTranslation.shape.e_x[1], body.frameTranslation.shape.e_x[2], body.frameTranslation.shape.e_x[3]}, if noEvent(body.frameTranslation.shape.n_z_aux[1] ^ 2.0 + body.frameTranslation.shape.n_z_aux[2] ^ 2.0 + body.frameTranslation.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {body.frameTranslation.shape.widthDirection[1], body.frameTranslation.shape.widthDirection[2], body.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(body.frameTranslation.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {body.frameTranslation.shape.e_x[1], body.frameTranslation.shape.e_x[2], body.frameTranslation.shape.e_x[3]})[1];
//   protected Real body.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.frameTranslation.shape.e_x[1], body.frameTranslation.shape.e_x[2], body.frameTranslation.shape.e_x[3]}, if noEvent(body.frameTranslation.shape.n_z_aux[1] ^ 2.0 + body.frameTranslation.shape.n_z_aux[2] ^ 2.0 + body.frameTranslation.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {body.frameTranslation.shape.widthDirection[1], body.frameTranslation.shape.widthDirection[2], body.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(body.frameTranslation.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {body.frameTranslation.shape.e_x[1], body.frameTranslation.shape.e_x[2], body.frameTranslation.shape.e_x[3]})[2];
//   protected Real body.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.frameTranslation.shape.e_x[1], body.frameTranslation.shape.e_x[2], body.frameTranslation.shape.e_x[3]}, if noEvent(body.frameTranslation.shape.n_z_aux[1] ^ 2.0 + body.frameTranslation.shape.n_z_aux[2] ^ 2.0 + body.frameTranslation.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {body.frameTranslation.shape.widthDirection[1], body.frameTranslation.shape.widthDirection[2], body.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(body.frameTranslation.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {body.frameTranslation.shape.e_x[1], body.frameTranslation.shape.e_x[2], body.frameTranslation.shape.e_x[3]})[3];
//   protected output Real body.frameTranslation.shape.Form;
//   output Real body.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.frameTranslation.shape.Material;
//   protected output Real body.frameTranslation.shape.Extra;
//   Real fixed1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixed1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixed1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixed1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real fixed1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixed1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixed1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixed1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixed1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixed1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixed1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixed1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixed1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean fixed1.animation = true \"= true, if animation shall be enabled\";
//   parameter Real fixed1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from world frame to frame_b, resolved in world frame\";
//   parameter Real fixed1.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"Position vector from world frame to frame_b, resolved in world frame\";
//   parameter Real fixed1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from world frame to frame_b, resolved in world frame\";
//   parameter String fixed1.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real fixed1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from world frame to shape origin, resolved in world frame\";
//   parameter Real fixed1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from world frame to shape origin, resolved in world frame\";
//   parameter Real fixed1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from world frame to shape origin, resolved in world frame\";
//   parameter Real fixed1.widthDirection[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector in width direction of shape, resolved in world frame\";
//   parameter Real fixed1.widthDirection[2](quantity = \"Length\", unit = \"m\") = 1.0 \" Vector in width direction of shape, resolved in world frame\";
//   parameter Real fixed1.widthDirection[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector in width direction of shape, resolved in world frame\";
//   parameter Real fixed1.extra = 0.0 \" Additional parameter for cone, pipe etc. (see docu of Visualizers.Advanced.Shape)\";
//   input Integer fixed1.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer fixed1.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer fixed1.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real fixed1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real fixed1.lengthDirection[1](quantity = \"Length\", unit = \"m\") = fixed1.r[1] - fixed1.r_shape[1] \" Vector in length direction of shape, resolved in world frame\";
//   parameter Real fixed1.lengthDirection[2](quantity = \"Length\", unit = \"m\") = fixed1.r[2] - fixed1.r_shape[2] \" Vector in length direction of shape, resolved in world frame\";
//   parameter Real fixed1.lengthDirection[3](quantity = \"Length\", unit = \"m\") = fixed1.r[3] - fixed1.r_shape[3] \" Vector in length direction of shape, resolved in world frame\";
//   parameter Real fixed1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({fixed1.r[1] - fixed1.r_shape[1], fixed1.r[2] - fixed1.r_shape[2], fixed1.r[3] - fixed1.r_shape[3]}) \" Length of shape\";
//   parameter Real fixed1.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.03 \" Width of shape\";
//   parameter Real fixed1.height(quantity = \"Length\", unit = \"m\", min = 0.0) = fixed1.width \" Height of shape\";
//   parameter String fixed1.shape.shapeType = fixed1.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixed1.shape.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed1.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixed1.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixed1.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixed1.shape.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixed1.shape.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixed1.shape.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixed1.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = fixed1.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixed1.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = fixed1.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixed1.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = fixed1.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixed1.shape.lengthDirection[1](unit = \"1\") = fixed1.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real fixed1.shape.lengthDirection[2](unit = \"1\") = fixed1.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real fixed1.shape.lengthDirection[3](unit = \"1\") = fixed1.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real fixed1.shape.widthDirection[1](unit = \"1\") = fixed1.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real fixed1.shape.widthDirection[2](unit = \"1\") = fixed1.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real fixed1.shape.widthDirection[3](unit = \"1\") = fixed1.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real fixed1.shape.length(quantity = \"Length\", unit = \"m\") = fixed1.length \"Length of visual object\";
//   input Real fixed1.shape.width(quantity = \"Length\", unit = \"m\") = fixed1.width \"Width of visual object\";
//   input Real fixed1.shape.height(quantity = \"Length\", unit = \"m\") = fixed1.height \"Height of visual object\";
//   input Real fixed1.shape.extra = fixed1.extra \"Additional size data for some of the shape types\";
//   input Real fixed1.shape.color[1] = Real(fixed1.color[1]) \"Color of shape\";
//   input Real fixed1.shape.color[2] = Real(fixed1.color[2]) \"Color of shape\";
//   input Real fixed1.shape.color[3] = Real(fixed1.color[3]) \"Color of shape\";
//   input Real fixed1.shape.specularCoefficient = fixed1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixed1.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixed1.shape.lengthDirection[1], fixed1.shape.lengthDirection[2], fixed1.shape.lengthDirection[3]});
//   protected Real fixed1.shape.e_x[1](unit = \"1\") = if noEvent(fixed1.shape.abs_n_x < 0.0000000001) then 1.0 else fixed1.shape.lengthDirection[1] / fixed1.shape.abs_n_x;
//   protected Real fixed1.shape.e_x[2](unit = \"1\") = if noEvent(fixed1.shape.abs_n_x < 0.0000000001) then 0.0 else fixed1.shape.lengthDirection[2] / fixed1.shape.abs_n_x;
//   protected Real fixed1.shape.e_x[3](unit = \"1\") = if noEvent(fixed1.shape.abs_n_x < 0.0000000001) then 0.0 else fixed1.shape.lengthDirection[3] / fixed1.shape.abs_n_x;
//   protected Real fixed1.shape.n_z_aux[1](unit = \"1\") = fixed1.shape.e_x[2] * fixed1.shape.widthDirection[3] - fixed1.shape.e_x[3] * fixed1.shape.widthDirection[2];
//   protected Real fixed1.shape.n_z_aux[2](unit = \"1\") = fixed1.shape.e_x[3] * fixed1.shape.widthDirection[1] - fixed1.shape.e_x[1] * fixed1.shape.widthDirection[3];
//   protected Real fixed1.shape.n_z_aux[3](unit = \"1\") = fixed1.shape.e_x[1] * fixed1.shape.widthDirection[2] - fixed1.shape.e_x[2] * fixed1.shape.widthDirection[1];
//   protected Real fixed1.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixed1.shape.e_x[1], fixed1.shape.e_x[2], fixed1.shape.e_x[3]}, if noEvent(fixed1.shape.n_z_aux[1] ^ 2.0 + fixed1.shape.n_z_aux[2] ^ 2.0 + fixed1.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixed1.shape.widthDirection[1], fixed1.shape.widthDirection[2], fixed1.shape.widthDirection[3]} else if noEvent(abs(fixed1.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixed1.shape.e_x[1], fixed1.shape.e_x[2], fixed1.shape.e_x[3]})[1];
//   protected Real fixed1.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixed1.shape.e_x[1], fixed1.shape.e_x[2], fixed1.shape.e_x[3]}, if noEvent(fixed1.shape.n_z_aux[1] ^ 2.0 + fixed1.shape.n_z_aux[2] ^ 2.0 + fixed1.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixed1.shape.widthDirection[1], fixed1.shape.widthDirection[2], fixed1.shape.widthDirection[3]} else if noEvent(abs(fixed1.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixed1.shape.e_x[1], fixed1.shape.e_x[2], fixed1.shape.e_x[3]})[2];
//   protected Real fixed1.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixed1.shape.e_x[1], fixed1.shape.e_x[2], fixed1.shape.e_x[3]}, if noEvent(fixed1.shape.n_z_aux[1] ^ 2.0 + fixed1.shape.n_z_aux[2] ^ 2.0 + fixed1.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixed1.shape.widthDirection[1], fixed1.shape.widthDirection[2], fixed1.shape.widthDirection[3]} else if noEvent(abs(fixed1.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixed1.shape.e_x[1], fixed1.shape.e_x[2], fixed1.shape.e_x[3]})[3];
//   protected output Real fixed1.shape.Form;
//   output Real fixed1.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixed1.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixed1.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixed1.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixed1.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixed1.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixed1.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixed1.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixed1.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixed1.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixed1.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixed1.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixed1.shape.Material;
//   protected output Real fixed1.shape.Extra;
//   Real fixedRotation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixedRotation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixedRotation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixedRotation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixedRotation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixedRotation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixedRotation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixedRotation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixedRotation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixedRotation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixedRotation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixedRotation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixedRotation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixedRotation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixedRotation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixedRotation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real fixedRotation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixedRotation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixedRotation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixedRotation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixedRotation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixedRotation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixedRotation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixedRotation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixedRotation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean fixedRotation.animation = true \"= true, if animation shall be enabled\";
//   parameter Real fixedRotation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real fixedRotation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real fixedRotation.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter enumeration(RotationAxis, TwoAxesVectors, PlanarRotationSequence) fixedRotation.rotationType = Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis \"Type of rotation description\";
//   parameter Real fixedRotation.n[1](unit = \"1\") = 0.0 \" Axis of rotation in frame_a (= same as in frame_b)\";
//   parameter Real fixedRotation.n[2](unit = \"1\") = 0.0 \" Axis of rotation in frame_a (= same as in frame_b)\";
//   parameter Real fixedRotation.n[3](unit = \"1\") = 1.0 \" Axis of rotation in frame_a (= same as in frame_b)\";
//   parameter Real fixedRotation.angle(quantity = \"Angle\", unit = \"deg\") = 30.0 \" Angle to rotate frame_a around axis n into frame_b\";
//   parameter Real fixedRotation.n_x[1](unit = \"1\") = 1.0 \" Vector along x-axis of frame_b resolved in frame_a\";
//   parameter Real fixedRotation.n_x[2](unit = \"1\") = 0.0 \" Vector along x-axis of frame_b resolved in frame_a\";
//   parameter Real fixedRotation.n_x[3](unit = \"1\") = 0.0 \" Vector along x-axis of frame_b resolved in frame_a\";
//   parameter Real fixedRotation.n_y[1](unit = \"1\") = 0.0 \" Vector along y-axis of frame_b resolved in frame_a\";
//   parameter Real fixedRotation.n_y[2](unit = \"1\") = 1.0 \" Vector along y-axis of frame_b resolved in frame_a\";
//   parameter Real fixedRotation.n_y[3](unit = \"1\") = 0.0 \" Vector along y-axis of frame_b resolved in frame_a\";
//   parameter Integer fixedRotation.sequence[1](min = 1, max = 3) = 1 \" Sequence of rotations\";
//   parameter Integer fixedRotation.sequence[2](min = 1, max = 3) = 2 \" Sequence of rotations\";
//   parameter Integer fixedRotation.sequence[3](min = 1, max = 3) = 3 \" Sequence of rotations\";
//   parameter Real fixedRotation.angles[1](quantity = \"Angle\", unit = \"deg\") = 0.0 \" Rotation angles around the axes defined in 'sequence'\";
//   parameter Real fixedRotation.angles[2](quantity = \"Angle\", unit = \"deg\") = 0.0 \" Rotation angles around the axes defined in 'sequence'\";
//   parameter Real fixedRotation.angles[3](quantity = \"Angle\", unit = \"deg\") = 0.0 \" Rotation angles around the axes defined in 'sequence'\";
//   parameter String fixedRotation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real fixedRotation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real fixedRotation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real fixedRotation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real fixedRotation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real fixedRotation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real fixedRotation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real fixedRotation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer fixedRotation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer fixedRotation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer fixedRotation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real fixedRotation.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   final parameter Real fixedRotation.R_rel.T[1,1] = 0.8660254037844387 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[1,2] = 0.49999999999999994 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[2,1] = -0.49999999999999994 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[2,2] = 0.8660254037844387 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real fixedRotation.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real fixedRotation.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real fixedRotation.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[1,1] = 0.8660254037844387 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[1,2] = -0.49999999999999994 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[2,1] = 0.49999999999999994 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[2,2] = 0.8660254037844387 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real fixedRotation.R_rel_inv.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real fixedRotation.R_rel_inv.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real fixedRotation.R_rel_inv.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real fixedRotation.lengthDirection[1](unit = \"1\") = fixedRotation.r[1] - fixedRotation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real fixedRotation.lengthDirection[2](unit = \"1\") = fixedRotation.r[2] - fixedRotation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real fixedRotation.lengthDirection[3](unit = \"1\") = fixedRotation.r[3] - fixedRotation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real fixedRotation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({fixedRotation.r[1] - fixedRotation.r_shape[1], fixedRotation.r[2] - fixedRotation.r_shape[2], fixedRotation.r[3] - fixedRotation.r_shape[3]}) \" Length of shape\";
//   parameter Real fixedRotation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = fixedRotation.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real fixedRotation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = fixedRotation.width \" Height of shape.\";
//   parameter String fixedRotation.shape.shapeType = fixedRotation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedRotation.shape.R.T[1,1] = fixedRotation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[1,2] = fixedRotation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[1,3] = fixedRotation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[2,1] = fixedRotation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[2,2] = fixedRotation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[2,3] = fixedRotation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[3,1] = fixedRotation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[3,2] = fixedRotation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.T[3,3] = fixedRotation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real fixedRotation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = fixedRotation.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedRotation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = fixedRotation.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedRotation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = fixedRotation.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedRotation.shape.r[1](quantity = \"Length\", unit = \"m\") = fixedRotation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedRotation.shape.r[2](quantity = \"Length\", unit = \"m\") = fixedRotation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedRotation.shape.r[3](quantity = \"Length\", unit = \"m\") = fixedRotation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedRotation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = fixedRotation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedRotation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = fixedRotation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedRotation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = fixedRotation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedRotation.shape.lengthDirection[1](unit = \"1\") = fixedRotation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real fixedRotation.shape.lengthDirection[2](unit = \"1\") = fixedRotation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real fixedRotation.shape.lengthDirection[3](unit = \"1\") = fixedRotation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real fixedRotation.shape.widthDirection[1](unit = \"1\") = fixedRotation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real fixedRotation.shape.widthDirection[2](unit = \"1\") = fixedRotation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real fixedRotation.shape.widthDirection[3](unit = \"1\") = fixedRotation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real fixedRotation.shape.length(quantity = \"Length\", unit = \"m\") = fixedRotation.length \"Length of visual object\";
//   input Real fixedRotation.shape.width(quantity = \"Length\", unit = \"m\") = fixedRotation.width \"Width of visual object\";
//   input Real fixedRotation.shape.height(quantity = \"Length\", unit = \"m\") = fixedRotation.height \"Height of visual object\";
//   input Real fixedRotation.shape.extra = fixedRotation.extra \"Additional size data for some of the shape types\";
//   input Real fixedRotation.shape.color[1] = Real(fixedRotation.color[1]) \"Color of shape\";
//   input Real fixedRotation.shape.color[2] = Real(fixedRotation.color[2]) \"Color of shape\";
//   input Real fixedRotation.shape.color[3] = Real(fixedRotation.color[3]) \"Color of shape\";
//   input Real fixedRotation.shape.specularCoefficient = fixedRotation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedRotation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedRotation.shape.lengthDirection[1], fixedRotation.shape.lengthDirection[2], fixedRotation.shape.lengthDirection[3]});
//   protected Real fixedRotation.shape.e_x[1](unit = \"1\") = if noEvent(fixedRotation.shape.abs_n_x < 0.0000000001) then 1.0 else fixedRotation.shape.lengthDirection[1] / fixedRotation.shape.abs_n_x;
//   protected Real fixedRotation.shape.e_x[2](unit = \"1\") = if noEvent(fixedRotation.shape.abs_n_x < 0.0000000001) then 0.0 else fixedRotation.shape.lengthDirection[2] / fixedRotation.shape.abs_n_x;
//   protected Real fixedRotation.shape.e_x[3](unit = \"1\") = if noEvent(fixedRotation.shape.abs_n_x < 0.0000000001) then 0.0 else fixedRotation.shape.lengthDirection[3] / fixedRotation.shape.abs_n_x;
//   protected Real fixedRotation.shape.n_z_aux[1](unit = \"1\") = fixedRotation.shape.e_x[2] * fixedRotation.shape.widthDirection[3] - fixedRotation.shape.e_x[3] * fixedRotation.shape.widthDirection[2];
//   protected Real fixedRotation.shape.n_z_aux[2](unit = \"1\") = fixedRotation.shape.e_x[3] * fixedRotation.shape.widthDirection[1] - fixedRotation.shape.e_x[1] * fixedRotation.shape.widthDirection[3];
//   protected Real fixedRotation.shape.n_z_aux[3](unit = \"1\") = fixedRotation.shape.e_x[1] * fixedRotation.shape.widthDirection[2] - fixedRotation.shape.e_x[2] * fixedRotation.shape.widthDirection[1];
//   protected Real fixedRotation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedRotation.shape.e_x[1], fixedRotation.shape.e_x[2], fixedRotation.shape.e_x[3]}, if noEvent(fixedRotation.shape.n_z_aux[1] ^ 2.0 + fixedRotation.shape.n_z_aux[2] ^ 2.0 + fixedRotation.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixedRotation.shape.widthDirection[1], fixedRotation.shape.widthDirection[2], fixedRotation.shape.widthDirection[3]} else if noEvent(abs(fixedRotation.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixedRotation.shape.e_x[1], fixedRotation.shape.e_x[2], fixedRotation.shape.e_x[3]})[1];
//   protected Real fixedRotation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedRotation.shape.e_x[1], fixedRotation.shape.e_x[2], fixedRotation.shape.e_x[3]}, if noEvent(fixedRotation.shape.n_z_aux[1] ^ 2.0 + fixedRotation.shape.n_z_aux[2] ^ 2.0 + fixedRotation.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixedRotation.shape.widthDirection[1], fixedRotation.shape.widthDirection[2], fixedRotation.shape.widthDirection[3]} else if noEvent(abs(fixedRotation.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixedRotation.shape.e_x[1], fixedRotation.shape.e_x[2], fixedRotation.shape.e_x[3]})[2];
//   protected Real fixedRotation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedRotation.shape.e_x[1], fixedRotation.shape.e_x[2], fixedRotation.shape.e_x[3]}, if noEvent(fixedRotation.shape.n_z_aux[1] ^ 2.0 + fixedRotation.shape.n_z_aux[2] ^ 2.0 + fixedRotation.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixedRotation.shape.widthDirection[1], fixedRotation.shape.widthDirection[2], fixedRotation.shape.widthDirection[3]} else if noEvent(abs(fixedRotation.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixedRotation.shape.e_x[1], fixedRotation.shape.e_x[2], fixedRotation.shape.e_x[3]})[3];
//   protected output Real fixedRotation.shape.Form;
//   output Real fixedRotation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedRotation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedRotation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedRotation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedRotation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedRotation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedRotation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedRotation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedRotation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedRotation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedRotation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedRotation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedRotation.shape.Material;
//   protected output Real fixedRotation.shape.Extra;
//   Real forceAndTorque.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   input Real forceAndTorque.force[1](quantity = \"Force\", unit = \"N\") \"x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.force[2](quantity = \"Force\", unit = \"N\") \"x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.force[3](quantity = \"Force\", unit = \"N\") \"x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.torque[1](quantity = \"Torque\", unit = \"N.m\") \"x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.torque[2](quantity = \"Torque\", unit = \"N.m\") \"x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.torque[3](quantity = \"Torque\", unit = \"N.m\") \"x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame\";
//   parameter Boolean forceAndTorque.animation = true \"= true, if animation shall be enabled\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) forceAndTorque.resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve \"Frame in which input force and torque are resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   parameter Real forceAndTorque.N_to_m(unit = \"N/m\") = 1200.0 \"Force arrow scaling (length = force/N_to_m)\";
//   parameter Real forceAndTorque.Nm_to_m(unit = \"N.m/m\") = 120.0 \"Torque arrow scaling (length = torque/Nm_to_m)\";
//   input Real forceAndTorque.forceDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultArrowDiameter \"Diameter of force arrow\";
//   input Real forceAndTorque.torqueDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = forceAndTorque.forceDiameter \" Diameter of torque arrow\";
//   input Real forceAndTorque.connectionLineDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = forceAndTorque.forceDiameter \"Diameter of line connecting frame_a and frame_b\";
//   input Integer forceAndTorque.forceColor[1](min = 0, max = 255) = 0 \"Color of force arrow\";
//   input Integer forceAndTorque.forceColor[2](min = 0, max = 255) = 128 \"Color of force arrow\";
//   input Integer forceAndTorque.forceColor[3](min = 0, max = 255) = 0 \"Color of force arrow\";
//   input Integer forceAndTorque.torqueColor[1](min = 0, max = 255) = 0 \"Color of torque arrow\";
//   input Integer forceAndTorque.torqueColor[2](min = 0, max = 255) = 128 \"Color of torque arrow\";
//   input Integer forceAndTorque.torqueColor[3](min = 0, max = 255) = 0 \"Color of torque arrow\";
//   input Integer forceAndTorque.connectionLineColor[1](min = 0, max = 255) = 255 \"Color of line connecting frame_a and frame_b\";
//   input Integer forceAndTorque.connectionLineColor[2](min = 0, max = 255) = 255 \"Color of line connecting frame_a and frame_b\";
//   input Integer forceAndTorque.connectionLineColor[3](min = 0, max = 255) = 0 \"Color of line connecting frame_a and frame_b\";
//   input Real forceAndTorque.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.f_in_m[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.f[1] / forceAndTorque.N_to_m \"Force mapped from N to m for animation\";
//   protected Real forceAndTorque.f_in_m[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.f[2] / forceAndTorque.N_to_m \"Force mapped from N to m for animation\";
//   protected Real forceAndTorque.f_in_m[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.f[3] / forceAndTorque.N_to_m \"Force mapped from N to m for animation\";
//   protected Real forceAndTorque.t_in_m[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.t[1] / forceAndTorque.Nm_to_m \"Torque mapped from Nm to m for animation\";
//   protected Real forceAndTorque.t_in_m[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.t[2] / forceAndTorque.Nm_to_m \"Torque mapped from Nm to m for animation\";
//   protected Real forceAndTorque.t_in_m[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.t[3] / forceAndTorque.Nm_to_m \"Torque mapped from Nm to m for animation\";
//   Real forceAndTorque.basicForce.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicForce.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicForce.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   input Real forceAndTorque.basicForce.force[1](quantity = \"Force\", unit = \"N\") \"x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.basicForce.force[2](quantity = \"Force\", unit = \"N\") \"x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.basicForce.force[3](quantity = \"Force\", unit = \"N\") \"x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) forceAndTorque.basicForce.resolveInFrame = forceAndTorque.resolveInFrame \"Frame in which force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real forceAndTorque.basicForce.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real forceAndTorque.basicForce.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real forceAndTorque.basicForce.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real forceAndTorque.basicForce.f_b_0[1](quantity = \"Force\", unit = \"N\") \"frame_b.f resoved in world frame\";
//   Real forceAndTorque.basicForce.f_b_0[2](quantity = \"Force\", unit = \"N\") \"frame_b.f resoved in world frame\";
//   Real forceAndTorque.basicForce.f_b_0[3](quantity = \"Force\", unit = \"N\") \"frame_b.f resoved in world frame\";
//   Real forceAndTorque.basicTorque.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.basicTorque.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   input Real forceAndTorque.basicTorque.torque[1](quantity = \"Torque\", unit = \"N.m\") \"x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.basicTorque.torque[2](quantity = \"Torque\", unit = \"N.m\") \"x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame\";
//   input Real forceAndTorque.basicTorque.torque[3](quantity = \"Torque\", unit = \"N.m\") \"x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) forceAndTorque.basicTorque.resolveInFrame = forceAndTorque.resolveInFrame \"Frame in which torque is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real forceAndTorque.basicTorque.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real forceAndTorque.basicTorque.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real forceAndTorque.basicTorque.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real forceAndTorque.basicTorque.t_b_0[1](quantity = \"Torque\", unit = \"N.m\") \"frame_b.t resoved in world frame\";
//   Real forceAndTorque.basicTorque.t_b_0[2](quantity = \"Torque\", unit = \"N.m\") \"frame_b.t resoved in world frame\";
//   Real forceAndTorque.basicTorque.t_b_0[3](quantity = \"Torque\", unit = \"N.m\") \"frame_b.t resoved in world frame\";
//   Real forceAndTorque.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real forceAndTorque.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real forceAndTorque.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real forceAndTorque.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real forceAndTorque.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real forceAndTorque.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   input Real forceAndTorque.forceArrow.R.T[1,1] = forceAndTorque.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[1,2] = forceAndTorque.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[1,3] = forceAndTorque.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[2,1] = forceAndTorque.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[2,2] = forceAndTorque.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[2,3] = forceAndTorque.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[3,1] = forceAndTorque.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[3,2] = forceAndTorque.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.T[3,3] = forceAndTorque.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.frame_b.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.frame_b.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.frame_b.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.r_0[1] \"Position vector from origin of world frame to origin of arrow frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.r_0[2] \"Position vector from origin of world frame to origin of arrow frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.r_0[3] \"Position vector from origin of world frame to origin of arrow frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.r_tail[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.f_in_m[1] \"Position vector from origin of arrow frame to arrow tail, resolved in arrow frame\";
//   input Real forceAndTorque.forceArrow.r_tail[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.f_in_m[2] \"Position vector from origin of arrow frame to arrow tail, resolved in arrow frame\";
//   input Real forceAndTorque.forceArrow.r_tail[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.f_in_m[3] \"Position vector from origin of arrow frame to arrow tail, resolved in arrow frame\";
//   input Real forceAndTorque.forceArrow.r_head[1](quantity = \"Length\", unit = \"m\") = -forceAndTorque.f_in_m[1] \"Position vector from arrow tail to the head of the arrow, resolved in arrow frame\";
//   input Real forceAndTorque.forceArrow.r_head[2](quantity = \"Length\", unit = \"m\") = -forceAndTorque.f_in_m[2] \"Position vector from arrow tail to the head of the arrow, resolved in arrow frame\";
//   input Real forceAndTorque.forceArrow.r_head[3](quantity = \"Length\", unit = \"m\") = -forceAndTorque.f_in_m[3] \"Position vector from arrow tail to the head of the arrow, resolved in arrow frame\";
//   input Real forceAndTorque.forceArrow.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = forceAndTorque.forceDiameter \"Diameter of arrow line\";
//   input Integer forceAndTorque.forceArrow.color[1](min = 0, max = 255) = forceAndTorque.forceColor[1] \"Color of arrow\";
//   input Integer forceAndTorque.forceArrow.color[2](min = 0, max = 255) = forceAndTorque.forceColor[2] \"Color of arrow\";
//   input Integer forceAndTorque.forceArrow.color[3](min = 0, max = 255) = forceAndTorque.forceColor[3] \"Color of arrow\";
//   input Real forceAndTorque.forceArrow.specularCoefficient = forceAndTorque.specularCoefficient \"Material property describing the reflecting of ambient light (= 0 means, that light is completely absorbed)\";
//   protected Real forceAndTorque.forceArrow.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({forceAndTorque.forceArrow.r_head[1], forceAndTorque.forceArrow.r_head[2], forceAndTorque.forceArrow.r_head[3]}) \"Length of arrow\";
//   parameter String forceAndTorque.forceArrow.arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[1,1] = forceAndTorque.forceArrow.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[1,2] = forceAndTorque.forceArrow.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[1,3] = forceAndTorque.forceArrow.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[2,1] = forceAndTorque.forceArrow.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[2,2] = forceAndTorque.forceArrow.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[2,3] = forceAndTorque.forceArrow.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[3,1] = forceAndTorque.forceArrow.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[3,2] = forceAndTorque.forceArrow.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.T[3,3] = forceAndTorque.forceArrow.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.forceArrow.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.forceArrow.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.forceArrow.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.r[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.r[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.r[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.r_tail[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.r_tail[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.r_tail[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.lengthDirection[1](unit = \"1\") = forceAndTorque.forceArrow.r_head[1] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.lengthDirection[2](unit = \"1\") = forceAndTorque.forceArrow.r_head[2] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.lengthDirection[3](unit = \"1\") = forceAndTorque.forceArrow.r_head[3] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowLine.length(quantity = \"Length\", unit = \"m\") = max(0.0, forceAndTorque.forceArrow.length + -4.0 * forceAndTorque.forceArrow.diameter) \"Length of visual object\";
//   input Real forceAndTorque.forceArrow.arrowLine.width(quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.diameter \"Width of visual object\";
//   input Real forceAndTorque.forceArrow.arrowLine.height(quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.diameter \"Height of visual object\";
//   input Real forceAndTorque.forceArrow.arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real forceAndTorque.forceArrow.arrowLine.color[1] = Real(forceAndTorque.forceArrow.color[1]) \"Color of shape\";
//   input Real forceAndTorque.forceArrow.arrowLine.color[2] = Real(forceAndTorque.forceArrow.color[2]) \"Color of shape\";
//   input Real forceAndTorque.forceArrow.arrowLine.color[3] = Real(forceAndTorque.forceArrow.color[3]) \"Color of shape\";
//   input Real forceAndTorque.forceArrow.arrowLine.specularCoefficient = forceAndTorque.forceArrow.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.forceArrow.arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({forceAndTorque.forceArrow.arrowLine.lengthDirection[1], forceAndTorque.forceArrow.arrowLine.lengthDirection[2], forceAndTorque.forceArrow.arrowLine.lengthDirection[3]});
//   protected Real forceAndTorque.forceArrow.arrowLine.e_x[1](unit = \"1\") = if noEvent(forceAndTorque.forceArrow.arrowLine.abs_n_x < 0.0000000001) then 1.0 else forceAndTorque.forceArrow.arrowLine.lengthDirection[1] / forceAndTorque.forceArrow.arrowLine.abs_n_x;
//   protected Real forceAndTorque.forceArrow.arrowLine.e_x[2](unit = \"1\") = if noEvent(forceAndTorque.forceArrow.arrowLine.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.forceArrow.arrowLine.lengthDirection[2] / forceAndTorque.forceArrow.arrowLine.abs_n_x;
//   protected Real forceAndTorque.forceArrow.arrowLine.e_x[3](unit = \"1\") = if noEvent(forceAndTorque.forceArrow.arrowLine.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.forceArrow.arrowLine.lengthDirection[3] / forceAndTorque.forceArrow.arrowLine.abs_n_x;
//   protected Real forceAndTorque.forceArrow.arrowLine.n_z_aux[1](unit = \"1\") = forceAndTorque.forceArrow.arrowLine.e_x[2] * forceAndTorque.forceArrow.arrowLine.widthDirection[3] - forceAndTorque.forceArrow.arrowLine.e_x[3] * forceAndTorque.forceArrow.arrowLine.widthDirection[2];
//   protected Real forceAndTorque.forceArrow.arrowLine.n_z_aux[2](unit = \"1\") = forceAndTorque.forceArrow.arrowLine.e_x[3] * forceAndTorque.forceArrow.arrowLine.widthDirection[1] - forceAndTorque.forceArrow.arrowLine.e_x[1] * forceAndTorque.forceArrow.arrowLine.widthDirection[3];
//   protected Real forceAndTorque.forceArrow.arrowLine.n_z_aux[3](unit = \"1\") = forceAndTorque.forceArrow.arrowLine.e_x[1] * forceAndTorque.forceArrow.arrowLine.widthDirection[2] - forceAndTorque.forceArrow.arrowLine.e_x[2] * forceAndTorque.forceArrow.arrowLine.widthDirection[1];
//   protected Real forceAndTorque.forceArrow.arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.forceArrow.arrowLine.e_x[1], forceAndTorque.forceArrow.arrowLine.e_x[2], forceAndTorque.forceArrow.arrowLine.e_x[3]}, if noEvent(forceAndTorque.forceArrow.arrowLine.n_z_aux[1] ^ 2.0 + forceAndTorque.forceArrow.arrowLine.n_z_aux[2] ^ 2.0 + forceAndTorque.forceArrow.arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.forceArrow.arrowLine.widthDirection[1], forceAndTorque.forceArrow.arrowLine.widthDirection[2], forceAndTorque.forceArrow.arrowLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.forceArrow.arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.forceArrow.arrowLine.e_x[1], forceAndTorque.forceArrow.arrowLine.e_x[2], forceAndTorque.forceArrow.arrowLine.e_x[3]})[1];
//   protected Real forceAndTorque.forceArrow.arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.forceArrow.arrowLine.e_x[1], forceAndTorque.forceArrow.arrowLine.e_x[2], forceAndTorque.forceArrow.arrowLine.e_x[3]}, if noEvent(forceAndTorque.forceArrow.arrowLine.n_z_aux[1] ^ 2.0 + forceAndTorque.forceArrow.arrowLine.n_z_aux[2] ^ 2.0 + forceAndTorque.forceArrow.arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.forceArrow.arrowLine.widthDirection[1], forceAndTorque.forceArrow.arrowLine.widthDirection[2], forceAndTorque.forceArrow.arrowLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.forceArrow.arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.forceArrow.arrowLine.e_x[1], forceAndTorque.forceArrow.arrowLine.e_x[2], forceAndTorque.forceArrow.arrowLine.e_x[3]})[2];
//   protected Real forceAndTorque.forceArrow.arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.forceArrow.arrowLine.e_x[1], forceAndTorque.forceArrow.arrowLine.e_x[2], forceAndTorque.forceArrow.arrowLine.e_x[3]}, if noEvent(forceAndTorque.forceArrow.arrowLine.n_z_aux[1] ^ 2.0 + forceAndTorque.forceArrow.arrowLine.n_z_aux[2] ^ 2.0 + forceAndTorque.forceArrow.arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.forceArrow.arrowLine.widthDirection[1], forceAndTorque.forceArrow.arrowLine.widthDirection[2], forceAndTorque.forceArrow.arrowLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.forceArrow.arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.forceArrow.arrowLine.e_x[1], forceAndTorque.forceArrow.arrowLine.e_x[2], forceAndTorque.forceArrow.arrowLine.e_x[3]})[3];
//   protected output Real forceAndTorque.forceArrow.arrowLine.Form;
//   output Real forceAndTorque.forceArrow.arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real forceAndTorque.forceArrow.arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.forceArrow.arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.forceArrow.arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.forceArrow.arrowLine.Material;
//   protected output Real forceAndTorque.forceArrow.arrowLine.Extra;
//   parameter String forceAndTorque.forceArrow.arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[1,1] = forceAndTorque.forceArrow.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[1,2] = forceAndTorque.forceArrow.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[1,3] = forceAndTorque.forceArrow.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[2,1] = forceAndTorque.forceArrow.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[2,2] = forceAndTorque.forceArrow.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[2,3] = forceAndTorque.forceArrow.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[3,1] = forceAndTorque.forceArrow.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[3,2] = forceAndTorque.forceArrow.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.T[3,3] = forceAndTorque.forceArrow.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.forceArrow.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.forceArrow.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.forceArrow.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.arrowLine.rvisobj[1] + forceAndTorque.forceArrow.arrowLine.rxvisobj[1] * forceAndTorque.forceArrow.arrowLine.length \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.arrowLine.rvisobj[2] + forceAndTorque.forceArrow.arrowLine.rxvisobj[2] * forceAndTorque.forceArrow.arrowLine.length \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.forceArrow.arrowLine.rvisobj[3] + forceAndTorque.forceArrow.arrowLine.rxvisobj[3] * forceAndTorque.forceArrow.arrowLine.length \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.lengthDirection[1](unit = \"1\") = forceAndTorque.forceArrow.r_head[1] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.lengthDirection[2](unit = \"1\") = forceAndTorque.forceArrow.r_head[2] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.lengthDirection[3](unit = \"1\") = forceAndTorque.forceArrow.r_head[3] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.forceArrow.arrowHead.length(quantity = \"Length\", unit = \"m\") = max(0.0, min(forceAndTorque.forceArrow.length, 4.0 * forceAndTorque.forceArrow.diameter)) \"Length of visual object\";
//   input Real forceAndTorque.forceArrow.arrowHead.width(quantity = \"Length\", unit = \"m\") = max(0.0, 3.0 * forceAndTorque.forceArrow.diameter) \"Width of visual object\";
//   input Real forceAndTorque.forceArrow.arrowHead.height(quantity = \"Length\", unit = \"m\") = max(0.0, 3.0 * forceAndTorque.forceArrow.diameter) \"Height of visual object\";
//   input Real forceAndTorque.forceArrow.arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real forceAndTorque.forceArrow.arrowHead.color[1] = Real(forceAndTorque.forceArrow.color[1]) \"Color of shape\";
//   input Real forceAndTorque.forceArrow.arrowHead.color[2] = Real(forceAndTorque.forceArrow.color[2]) \"Color of shape\";
//   input Real forceAndTorque.forceArrow.arrowHead.color[3] = Real(forceAndTorque.forceArrow.color[3]) \"Color of shape\";
//   input Real forceAndTorque.forceArrow.arrowHead.specularCoefficient = forceAndTorque.forceArrow.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.forceArrow.arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({forceAndTorque.forceArrow.arrowHead.lengthDirection[1], forceAndTorque.forceArrow.arrowHead.lengthDirection[2], forceAndTorque.forceArrow.arrowHead.lengthDirection[3]});
//   protected Real forceAndTorque.forceArrow.arrowHead.e_x[1](unit = \"1\") = if noEvent(forceAndTorque.forceArrow.arrowHead.abs_n_x < 0.0000000001) then 1.0 else forceAndTorque.forceArrow.arrowHead.lengthDirection[1] / forceAndTorque.forceArrow.arrowHead.abs_n_x;
//   protected Real forceAndTorque.forceArrow.arrowHead.e_x[2](unit = \"1\") = if noEvent(forceAndTorque.forceArrow.arrowHead.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.forceArrow.arrowHead.lengthDirection[2] / forceAndTorque.forceArrow.arrowHead.abs_n_x;
//   protected Real forceAndTorque.forceArrow.arrowHead.e_x[3](unit = \"1\") = if noEvent(forceAndTorque.forceArrow.arrowHead.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.forceArrow.arrowHead.lengthDirection[3] / forceAndTorque.forceArrow.arrowHead.abs_n_x;
//   protected Real forceAndTorque.forceArrow.arrowHead.n_z_aux[1](unit = \"1\") = forceAndTorque.forceArrow.arrowHead.e_x[2] * forceAndTorque.forceArrow.arrowHead.widthDirection[3] - forceAndTorque.forceArrow.arrowHead.e_x[3] * forceAndTorque.forceArrow.arrowHead.widthDirection[2];
//   protected Real forceAndTorque.forceArrow.arrowHead.n_z_aux[2](unit = \"1\") = forceAndTorque.forceArrow.arrowHead.e_x[3] * forceAndTorque.forceArrow.arrowHead.widthDirection[1] - forceAndTorque.forceArrow.arrowHead.e_x[1] * forceAndTorque.forceArrow.arrowHead.widthDirection[3];
//   protected Real forceAndTorque.forceArrow.arrowHead.n_z_aux[3](unit = \"1\") = forceAndTorque.forceArrow.arrowHead.e_x[1] * forceAndTorque.forceArrow.arrowHead.widthDirection[2] - forceAndTorque.forceArrow.arrowHead.e_x[2] * forceAndTorque.forceArrow.arrowHead.widthDirection[1];
//   protected Real forceAndTorque.forceArrow.arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.forceArrow.arrowHead.e_x[1], forceAndTorque.forceArrow.arrowHead.e_x[2], forceAndTorque.forceArrow.arrowHead.e_x[3]}, if noEvent(forceAndTorque.forceArrow.arrowHead.n_z_aux[1] ^ 2.0 + forceAndTorque.forceArrow.arrowHead.n_z_aux[2] ^ 2.0 + forceAndTorque.forceArrow.arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.forceArrow.arrowHead.widthDirection[1], forceAndTorque.forceArrow.arrowHead.widthDirection[2], forceAndTorque.forceArrow.arrowHead.widthDirection[3]} else if noEvent(abs(forceAndTorque.forceArrow.arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.forceArrow.arrowHead.e_x[1], forceAndTorque.forceArrow.arrowHead.e_x[2], forceAndTorque.forceArrow.arrowHead.e_x[3]})[1];
//   protected Real forceAndTorque.forceArrow.arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.forceArrow.arrowHead.e_x[1], forceAndTorque.forceArrow.arrowHead.e_x[2], forceAndTorque.forceArrow.arrowHead.e_x[3]}, if noEvent(forceAndTorque.forceArrow.arrowHead.n_z_aux[1] ^ 2.0 + forceAndTorque.forceArrow.arrowHead.n_z_aux[2] ^ 2.0 + forceAndTorque.forceArrow.arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.forceArrow.arrowHead.widthDirection[1], forceAndTorque.forceArrow.arrowHead.widthDirection[2], forceAndTorque.forceArrow.arrowHead.widthDirection[3]} else if noEvent(abs(forceAndTorque.forceArrow.arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.forceArrow.arrowHead.e_x[1], forceAndTorque.forceArrow.arrowHead.e_x[2], forceAndTorque.forceArrow.arrowHead.e_x[3]})[2];
//   protected Real forceAndTorque.forceArrow.arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.forceArrow.arrowHead.e_x[1], forceAndTorque.forceArrow.arrowHead.e_x[2], forceAndTorque.forceArrow.arrowHead.e_x[3]}, if noEvent(forceAndTorque.forceArrow.arrowHead.n_z_aux[1] ^ 2.0 + forceAndTorque.forceArrow.arrowHead.n_z_aux[2] ^ 2.0 + forceAndTorque.forceArrow.arrowHead.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.forceArrow.arrowHead.widthDirection[1], forceAndTorque.forceArrow.arrowHead.widthDirection[2], forceAndTorque.forceArrow.arrowHead.widthDirection[3]} else if noEvent(abs(forceAndTorque.forceArrow.arrowHead.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.forceArrow.arrowHead.e_x[1], forceAndTorque.forceArrow.arrowHead.e_x[2], forceAndTorque.forceArrow.arrowHead.e_x[3]})[3];
//   protected output Real forceAndTorque.forceArrow.arrowHead.Form;
//   output Real forceAndTorque.forceArrow.arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.forceArrow.arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real forceAndTorque.forceArrow.arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.forceArrow.arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.forceArrow.arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.forceArrow.arrowHead.Material;
//   protected output Real forceAndTorque.forceArrow.arrowHead.Extra;
//   input Real forceAndTorque.torqueArrow.R.T[1,1] = forceAndTorque.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[1,2] = forceAndTorque.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[1,3] = forceAndTorque.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[2,1] = forceAndTorque.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[2,2] = forceAndTorque.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[2,3] = forceAndTorque.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[3,1] = forceAndTorque.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[3,2] = forceAndTorque.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.T[3,3] = forceAndTorque.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.frame_b.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.frame_b.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.frame_b.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.r_0[1] \"Position vector from origin of world frame to origin of arrow frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.r_0[2] \"Position vector from origin of world frame to origin of arrow frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_b.r_0[3] \"Position vector from origin of world frame to origin of arrow frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.r_tail[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.t_in_m[1] \"Position vector from origin of arrow frame to double arrow tail, resolved in arrow frame\";
//   input Real forceAndTorque.torqueArrow.r_tail[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.t_in_m[2] \"Position vector from origin of arrow frame to double arrow tail, resolved in arrow frame\";
//   input Real forceAndTorque.torqueArrow.r_tail[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.t_in_m[3] \"Position vector from origin of arrow frame to double arrow tail, resolved in arrow frame\";
//   input Real forceAndTorque.torqueArrow.r_head[1](quantity = \"Length\", unit = \"m\") = -forceAndTorque.t_in_m[1] \"Position vector from double arrow tail to the head of the double arrow, resolved in arrow frame\";
//   input Real forceAndTorque.torqueArrow.r_head[2](quantity = \"Length\", unit = \"m\") = -forceAndTorque.t_in_m[2] \"Position vector from double arrow tail to the head of the double arrow, resolved in arrow frame\";
//   input Real forceAndTorque.torqueArrow.r_head[3](quantity = \"Length\", unit = \"m\") = -forceAndTorque.t_in_m[3] \"Position vector from double arrow tail to the head of the double arrow, resolved in arrow frame\";
//   input Real forceAndTorque.torqueArrow.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = forceAndTorque.torqueDiameter \"Diameter of arrow line\";
//   input Integer forceAndTorque.torqueArrow.color[1](min = 0, max = 255) = forceAndTorque.torqueColor[1] \"Color of double arrow\";
//   input Integer forceAndTorque.torqueArrow.color[2](min = 0, max = 255) = forceAndTorque.torqueColor[2] \"Color of double arrow\";
//   input Integer forceAndTorque.torqueArrow.color[3](min = 0, max = 255) = forceAndTorque.torqueColor[3] \"Color of double arrow\";
//   input Real forceAndTorque.torqueArrow.specularCoefficient = forceAndTorque.specularCoefficient \"Material property describing the reflecting of ambient light (= 0 means, that light is completely absorbed)\";
//   protected Real forceAndTorque.torqueArrow.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({forceAndTorque.torqueArrow.r_head[1], forceAndTorque.torqueArrow.r_head[2], forceAndTorque.torqueArrow.r_head[3]}) \"Length of arrow\";
//   protected Real forceAndTorque.torqueArrow.headLength(quantity = \"Length\", unit = \"m\") = max(0.0, min(forceAndTorque.torqueArrow.length, 4.0 * forceAndTorque.torqueArrow.diameter));
//   protected Real forceAndTorque.torqueArrow.headWidth(quantity = \"Length\", unit = \"m\") = max(0.0, 3.0 * forceAndTorque.torqueArrow.diameter);
//   parameter String forceAndTorque.torqueArrow.arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[1,1] = forceAndTorque.torqueArrow.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[1,2] = forceAndTorque.torqueArrow.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[1,3] = forceAndTorque.torqueArrow.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[2,1] = forceAndTorque.torqueArrow.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[2,2] = forceAndTorque.torqueArrow.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[2,3] = forceAndTorque.torqueArrow.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[3,1] = forceAndTorque.torqueArrow.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[3,2] = forceAndTorque.torqueArrow.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.T[3,3] = forceAndTorque.torqueArrow.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.r[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.r[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.r[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.r_tail[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.r_tail[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.r_tail[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.lengthDirection[1](unit = \"1\") = forceAndTorque.torqueArrow.r_head[1] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.lengthDirection[2](unit = \"1\") = forceAndTorque.torqueArrow.r_head[2] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.lengthDirection[3](unit = \"1\") = forceAndTorque.torqueArrow.r_head[3] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowLine.length(quantity = \"Length\", unit = \"m\") = max(0.0, forceAndTorque.torqueArrow.length + -6.0 * forceAndTorque.torqueArrow.diameter) \"Length of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowLine.width(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.diameter \"Width of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowLine.height(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.diameter \"Height of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real forceAndTorque.torqueArrow.arrowLine.color[1] = Real(forceAndTorque.torqueArrow.color[1]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowLine.color[2] = Real(forceAndTorque.torqueArrow.color[2]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowLine.color[3] = Real(forceAndTorque.torqueArrow.color[3]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowLine.specularCoefficient = forceAndTorque.torqueArrow.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.torqueArrow.arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({forceAndTorque.torqueArrow.arrowLine.lengthDirection[1], forceAndTorque.torqueArrow.arrowLine.lengthDirection[2], forceAndTorque.torqueArrow.arrowLine.lengthDirection[3]});
//   protected Real forceAndTorque.torqueArrow.arrowLine.e_x[1](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowLine.abs_n_x < 0.0000000001) then 1.0 else forceAndTorque.torqueArrow.arrowLine.lengthDirection[1] / forceAndTorque.torqueArrow.arrowLine.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowLine.e_x[2](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowLine.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.torqueArrow.arrowLine.lengthDirection[2] / forceAndTorque.torqueArrow.arrowLine.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowLine.e_x[3](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowLine.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.torqueArrow.arrowLine.lengthDirection[3] / forceAndTorque.torqueArrow.arrowLine.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowLine.n_z_aux[1](unit = \"1\") = forceAndTorque.torqueArrow.arrowLine.e_x[2] * forceAndTorque.torqueArrow.arrowLine.widthDirection[3] - forceAndTorque.torqueArrow.arrowLine.e_x[3] * forceAndTorque.torqueArrow.arrowLine.widthDirection[2];
//   protected Real forceAndTorque.torqueArrow.arrowLine.n_z_aux[2](unit = \"1\") = forceAndTorque.torqueArrow.arrowLine.e_x[3] * forceAndTorque.torqueArrow.arrowLine.widthDirection[1] - forceAndTorque.torqueArrow.arrowLine.e_x[1] * forceAndTorque.torqueArrow.arrowLine.widthDirection[3];
//   protected Real forceAndTorque.torqueArrow.arrowLine.n_z_aux[3](unit = \"1\") = forceAndTorque.torqueArrow.arrowLine.e_x[1] * forceAndTorque.torqueArrow.arrowLine.widthDirection[2] - forceAndTorque.torqueArrow.arrowLine.e_x[2] * forceAndTorque.torqueArrow.arrowLine.widthDirection[1];
//   protected Real forceAndTorque.torqueArrow.arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowLine.e_x[1], forceAndTorque.torqueArrow.arrowLine.e_x[2], forceAndTorque.torqueArrow.arrowLine.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowLine.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowLine.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowLine.widthDirection[1], forceAndTorque.torqueArrow.arrowLine.widthDirection[2], forceAndTorque.torqueArrow.arrowLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowLine.e_x[1], forceAndTorque.torqueArrow.arrowLine.e_x[2], forceAndTorque.torqueArrow.arrowLine.e_x[3]})[1];
//   protected Real forceAndTorque.torqueArrow.arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowLine.e_x[1], forceAndTorque.torqueArrow.arrowLine.e_x[2], forceAndTorque.torqueArrow.arrowLine.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowLine.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowLine.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowLine.widthDirection[1], forceAndTorque.torqueArrow.arrowLine.widthDirection[2], forceAndTorque.torqueArrow.arrowLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowLine.e_x[1], forceAndTorque.torqueArrow.arrowLine.e_x[2], forceAndTorque.torqueArrow.arrowLine.e_x[3]})[2];
//   protected Real forceAndTorque.torqueArrow.arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowLine.e_x[1], forceAndTorque.torqueArrow.arrowLine.e_x[2], forceAndTorque.torqueArrow.arrowLine.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowLine.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowLine.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowLine.widthDirection[1], forceAndTorque.torqueArrow.arrowLine.widthDirection[2], forceAndTorque.torqueArrow.arrowLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowLine.e_x[1], forceAndTorque.torqueArrow.arrowLine.e_x[2], forceAndTorque.torqueArrow.arrowLine.e_x[3]})[3];
//   protected output Real forceAndTorque.torqueArrow.arrowLine.Form;
//   output Real forceAndTorque.torqueArrow.arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real forceAndTorque.torqueArrow.arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowLine.Material;
//   protected output Real forceAndTorque.torqueArrow.arrowLine.Extra;
//   parameter String forceAndTorque.torqueArrow.arrowHead1.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[1,1] = forceAndTorque.torqueArrow.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[1,2] = forceAndTorque.torqueArrow.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[1,3] = forceAndTorque.torqueArrow.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[2,1] = forceAndTorque.torqueArrow.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[2,2] = forceAndTorque.torqueArrow.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[2,3] = forceAndTorque.torqueArrow.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[3,1] = forceAndTorque.torqueArrow.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[3,2] = forceAndTorque.torqueArrow.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.T[3,3] = forceAndTorque.torqueArrow.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.arrowLine.rvisobj[1] + forceAndTorque.torqueArrow.arrowLine.rxvisobj[1] * forceAndTorque.torqueArrow.arrowLine.length \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.arrowLine.rvisobj[2] + forceAndTorque.torqueArrow.arrowLine.rxvisobj[2] * forceAndTorque.torqueArrow.arrowLine.length \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.arrowLine.rvisobj[3] + forceAndTorque.torqueArrow.arrowLine.rxvisobj[3] * forceAndTorque.torqueArrow.arrowLine.length \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.lengthDirection[1](unit = \"1\") = forceAndTorque.torqueArrow.r_head[1] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.lengthDirection[2](unit = \"1\") = forceAndTorque.torqueArrow.r_head[2] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.lengthDirection[3](unit = \"1\") = forceAndTorque.torqueArrow.r_head[3] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.length(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.headLength \"Length of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.width(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.headWidth \"Width of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.height(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.headWidth \"Height of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.color[1] = Real(forceAndTorque.torqueArrow.color[1]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.color[2] = Real(forceAndTorque.torqueArrow.color[2]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.color[3] = Real(forceAndTorque.torqueArrow.color[3]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowHead1.specularCoefficient = forceAndTorque.torqueArrow.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.torqueArrow.arrowHead1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({forceAndTorque.torqueArrow.arrowHead1.lengthDirection[1], forceAndTorque.torqueArrow.arrowHead1.lengthDirection[2], forceAndTorque.torqueArrow.arrowHead1.lengthDirection[3]});
//   protected Real forceAndTorque.torqueArrow.arrowHead1.e_x[1](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowHead1.abs_n_x < 0.0000000001) then 1.0 else forceAndTorque.torqueArrow.arrowHead1.lengthDirection[1] / forceAndTorque.torqueArrow.arrowHead1.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowHead1.e_x[2](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowHead1.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.torqueArrow.arrowHead1.lengthDirection[2] / forceAndTorque.torqueArrow.arrowHead1.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowHead1.e_x[3](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowHead1.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.torqueArrow.arrowHead1.lengthDirection[3] / forceAndTorque.torqueArrow.arrowHead1.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowHead1.n_z_aux[1](unit = \"1\") = forceAndTorque.torqueArrow.arrowHead1.e_x[2] * forceAndTorque.torqueArrow.arrowHead1.widthDirection[3] - forceAndTorque.torqueArrow.arrowHead1.e_x[3] * forceAndTorque.torqueArrow.arrowHead1.widthDirection[2];
//   protected Real forceAndTorque.torqueArrow.arrowHead1.n_z_aux[2](unit = \"1\") = forceAndTorque.torqueArrow.arrowHead1.e_x[3] * forceAndTorque.torqueArrow.arrowHead1.widthDirection[1] - forceAndTorque.torqueArrow.arrowHead1.e_x[1] * forceAndTorque.torqueArrow.arrowHead1.widthDirection[3];
//   protected Real forceAndTorque.torqueArrow.arrowHead1.n_z_aux[3](unit = \"1\") = forceAndTorque.torqueArrow.arrowHead1.e_x[1] * forceAndTorque.torqueArrow.arrowHead1.widthDirection[2] - forceAndTorque.torqueArrow.arrowHead1.e_x[2] * forceAndTorque.torqueArrow.arrowHead1.widthDirection[1];
//   protected Real forceAndTorque.torqueArrow.arrowHead1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowHead1.e_x[1], forceAndTorque.torqueArrow.arrowHead1.e_x[2], forceAndTorque.torqueArrow.arrowHead1.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowHead1.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead1.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead1.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowHead1.widthDirection[1], forceAndTorque.torqueArrow.arrowHead1.widthDirection[2], forceAndTorque.torqueArrow.arrowHead1.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowHead1.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowHead1.e_x[1], forceAndTorque.torqueArrow.arrowHead1.e_x[2], forceAndTorque.torqueArrow.arrowHead1.e_x[3]})[1];
//   protected Real forceAndTorque.torqueArrow.arrowHead1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowHead1.e_x[1], forceAndTorque.torqueArrow.arrowHead1.e_x[2], forceAndTorque.torqueArrow.arrowHead1.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowHead1.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead1.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead1.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowHead1.widthDirection[1], forceAndTorque.torqueArrow.arrowHead1.widthDirection[2], forceAndTorque.torqueArrow.arrowHead1.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowHead1.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowHead1.e_x[1], forceAndTorque.torqueArrow.arrowHead1.e_x[2], forceAndTorque.torqueArrow.arrowHead1.e_x[3]})[2];
//   protected Real forceAndTorque.torqueArrow.arrowHead1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowHead1.e_x[1], forceAndTorque.torqueArrow.arrowHead1.e_x[2], forceAndTorque.torqueArrow.arrowHead1.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowHead1.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead1.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead1.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowHead1.widthDirection[1], forceAndTorque.torqueArrow.arrowHead1.widthDirection[2], forceAndTorque.torqueArrow.arrowHead1.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowHead1.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowHead1.e_x[1], forceAndTorque.torqueArrow.arrowHead1.e_x[2], forceAndTorque.torqueArrow.arrowHead1.e_x[3]})[3];
//   protected output Real forceAndTorque.torqueArrow.arrowHead1.Form;
//   output Real forceAndTorque.torqueArrow.arrowHead1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead1.Material;
//   protected output Real forceAndTorque.torqueArrow.arrowHead1.Extra;
//   parameter String forceAndTorque.torqueArrow.arrowHead2.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[1,1] = forceAndTorque.torqueArrow.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[1,2] = forceAndTorque.torqueArrow.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[1,3] = forceAndTorque.torqueArrow.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[2,1] = forceAndTorque.torqueArrow.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[2,2] = forceAndTorque.torqueArrow.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[2,3] = forceAndTorque.torqueArrow.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[3,1] = forceAndTorque.torqueArrow.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[3,2] = forceAndTorque.torqueArrow.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.T[3,3] = forceAndTorque.torqueArrow.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = forceAndTorque.torqueArrow.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.arrowLine.rvisobj[1] + forceAndTorque.torqueArrow.arrowLine.rxvisobj[1] * (forceAndTorque.torqueArrow.arrowLine.length + 0.5 * forceAndTorque.torqueArrow.arrowHead1.length) \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.arrowLine.rvisobj[2] + forceAndTorque.torqueArrow.arrowLine.rxvisobj[2] * (forceAndTorque.torqueArrow.arrowLine.length + 0.5 * forceAndTorque.torqueArrow.arrowHead1.length) \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.arrowLine.rvisobj[3] + forceAndTorque.torqueArrow.arrowLine.rxvisobj[3] * (forceAndTorque.torqueArrow.arrowLine.length + 0.5 * forceAndTorque.torqueArrow.arrowHead1.length) \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.lengthDirection[1](unit = \"1\") = forceAndTorque.torqueArrow.r_head[1] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.lengthDirection[2](unit = \"1\") = forceAndTorque.torqueArrow.r_head[2] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.lengthDirection[3](unit = \"1\") = forceAndTorque.torqueArrow.r_head[3] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.length(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.headLength \"Length of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.width(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.headWidth \"Width of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.height(quantity = \"Length\", unit = \"m\") = forceAndTorque.torqueArrow.headWidth \"Height of visual object\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.color[1] = Real(forceAndTorque.torqueArrow.color[1]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.color[2] = Real(forceAndTorque.torqueArrow.color[2]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.color[3] = Real(forceAndTorque.torqueArrow.color[3]) \"Color of shape\";
//   input Real forceAndTorque.torqueArrow.arrowHead2.specularCoefficient = forceAndTorque.torqueArrow.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.torqueArrow.arrowHead2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({forceAndTorque.torqueArrow.arrowHead2.lengthDirection[1], forceAndTorque.torqueArrow.arrowHead2.lengthDirection[2], forceAndTorque.torqueArrow.arrowHead2.lengthDirection[3]});
//   protected Real forceAndTorque.torqueArrow.arrowHead2.e_x[1](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowHead2.abs_n_x < 0.0000000001) then 1.0 else forceAndTorque.torqueArrow.arrowHead2.lengthDirection[1] / forceAndTorque.torqueArrow.arrowHead2.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowHead2.e_x[2](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowHead2.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.torqueArrow.arrowHead2.lengthDirection[2] / forceAndTorque.torqueArrow.arrowHead2.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowHead2.e_x[3](unit = \"1\") = if noEvent(forceAndTorque.torqueArrow.arrowHead2.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.torqueArrow.arrowHead2.lengthDirection[3] / forceAndTorque.torqueArrow.arrowHead2.abs_n_x;
//   protected Real forceAndTorque.torqueArrow.arrowHead2.n_z_aux[1](unit = \"1\") = forceAndTorque.torqueArrow.arrowHead2.e_x[2] * forceAndTorque.torqueArrow.arrowHead2.widthDirection[3] - forceAndTorque.torqueArrow.arrowHead2.e_x[3] * forceAndTorque.torqueArrow.arrowHead2.widthDirection[2];
//   protected Real forceAndTorque.torqueArrow.arrowHead2.n_z_aux[2](unit = \"1\") = forceAndTorque.torqueArrow.arrowHead2.e_x[3] * forceAndTorque.torqueArrow.arrowHead2.widthDirection[1] - forceAndTorque.torqueArrow.arrowHead2.e_x[1] * forceAndTorque.torqueArrow.arrowHead2.widthDirection[3];
//   protected Real forceAndTorque.torqueArrow.arrowHead2.n_z_aux[3](unit = \"1\") = forceAndTorque.torqueArrow.arrowHead2.e_x[1] * forceAndTorque.torqueArrow.arrowHead2.widthDirection[2] - forceAndTorque.torqueArrow.arrowHead2.e_x[2] * forceAndTorque.torqueArrow.arrowHead2.widthDirection[1];
//   protected Real forceAndTorque.torqueArrow.arrowHead2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowHead2.e_x[1], forceAndTorque.torqueArrow.arrowHead2.e_x[2], forceAndTorque.torqueArrow.arrowHead2.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowHead2.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead2.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead2.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowHead2.widthDirection[1], forceAndTorque.torqueArrow.arrowHead2.widthDirection[2], forceAndTorque.torqueArrow.arrowHead2.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowHead2.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowHead2.e_x[1], forceAndTorque.torqueArrow.arrowHead2.e_x[2], forceAndTorque.torqueArrow.arrowHead2.e_x[3]})[1];
//   protected Real forceAndTorque.torqueArrow.arrowHead2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowHead2.e_x[1], forceAndTorque.torqueArrow.arrowHead2.e_x[2], forceAndTorque.torqueArrow.arrowHead2.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowHead2.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead2.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead2.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowHead2.widthDirection[1], forceAndTorque.torqueArrow.arrowHead2.widthDirection[2], forceAndTorque.torqueArrow.arrowHead2.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowHead2.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowHead2.e_x[1], forceAndTorque.torqueArrow.arrowHead2.e_x[2], forceAndTorque.torqueArrow.arrowHead2.e_x[3]})[2];
//   protected Real forceAndTorque.torqueArrow.arrowHead2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.torqueArrow.arrowHead2.e_x[1], forceAndTorque.torqueArrow.arrowHead2.e_x[2], forceAndTorque.torqueArrow.arrowHead2.e_x[3]}, if noEvent(forceAndTorque.torqueArrow.arrowHead2.n_z_aux[1] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead2.n_z_aux[2] ^ 2.0 + forceAndTorque.torqueArrow.arrowHead2.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.torqueArrow.arrowHead2.widthDirection[1], forceAndTorque.torqueArrow.arrowHead2.widthDirection[2], forceAndTorque.torqueArrow.arrowHead2.widthDirection[3]} else if noEvent(abs(forceAndTorque.torqueArrow.arrowHead2.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.torqueArrow.arrowHead2.e_x[1], forceAndTorque.torqueArrow.arrowHead2.e_x[2], forceAndTorque.torqueArrow.arrowHead2.e_x[3]})[3];
//   protected output Real forceAndTorque.torqueArrow.arrowHead2.Form;
//   output Real forceAndTorque.torqueArrow.arrowHead2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.torqueArrow.arrowHead2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.torqueArrow.arrowHead2.Material;
//   protected output Real forceAndTorque.torqueArrow.arrowHead2.Extra;
//   parameter String forceAndTorque.connectionLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real forceAndTorque.connectionLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real forceAndTorque.connectionLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.connectionLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.connectionLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real forceAndTorque.connectionLine.r[1](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.connectionLine.r[2](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.connectionLine.r[3](quantity = \"Length\", unit = \"m\") = forceAndTorque.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real forceAndTorque.connectionLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.lengthDirection[1](unit = \"1\") = forceAndTorque.basicForce.r_0[1] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.lengthDirection[2](unit = \"1\") = forceAndTorque.basicForce.r_0[2] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.lengthDirection[3](unit = \"1\") = forceAndTorque.basicForce.r_0[3] \"Vector in length direction, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real forceAndTorque.connectionLine.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({forceAndTorque.basicForce.r_0[1], forceAndTorque.basicForce.r_0[2], forceAndTorque.basicForce.r_0[3]}) \"Length of visual object\";
//   input Real forceAndTorque.connectionLine.width(quantity = \"Length\", unit = \"m\") = forceAndTorque.connectionLineDiameter \"Width of visual object\";
//   input Real forceAndTorque.connectionLine.height(quantity = \"Length\", unit = \"m\") = forceAndTorque.connectionLineDiameter \"Height of visual object\";
//   input Real forceAndTorque.connectionLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real forceAndTorque.connectionLine.color[1] = Real(forceAndTorque.connectionLineColor[1]) \"Color of shape\";
//   input Real forceAndTorque.connectionLine.color[2] = Real(forceAndTorque.connectionLineColor[2]) \"Color of shape\";
//   input Real forceAndTorque.connectionLine.color[3] = Real(forceAndTorque.connectionLineColor[3]) \"Color of shape\";
//   input Real forceAndTorque.connectionLine.specularCoefficient = forceAndTorque.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real forceAndTorque.connectionLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({forceAndTorque.connectionLine.lengthDirection[1], forceAndTorque.connectionLine.lengthDirection[2], forceAndTorque.connectionLine.lengthDirection[3]});
//   protected Real forceAndTorque.connectionLine.e_x[1](unit = \"1\") = if noEvent(forceAndTorque.connectionLine.abs_n_x < 0.0000000001) then 1.0 else forceAndTorque.connectionLine.lengthDirection[1] / forceAndTorque.connectionLine.abs_n_x;
//   protected Real forceAndTorque.connectionLine.e_x[2](unit = \"1\") = if noEvent(forceAndTorque.connectionLine.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.connectionLine.lengthDirection[2] / forceAndTorque.connectionLine.abs_n_x;
//   protected Real forceAndTorque.connectionLine.e_x[3](unit = \"1\") = if noEvent(forceAndTorque.connectionLine.abs_n_x < 0.0000000001) then 0.0 else forceAndTorque.connectionLine.lengthDirection[3] / forceAndTorque.connectionLine.abs_n_x;
//   protected Real forceAndTorque.connectionLine.n_z_aux[1](unit = \"1\") = forceAndTorque.connectionLine.e_x[2] * forceAndTorque.connectionLine.widthDirection[3] - forceAndTorque.connectionLine.e_x[3] * forceAndTorque.connectionLine.widthDirection[2];
//   protected Real forceAndTorque.connectionLine.n_z_aux[2](unit = \"1\") = forceAndTorque.connectionLine.e_x[3] * forceAndTorque.connectionLine.widthDirection[1] - forceAndTorque.connectionLine.e_x[1] * forceAndTorque.connectionLine.widthDirection[3];
//   protected Real forceAndTorque.connectionLine.n_z_aux[3](unit = \"1\") = forceAndTorque.connectionLine.e_x[1] * forceAndTorque.connectionLine.widthDirection[2] - forceAndTorque.connectionLine.e_x[2] * forceAndTorque.connectionLine.widthDirection[1];
//   protected Real forceAndTorque.connectionLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.connectionLine.e_x[1], forceAndTorque.connectionLine.e_x[2], forceAndTorque.connectionLine.e_x[3]}, if noEvent(forceAndTorque.connectionLine.n_z_aux[1] ^ 2.0 + forceAndTorque.connectionLine.n_z_aux[2] ^ 2.0 + forceAndTorque.connectionLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.connectionLine.widthDirection[1], forceAndTorque.connectionLine.widthDirection[2], forceAndTorque.connectionLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.connectionLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.connectionLine.e_x[1], forceAndTorque.connectionLine.e_x[2], forceAndTorque.connectionLine.e_x[3]})[1];
//   protected Real forceAndTorque.connectionLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.connectionLine.e_x[1], forceAndTorque.connectionLine.e_x[2], forceAndTorque.connectionLine.e_x[3]}, if noEvent(forceAndTorque.connectionLine.n_z_aux[1] ^ 2.0 + forceAndTorque.connectionLine.n_z_aux[2] ^ 2.0 + forceAndTorque.connectionLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.connectionLine.widthDirection[1], forceAndTorque.connectionLine.widthDirection[2], forceAndTorque.connectionLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.connectionLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.connectionLine.e_x[1], forceAndTorque.connectionLine.e_x[2], forceAndTorque.connectionLine.e_x[3]})[2];
//   protected Real forceAndTorque.connectionLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({forceAndTorque.connectionLine.e_x[1], forceAndTorque.connectionLine.e_x[2], forceAndTorque.connectionLine.e_x[3]}, if noEvent(forceAndTorque.connectionLine.n_z_aux[1] ^ 2.0 + forceAndTorque.connectionLine.n_z_aux[2] ^ 2.0 + forceAndTorque.connectionLine.n_z_aux[3] ^ 2.0 > 0.000001) then {forceAndTorque.connectionLine.widthDirection[1], forceAndTorque.connectionLine.widthDirection[2], forceAndTorque.connectionLine.widthDirection[3]} else if noEvent(abs(forceAndTorque.connectionLine.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {forceAndTorque.connectionLine.e_x[1], forceAndTorque.connectionLine.e_x[2], forceAndTorque.connectionLine.e_x[3]})[3];
//   protected output Real forceAndTorque.connectionLine.Form;
//   output Real forceAndTorque.connectionLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real forceAndTorque.connectionLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real forceAndTorque.connectionLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.connectionLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.connectionLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real forceAndTorque.connectionLine.Material;
//   protected output Real forceAndTorque.connectionLine.Extra;
//   Real revolute2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean revolute2.useAxisFlange = false \"= true, if axis flange is enabled\";
//   parameter Boolean revolute2.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real revolute2.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real revolute2.n[2](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real revolute2.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real revolute2.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real revolute2.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real revolute2.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer revolute2.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer revolute2.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer revolute2.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real revolute2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) revolute2.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real revolute2.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real revolute2.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real revolute2.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real revolute2.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute2.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute2.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real revolute2.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real revolute2.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real revolute2.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean revolute2.constantTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real revolute2.constantTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real revolute2.constantTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real revolute2.constantTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real revolute2.constantTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real revolute2.constantTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real revolute2.constantTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   protected parameter Real revolute2.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({revolute2.n[1], revolute2.n[2], revolute2.n[3]}, 0.0000000000001)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real revolute2.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({revolute2.n[1], revolute2.n[2], revolute2.n[3]}, 0.0000000000001)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real revolute2.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({revolute2.n[1], revolute2.n[2], revolute2.n[3]}, 0.0000000000001)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real revolute2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real revolute2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   input Real revolute2.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = revolute2.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real revolute2.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real revolute2.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real revolute2.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String revolute2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute2.cylinder.R.T[1,1] = revolute2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,2] = revolute2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,3] = revolute2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,1] = revolute2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,2] = revolute2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,3] = revolute2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,1] = revolute2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,2] = revolute2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,3] = revolute2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = revolute2.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = revolute2.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = revolute2.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = (-revolute2.e[1]) * revolute2.cylinderLength / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-revolute2.e[2]) * revolute2.cylinderLength / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = (-revolute2.e[3]) * revolute2.cylinderLength / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[1](unit = \"1\") = revolute2.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[2](unit = \"1\") = revolute2.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[3](unit = \"1\") = revolute2.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.length(quantity = \"Length\", unit = \"m\") = revolute2.cylinderLength \"Length of visual object\";
//   input Real revolute2.cylinder.width(quantity = \"Length\", unit = \"m\") = revolute2.cylinderDiameter \"Width of visual object\";
//   input Real revolute2.cylinder.height(quantity = \"Length\", unit = \"m\") = revolute2.cylinderDiameter \"Height of visual object\";
//   input Real revolute2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute2.cylinder.color[1] = Real(revolute2.cylinderColor[1]) \"Color of shape\";
//   input Real revolute2.cylinder.color[2] = Real(revolute2.cylinderColor[2]) \"Color of shape\";
//   input Real revolute2.cylinder.color[3] = Real(revolute2.cylinderColor[3]) \"Color of shape\";
//   input Real revolute2.cylinder.specularCoefficient = revolute2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute2.cylinder.lengthDirection[1], revolute2.cylinder.lengthDirection[2], revolute2.cylinder.lengthDirection[3]});
//   protected Real revolute2.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute2.cylinder.lengthDirection[1] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute2.cylinder.lengthDirection[2] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute2.cylinder.lengthDirection[3] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.n_z_aux[1](unit = \"1\") = revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[3] - revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[2];
//   protected Real revolute2.cylinder.n_z_aux[2](unit = \"1\") = revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[1] - revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[3];
//   protected Real revolute2.cylinder.n_z_aux[3](unit = \"1\") = revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[2] - revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[1];
//   protected Real revolute2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1], revolute2.cylinder.e_x[2], revolute2.cylinder.e_x[3]}, if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0 > 0.000001) then {revolute2.cylinder.widthDirection[1], revolute2.cylinder.widthDirection[2], revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {revolute2.cylinder.e_x[1], revolute2.cylinder.e_x[2], revolute2.cylinder.e_x[3]})[1];
//   protected Real revolute2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1], revolute2.cylinder.e_x[2], revolute2.cylinder.e_x[3]}, if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0 > 0.000001) then {revolute2.cylinder.widthDirection[1], revolute2.cylinder.widthDirection[2], revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {revolute2.cylinder.e_x[1], revolute2.cylinder.e_x[2], revolute2.cylinder.e_x[3]})[2];
//   protected Real revolute2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1], revolute2.cylinder.e_x[2], revolute2.cylinder.e_x[3]}, if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0 > 0.000001) then {revolute2.cylinder.widthDirection[1], revolute2.cylinder.widthDirection[2], revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {revolute2.cylinder.e_x[1], revolute2.cylinder.e_x[2], revolute2.cylinder.e_x[3]})[3];
//   protected output Real revolute2.cylinder.Form;
//   output Real revolute2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.Material;
//   protected output Real revolute2.cylinder.Extra;
//   output Real torque[1].y \"Connector of Real output signal\";
//   parameter Real torque[1].k(start = 1.0) = -100.0 \"Constant output value\";
//   output Real torque[2].y \"Connector of Real output signal\";
//   parameter Real torque[2].k(start = 1.0) = 100.0 \"Constant output value\";
//   output Real torque[3].y \"Connector of Real output signal\";
//   parameter Real torque[3].k(start = 1.0) = 0.0 \"Constant output value\";
//   Real revolute1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real revolute1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real revolute1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real revolute1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean revolute1.useAxisFlange = false \"= true, if axis flange is enabled\";
//   parameter Boolean revolute1.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real revolute1.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real revolute1.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real revolute1.n[3](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real revolute1.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real revolute1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real revolute1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer revolute1.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer revolute1.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer revolute1.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real revolute1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) revolute1.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real revolute1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real revolute1.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real revolute1.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real revolute1.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real revolute1.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real revolute1.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real revolute1.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real revolute1.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real revolute1.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean revolute1.constantTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real revolute1.constantTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real revolute1.constantTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real revolute1.constantTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real revolute1.constantTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real revolute1.constantTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real revolute1.constantTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   protected parameter Real revolute1.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({revolute1.n[1], revolute1.n[2], revolute1.n[3]}, 0.0000000000001)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real revolute1.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({revolute1.n[1], revolute1.n[2], revolute1.n[3]}, 0.0000000000001)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real revolute1.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({revolute1.n[1], revolute1.n[2], revolute1.n[3]}, 0.0000000000001)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real revolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real revolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   input Real revolute1.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = revolute1.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real revolute1.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real revolute1.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real revolute1.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String revolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute1.cylinder.R.T[1,1] = revolute1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,2] = revolute1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,3] = revolute1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,1] = revolute1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,2] = revolute1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,3] = revolute1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,1] = revolute1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,2] = revolute1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,3] = revolute1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = revolute1.frame_a.R.w[1] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = revolute1.frame_a.R.w[2] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = revolute1.frame_a.R.w[3] \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = (-revolute1.e[1]) * revolute1.cylinderLength / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-revolute1.e[2]) * revolute1.cylinderLength / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = (-revolute1.e[3]) * revolute1.cylinderLength / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[1](unit = \"1\") = revolute1.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[2](unit = \"1\") = revolute1.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[3](unit = \"1\") = revolute1.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = revolute1.cylinderLength \"Length of visual object\";
//   input Real revolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = revolute1.cylinderDiameter \"Width of visual object\";
//   input Real revolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = revolute1.cylinderDiameter \"Height of visual object\";
//   input Real revolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute1.cylinder.color[1] = Real(revolute1.cylinderColor[1]) \"Color of shape\";
//   input Real revolute1.cylinder.color[2] = Real(revolute1.cylinderColor[2]) \"Color of shape\";
//   input Real revolute1.cylinder.color[3] = Real(revolute1.cylinderColor[3]) \"Color of shape\";
//   input Real revolute1.cylinder.specularCoefficient = revolute1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1], revolute1.cylinder.lengthDirection[2], revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = \"1\") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = \"1\") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = \"1\") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1], revolute1.cylinder.e_x[2], revolute1.cylinder.e_x[3]}, if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0 > 0.000001) then {revolute1.cylinder.widthDirection[1], revolute1.cylinder.widthDirection[2], revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {revolute1.cylinder.e_x[1], revolute1.cylinder.e_x[2], revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1], revolute1.cylinder.e_x[2], revolute1.cylinder.e_x[3]}, if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0 > 0.000001) then {revolute1.cylinder.widthDirection[1], revolute1.cylinder.widthDirection[2], revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {revolute1.cylinder.e_x[1], revolute1.cylinder.e_x[2], revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1], revolute1.cylinder.e_x[2], revolute1.cylinder.e_x[3]}, if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0 > 0.000001) then {revolute1.cylinder.widthDirection[1], revolute1.cylinder.widthDirection[2], revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {revolute1.cylinder.e_x[1], revolute1.cylinder.e_x[2], revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   Real fixed2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixed2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixed2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real fixed2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real fixed2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixed2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixed2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real fixed2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixed2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixed2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real fixed2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixed2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real fixed2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean fixed2.animation = true \"= true, if animation shall be enabled\";
//   parameter Real fixed2.r[1](quantity = \"Length\", unit = \"m\") = 1.5 \"Position vector from world frame to frame_b, resolved in world frame\";
//   parameter Real fixed2.r[2](quantity = \"Length\", unit = \"m\") = 0.25 \"Position vector from world frame to frame_b, resolved in world frame\";
//   parameter Real fixed2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from world frame to frame_b, resolved in world frame\";
//   parameter String fixed2.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real fixed2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from world frame to shape origin, resolved in world frame\";
//   parameter Real fixed2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from world frame to shape origin, resolved in world frame\";
//   parameter Real fixed2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from world frame to shape origin, resolved in world frame\";
//   parameter Real fixed2.widthDirection[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector in width direction of shape, resolved in world frame\";
//   parameter Real fixed2.widthDirection[2](quantity = \"Length\", unit = \"m\") = 1.0 \" Vector in width direction of shape, resolved in world frame\";
//   parameter Real fixed2.widthDirection[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector in width direction of shape, resolved in world frame\";
//   parameter Real fixed2.extra = 0.0 \" Additional parameter for cone, pipe etc. (see docu of Visualizers.Advanced.Shape)\";
//   input Integer fixed2.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer fixed2.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer fixed2.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real fixed2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real fixed2.lengthDirection[1](quantity = \"Length\", unit = \"m\") = fixed2.r[1] - fixed2.r_shape[1] \" Vector in length direction of shape, resolved in world frame\";
//   parameter Real fixed2.lengthDirection[2](quantity = \"Length\", unit = \"m\") = fixed2.r[2] - fixed2.r_shape[2] \" Vector in length direction of shape, resolved in world frame\";
//   parameter Real fixed2.lengthDirection[3](quantity = \"Length\", unit = \"m\") = fixed2.r[3] - fixed2.r_shape[3] \" Vector in length direction of shape, resolved in world frame\";
//   parameter Real fixed2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({fixed2.r[1] - fixed2.r_shape[1], fixed2.r[2] - fixed2.r_shape[2], fixed2.r[3] - fixed2.r_shape[3]}) \" Length of shape\";
//   parameter Real fixed2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.03 \" Width of shape\";
//   parameter Real fixed2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = fixed2.width \" Height of shape\";
//   parameter String fixed2.shape.shapeType = fixed2.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixed2.shape.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixed2.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixed2.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixed2.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixed2.shape.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixed2.shape.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixed2.shape.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixed2.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = fixed2.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixed2.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = fixed2.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixed2.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = fixed2.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixed2.shape.lengthDirection[1](unit = \"1\") = fixed2.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real fixed2.shape.lengthDirection[2](unit = \"1\") = fixed2.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real fixed2.shape.lengthDirection[3](unit = \"1\") = fixed2.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real fixed2.shape.widthDirection[1](unit = \"1\") = fixed2.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real fixed2.shape.widthDirection[2](unit = \"1\") = fixed2.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real fixed2.shape.widthDirection[3](unit = \"1\") = fixed2.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real fixed2.shape.length(quantity = \"Length\", unit = \"m\") = fixed2.length \"Length of visual object\";
//   input Real fixed2.shape.width(quantity = \"Length\", unit = \"m\") = fixed2.width \"Width of visual object\";
//   input Real fixed2.shape.height(quantity = \"Length\", unit = \"m\") = fixed2.height \"Height of visual object\";
//   input Real fixed2.shape.extra = fixed2.extra \"Additional size data for some of the shape types\";
//   input Real fixed2.shape.color[1] = Real(fixed2.color[1]) \"Color of shape\";
//   input Real fixed2.shape.color[2] = Real(fixed2.color[2]) \"Color of shape\";
//   input Real fixed2.shape.color[3] = Real(fixed2.color[3]) \"Color of shape\";
//   input Real fixed2.shape.specularCoefficient = fixed2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixed2.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixed2.shape.lengthDirection[1], fixed2.shape.lengthDirection[2], fixed2.shape.lengthDirection[3]});
//   protected Real fixed2.shape.e_x[1](unit = \"1\") = if noEvent(fixed2.shape.abs_n_x < 0.0000000001) then 1.0 else fixed2.shape.lengthDirection[1] / fixed2.shape.abs_n_x;
//   protected Real fixed2.shape.e_x[2](unit = \"1\") = if noEvent(fixed2.shape.abs_n_x < 0.0000000001) then 0.0 else fixed2.shape.lengthDirection[2] / fixed2.shape.abs_n_x;
//   protected Real fixed2.shape.e_x[3](unit = \"1\") = if noEvent(fixed2.shape.abs_n_x < 0.0000000001) then 0.0 else fixed2.shape.lengthDirection[3] / fixed2.shape.abs_n_x;
//   protected Real fixed2.shape.n_z_aux[1](unit = \"1\") = fixed2.shape.e_x[2] * fixed2.shape.widthDirection[3] - fixed2.shape.e_x[3] * fixed2.shape.widthDirection[2];
//   protected Real fixed2.shape.n_z_aux[2](unit = \"1\") = fixed2.shape.e_x[3] * fixed2.shape.widthDirection[1] - fixed2.shape.e_x[1] * fixed2.shape.widthDirection[3];
//   protected Real fixed2.shape.n_z_aux[3](unit = \"1\") = fixed2.shape.e_x[1] * fixed2.shape.widthDirection[2] - fixed2.shape.e_x[2] * fixed2.shape.widthDirection[1];
//   protected Real fixed2.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixed2.shape.e_x[1], fixed2.shape.e_x[2], fixed2.shape.e_x[3]}, if noEvent(fixed2.shape.n_z_aux[1] ^ 2.0 + fixed2.shape.n_z_aux[2] ^ 2.0 + fixed2.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixed2.shape.widthDirection[1], fixed2.shape.widthDirection[2], fixed2.shape.widthDirection[3]} else if noEvent(abs(fixed2.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixed2.shape.e_x[1], fixed2.shape.e_x[2], fixed2.shape.e_x[3]})[1];
//   protected Real fixed2.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixed2.shape.e_x[1], fixed2.shape.e_x[2], fixed2.shape.e_x[3]}, if noEvent(fixed2.shape.n_z_aux[1] ^ 2.0 + fixed2.shape.n_z_aux[2] ^ 2.0 + fixed2.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixed2.shape.widthDirection[1], fixed2.shape.widthDirection[2], fixed2.shape.widthDirection[3]} else if noEvent(abs(fixed2.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixed2.shape.e_x[1], fixed2.shape.e_x[2], fixed2.shape.e_x[3]})[2];
//   protected Real fixed2.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixed2.shape.e_x[1], fixed2.shape.e_x[2], fixed2.shape.e_x[3]}, if noEvent(fixed2.shape.n_z_aux[1] ^ 2.0 + fixed2.shape.n_z_aux[2] ^ 2.0 + fixed2.shape.n_z_aux[3] ^ 2.0 > 0.000001) then {fixed2.shape.widthDirection[1], fixed2.shape.widthDirection[2], fixed2.shape.widthDirection[3]} else if noEvent(abs(fixed2.shape.e_x[1]) > 0.000001) then {0.0, 1.0, 0.0} else {1.0, 0.0, 0.0}), 0.0000000000001), {fixed2.shape.e_x[1], fixed2.shape.e_x[2], fixed2.shape.e_x[3]})[3];
//   protected output Real fixed2.shape.Form;
//   output Real fixed2.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixed2.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixed2.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixed2.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixed2.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixed2.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixed2.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixed2.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixed2.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixed2.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixed2.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixed2.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixed2.shape.Material;
//   protected output Real fixed2.shape.Extra;
//   output Real force[1].y \"Connector of Real output signal\";
//   parameter Real force[1].k(start = 1.0) = 0.0 \"Constant output value\";
//   output Real force[2].y \"Connector of Real output signal\";
//   parameter Real force[2].k(start = 1.0) = 1000.0 \"Constant output value\";
//   output Real force[3].y \"Connector of Real output signal\";
//   parameter Real force[3].k(start = 1.0) = 0.0 \"Constant output value\";
// equation
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3];
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3];
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1], world.x_label.cylinders[1].R.T[1,2], world.x_label.cylinders[1].R.T[1,3]}, {world.x_label.cylinders[1].R.T[2,1], world.x_label.cylinders[1].R.T[2,2], world.x_label.cylinders[1].R.T[2,3]}, {world.x_label.cylinders[1].R.T[3,1], world.x_label.cylinders[1].R.T[3,2], world.x_label.cylinders[1].R.T[3,3]}}, {world.x_label.cylinders[1].r_shape[1], world.x_label.cylinders[1].r_shape[2], world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0, world.x_label.cylinders[1].color[2] / 255.0, world.x_label.cylinders[1].color[3] / 255.0, world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3];
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3];
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1], world.x_label.cylinders[2].R.T[1,2], world.x_label.cylinders[2].R.T[1,3]}, {world.x_label.cylinders[2].R.T[2,1], world.x_label.cylinders[2].R.T[2,2], world.x_label.cylinders[2].R.T[2,3]}, {world.x_label.cylinders[2].R.T[3,1], world.x_label.cylinders[2].R.T[3,2], world.x_label.cylinders[2].R.T[3,3]}}, {world.x_label.cylinders[2].r_shape[1], world.x_label.cylinders[2].r_shape[2], world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0, world.x_label.cylinders[2].color[2] / 255.0, world.x_label.cylinders[2].color[3] / 255.0, world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3];
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3];
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1], world.y_label.cylinders[1].R.T[1,2], world.y_label.cylinders[1].R.T[1,3]}, {world.y_label.cylinders[1].R.T[2,1], world.y_label.cylinders[1].R.T[2,2], world.y_label.cylinders[1].R.T[2,3]}, {world.y_label.cylinders[1].R.T[3,1], world.y_label.cylinders[1].R.T[3,2], world.y_label.cylinders[1].R.T[3,3]}}, {world.y_label.cylinders[1].r_shape[1], world.y_label.cylinders[1].r_shape[2], world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0, world.y_label.cylinders[1].color[2] / 255.0, world.y_label.cylinders[1].color[3] / 255.0, world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3];
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3];
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1], world.y_label.cylinders[2].R.T[1,2], world.y_label.cylinders[2].R.T[1,3]}, {world.y_label.cylinders[2].R.T[2,1], world.y_label.cylinders[2].R.T[2,2], world.y_label.cylinders[2].R.T[2,3]}, {world.y_label.cylinders[2].R.T[3,1], world.y_label.cylinders[2].R.T[3,2], world.y_label.cylinders[2].R.T[3,3]}}, {world.y_label.cylinders[2].r_shape[1], world.y_label.cylinders[2].r_shape[2], world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0, world.y_label.cylinders[2].color[2] / 255.0, world.y_label.cylinders[2].color[3] / 255.0, world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3];
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3];
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1], world.z_label.cylinders[1].R.T[1,2], world.z_label.cylinders[1].R.T[1,3]}, {world.z_label.cylinders[1].R.T[2,1], world.z_label.cylinders[1].R.T[2,2], world.z_label.cylinders[1].R.T[2,3]}, {world.z_label.cylinders[1].R.T[3,1], world.z_label.cylinders[1].R.T[3,2], world.z_label.cylinders[1].R.T[3,3]}}, {world.z_label.cylinders[1].r_shape[1], world.z_label.cylinders[1].r_shape[2], world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0, world.z_label.cylinders[1].color[2] / 255.0, world.z_label.cylinders[1].color[3] / 255.0, world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3];
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3];
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1], world.z_label.cylinders[2].R.T[1,2], world.z_label.cylinders[2].R.T[1,3]}, {world.z_label.cylinders[2].R.T[2,1], world.z_label.cylinders[2].R.T[2,2], world.z_label.cylinders[2].R.T[2,3]}, {world.z_label.cylinders[2].R.T[3,1], world.z_label.cylinders[2].R.T[3,2], world.z_label.cylinders[2].R.T[3,3]}}, {world.z_label.cylinders[2].r_shape[1], world.z_label.cylinders[2].r_shape[2], world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0, world.z_label.cylinders[2].color[2] / 255.0, world.z_label.cylinders[2].color[3] / 255.0, world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3];
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3];
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1], world.z_label.cylinders[3].R.T[1,2], world.z_label.cylinders[3].R.T[1,3]}, {world.z_label.cylinders[3].R.T[2,1], world.z_label.cylinders[3].R.T[2,2], world.z_label.cylinders[3].R.T[2,3]}, {world.z_label.cylinders[3].R.T[3,1], world.z_label.cylinders[3].R.T[3,2], world.z_label.cylinders[3].R.T[3,3]}}, {world.z_label.cylinders[3].r_shape[1], world.z_label.cylinders[3].r_shape[2], world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0, world.z_label.cylinders[3].color[2] / 255.0, world.z_label.cylinders[3].color[3] / 255.0, world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3];
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3];
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1], world.x_arrowLine.R.T[1,2], world.x_arrowLine.R.T[1,3]}, {world.x_arrowLine.R.T[2,1], world.x_arrowLine.R.T[2,2], world.x_arrowLine.R.T[2,3]}, {world.x_arrowLine.R.T[3,1], world.x_arrowLine.R.T[3,2], world.x_arrowLine.R.T[3,3]}}, {world.x_arrowLine.r_shape[1], world.x_arrowLine.r_shape[2], world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0, world.x_arrowLine.color[2] / 255.0, world.x_arrowLine.color[3] / 255.0, world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3];
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3];
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1], world.x_arrowHead.R.T[1,2], world.x_arrowHead.R.T[1,3]}, {world.x_arrowHead.R.T[2,1], world.x_arrowHead.R.T[2,2], world.x_arrowHead.R.T[2,3]}, {world.x_arrowHead.R.T[3,1], world.x_arrowHead.R.T[3,2], world.x_arrowHead.R.T[3,3]}}, {world.x_arrowHead.r_shape[1], world.x_arrowHead.r_shape[2], world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0, world.x_arrowHead.color[2] / 255.0, world.x_arrowHead.color[3] / 255.0, world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3];
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3];
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1], world.y_arrowLine.R.T[1,2], world.y_arrowLine.R.T[1,3]}, {world.y_arrowLine.R.T[2,1], world.y_arrowLine.R.T[2,2], world.y_arrowLine.R.T[2,3]}, {world.y_arrowLine.R.T[3,1], world.y_arrowLine.R.T[3,2], world.y_arrowLine.R.T[3,3]}}, {world.y_arrowLine.r_shape[1], world.y_arrowLine.r_shape[2], world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0, world.y_arrowLine.color[2] / 255.0, world.y_arrowLine.color[3] / 255.0, world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3];
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3];
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1], world.y_arrowHead.R.T[1,2], world.y_arrowHead.R.T[1,3]}, {world.y_arrowHead.R.T[2,1], world.y_arrowHead.R.T[2,2], world.y_arrowHead.R.T[2,3]}, {world.y_arrowHead.R.T[3,1], world.y_arrowHead.R.T[3,2], world.y_arrowHead.R.T[3,3]}}, {world.y_arrowHead.r_shape[1], world.y_arrowHead.r_shape[2], world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0, world.y_arrowHead.color[2] / 255.0, world.y_arrowHead.color[3] / 255.0, world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3];
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3];
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1], world.z_arrowLine.R.T[1,2], world.z_arrowLine.R.T[1,3]}, {world.z_arrowLine.R.T[2,1], world.z_arrowLine.R.T[2,2], world.z_arrowLine.R.T[2,3]}, {world.z_arrowLine.R.T[3,1], world.z_arrowLine.R.T[3,2], world.z_arrowLine.R.T[3,3]}}, {world.z_arrowLine.r_shape[1], world.z_arrowLine.r_shape[2], world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0, world.z_arrowLine.color[2] / 255.0, world.z_arrowLine.color[3] / 255.0, world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3];
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3];
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1], world.z_arrowHead.R.T[1,2], world.z_arrowHead.R.T[1,3]}, {world.z_arrowHead.R.T[2,1], world.z_arrowHead.R.T[2,2], world.z_arrowHead.R.T[2,3]}, {world.z_arrowHead.R.T[3,1], world.z_arrowHead.R.T[3,2], world.z_arrowHead.R.T[3,3]}}, {world.z_arrowHead.r_shape[1], world.z_arrowHead.r_shape[2], world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0, world.z_arrowHead.color[2] / 255.0, world.z_arrowHead.color[3] / 255.0, world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   assert(Modelica.Math.Vectors.length({world.n[1], world.n[2], world.n[3]}) > 0.0000000001,\"Parameter n of World object is wrong (lenght(n) > 0 required)\");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   body.body.r_0[1] = body.body.frame_a.r_0[1];
//   body.body.r_0[2] = body.body.frame_a.r_0[2];
//   body.body.r_0[3] = body.body.frame_a.r_0[3];
//   if true then
//   body.body.Q[1] = 0.0;
//   body.body.Q[2] = 0.0;
//   body.body.Q[3] = 0.0;
//   body.body.Q[4] = 1.0;
//   body.body.phi[1] = 0.0;
//   body.body.phi[2] = 0.0;
//   body.body.phi[3] = 0.0;
//   body.body.phi_d[1] = 0.0;
//   body.body.phi_d[2] = 0.0;
//   body.body.phi_d[3] = 0.0;
//   body.body.phi_dd[1] = 0.0;
//   body.body.phi_dd[2] = 0.0;
//   body.body.phi_dd[3] = 0.0;
//   elseif body.body.useQuaternions then
//   body.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({body.body.Q[1], body.body.Q[2], body.body.Q[3], body.body.Q[4]}, Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({body.body.Q[1], body.body.Q[2], body.body.Q[3], body.body.Q[4]}, {der(body.body.Q[1]), der(body.body.Q[2]), der(body.body.Q[3]), der(body.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({body.body.Q[1], body.body.Q[2], body.body.Q[3], body.body.Q[4]});
//   body.body.phi[1] = 0.0;
//   body.body.phi[2] = 0.0;
//   body.body.phi[3] = 0.0;
//   body.body.phi_d[1] = 0.0;
//   body.body.phi_d[2] = 0.0;
//   body.body.phi_d[3] = 0.0;
//   body.body.phi_dd[1] = 0.0;
//   body.body.phi_dd[2] = 0.0;
//   body.body.phi_dd[3] = 0.0;
//   else
//   body.body.phi_d[1] = der(body.body.phi[1]);
//   body.body.phi_d[2] = der(body.body.phi[2]);
//   body.body.phi_d[3] = der(body.body.phi[3]);
//   body.body.phi_dd[1] = der(body.body.phi_d[1]);
//   body.body.phi_dd[2] = der(body.body.phi_d[2]);
//   body.body.phi_dd[3] = der(body.body.phi_d[3]);
//   body.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({body.body.sequence_angleStates[1], body.body.sequence_angleStates[2], body.body.sequence_angleStates[3]}, {body.body.phi[1], body.body.phi[2], body.body.phi[3]}, {body.body.phi_d[1], body.body.phi_d[2], body.body.phi_d[3]});
//   body.body.Q[1] = 0.0;
//   body.body.Q[2] = 0.0;
//   body.body.Q[3] = 0.0;
//   body.body.Q[4] = 1.0;
//   end if;
//   body.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({body.body.frame_a.r_0[1], body.body.frame_a.r_0[2], body.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(body.body.frame_a.R, {body.body.r_CM[1], body.body.r_CM[2], body.body.r_CM[3]}), world.gravityType, Modelica.Math.Vectors.normalize({world.n[1], world.n[2], world.n[3]}, 0.0000000000001) * world.g, world.mue);
//   body.body.v_0[1] = der(body.body.frame_a.r_0[1]);
//   body.body.v_0[2] = der(body.body.frame_a.r_0[2]);
//   body.body.v_0[3] = der(body.body.frame_a.r_0[3]);
//   body.body.a_0[1] = der(body.body.v_0[1]);
//   body.body.a_0[2] = der(body.body.v_0[2]);
//   body.body.a_0[3] = der(body.body.v_0[3]);
//   body.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(body.body.frame_a.R);
//   body.body.z_a[1] = der(body.body.w_a[1]);
//   body.body.z_a[2] = der(body.body.w_a[2]);
//   body.body.z_a[3] = der(body.body.w_a[3]);
//   body.body.frame_a.f = (Modelica.Mechanics.MultiBody.Frames.resolve2(body.body.frame_a.R, {body.body.a_0[1] - body.body.g_0[1], body.body.a_0[2] - body.body.g_0[2], body.body.a_0[3] - body.body.g_0[3]}) + {body.body.z_a[2] * body.body.r_CM[3] - body.body.z_a[3] * body.body.r_CM[2], body.body.z_a[3] * body.body.r_CM[1] - body.body.z_a[1] * body.body.r_CM[3], body.body.z_a[1] * body.body.r_CM[2] - body.body.z_a[2] * body.body.r_CM[1]} + {body.body.w_a[2] * (body.body.w_a[1] * body.body.r_CM[2] - body.body.w_a[2] * body.body.r_CM[1]) - body.body.w_a[3] * (body.body.w_a[3] * body.body.r_CM[1] - body.body.w_a[1] * body.body.r_CM[3]), body.body.w_a[3] * (body.body.w_a[2] * body.body.r_CM[3] - body.body.w_a[3] * body.body.r_CM[2]) - body.body.w_a[1] * (body.body.w_a[1] * body.body.r_CM[2] - body.body.w_a[2] * body.body.r_CM[1]), body.body.w_a[1] * (body.body.w_a[3] * body.body.r_CM[1] - body.body.w_a[1] * body.body.r_CM[3]) - body.body.w_a[2] * (body.body.w_a[2] * body.body.r_CM[3] - body.body.w_a[3] * body.body.r_CM[2])}) * body.body.m;
//   body.body.frame_a.t[1] = body.body.I[1,1] * body.body.z_a[1] + body.body.I[1,2] * body.body.z_a[2] + body.body.I[1,3] * body.body.z_a[3] + body.body.w_a[2] * (body.body.I[3,1] * body.body.w_a[1] + body.body.I[3,2] * body.body.w_a[2] + body.body.I[3,3] * body.body.w_a[3]) - body.body.w_a[3] * (body.body.I[2,1] * body.body.w_a[1] + body.body.I[2,2] * body.body.w_a[2] + body.body.I[2,3] * body.body.w_a[3]) + body.body.r_CM[2] * body.body.frame_a.f[3] - body.body.r_CM[3] * body.body.frame_a.f[2];
//   body.body.frame_a.t[2] = body.body.I[2,1] * body.body.z_a[1] + body.body.I[2,2] * body.body.z_a[2] + body.body.I[2,3] * body.body.z_a[3] + body.body.w_a[3] * (body.body.I[1,1] * body.body.w_a[1] + body.body.I[1,2] * body.body.w_a[2] + body.body.I[1,3] * body.body.w_a[3]) - body.body.w_a[1] * (body.body.I[3,1] * body.body.w_a[1] + body.body.I[3,2] * body.body.w_a[2] + body.body.I[3,3] * body.body.w_a[3]) + body.body.r_CM[3] * body.body.frame_a.f[1] - body.body.r_CM[1] * body.body.frame_a.f[3];
//   body.body.frame_a.t[3] = body.body.I[3,1] * body.body.z_a[1] + body.body.I[3,2] * body.body.z_a[2] + body.body.I[3,3] * body.body.z_a[3] + body.body.w_a[1] * (body.body.I[2,1] * body.body.w_a[1] + body.body.I[2,2] * body.body.w_a[2] + body.body.I[2,3] * body.body.w_a[3]) - body.body.w_a[2] * (body.body.I[1,1] * body.body.w_a[1] + body.body.I[1,2] * body.body.w_a[2] + body.body.I[1,3] * body.body.w_a[3]) + body.body.r_CM[1] * body.body.frame_a.f[2] - body.body.r_CM[2] * body.body.frame_a.f[1];
//   body.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.frameTranslation.shape.shapeType);
//   body.frameTranslation.shape.rxvisobj[1] = body.frameTranslation.shape.R.T[1,1] * body.frameTranslation.shape.e_x[1] + body.frameTranslation.shape.R.T[2,1] * body.frameTranslation.shape.e_x[2] + body.frameTranslation.shape.R.T[3,1] * body.frameTranslation.shape.e_x[3];
//   body.frameTranslation.shape.rxvisobj[2] = body.frameTranslation.shape.R.T[1,2] * body.frameTranslation.shape.e_x[1] + body.frameTranslation.shape.R.T[2,2] * body.frameTranslation.shape.e_x[2] + body.frameTranslation.shape.R.T[3,2] * body.frameTranslation.shape.e_x[3];
//   body.frameTranslation.shape.rxvisobj[3] = body.frameTranslation.shape.R.T[1,3] * body.frameTranslation.shape.e_x[1] + body.frameTranslation.shape.R.T[2,3] * body.frameTranslation.shape.e_x[2] + body.frameTranslation.shape.R.T[3,3] * body.frameTranslation.shape.e_x[3];
//   body.frameTranslation.shape.ryvisobj[1] = body.frameTranslation.shape.R.T[1,1] * body.frameTranslation.shape.e_y[1] + body.frameTranslation.shape.R.T[2,1] * body.frameTranslation.shape.e_y[2] + body.frameTranslation.shape.R.T[3,1] * body.frameTranslation.shape.e_y[3];
//   body.frameTranslation.shape.ryvisobj[2] = body.frameTranslation.shape.R.T[1,2] * body.frameTranslation.shape.e_y[1] + body.frameTranslation.shape.R.T[2,2] * body.frameTranslation.shape.e_y[2] + body.frameTranslation.shape.R.T[3,2] * body.frameTranslation.shape.e_y[3];
//   body.frameTranslation.shape.ryvisobj[3] = body.frameTranslation.shape.R.T[1,3] * body.frameTranslation.shape.e_y[1] + body.frameTranslation.shape.R.T[2,3] * body.frameTranslation.shape.e_y[2] + body.frameTranslation.shape.R.T[3,3] * body.frameTranslation.shape.e_y[3];
//   body.frameTranslation.shape.rvisobj = body.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.frameTranslation.shape.R.T[1,1], body.frameTranslation.shape.R.T[1,2], body.frameTranslation.shape.R.T[1,3]}, {body.frameTranslation.shape.R.T[2,1], body.frameTranslation.shape.R.T[2,2], body.frameTranslation.shape.R.T[2,3]}, {body.frameTranslation.shape.R.T[3,1], body.frameTranslation.shape.R.T[3,2], body.frameTranslation.shape.R.T[3,3]}}, {body.frameTranslation.shape.r_shape[1], body.frameTranslation.shape.r_shape[2], body.frameTranslation.shape.r_shape[3]});
//   body.frameTranslation.shape.size[1] = body.frameTranslation.shape.length;
//   body.frameTranslation.shape.size[2] = body.frameTranslation.shape.width;
//   body.frameTranslation.shape.size[3] = body.frameTranslation.shape.height;
//   body.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.frameTranslation.shape.color[1] / 255.0, body.frameTranslation.shape.color[2] / 255.0, body.frameTranslation.shape.color[3] / 255.0, body.frameTranslation.shape.specularCoefficient);
//   body.frameTranslation.shape.Extra = body.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   body.frameTranslation.frame_b.r_0 = body.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(body.frameTranslation.frame_a.R, {body.frameTranslation.r[1], body.frameTranslation.r[2], body.frameTranslation.r[3]});
//   body.frameTranslation.frame_b.R.T[1,1] = body.frameTranslation.frame_a.R.T[1,1];
//   body.frameTranslation.frame_b.R.T[1,2] = body.frameTranslation.frame_a.R.T[1,2];
//   body.frameTranslation.frame_b.R.T[1,3] = body.frameTranslation.frame_a.R.T[1,3];
//   body.frameTranslation.frame_b.R.T[2,1] = body.frameTranslation.frame_a.R.T[2,1];
//   body.frameTranslation.frame_b.R.T[2,2] = body.frameTranslation.frame_a.R.T[2,2];
//   body.frameTranslation.frame_b.R.T[2,3] = body.frameTranslation.frame_a.R.T[2,3];
//   body.frameTranslation.frame_b.R.T[3,1] = body.frameTranslation.frame_a.R.T[3,1];
//   body.frameTranslation.frame_b.R.T[3,2] = body.frameTranslation.frame_a.R.T[3,2];
//   body.frameTranslation.frame_b.R.T[3,3] = body.frameTranslation.frame_a.R.T[3,3];
//   body.frameTranslation.frame_b.R.w[1] = body.frameTranslation.frame_a.R.w[1];
//   body.frameTranslation.frame_b.R.w[2] = body.frameTranslation.frame_a.R.w[2];
//   body.frameTranslation.frame_b.R.w[3] = body.frameTranslation.frame_a.R.w[3];
//   0.0 = body.frameTranslation.frame_a.f[1] + body.frameTranslation.frame_b.f[1];
//   0.0 = body.frameTranslation.frame_a.f[2] + body.frameTranslation.frame_b.f[2];
//   0.0 = body.frameTranslation.frame_a.f[3] + body.frameTranslation.frame_b.f[3];
//   0.0 = body.frameTranslation.frame_a.t[1] + body.frameTranslation.frame_b.t[1] + body.frameTranslation.r[2] * body.frameTranslation.frame_b.f[3] - body.frameTranslation.r[3] * body.frameTranslation.frame_b.f[2];
//   0.0 = body.frameTranslation.frame_a.t[2] + body.frameTranslation.frame_b.t[2] + body.frameTranslation.r[3] * body.frameTranslation.frame_b.f[1] - body.frameTranslation.r[1] * body.frameTranslation.frame_b.f[3];
//   0.0 = body.frameTranslation.frame_a.t[3] + body.frameTranslation.frame_b.t[3] + body.frameTranslation.r[1] * body.frameTranslation.frame_b.f[2] - body.frameTranslation.r[2] * body.frameTranslation.frame_b.f[1];
//   body.r_0[1] = body.frame_a.r_0[1];
//   body.r_0[2] = body.frame_a.r_0[2];
//   body.r_0[3] = body.frame_a.r_0[3];
//   body.v_0[1] = der(body.r_0[1]);
//   body.v_0[2] = der(body.r_0[2]);
//   body.v_0[3] = der(body.r_0[3]);
//   body.a_0[1] = der(body.v_0[1]);
//   body.a_0[2] = der(body.v_0[2]);
//   body.a_0[3] = der(body.v_0[3]);
//   assert(body.innerDiameter < body.diameter,\"parameter innerDiameter is greater as parameter diameter.\");
//   fixed1.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixed1.shape.shapeType);
//   fixed1.shape.rxvisobj[1] = fixed1.shape.R.T[1,1] * fixed1.shape.e_x[1] + fixed1.shape.R.T[2,1] * fixed1.shape.e_x[2] + fixed1.shape.R.T[3,1] * fixed1.shape.e_x[3];
//   fixed1.shape.rxvisobj[2] = fixed1.shape.R.T[1,2] * fixed1.shape.e_x[1] + fixed1.shape.R.T[2,2] * fixed1.shape.e_x[2] + fixed1.shape.R.T[3,2] * fixed1.shape.e_x[3];
//   fixed1.shape.rxvisobj[3] = fixed1.shape.R.T[1,3] * fixed1.shape.e_x[1] + fixed1.shape.R.T[2,3] * fixed1.shape.e_x[2] + fixed1.shape.R.T[3,3] * fixed1.shape.e_x[3];
//   fixed1.shape.ryvisobj[1] = fixed1.shape.R.T[1,1] * fixed1.shape.e_y[1] + fixed1.shape.R.T[2,1] * fixed1.shape.e_y[2] + fixed1.shape.R.T[3,1] * fixed1.shape.e_y[3];
//   fixed1.shape.ryvisobj[2] = fixed1.shape.R.T[1,2] * fixed1.shape.e_y[1] + fixed1.shape.R.T[2,2] * fixed1.shape.e_y[2] + fixed1.shape.R.T[3,2] * fixed1.shape.e_y[3];
//   fixed1.shape.ryvisobj[3] = fixed1.shape.R.T[1,3] * fixed1.shape.e_y[1] + fixed1.shape.R.T[2,3] * fixed1.shape.e_y[2] + fixed1.shape.R.T[3,3] * fixed1.shape.e_y[3];
//   fixed1.shape.rvisobj = fixed1.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixed1.shape.R.T[1,1], fixed1.shape.R.T[1,2], fixed1.shape.R.T[1,3]}, {fixed1.shape.R.T[2,1], fixed1.shape.R.T[2,2], fixed1.shape.R.T[2,3]}, {fixed1.shape.R.T[3,1], fixed1.shape.R.T[3,2], fixed1.shape.R.T[3,3]}}, {fixed1.shape.r_shape[1], fixed1.shape.r_shape[2], fixed1.shape.r_shape[3]});
//   fixed1.shape.size[1] = fixed1.shape.length;
//   fixed1.shape.size[2] = fixed1.shape.width;
//   fixed1.shape.size[3] = fixed1.shape.height;
//   fixed1.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixed1.shape.color[1] / 255.0, fixed1.shape.color[2] / 255.0, fixed1.shape.color[3] / 255.0, fixed1.shape.specularCoefficient);
//   fixed1.shape.Extra = fixed1.shape.extra;
//   fixed1.frame_b.r_0[1] = fixed1.r[1];
//   fixed1.frame_b.r_0[2] = fixed1.r[2];
//   fixed1.frame_b.r_0[3] = fixed1.r[3];
//   fixed1.frame_b.R.w[3] = 0.0;
//   fixed1.frame_b.R.w[2] = 0.0;
//   fixed1.frame_b.R.w[1] = 0.0;
//   fixed1.frame_b.R.T[3,3] = 1.0;
//   fixed1.frame_b.R.T[3,2] = 0.0;
//   fixed1.frame_b.R.T[3,1] = 0.0;
//   fixed1.frame_b.R.T[2,3] = 0.0;
//   fixed1.frame_b.R.T[2,2] = 1.0;
//   fixed1.frame_b.R.T[2,1] = 0.0;
//   fixed1.frame_b.R.T[1,3] = 0.0;
//   fixed1.frame_b.R.T[1,2] = 0.0;
//   fixed1.frame_b.R.T[1,1] = 1.0;
//   fixedRotation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedRotation.shape.shapeType);
//   fixedRotation.shape.rxvisobj[1] = fixedRotation.shape.R.T[1,1] * fixedRotation.shape.e_x[1] + fixedRotation.shape.R.T[2,1] * fixedRotation.shape.e_x[2] + fixedRotation.shape.R.T[3,1] * fixedRotation.shape.e_x[3];
//   fixedRotation.shape.rxvisobj[2] = fixedRotation.shape.R.T[1,2] * fixedRotation.shape.e_x[1] + fixedRotation.shape.R.T[2,2] * fixedRotation.shape.e_x[2] + fixedRotation.shape.R.T[3,2] * fixedRotation.shape.e_x[3];
//   fixedRotation.shape.rxvisobj[3] = fixedRotation.shape.R.T[1,3] * fixedRotation.shape.e_x[1] + fixedRotation.shape.R.T[2,3] * fixedRotation.shape.e_x[2] + fixedRotation.shape.R.T[3,3] * fixedRotation.shape.e_x[3];
//   fixedRotation.shape.ryvisobj[1] = fixedRotation.shape.R.T[1,1] * fixedRotation.shape.e_y[1] + fixedRotation.shape.R.T[2,1] * fixedRotation.shape.e_y[2] + fixedRotation.shape.R.T[3,1] * fixedRotation.shape.e_y[3];
//   fixedRotation.shape.ryvisobj[2] = fixedRotation.shape.R.T[1,2] * fixedRotation.shape.e_y[1] + fixedRotation.shape.R.T[2,2] * fixedRotation.shape.e_y[2] + fixedRotation.shape.R.T[3,2] * fixedRotation.shape.e_y[3];
//   fixedRotation.shape.ryvisobj[3] = fixedRotation.shape.R.T[1,3] * fixedRotation.shape.e_y[1] + fixedRotation.shape.R.T[2,3] * fixedRotation.shape.e_y[2] + fixedRotation.shape.R.T[3,3] * fixedRotation.shape.e_y[3];
//   fixedRotation.shape.rvisobj = fixedRotation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedRotation.shape.R.T[1,1], fixedRotation.shape.R.T[1,2], fixedRotation.shape.R.T[1,3]}, {fixedRotation.shape.R.T[2,1], fixedRotation.shape.R.T[2,2], fixedRotation.shape.R.T[2,3]}, {fixedRotation.shape.R.T[3,1], fixedRotation.shape.R.T[3,2], fixedRotation.shape.R.T[3,3]}}, {fixedRotation.shape.r_shape[1], fixedRotation.shape.r_shape[2], fixedRotation.shape.r_shape[3]});
//   fixedRotation.shape.size[1] = fixedRotation.shape.length;
//   fixedRotation.shape.size[2] = fixedRotation.shape.width;
//   fixedRotation.shape.size[3] = fixedRotation.shape.height;
//   fixedRotation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedRotation.shape.color[1] / 255.0, fixedRotation.shape.color[2] / 255.0, fixedRotation.shape.color[3] / 255.0, fixedRotation.shape.specularCoefficient);
//   fixedRotation.shape.Extra = fixedRotation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedRotation object is connected\");
//   fixedRotation.frame_b.r_0 = fixedRotation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedRotation.frame_a.R, {fixedRotation.r[1], fixedRotation.r[2], fixedRotation.r[3]});
//   if true then
//   fixedRotation.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(fixedRotation.frame_a.R, fixedRotation.R_rel);
//   {0.0, 0.0, 0.0} = fixedRotation.frame_a.f + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedRotation.R_rel, {fixedRotation.frame_b.f[1], fixedRotation.frame_b.f[2], fixedRotation.frame_b.f[3]});
//   {0.0, 0.0, 0.0} = fixedRotation.frame_a.t + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedRotation.R_rel, {fixedRotation.frame_b.t[1], fixedRotation.frame_b.t[2], fixedRotation.frame_b.t[3]}) - {fixedRotation.r[2] * fixedRotation.frame_a.f[3] - fixedRotation.r[3] * fixedRotation.frame_a.f[2], fixedRotation.r[3] * fixedRotation.frame_a.f[1] - fixedRotation.r[1] * fixedRotation.frame_a.f[3], fixedRotation.r[1] * fixedRotation.frame_a.f[2] - fixedRotation.r[2] * fixedRotation.frame_a.f[1]};
//   else
//   fixedRotation.frame_a.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(fixedRotation.frame_b.R, fixedRotation.R_rel_inv);
//   {0.0, 0.0, 0.0} = fixedRotation.frame_b.f + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedRotation.R_rel_inv, {fixedRotation.frame_a.f[1], fixedRotation.frame_a.f[2], fixedRotation.frame_a.f[3]});
//   {0.0, 0.0, 0.0} = fixedRotation.frame_b.t + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedRotation.R_rel_inv, {fixedRotation.frame_a.t[1], fixedRotation.frame_a.t[2], fixedRotation.frame_a.t[3]}) + cross(Modelica.Mechanics.MultiBody.Frames.resolve1(fixedRotation.R_rel_inv, {fixedRotation.r[1], fixedRotation.r[2], fixedRotation.r[3]}), {fixedRotation.frame_b.f[1], fixedRotation.frame_b.f[2], fixedRotation.frame_b.f[3]});
//   end if;
//   assert(true,\"Connector frame_resolve must be connected at least once and frame_resolve.r_0/.R must be set\");
//   forceAndTorque.basicForce.frame_resolve.f[1] = 0.0;
//   forceAndTorque.basicForce.frame_resolve.f[2] = 0.0;
//   forceAndTorque.basicForce.frame_resolve.f[3] = 0.0;
//   forceAndTorque.basicForce.frame_resolve.t[1] = 0.0;
//   forceAndTorque.basicForce.frame_resolve.t[2] = 0.0;
//   forceAndTorque.basicForce.frame_resolve.t[3] = 0.0;
//   forceAndTorque.basicForce.f_b_0 = -Modelica.Mechanics.MultiBody.Frames.resolve1(forceAndTorque.basicForce.frame_resolve.R, {forceAndTorque.basicForce.force[1], forceAndTorque.basicForce.force[2], forceAndTorque.basicForce.force[3]});
//   forceAndTorque.basicForce.frame_b.f = Modelica.Mechanics.MultiBody.Frames.resolve2(forceAndTorque.basicForce.frame_b.R, {forceAndTorque.basicForce.f_b_0[1], forceAndTorque.basicForce.f_b_0[2], forceAndTorque.basicForce.f_b_0[3]});
//   forceAndTorque.basicForce.frame_b.t[1] = 0.0;
//   forceAndTorque.basicForce.frame_b.t[2] = 0.0;
//   forceAndTorque.basicForce.frame_b.t[3] = 0.0;
//   forceAndTorque.basicForce.r_0[1] = forceAndTorque.basicForce.frame_b.r_0[1] - forceAndTorque.basicForce.frame_a.r_0[1];
//   forceAndTorque.basicForce.r_0[2] = forceAndTorque.basicForce.frame_b.r_0[2] - forceAndTorque.basicForce.frame_a.r_0[2];
//   forceAndTorque.basicForce.r_0[3] = forceAndTorque.basicForce.frame_b.r_0[3] - forceAndTorque.basicForce.frame_a.r_0[3];
//   {0.0, 0.0, 0.0} = forceAndTorque.basicForce.frame_a.f + Modelica.Mechanics.MultiBody.Frames.resolve2(forceAndTorque.basicForce.frame_a.R, {forceAndTorque.basicForce.f_b_0[1], forceAndTorque.basicForce.f_b_0[2], forceAndTorque.basicForce.f_b_0[3]});
//   {0.0, 0.0, 0.0} = forceAndTorque.basicForce.frame_a.t + Modelica.Mechanics.MultiBody.Frames.resolve2(forceAndTorque.basicForce.frame_a.R, {forceAndTorque.basicForce.r_0[2] * forceAndTorque.basicForce.f_b_0[3] - forceAndTorque.basicForce.r_0[3] * forceAndTorque.basicForce.f_b_0[2], forceAndTorque.basicForce.r_0[3] * forceAndTorque.basicForce.f_b_0[1] - forceAndTorque.basicForce.r_0[1] * forceAndTorque.basicForce.f_b_0[3], forceAndTorque.basicForce.r_0[1] * forceAndTorque.basicForce.f_b_0[2] - forceAndTorque.basicForce.r_0[2] * forceAndTorque.basicForce.f_b_0[1]});
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   assert(true,\"Connector frame_resolve must be connected at least once and frame_resolve.r_0/.R must be set\");
//   forceAndTorque.basicTorque.frame_resolve.f[1] = 0.0;
//   forceAndTorque.basicTorque.frame_resolve.f[2] = 0.0;
//   forceAndTorque.basicTorque.frame_resolve.f[3] = 0.0;
//   forceAndTorque.basicTorque.frame_resolve.t[1] = 0.0;
//   forceAndTorque.basicTorque.frame_resolve.t[2] = 0.0;
//   forceAndTorque.basicTorque.frame_resolve.t[3] = 0.0;
//   forceAndTorque.basicTorque.r_0[1] = forceAndTorque.basicTorque.frame_b.r_0[1] - forceAndTorque.basicTorque.frame_a.r_0[1];
//   forceAndTorque.basicTorque.r_0[2] = forceAndTorque.basicTorque.frame_b.r_0[2] - forceAndTorque.basicTorque.frame_a.r_0[2];
//   forceAndTorque.basicTorque.r_0[3] = forceAndTorque.basicTorque.frame_b.r_0[3] - forceAndTorque.basicTorque.frame_a.r_0[3];
//   forceAndTorque.basicTorque.frame_a.f[1] = 0.0;
//   forceAndTorque.basicTorque.frame_a.f[2] = 0.0;
//   forceAndTorque.basicTorque.frame_a.f[3] = 0.0;
//   forceAndTorque.basicTorque.frame_b.f[1] = 0.0;
//   forceAndTorque.basicTorque.frame_b.f[2] = 0.0;
//   forceAndTorque.basicTorque.frame_b.f[3] = 0.0;
//   forceAndTorque.basicTorque.t_b_0 = -Modelica.Mechanics.MultiBody.Frames.resolve1(forceAndTorque.basicTorque.frame_resolve.R, {forceAndTorque.basicTorque.torque[1], forceAndTorque.basicTorque.torque[2], forceAndTorque.basicTorque.torque[3]});
//   forceAndTorque.basicTorque.frame_b.t = Modelica.Mechanics.MultiBody.Frames.resolve2(forceAndTorque.basicTorque.frame_b.R, {forceAndTorque.basicTorque.t_b_0[1], forceAndTorque.basicTorque.t_b_0[2], forceAndTorque.basicTorque.t_b_0[3]});
//   {0.0, 0.0, 0.0} = forceAndTorque.basicTorque.frame_a.t + Modelica.Mechanics.MultiBody.Frames.resolve2(forceAndTorque.basicTorque.frame_a.R, {forceAndTorque.basicTorque.t_b_0[1], forceAndTorque.basicTorque.t_b_0[2], forceAndTorque.basicTorque.t_b_0[3]});
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   forceAndTorque.forceArrow.arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(forceAndTorque.forceArrow.arrowLine.shapeType);
//   forceAndTorque.forceArrow.arrowLine.rxvisobj[1] = forceAndTorque.forceArrow.arrowLine.R.T[1,1] * forceAndTorque.forceArrow.arrowLine.e_x[1] + forceAndTorque.forceArrow.arrowLine.R.T[2,1] * forceAndTorque.forceArrow.arrowLine.e_x[2] + forceAndTorque.forceArrow.arrowLine.R.T[3,1] * forceAndTorque.forceArrow.arrowLine.e_x[3];
//   forceAndTorque.forceArrow.arrowLine.rxvisobj[2] = forceAndTorque.forceArrow.arrowLine.R.T[1,2] * forceAndTorque.forceArrow.arrowLine.e_x[1] + forceAndTorque.forceArrow.arrowLine.R.T[2,2] * forceAndTorque.forceArrow.arrowLine.e_x[2] + forceAndTorque.forceArrow.arrowLine.R.T[3,2] * forceAndTorque.forceArrow.arrowLine.e_x[3];
//   forceAndTorque.forceArrow.arrowLine.rxvisobj[3] = forceAndTorque.forceArrow.arrowLine.R.T[1,3] * forceAndTorque.forceArrow.arrowLine.e_x[1] + forceAndTorque.forceArrow.arrowLine.R.T[2,3] * forceAndTorque.forceArrow.arrowLine.e_x[2] + forceAndTorque.forceArrow.arrowLine.R.T[3,3] * forceAndTorque.forceArrow.arrowLine.e_x[3];
//   forceAndTorque.forceArrow.arrowLine.ryvisobj[1] = forceAndTorque.forceArrow.arrowLine.R.T[1,1] * forceAndTorque.forceArrow.arrowLine.e_y[1] + forceAndTorque.forceArrow.arrowLine.R.T[2,1] * forceAndTorque.forceArrow.arrowLine.e_y[2] + forceAndTorque.forceArrow.arrowLine.R.T[3,1] * forceAndTorque.forceArrow.arrowLine.e_y[3];
//   forceAndTorque.forceArrow.arrowLine.ryvisobj[2] = forceAndTorque.forceArrow.arrowLine.R.T[1,2] * forceAndTorque.forceArrow.arrowLine.e_y[1] + forceAndTorque.forceArrow.arrowLine.R.T[2,2] * forceAndTorque.forceArrow.arrowLine.e_y[2] + forceAndTorque.forceArrow.arrowLine.R.T[3,2] * forceAndTorque.forceArrow.arrowLine.e_y[3];
//   forceAndTorque.forceArrow.arrowLine.ryvisobj[3] = forceAndTorque.forceArrow.arrowLine.R.T[1,3] * forceAndTorque.forceArrow.arrowLine.e_y[1] + forceAndTorque.forceArrow.arrowLine.R.T[2,3] * forceAndTorque.forceArrow.arrowLine.e_y[2] + forceAndTorque.forceArrow.arrowLine.R.T[3,3] * forceAndTorque.forceArrow.arrowLine.e_y[3];
//   forceAndTorque.forceArrow.arrowLine.rvisobj = forceAndTorque.forceArrow.arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{forceAndTorque.forceArrow.arrowLine.R.T[1,1], forceAndTorque.forceArrow.arrowLine.R.T[1,2], forceAndTorque.forceArrow.arrowLine.R.T[1,3]}, {forceAndTorque.forceArrow.arrowLine.R.T[2,1], forceAndTorque.forceArrow.arrowLine.R.T[2,2], forceAndTorque.forceArrow.arrowLine.R.T[2,3]}, {forceAndTorque.forceArrow.arrowLine.R.T[3,1], forceAndTorque.forceArrow.arrowLine.R.T[3,2], forceAndTorque.forceArrow.arrowLine.R.T[3,3]}}, {forceAndTorque.forceArrow.arrowLine.r_shape[1], forceAndTorque.forceArrow.arrowLine.r_shape[2], forceAndTorque.forceArrow.arrowLine.r_shape[3]});
//   forceAndTorque.forceArrow.arrowLine.size[1] = forceAndTorque.forceArrow.arrowLine.length;
//   forceAndTorque.forceArrow.arrowLine.size[2] = forceAndTorque.forceArrow.arrowLine.width;
//   forceAndTorque.forceArrow.arrowLine.size[3] = forceAndTorque.forceArrow.arrowLine.height;
//   forceAndTorque.forceArrow.arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(forceAndTorque.forceArrow.arrowLine.color[1] / 255.0, forceAndTorque.forceArrow.arrowLine.color[2] / 255.0, forceAndTorque.forceArrow.arrowLine.color[3] / 255.0, forceAndTorque.forceArrow.arrowLine.specularCoefficient);
//   forceAndTorque.forceArrow.arrowLine.Extra = forceAndTorque.forceArrow.arrowLine.extra;
//   forceAndTorque.forceArrow.arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(forceAndTorque.forceArrow.arrowHead.shapeType);
//   forceAndTorque.forceArrow.arrowHead.rxvisobj[1] = forceAndTorque.forceArrow.arrowHead.R.T[1,1] * forceAndTorque.forceArrow.arrowHead.e_x[1] + forceAndTorque.forceArrow.arrowHead.R.T[2,1] * forceAndTorque.forceArrow.arrowHead.e_x[2] + forceAndTorque.forceArrow.arrowHead.R.T[3,1] * forceAndTorque.forceArrow.arrowHead.e_x[3];
//   forceAndTorque.forceArrow.arrowHead.rxvisobj[2] = forceAndTorque.forceArrow.arrowHead.R.T[1,2] * forceAndTorque.forceArrow.arrowHead.e_x[1] + forceAndTorque.forceArrow.arrowHead.R.T[2,2] * forceAndTorque.forceArrow.arrowHead.e_x[2] + forceAndTorque.forceArrow.arrowHead.R.T[3,2] * forceAndTorque.forceArrow.arrowHead.e_x[3];
//   forceAndTorque.forceArrow.arrowHead.rxvisobj[3] = forceAndTorque.forceArrow.arrowHead.R.T[1,3] * forceAndTorque.forceArrow.arrowHead.e_x[1] + forceAndTorque.forceArrow.arrowHead.R.T[2,3] * forceAndTorque.forceArrow.arrowHead.e_x[2] + forceAndTorque.forceArrow.arrowHead.R.T[3,3] * forceAndTorque.forceArrow.arrowHead.e_x[3];
//   forceAndTorque.forceArrow.arrowHead.ryvisobj[1] = forceAndTorque.forceArrow.arrowHead.R.T[1,1] * forceAndTorque.forceArrow.arrowHead.e_y[1] + forceAndTorque.forceArrow.arrowHead.R.T[2,1] * forceAndTorque.forceArrow.arrowHead.e_y[2] + forceAndTorque.forceArrow.arrowHead.R.T[3,1] * forceAndTorque.forceArrow.arrowHead.e_y[3];
//   forceAndTorque.forceArrow.arrowHead.ryvisobj[2] = forceAndTorque.forceArrow.arrowHead.R.T[1,2] * forceAndTorque.forceArrow.arrowHead.e_y[1] + forceAndTorque.forceArrow.arrowHead.R.T[2,2] * forceAndTorque.forceArrow.arrowHead.e_y[2] + forceAndTorque.forceArrow.arrowHead.R.T[3,2] * forceAndTorque.forceArrow.arrowHead.e_y[3];
//   forceAndTorque.forceArrow.arrowHead.ryvisobj[3] = forceAndTorque.forceArrow.arrowHead.R.T[1,3] * forceAndTorque.forceArrow.arrowHead.e_y[1] + forceAndTorque.forceArrow.arrowHead.R.T[2,3] * forceAndTorque.forceArrow.arrowHead.e_y[2] + forceAndTorque.forceArrow.arrowHead.R.T[3,3] * forceAndTorque.forceArrow.arrowHead.e_y[3];
//   forceAndTorque.forceArrow.arrowHead.rvisobj = forceAndTorque.forceArrow.arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{forceAndTorque.forceArrow.arrowHead.R.T[1,1], forceAndTorque.forceArrow.arrowHead.R.T[1,2], forceAndTorque.forceArrow.arrowHead.R.T[1,3]}, {forceAndTorque.forceArrow.arrowHead.R.T[2,1], forceAndTorque.forceArrow.arrowHead.R.T[2,2], forceAndTorque.forceArrow.arrowHead.R.T[2,3]}, {forceAndTorque.forceArrow.arrowHead.R.T[3,1], forceAndTorque.forceArrow.arrowHead.R.T[3,2], forceAndTorque.forceArrow.arrowHead.R.T[3,3]}}, {forceAndTorque.forceArrow.arrowHead.r_shape[1], forceAndTorque.forceArrow.arrowHead.r_shape[2], forceAndTorque.forceArrow.arrowHead.r_shape[3]});
//   forceAndTorque.forceArrow.arrowHead.size[1] = forceAndTorque.forceArrow.arrowHead.length;
//   forceAndTorque.forceArrow.arrowHead.size[2] = forceAndTorque.forceArrow.arrowHead.width;
//   forceAndTorque.forceArrow.arrowHead.size[3] = forceAndTorque.forceArrow.arrowHead.height;
//   forceAndTorque.forceArrow.arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(forceAndTorque.forceArrow.arrowHead.color[1] / 255.0, forceAndTorque.forceArrow.arrowHead.color[2] / 255.0, forceAndTorque.forceArrow.arrowHead.color[3] / 255.0, forceAndTorque.forceArrow.arrowHead.specularCoefficient);
//   forceAndTorque.forceArrow.arrowHead.Extra = forceAndTorque.forceArrow.arrowHead.extra;
//   forceAndTorque.torqueArrow.arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(forceAndTorque.torqueArrow.arrowLine.shapeType);
//   forceAndTorque.torqueArrow.arrowLine.rxvisobj[1] = forceAndTorque.torqueArrow.arrowLine.R.T[1,1] * forceAndTorque.torqueArrow.arrowLine.e_x[1] + forceAndTorque.torqueArrow.arrowLine.R.T[2,1] * forceAndTorque.torqueArrow.arrowLine.e_x[2] + forceAndTorque.torqueArrow.arrowLine.R.T[3,1] * forceAndTorque.torqueArrow.arrowLine.e_x[3];
//   forceAndTorque.torqueArrow.arrowLine.rxvisobj[2] = forceAndTorque.torqueArrow.arrowLine.R.T[1,2] * forceAndTorque.torqueArrow.arrowLine.e_x[1] + forceAndTorque.torqueArrow.arrowLine.R.T[2,2] * forceAndTorque.torqueArrow.arrowLine.e_x[2] + forceAndTorque.torqueArrow.arrowLine.R.T[3,2] * forceAndTorque.torqueArrow.arrowLine.e_x[3];
//   forceAndTorque.torqueArrow.arrowLine.rxvisobj[3] = forceAndTorque.torqueArrow.arrowLine.R.T[1,3] * forceAndTorque.torqueArrow.arrowLine.e_x[1] + forceAndTorque.torqueArrow.arrowLine.R.T[2,3] * forceAndTorque.torqueArrow.arrowLine.e_x[2] + forceAndTorque.torqueArrow.arrowLine.R.T[3,3] * forceAndTorque.torqueArrow.arrowLine.e_x[3];
//   forceAndTorque.torqueArrow.arrowLine.ryvisobj[1] = forceAndTorque.torqueArrow.arrowLine.R.T[1,1] * forceAndTorque.torqueArrow.arrowLine.e_y[1] + forceAndTorque.torqueArrow.arrowLine.R.T[2,1] * forceAndTorque.torqueArrow.arrowLine.e_y[2] + forceAndTorque.torqueArrow.arrowLine.R.T[3,1] * forceAndTorque.torqueArrow.arrowLine.e_y[3];
//   forceAndTorque.torqueArrow.arrowLine.ryvisobj[2] = forceAndTorque.torqueArrow.arrowLine.R.T[1,2] * forceAndTorque.torqueArrow.arrowLine.e_y[1] + forceAndTorque.torqueArrow.arrowLine.R.T[2,2] * forceAndTorque.torqueArrow.arrowLine.e_y[2] + forceAndTorque.torqueArrow.arrowLine.R.T[3,2] * forceAndTorque.torqueArrow.arrowLine.e_y[3];
//   forceAndTorque.torqueArrow.arrowLine.ryvisobj[3] = forceAndTorque.torqueArrow.arrowLine.R.T[1,3] * forceAndTorque.torqueArrow.arrowLine.e_y[1] + forceAndTorque.torqueArrow.arrowLine.R.T[2,3] * forceAndTorque.torqueArrow.arrowLine.e_y[2] + forceAndTorque.torqueArrow.arrowLine.R.T[3,3] * forceAndTorque.torqueArrow.arrowLine.e_y[3];
//   forceAndTorque.torqueArrow.arrowLine.rvisobj = forceAndTorque.torqueArrow.arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{forceAndTorque.torqueArrow.arrowLine.R.T[1,1], forceAndTorque.torqueArrow.arrowLine.R.T[1,2], forceAndTorque.torqueArrow.arrowLine.R.T[1,3]}, {forceAndTorque.torqueArrow.arrowLine.R.T[2,1], forceAndTorque.torqueArrow.arrowLine.R.T[2,2], forceAndTorque.torqueArrow.arrowLine.R.T[2,3]}, {forceAndTorque.torqueArrow.arrowLine.R.T[3,1], forceAndTorque.torqueArrow.arrowLine.R.T[3,2], forceAndTorque.torqueArrow.arrowLine.R.T[3,3]}}, {forceAndTorque.torqueArrow.arrowLine.r_shape[1], forceAndTorque.torqueArrow.arrowLine.r_shape[2], forceAndTorque.torqueArrow.arrowLine.r_shape[3]});
//   forceAndTorque.torqueArrow.arrowLine.size[1] = forceAndTorque.torqueArrow.arrowLine.length;
//   forceAndTorque.torqueArrow.arrowLine.size[2] = forceAndTorque.torqueArrow.arrowLine.width;
//   forceAndTorque.torqueArrow.arrowLine.size[3] = forceAndTorque.torqueArrow.arrowLine.height;
//   forceAndTorque.torqueArrow.arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(forceAndTorque.torqueArrow.arrowLine.color[1] / 255.0, forceAndTorque.torqueArrow.arrowLine.color[2] / 255.0, forceAndTorque.torqueArrow.arrowLine.color[3] / 255.0, forceAndTorque.torqueArrow.arrowLine.specularCoefficient);
//   forceAndTorque.torqueArrow.arrowLine.Extra = forceAndTorque.torqueArrow.arrowLine.extra;
//   forceAndTorque.torqueArrow.arrowHead1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(forceAndTorque.torqueArrow.arrowHead1.shapeType);
//   forceAndTorque.torqueArrow.arrowHead1.rxvisobj[1] = forceAndTorque.torqueArrow.arrowHead1.R.T[1,1] * forceAndTorque.torqueArrow.arrowHead1.e_x[1] + forceAndTorque.torqueArrow.arrowHead1.R.T[2,1] * forceAndTorque.torqueArrow.arrowHead1.e_x[2] + forceAndTorque.torqueArrow.arrowHead1.R.T[3,1] * forceAndTorque.torqueArrow.arrowHead1.e_x[3];
//   forceAndTorque.torqueArrow.arrowHead1.rxvisobj[2] = forceAndTorque.torqueArrow.arrowHead1.R.T[1,2] * forceAndTorque.torqueArrow.arrowHead1.e_x[1] + forceAndTorque.torqueArrow.arrowHead1.R.T[2,2] * forceAndTorque.torqueArrow.arrowHead1.e_x[2] + forceAndTorque.torqueArrow.arrowHead1.R.T[3,2] * forceAndTorque.torqueArrow.arrowHead1.e_x[3];
//   forceAndTorque.torqueArrow.arrowHead1.rxvisobj[3] = forceAndTorque.torqueArrow.arrowHead1.R.T[1,3] * forceAndTorque.torqueArrow.arrowHead1.e_x[1] + forceAndTorque.torqueArrow.arrowHead1.R.T[2,3] * forceAndTorque.torqueArrow.arrowHead1.e_x[2] + forceAndTorque.torqueArrow.arrowHead1.R.T[3,3] * forceAndTorque.torqueArrow.arrowHead1.e_x[3];
//   forceAndTorque.torqueArrow.arrowHead1.ryvisobj[1] = forceAndTorque.torqueArrow.arrowHead1.R.T[1,1] * forceAndTorque.torqueArrow.arrowHead1.e_y[1] + forceAndTorque.torqueArrow.arrowHead1.R.T[2,1] * forceAndTorque.torqueArrow.arrowHead1.e_y[2] + forceAndTorque.torqueArrow.arrowHead1.R.T[3,1] * forceAndTorque.torqueArrow.arrowHead1.e_y[3];
//   forceAndTorque.torqueArrow.arrowHead1.ryvisobj[2] = forceAndTorque.torqueArrow.arrowHead1.R.T[1,2] * forceAndTorque.torqueArrow.arrowHead1.e_y[1] + forceAndTorque.torqueArrow.arrowHead1.R.T[2,2] * forceAndTorque.torqueArrow.arrowHead1.e_y[2] + forceAndTorque.torqueArrow.arrowHead1.R.T[3,2] * forceAndTorque.torqueArrow.arrowHead1.e_y[3];
//   forceAndTorque.torqueArrow.arrowHead1.ryvisobj[3] = forceAndTorque.torqueArrow.arrowHead1.R.T[1,3] * forceAndTorque.torqueArrow.arrowHead1.e_y[1] + forceAndTorque.torqueArrow.arrowHead1.R.T[2,3] * forceAndTorque.torqueArrow.arrowHead1.e_y[2] + forceAndTorque.torqueArrow.arrowHead1.R.T[3,3] * forceAndTorque.torqueArrow.arrowHead1.e_y[3];
//   forceAndTorque.torqueArrow.arrowHead1.rvisobj = forceAndTorque.torqueArrow.arrowHead1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{forceAndTorque.torqueArrow.arrowHead1.R.T[1,1], forceAndTorque.torqueArrow.arrowHead1.R.T[1,2], forceAndTorque.torqueArrow.arrowHead1.R.T[1,3]}, {forceAndTorque.torqueArrow.arrowHead1.R.T[2,1], forceAndTorque.torqueArrow.arrowHead1.R.T[2,2], forceAndTorque.torqueArrow.arrowHead1.R.T[2,3]}, {forceAndTorque.torqueArrow.arrowHead1.R.T[3,1], forceAndTorque.torqueArrow.arrowHead1.R.T[3,2], forceAndTorque.torqueArrow.arrowHead1.R.T[3,3]}}, {forceAndTorque.torqueArrow.arrowHead1.r_shape[1], forceAndTorque.torqueArrow.arrowHead1.r_shape[2], forceAndTorque.torqueArrow.arrowHead1.r_shape[3]});
//   forceAndTorque.torqueArrow.arrowHead1.size[1] = forceAndTorque.torqueArrow.arrowHead1.length;
//   forceAndTorque.torqueArrow.arrowHead1.size[2] = forceAndTorque.torqueArrow.arrowHead1.width;
//   forceAndTorque.torqueArrow.arrowHead1.size[3] = forceAndTorque.torqueArrow.arrowHead1.height;
//   forceAndTorque.torqueArrow.arrowHead1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(forceAndTorque.torqueArrow.arrowHead1.color[1] / 255.0, forceAndTorque.torqueArrow.arrowHead1.color[2] / 255.0, forceAndTorque.torqueArrow.arrowHead1.color[3] / 255.0, forceAndTorque.torqueArrow.arrowHead1.specularCoefficient);
//   forceAndTorque.torqueArrow.arrowHead1.Extra = forceAndTorque.torqueArrow.arrowHead1.extra;
//   forceAndTorque.torqueArrow.arrowHead2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(forceAndTorque.torqueArrow.arrowHead2.shapeType);
//   forceAndTorque.torqueArrow.arrowHead2.rxvisobj[1] = forceAndTorque.torqueArrow.arrowHead2.R.T[1,1] * forceAndTorque.torqueArrow.arrowHead2.e_x[1] + forceAndTorque.torqueArrow.arrowHead2.R.T[2,1] * forceAndTorque.torqueArrow.arrowHead2.e_x[2] + forceAndTorque.torqueArrow.arrowHead2.R.T[3,1] * forceAndTorque.torqueArrow.arrowHead2.e_x[3];
//   forceAndTorque.torqueArrow.arrowHead2.rxvisobj[2] = forceAndTorque.torqueArrow.arrowHead2.R.T[1,2] * forceAndTorque.torqueArrow.arrowHead2.e_x[1] + forceAndTorque.torqueArrow.arrowHead2.R.T[2,2] * forceAndTorque.torqueArrow.arrowHead2.e_x[2] + forceAndTorque.torqueArrow.arrowHead2.R.T[3,2] * forceAndTorque.torqueArrow.arrowHead2.e_x[3];
//   forceAndTorque.torqueArrow.arrowHead2.rxvisobj[3] = forceAndTorque.torqueArrow.arrowHead2.R.T[1,3] * forceAndTorque.torqueArrow.arrowHead2.e_x[1] + forceAndTorque.torqueArrow.arrowHead2.R.T[2,3] * forceAndTorque.torqueArrow.arrowHead2.e_x[2] + forceAndTorque.torqueArrow.arrowHead2.R.T[3,3] * forceAndTorque.torqueArrow.arrowHead2.e_x[3];
//   forceAndTorque.torqueArrow.arrowHead2.ryvisobj[1] = forceAndTorque.torqueArrow.arrowHead2.R.T[1,1] * forceAndTorque.torqueArrow.arrowHead2.e_y[1] + forceAndTorque.torqueArrow.arrowHead2.R.T[2,1] * forceAndTorque.torqueArrow.arrowHead2.e_y[2] + forceAndTorque.torqueArrow.arrowHead2.R.T[3,1] * forceAndTorque.torqueArrow.arrowHead2.e_y[3];
//   forceAndTorque.torqueArrow.arrowHead2.ryvisobj[2] = forceAndTorque.torqueArrow.arrowHead2.R.T[1,2] * forceAndTorque.torqueArrow.arrowHead2.e_y[1] + forceAndTorque.torqueArrow.arrowHead2.R.T[2,2] * forceAndTorque.torqueArrow.arrowHead2.e_y[2] + forceAndTorque.torqueArrow.arrowHead2.R.T[3,2] * forceAndTorque.torqueArrow.arrowHead2.e_y[3];
//   forceAndTorque.torqueArrow.arrowHead2.ryvisobj[3] = forceAndTorque.torqueArrow.arrowHead2.R.T[1,3] * forceAndTorque.torqueArrow.arrowHead2.e_y[1] + forceAndTorque.torqueArrow.arrowHead2.R.T[2,3] * forceAndTorque.torqueArrow.arrowHead2.e_y[2] + forceAndTorque.torqueArrow.arrowHead2.R.T[3,3] * forceAndTorque.torqueArrow.arrowHead2.e_y[3];
//   forceAndTorque.torqueArrow.arrowHead2.rvisobj = forceAndTorque.torqueArrow.arrowHead2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{forceAndTorque.torqueArrow.arrowHead2.R.T[1,1], forceAndTorque.torqueArrow.arrowHead2.R.T[1,2], forceAndTorque.torqueArrow.arrowHead2.R.T[1,3]}, {forceAndTorque.torqueArrow.arrowHead2.R.T[2,1], forceAndTorque.torqueArrow.arrowHead2.R.T[2,2], forceAndTorque.torqueArrow.arrowHead2.R.T[2,3]}, {forceAndTorque.torqueArrow.arrowHead2.R.T[3,1], forceAndTorque.torqueArrow.arrowHead2.R.T[3,2], forceAndTorque.torqueArrow.arrowHead2.R.T[3,3]}}, {forceAndTorque.torqueArrow.arrowHead2.r_shape[1], forceAndTorque.torqueArrow.arrowHead2.r_shape[2], forceAndTorque.torqueArrow.arrowHead2.r_shape[3]});
//   forceAndTorque.torqueArrow.arrowHead2.size[1] = forceAndTorque.torqueArrow.arrowHead2.length;
//   forceAndTorque.torqueArrow.arrowHead2.size[2] = forceAndTorque.torqueArrow.arrowHead2.width;
//   forceAndTorque.torqueArrow.arrowHead2.size[3] = forceAndTorque.torqueArrow.arrowHead2.height;
//   forceAndTorque.torqueArrow.arrowHead2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(forceAndTorque.torqueArrow.arrowHead2.color[1] / 255.0, forceAndTorque.torqueArrow.arrowHead2.color[2] / 255.0, forceAndTorque.torqueArrow.arrowHead2.color[3] / 255.0, forceAndTorque.torqueArrow.arrowHead2.specularCoefficient);
//   forceAndTorque.torqueArrow.arrowHead2.Extra = forceAndTorque.torqueArrow.arrowHead2.extra;
//   forceAndTorque.connectionLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(forceAndTorque.connectionLine.shapeType);
//   forceAndTorque.connectionLine.rxvisobj[1] = forceAndTorque.connectionLine.R.T[1,1] * forceAndTorque.connectionLine.e_x[1] + forceAndTorque.connectionLine.R.T[2,1] * forceAndTorque.connectionLine.e_x[2] + forceAndTorque.connectionLine.R.T[3,1] * forceAndTorque.connectionLine.e_x[3];
//   forceAndTorque.connectionLine.rxvisobj[2] = forceAndTorque.connectionLine.R.T[1,2] * forceAndTorque.connectionLine.e_x[1] + forceAndTorque.connectionLine.R.T[2,2] * forceAndTorque.connectionLine.e_x[2] + forceAndTorque.connectionLine.R.T[3,2] * forceAndTorque.connectionLine.e_x[3];
//   forceAndTorque.connectionLine.rxvisobj[3] = forceAndTorque.connectionLine.R.T[1,3] * forceAndTorque.connectionLine.e_x[1] + forceAndTorque.connectionLine.R.T[2,3] * forceAndTorque.connectionLine.e_x[2] + forceAndTorque.connectionLine.R.T[3,3] * forceAndTorque.connectionLine.e_x[3];
//   forceAndTorque.connectionLine.ryvisobj[1] = forceAndTorque.connectionLine.R.T[1,1] * forceAndTorque.connectionLine.e_y[1] + forceAndTorque.connectionLine.R.T[2,1] * forceAndTorque.connectionLine.e_y[2] + forceAndTorque.connectionLine.R.T[3,1] * forceAndTorque.connectionLine.e_y[3];
//   forceAndTorque.connectionLine.ryvisobj[2] = forceAndTorque.connectionLine.R.T[1,2] * forceAndTorque.connectionLine.e_y[1] + forceAndTorque.connectionLine.R.T[2,2] * forceAndTorque.connectionLine.e_y[2] + forceAndTorque.connectionLine.R.T[3,2] * forceAndTorque.connectionLine.e_y[3];
//   forceAndTorque.connectionLine.ryvisobj[3] = forceAndTorque.connectionLine.R.T[1,3] * forceAndTorque.connectionLine.e_y[1] + forceAndTorque.connectionLine.R.T[2,3] * forceAndTorque.connectionLine.e_y[2] + forceAndTorque.connectionLine.R.T[3,3] * forceAndTorque.connectionLine.e_y[3];
//   forceAndTorque.connectionLine.rvisobj = forceAndTorque.connectionLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{forceAndTorque.connectionLine.R.T[1,1], forceAndTorque.connectionLine.R.T[1,2], forceAndTorque.connectionLine.R.T[1,3]}, {forceAndTorque.connectionLine.R.T[2,1], forceAndTorque.connectionLine.R.T[2,2], forceAndTorque.connectionLine.R.T[2,3]}, {forceAndTorque.connectionLine.R.T[3,1], forceAndTorque.connectionLine.R.T[3,2], forceAndTorque.connectionLine.R.T[3,3]}}, {forceAndTorque.connectionLine.r_shape[1], forceAndTorque.connectionLine.r_shape[2], forceAndTorque.connectionLine.r_shape[3]});
//   forceAndTorque.connectionLine.size[1] = forceAndTorque.connectionLine.length;
//   forceAndTorque.connectionLine.size[2] = forceAndTorque.connectionLine.width;
//   forceAndTorque.connectionLine.size[3] = forceAndTorque.connectionLine.height;
//   forceAndTorque.connectionLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(forceAndTorque.connectionLine.color[1] / 255.0, forceAndTorque.connectionLine.color[2] / 255.0, forceAndTorque.connectionLine.color[3] / 255.0, forceAndTorque.connectionLine.specularCoefficient);
//   forceAndTorque.connectionLine.Extra = forceAndTorque.connectionLine.extra;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   revolute2.fixed.flange.phi = revolute2.fixed.phi0;
//   revolute2.constantTorque.tau = -revolute2.constantTorque.flange.tau;
//   revolute2.constantTorque.tau = revolute2.constantTorque.tau_constant;
//   revolute2.constantTorque.phi = revolute2.constantTorque.flange.phi - revolute2.constantTorque.phi_support;
//   revolute2.constantTorque.phi_support = 0.0;
//   revolute2.internalAxis.flange.tau = revolute2.internalAxis.tau;
//   revolute2.internalAxis.flange.phi = revolute2.internalAxis.phi;
//   revolute2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute2.cylinder.shapeType);
//   revolute2.cylinder.rxvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.ryvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.rvisobj = revolute2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute2.cylinder.R.T[1,1], revolute2.cylinder.R.T[1,2], revolute2.cylinder.R.T[1,3]}, {revolute2.cylinder.R.T[2,1], revolute2.cylinder.R.T[2,2], revolute2.cylinder.R.T[2,3]}, {revolute2.cylinder.R.T[3,1], revolute2.cylinder.R.T[3,2], revolute2.cylinder.R.T[3,3]}}, {revolute2.cylinder.r_shape[1], revolute2.cylinder.r_shape[2], revolute2.cylinder.r_shape[3]});
//   revolute2.cylinder.size[1] = revolute2.cylinder.length;
//   revolute2.cylinder.size[2] = revolute2.cylinder.width;
//   revolute2.cylinder.size[3] = revolute2.cylinder.height;
//   revolute2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute2.cylinder.color[1] / 255.0, revolute2.cylinder.color[2] / 255.0, revolute2.cylinder.color[3] / 255.0, revolute2.cylinder.specularCoefficient);
//   revolute2.cylinder.Extra = revolute2.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   revolute2.angle = revolute2.phi;
//   revolute2.w = der(revolute2.phi);
//   revolute2.a = der(revolute2.w);
//   revolute2.frame_b.r_0[1] = revolute2.frame_a.r_0[1];
//   revolute2.frame_b.r_0[2] = revolute2.frame_a.r_0[2];
//   revolute2.frame_b.r_0[3] = revolute2.frame_a.r_0[3];
//   if true then
//   revolute2.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({revolute2.e[1], revolute2.e[2], revolute2.e[3]}, revolute2.phi, revolute2.w);
//   revolute2.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(revolute2.frame_a.R, revolute2.R_rel);
//   revolute2.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute2.R_rel, {revolute2.frame_b.f[1], revolute2.frame_b.f[2], revolute2.frame_b.f[3]});
//   revolute2.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute2.R_rel, {revolute2.frame_b.t[1], revolute2.frame_b.t[2], revolute2.frame_b.t[3]});
//   else
//   revolute2.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation(-{revolute2.e[1], revolute2.e[2], revolute2.e[3]}, revolute2.phi, revolute2.w);
//   revolute2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(revolute2.frame_b.R, revolute2.R_rel);
//   revolute2.frame_b.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute2.R_rel, {revolute2.frame_a.f[1], revolute2.frame_a.f[2], revolute2.frame_a.f[3]});
//   revolute2.frame_b.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute2.R_rel, {revolute2.frame_a.t[1], revolute2.frame_a.t[2], revolute2.frame_a.t[3]});
//   end if;
//   revolute2.tau = (-revolute2.frame_b.t[1]) * revolute2.e[1] + (-revolute2.frame_b.t[2]) * revolute2.e[2] + (-revolute2.frame_b.t[3]) * revolute2.e[3];
//   revolute2.phi = revolute2.internalAxis.phi;
//   torque[1].y = torque[1].k;
//   torque[2].y = torque[2].k;
//   torque[3].y = torque[3].k;
//   revolute1.fixed.flange.phi = revolute1.fixed.phi0;
//   revolute1.constantTorque.tau = -revolute1.constantTorque.flange.tau;
//   revolute1.constantTorque.tau = revolute1.constantTorque.tau_constant;
//   revolute1.constantTorque.phi = revolute1.constantTorque.flange.phi - revolute1.constantTorque.phi_support;
//   revolute1.constantTorque.phi_support = 0.0;
//   revolute1.internalAxis.flange.tau = revolute1.internalAxis.tau;
//   revolute1.internalAxis.flange.phi = revolute1.internalAxis.phi;
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1], revolute1.cylinder.R.T[1,2], revolute1.cylinder.R.T[1,3]}, {revolute1.cylinder.R.T[2,1], revolute1.cylinder.R.T[2,2], revolute1.cylinder.R.T[2,3]}, {revolute1.cylinder.R.T[3,1], revolute1.cylinder.R.T[3,2], revolute1.cylinder.R.T[3,3]}}, {revolute1.cylinder.r_shape[1], revolute1.cylinder.r_shape[2], revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0, revolute1.cylinder.color[2] / 255.0, revolute1.cylinder.color[3] / 255.0, revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   revolute1.angle = revolute1.phi;
//   revolute1.w = der(revolute1.phi);
//   revolute1.a = der(revolute1.w);
//   revolute1.frame_b.r_0[1] = revolute1.frame_a.r_0[1];
//   revolute1.frame_b.r_0[2] = revolute1.frame_a.r_0[2];
//   revolute1.frame_b.r_0[3] = revolute1.frame_a.r_0[3];
//   if true then
//   revolute1.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({revolute1.e[1], revolute1.e[2], revolute1.e[3]}, revolute1.phi, revolute1.w);
//   revolute1.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(revolute1.frame_a.R, revolute1.R_rel);
//   revolute1.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute1.R_rel, {revolute1.frame_b.f[1], revolute1.frame_b.f[2], revolute1.frame_b.f[3]});
//   revolute1.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute1.R_rel, {revolute1.frame_b.t[1], revolute1.frame_b.t[2], revolute1.frame_b.t[3]});
//   else
//   revolute1.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation(-{revolute1.e[1], revolute1.e[2], revolute1.e[3]}, revolute1.phi, revolute1.w);
//   revolute1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(revolute1.frame_b.R, revolute1.R_rel);
//   revolute1.frame_b.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute1.R_rel, {revolute1.frame_a.f[1], revolute1.frame_a.f[2], revolute1.frame_a.f[3]});
//   revolute1.frame_b.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute1.R_rel, {revolute1.frame_a.t[1], revolute1.frame_a.t[2], revolute1.frame_a.t[3]});
//   end if;
//   revolute1.tau = (-revolute1.frame_b.t[1]) * revolute1.e[1] + (-revolute1.frame_b.t[2]) * revolute1.e[2] + (-revolute1.frame_b.t[3]) * revolute1.e[3];
//   revolute1.phi = revolute1.internalAxis.phi;
//   fixed2.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixed2.shape.shapeType);
//   fixed2.shape.rxvisobj[1] = fixed2.shape.R.T[1,1] * fixed2.shape.e_x[1] + fixed2.shape.R.T[2,1] * fixed2.shape.e_x[2] + fixed2.shape.R.T[3,1] * fixed2.shape.e_x[3];
//   fixed2.shape.rxvisobj[2] = fixed2.shape.R.T[1,2] * fixed2.shape.e_x[1] + fixed2.shape.R.T[2,2] * fixed2.shape.e_x[2] + fixed2.shape.R.T[3,2] * fixed2.shape.e_x[3];
//   fixed2.shape.rxvisobj[3] = fixed2.shape.R.T[1,3] * fixed2.shape.e_x[1] + fixed2.shape.R.T[2,3] * fixed2.shape.e_x[2] + fixed2.shape.R.T[3,3] * fixed2.shape.e_x[3];
//   fixed2.shape.ryvisobj[1] = fixed2.shape.R.T[1,1] * fixed2.shape.e_y[1] + fixed2.shape.R.T[2,1] * fixed2.shape.e_y[2] + fixed2.shape.R.T[3,1] * fixed2.shape.e_y[3];
//   fixed2.shape.ryvisobj[2] = fixed2.shape.R.T[1,2] * fixed2.shape.e_y[1] + fixed2.shape.R.T[2,2] * fixed2.shape.e_y[2] + fixed2.shape.R.T[3,2] * fixed2.shape.e_y[3];
//   fixed2.shape.ryvisobj[3] = fixed2.shape.R.T[1,3] * fixed2.shape.e_y[1] + fixed2.shape.R.T[2,3] * fixed2.shape.e_y[2] + fixed2.shape.R.T[3,3] * fixed2.shape.e_y[3];
//   fixed2.shape.rvisobj = fixed2.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixed2.shape.R.T[1,1], fixed2.shape.R.T[1,2], fixed2.shape.R.T[1,3]}, {fixed2.shape.R.T[2,1], fixed2.shape.R.T[2,2], fixed2.shape.R.T[2,3]}, {fixed2.shape.R.T[3,1], fixed2.shape.R.T[3,2], fixed2.shape.R.T[3,3]}}, {fixed2.shape.r_shape[1], fixed2.shape.r_shape[2], fixed2.shape.r_shape[3]});
//   fixed2.shape.size[1] = fixed2.shape.length;
//   fixed2.shape.size[2] = fixed2.shape.width;
//   fixed2.shape.size[3] = fixed2.shape.height;
//   fixed2.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixed2.shape.color[1] / 255.0, fixed2.shape.color[2] / 255.0, fixed2.shape.color[3] / 255.0, fixed2.shape.specularCoefficient);
//   fixed2.shape.Extra = fixed2.shape.extra;
//   fixed2.frame_b.r_0[1] = fixed2.r[1];
//   fixed2.frame_b.r_0[2] = fixed2.r[2];
//   fixed2.frame_b.r_0[3] = fixed2.r[3];
//   fixed2.frame_b.R.w[3] = 0.0;
//   fixed2.frame_b.R.w[2] = 0.0;
//   fixed2.frame_b.R.w[1] = 0.0;
//   fixed2.frame_b.R.T[3,3] = 1.0;
//   fixed2.frame_b.R.T[3,2] = 0.0;
//   fixed2.frame_b.R.T[3,1] = 0.0;
//   fixed2.frame_b.R.T[2,3] = 0.0;
//   fixed2.frame_b.R.T[2,2] = 1.0;
//   fixed2.frame_b.R.T[2,1] = 0.0;
//   fixed2.frame_b.R.T[1,3] = 0.0;
//   fixed2.frame_b.R.T[1,2] = 0.0;
//   fixed2.frame_b.R.T[1,1] = 1.0;
//   force[1].y = force[1].k;
//   force[2].y = force[2].k;
//   force[3].y = force[3].k;
//   world.frame_b.t[1] = 0.0;
//   world.frame_b.t[2] = 0.0;
//   world.frame_b.t[3] = 0.0;
//   world.frame_b.f[1] = 0.0;
//   world.frame_b.f[2] = 0.0;
//   world.frame_b.f[3] = 0.0;
//   body.frame_a.t[1] + revolute2.frame_b.t[1] = 0.0;
//   body.frame_a.t[2] + revolute2.frame_b.t[2] = 0.0;
//   body.frame_a.t[3] + revolute2.frame_b.t[3] = 0.0;
//   body.frame_a.f[1] + revolute2.frame_b.f[1] = 0.0;
//   body.frame_a.f[2] + revolute2.frame_b.f[2] = 0.0;
//   body.frame_a.f[3] + revolute2.frame_b.f[3] = 0.0;
//   body.frame_b.t[1] + forceAndTorque.frame_b.t[1] = 0.0;
//   body.frame_b.t[2] + forceAndTorque.frame_b.t[2] = 0.0;
//   body.frame_b.t[3] + forceAndTorque.frame_b.t[3] = 0.0;
//   body.frame_b.f[1] + forceAndTorque.frame_b.f[1] = 0.0;
//   body.frame_b.f[2] + forceAndTorque.frame_b.f[2] = 0.0;
//   body.frame_b.f[3] + forceAndTorque.frame_b.f[3] = 0.0;
//   (-body.frame_a.t[1]) + body.body.frame_a.t[1] + body.frameTranslation.frame_a.t[1] = 0.0;
//   (-body.frame_a.t[2]) + body.body.frame_a.t[2] + body.frameTranslation.frame_a.t[2] = 0.0;
//   (-body.frame_a.t[3]) + body.body.frame_a.t[3] + body.frameTranslation.frame_a.t[3] = 0.0;
//   (-body.frame_a.f[1]) + body.body.frame_a.f[1] + body.frameTranslation.frame_a.f[1] = 0.0;
//   (-body.frame_a.f[2]) + body.body.frame_a.f[2] + body.frameTranslation.frame_a.f[2] = 0.0;
//   (-body.frame_a.f[3]) + body.body.frame_a.f[3] + body.frameTranslation.frame_a.f[3] = 0.0;
//   (-body.frame_b.t[1]) + body.frameTranslation.frame_b.t[1] = 0.0;
//   (-body.frame_b.t[2]) + body.frameTranslation.frame_b.t[2] = 0.0;
//   (-body.frame_b.t[3]) + body.frameTranslation.frame_b.t[3] = 0.0;
//   (-body.frame_b.f[1]) + body.frameTranslation.frame_b.f[1] = 0.0;
//   (-body.frame_b.f[2]) + body.frameTranslation.frame_b.f[2] = 0.0;
//   (-body.frame_b.f[3]) + body.frameTranslation.frame_b.f[3] = 0.0;
//   body.body.frame_a.r_0[1] = body.frameTranslation.frame_a.r_0[1];
//   body.body.frame_a.r_0[1] = body.frame_a.r_0[1];
//   body.body.frame_a.r_0[2] = body.frameTranslation.frame_a.r_0[2];
//   body.body.frame_a.r_0[2] = body.frame_a.r_0[2];
//   body.body.frame_a.r_0[3] = body.frameTranslation.frame_a.r_0[3];
//   body.body.frame_a.r_0[3] = body.frame_a.r_0[3];
//   body.body.frame_a.R.T[1,1] = body.frameTranslation.frame_a.R.T[1,1];
//   body.body.frame_a.R.T[1,1] = body.frame_a.R.T[1,1];
//   body.body.frame_a.R.T[2,1] = body.frameTranslation.frame_a.R.T[2,1];
//   body.body.frame_a.R.T[2,1] = body.frame_a.R.T[2,1];
//   body.body.frame_a.R.T[3,1] = body.frameTranslation.frame_a.R.T[3,1];
//   body.body.frame_a.R.T[3,1] = body.frame_a.R.T[3,1];
//   body.body.frame_a.R.T[1,2] = body.frameTranslation.frame_a.R.T[1,2];
//   body.body.frame_a.R.T[1,2] = body.frame_a.R.T[1,2];
//   body.body.frame_a.R.T[2,2] = body.frameTranslation.frame_a.R.T[2,2];
//   body.body.frame_a.R.T[2,2] = body.frame_a.R.T[2,2];
//   body.body.frame_a.R.T[3,2] = body.frameTranslation.frame_a.R.T[3,2];
//   body.body.frame_a.R.T[3,2] = body.frame_a.R.T[3,2];
//   body.body.frame_a.R.T[1,3] = body.frameTranslation.frame_a.R.T[1,3];
//   body.body.frame_a.R.T[1,3] = body.frame_a.R.T[1,3];
//   body.body.frame_a.R.T[2,3] = body.frameTranslation.frame_a.R.T[2,3];
//   body.body.frame_a.R.T[2,3] = body.frame_a.R.T[2,3];
//   body.body.frame_a.R.T[3,3] = body.frameTranslation.frame_a.R.T[3,3];
//   body.body.frame_a.R.T[3,3] = body.frame_a.R.T[3,3];
//   body.body.frame_a.R.w[1] = body.frameTranslation.frame_a.R.w[1];
//   body.body.frame_a.R.w[1] = body.frame_a.R.w[1];
//   body.body.frame_a.R.w[2] = body.frameTranslation.frame_a.R.w[2];
//   body.body.frame_a.R.w[2] = body.frame_a.R.w[2];
//   body.body.frame_a.R.w[3] = body.frameTranslation.frame_a.R.w[3];
//   body.body.frame_a.R.w[3] = body.frame_a.R.w[3];
//   body.frameTranslation.frame_b.r_0[1] = body.frame_b.r_0[1];
//   body.frameTranslation.frame_b.r_0[2] = body.frame_b.r_0[2];
//   body.frameTranslation.frame_b.r_0[3] = body.frame_b.r_0[3];
//   body.frameTranslation.frame_b.R.T[1,1] = body.frame_b.R.T[1,1];
//   body.frameTranslation.frame_b.R.T[2,1] = body.frame_b.R.T[2,1];
//   body.frameTranslation.frame_b.R.T[3,1] = body.frame_b.R.T[3,1];
//   body.frameTranslation.frame_b.R.T[1,2] = body.frame_b.R.T[1,2];
//   body.frameTranslation.frame_b.R.T[2,2] = body.frame_b.R.T[2,2];
//   body.frameTranslation.frame_b.R.T[3,2] = body.frame_b.R.T[3,2];
//   body.frameTranslation.frame_b.R.T[1,3] = body.frame_b.R.T[1,3];
//   body.frameTranslation.frame_b.R.T[2,3] = body.frame_b.R.T[2,3];
//   body.frameTranslation.frame_b.R.T[3,3] = body.frame_b.R.T[3,3];
//   body.frameTranslation.frame_b.R.w[1] = body.frame_b.R.w[1];
//   body.frameTranslation.frame_b.R.w[2] = body.frame_b.R.w[2];
//   body.frameTranslation.frame_b.R.w[3] = body.frame_b.R.w[3];
//   fixed1.frame_b.t[1] + fixedRotation.frame_a.t[1] + revolute1.frame_a.t[1] = 0.0;
//   fixed1.frame_b.t[2] + fixedRotation.frame_a.t[2] + revolute1.frame_a.t[2] = 0.0;
//   fixed1.frame_b.t[3] + fixedRotation.frame_a.t[3] + revolute1.frame_a.t[3] = 0.0;
//   fixed1.frame_b.f[1] + fixedRotation.frame_a.f[1] + revolute1.frame_a.f[1] = 0.0;
//   fixed1.frame_b.f[2] + fixedRotation.frame_a.f[2] + revolute1.frame_a.f[2] = 0.0;
//   fixed1.frame_b.f[3] + fixedRotation.frame_a.f[3] + revolute1.frame_a.f[3] = 0.0;
//   fixedRotation.frame_b.t[1] + forceAndTorque.frame_resolve.t[1] = 0.0;
//   fixedRotation.frame_b.t[2] + forceAndTorque.frame_resolve.t[2] = 0.0;
//   fixedRotation.frame_b.t[3] + forceAndTorque.frame_resolve.t[3] = 0.0;
//   fixedRotation.frame_b.f[1] + forceAndTorque.frame_resolve.f[1] = 0.0;
//   fixedRotation.frame_b.f[2] + forceAndTorque.frame_resolve.f[2] = 0.0;
//   fixedRotation.frame_b.f[3] + forceAndTorque.frame_resolve.f[3] = 0.0;
//   forceAndTorque.frame_a.t[1] + fixed2.frame_b.t[1] = 0.0;
//   forceAndTorque.frame_a.t[2] + fixed2.frame_b.t[2] = 0.0;
//   forceAndTorque.frame_a.t[3] + fixed2.frame_b.t[3] = 0.0;
//   forceAndTorque.frame_a.f[1] + fixed2.frame_b.f[1] = 0.0;
//   forceAndTorque.frame_a.f[2] + fixed2.frame_b.f[2] = 0.0;
//   forceAndTorque.frame_a.f[3] + fixed2.frame_b.f[3] = 0.0;
//   (-forceAndTorque.frame_a.t[1]) + forceAndTorque.basicForce.frame_a.t[1] + forceAndTorque.basicTorque.frame_a.t[1] = 0.0;
//   (-forceAndTorque.frame_a.t[2]) + forceAndTorque.basicForce.frame_a.t[2] + forceAndTorque.basicTorque.frame_a.t[2] = 0.0;
//   (-forceAndTorque.frame_a.t[3]) + forceAndTorque.basicForce.frame_a.t[3] + forceAndTorque.basicTorque.frame_a.t[3] = 0.0;
//   (-forceAndTorque.frame_a.f[1]) + forceAndTorque.basicForce.frame_a.f[1] + forceAndTorque.basicTorque.frame_a.f[1] = 0.0;
//   (-forceAndTorque.frame_a.f[2]) + forceAndTorque.basicForce.frame_a.f[2] + forceAndTorque.basicTorque.frame_a.f[2] = 0.0;
//   (-forceAndTorque.frame_a.f[3]) + forceAndTorque.basicForce.frame_a.f[3] + forceAndTorque.basicTorque.frame_a.f[3] = 0.0;
//   (-forceAndTorque.frame_b.t[1]) + forceAndTorque.basicForce.frame_b.t[1] + forceAndTorque.basicTorque.frame_b.t[1] = 0.0;
//   (-forceAndTorque.frame_b.t[2]) + forceAndTorque.basicForce.frame_b.t[2] + forceAndTorque.basicTorque.frame_b.t[2] = 0.0;
//   (-forceAndTorque.frame_b.t[3]) + forceAndTorque.basicForce.frame_b.t[3] + forceAndTorque.basicTorque.frame_b.t[3] = 0.0;
//   (-forceAndTorque.frame_b.f[1]) + forceAndTorque.basicForce.frame_b.f[1] + forceAndTorque.basicTorque.frame_b.f[1] = 0.0;
//   (-forceAndTorque.frame_b.f[2]) + forceAndTorque.basicForce.frame_b.f[2] + forceAndTorque.basicTorque.frame_b.f[2] = 0.0;
//   (-forceAndTorque.frame_b.f[3]) + forceAndTorque.basicForce.frame_b.f[3] + forceAndTorque.basicTorque.frame_b.f[3] = 0.0;
//   forceAndTorque.basicForce.frame_resolve.t[1] + forceAndTorque.basicTorque.frame_resolve.t[1] + (-forceAndTorque.frame_resolve.t[1]) = 0.0;
//   forceAndTorque.basicForce.frame_resolve.t[2] + forceAndTorque.basicTorque.frame_resolve.t[2] + (-forceAndTorque.frame_resolve.t[2]) = 0.0;
//   forceAndTorque.basicForce.frame_resolve.t[3] + forceAndTorque.basicTorque.frame_resolve.t[3] + (-forceAndTorque.frame_resolve.t[3]) = 0.0;
//   forceAndTorque.basicForce.frame_resolve.f[1] + forceAndTorque.basicTorque.frame_resolve.f[1] + (-forceAndTorque.frame_resolve.f[1]) = 0.0;
//   forceAndTorque.basicForce.frame_resolve.f[2] + forceAndTorque.basicTorque.frame_resolve.f[2] + (-forceAndTorque.frame_resolve.f[2]) = 0.0;
//   forceAndTorque.basicForce.frame_resolve.f[3] + forceAndTorque.basicTorque.frame_resolve.f[3] + (-forceAndTorque.frame_resolve.f[3]) = 0.0;
//   forceAndTorque.basicForce.frame_a.r_0[1] = forceAndTorque.basicTorque.frame_a.r_0[1];
//   forceAndTorque.basicForce.frame_a.r_0[1] = forceAndTorque.frame_a.r_0[1];
//   forceAndTorque.basicForce.frame_a.r_0[2] = forceAndTorque.basicTorque.frame_a.r_0[2];
//   forceAndTorque.basicForce.frame_a.r_0[2] = forceAndTorque.frame_a.r_0[2];
//   forceAndTorque.basicForce.frame_a.r_0[3] = forceAndTorque.basicTorque.frame_a.r_0[3];
//   forceAndTorque.basicForce.frame_a.r_0[3] = forceAndTorque.frame_a.r_0[3];
//   forceAndTorque.basicForce.frame_a.R.T[1,1] = forceAndTorque.basicTorque.frame_a.R.T[1,1];
//   forceAndTorque.basicForce.frame_a.R.T[1,1] = forceAndTorque.frame_a.R.T[1,1];
//   forceAndTorque.basicForce.frame_a.R.T[2,1] = forceAndTorque.basicTorque.frame_a.R.T[2,1];
//   forceAndTorque.basicForce.frame_a.R.T[2,1] = forceAndTorque.frame_a.R.T[2,1];
//   forceAndTorque.basicForce.frame_a.R.T[3,1] = forceAndTorque.basicTorque.frame_a.R.T[3,1];
//   forceAndTorque.basicForce.frame_a.R.T[3,1] = forceAndTorque.frame_a.R.T[3,1];
//   forceAndTorque.basicForce.frame_a.R.T[1,2] = forceAndTorque.basicTorque.frame_a.R.T[1,2];
//   forceAndTorque.basicForce.frame_a.R.T[1,2] = forceAndTorque.frame_a.R.T[1,2];
//   forceAndTorque.basicForce.frame_a.R.T[2,2] = forceAndTorque.basicTorque.frame_a.R.T[2,2];
//   forceAndTorque.basicForce.frame_a.R.T[2,2] = forceAndTorque.frame_a.R.T[2,2];
//   forceAndTorque.basicForce.frame_a.R.T[3,2] = forceAndTorque.basicTorque.frame_a.R.T[3,2];
//   forceAndTorque.basicForce.frame_a.R.T[3,2] = forceAndTorque.frame_a.R.T[3,2];
//   forceAndTorque.basicForce.frame_a.R.T[1,3] = forceAndTorque.basicTorque.frame_a.R.T[1,3];
//   forceAndTorque.basicForce.frame_a.R.T[1,3] = forceAndTorque.frame_a.R.T[1,3];
//   forceAndTorque.basicForce.frame_a.R.T[2,3] = forceAndTorque.basicTorque.frame_a.R.T[2,3];
//   forceAndTorque.basicForce.frame_a.R.T[2,3] = forceAndTorque.frame_a.R.T[2,3];
//   forceAndTorque.basicForce.frame_a.R.T[3,3] = forceAndTorque.basicTorque.frame_a.R.T[3,3];
//   forceAndTorque.basicForce.frame_a.R.T[3,3] = forceAndTorque.frame_a.R.T[3,3];
//   forceAndTorque.basicForce.frame_a.R.w[1] = forceAndTorque.basicTorque.frame_a.R.w[1];
//   forceAndTorque.basicForce.frame_a.R.w[1] = forceAndTorque.frame_a.R.w[1];
//   forceAndTorque.basicForce.frame_a.R.w[2] = forceAndTorque.basicTorque.frame_a.R.w[2];
//   forceAndTorque.basicForce.frame_a.R.w[2] = forceAndTorque.frame_a.R.w[2];
//   forceAndTorque.basicForce.frame_a.R.w[3] = forceAndTorque.basicTorque.frame_a.R.w[3];
//   forceAndTorque.basicForce.frame_a.R.w[3] = forceAndTorque.frame_a.R.w[3];
//   forceAndTorque.basicForce.frame_b.r_0[1] = forceAndTorque.basicTorque.frame_b.r_0[1];
//   forceAndTorque.basicForce.frame_b.r_0[1] = forceAndTorque.frame_b.r_0[1];
//   forceAndTorque.basicForce.frame_b.r_0[2] = forceAndTorque.basicTorque.frame_b.r_0[2];
//   forceAndTorque.basicForce.frame_b.r_0[2] = forceAndTorque.frame_b.r_0[2];
//   forceAndTorque.basicForce.frame_b.r_0[3] = forceAndTorque.basicTorque.frame_b.r_0[3];
//   forceAndTorque.basicForce.frame_b.r_0[3] = forceAndTorque.frame_b.r_0[3];
//   forceAndTorque.basicForce.frame_b.R.T[1,1] = forceAndTorque.basicTorque.frame_b.R.T[1,1];
//   forceAndTorque.basicForce.frame_b.R.T[1,1] = forceAndTorque.frame_b.R.T[1,1];
//   forceAndTorque.basicForce.frame_b.R.T[2,1] = forceAndTorque.basicTorque.frame_b.R.T[2,1];
//   forceAndTorque.basicForce.frame_b.R.T[2,1] = forceAndTorque.frame_b.R.T[2,1];
//   forceAndTorque.basicForce.frame_b.R.T[3,1] = forceAndTorque.basicTorque.frame_b.R.T[3,1];
//   forceAndTorque.basicForce.frame_b.R.T[3,1] = forceAndTorque.frame_b.R.T[3,1];
//   forceAndTorque.basicForce.frame_b.R.T[1,2] = forceAndTorque.basicTorque.frame_b.R.T[1,2];
//   forceAndTorque.basicForce.frame_b.R.T[1,2] = forceAndTorque.frame_b.R.T[1,2];
//   forceAndTorque.basicForce.frame_b.R.T[2,2] = forceAndTorque.basicTorque.frame_b.R.T[2,2];
//   forceAndTorque.basicForce.frame_b.R.T[2,2] = forceAndTorque.frame_b.R.T[2,2];
//   forceAndTorque.basicForce.frame_b.R.T[3,2] = forceAndTorque.basicTorque.frame_b.R.T[3,2];
//   forceAndTorque.basicForce.frame_b.R.T[3,2] = forceAndTorque.frame_b.R.T[3,2];
//   forceAndTorque.basicForce.frame_b.R.T[1,3] = forceAndTorque.basicTorque.frame_b.R.T[1,3];
//   forceAndTorque.basicForce.frame_b.R.T[1,3] = forceAndTorque.frame_b.R.T[1,3];
//   forceAndTorque.basicForce.frame_b.R.T[2,3] = forceAndTorque.basicTorque.frame_b.R.T[2,3];
//   forceAndTorque.basicForce.frame_b.R.T[2,3] = forceAndTorque.frame_b.R.T[2,3];
//   forceAndTorque.basicForce.frame_b.R.T[3,3] = forceAndTorque.basicTorque.frame_b.R.T[3,3];
//   forceAndTorque.basicForce.frame_b.R.T[3,3] = forceAndTorque.frame_b.R.T[3,3];
//   forceAndTorque.basicForce.frame_b.R.w[1] = forceAndTorque.basicTorque.frame_b.R.w[1];
//   forceAndTorque.basicForce.frame_b.R.w[1] = forceAndTorque.frame_b.R.w[1];
//   forceAndTorque.basicForce.frame_b.R.w[2] = forceAndTorque.basicTorque.frame_b.R.w[2];
//   forceAndTorque.basicForce.frame_b.R.w[2] = forceAndTorque.frame_b.R.w[2];
//   forceAndTorque.basicForce.frame_b.R.w[3] = forceAndTorque.basicTorque.frame_b.R.w[3];
//   forceAndTorque.basicForce.frame_b.R.w[3] = forceAndTorque.frame_b.R.w[3];
//   forceAndTorque.basicForce.force[1] = forceAndTorque.force[1];
//   forceAndTorque.basicForce.force[2] = forceAndTorque.force[2];
//   forceAndTorque.basicForce.force[3] = forceAndTorque.force[3];
//   forceAndTorque.basicTorque.torque[1] = forceAndTorque.torque[1];
//   forceAndTorque.basicTorque.torque[2] = forceAndTorque.torque[2];
//   forceAndTorque.basicTorque.torque[3] = forceAndTorque.torque[3];
//   forceAndTorque.basicForce.frame_resolve.r_0[1] = forceAndTorque.basicTorque.frame_resolve.r_0[1];
//   forceAndTorque.basicForce.frame_resolve.r_0[1] = forceAndTorque.frame_resolve.r_0[1];
//   forceAndTorque.basicForce.frame_resolve.r_0[2] = forceAndTorque.basicTorque.frame_resolve.r_0[2];
//   forceAndTorque.basicForce.frame_resolve.r_0[2] = forceAndTorque.frame_resolve.r_0[2];
//   forceAndTorque.basicForce.frame_resolve.r_0[3] = forceAndTorque.basicTorque.frame_resolve.r_0[3];
//   forceAndTorque.basicForce.frame_resolve.r_0[3] = forceAndTorque.frame_resolve.r_0[3];
//   forceAndTorque.basicForce.frame_resolve.R.T[1,1] = forceAndTorque.basicTorque.frame_resolve.R.T[1,1];
//   forceAndTorque.basicForce.frame_resolve.R.T[1,1] = forceAndTorque.frame_resolve.R.T[1,1];
//   forceAndTorque.basicForce.frame_resolve.R.T[2,1] = forceAndTorque.basicTorque.frame_resolve.R.T[2,1];
//   forceAndTorque.basicForce.frame_resolve.R.T[2,1] = forceAndTorque.frame_resolve.R.T[2,1];
//   forceAndTorque.basicForce.frame_resolve.R.T[3,1] = forceAndTorque.basicTorque.frame_resolve.R.T[3,1];
//   forceAndTorque.basicForce.frame_resolve.R.T[3,1] = forceAndTorque.frame_resolve.R.T[3,1];
//   forceAndTorque.basicForce.frame_resolve.R.T[1,2] = forceAndTorque.basicTorque.frame_resolve.R.T[1,2];
//   forceAndTorque.basicForce.frame_resolve.R.T[1,2] = forceAndTorque.frame_resolve.R.T[1,2];
//   forceAndTorque.basicForce.frame_resolve.R.T[2,2] = forceAndTorque.basicTorque.frame_resolve.R.T[2,2];
//   forceAndTorque.basicForce.frame_resolve.R.T[2,2] = forceAndTorque.frame_resolve.R.T[2,2];
//   forceAndTorque.basicForce.frame_resolve.R.T[3,2] = forceAndTorque.basicTorque.frame_resolve.R.T[3,2];
//   forceAndTorque.basicForce.frame_resolve.R.T[3,2] = forceAndTorque.frame_resolve.R.T[3,2];
//   forceAndTorque.basicForce.frame_resolve.R.T[1,3] = forceAndTorque.basicTorque.frame_resolve.R.T[1,3];
//   forceAndTorque.basicForce.frame_resolve.R.T[1,3] = forceAndTorque.frame_resolve.R.T[1,3];
//   forceAndTorque.basicForce.frame_resolve.R.T[2,3] = forceAndTorque.basicTorque.frame_resolve.R.T[2,3];
//   forceAndTorque.basicForce.frame_resolve.R.T[2,3] = forceAndTorque.frame_resolve.R.T[2,3];
//   forceAndTorque.basicForce.frame_resolve.R.T[3,3] = forceAndTorque.basicTorque.frame_resolve.R.T[3,3];
//   forceAndTorque.basicForce.frame_resolve.R.T[3,3] = forceAndTorque.frame_resolve.R.T[3,3];
//   forceAndTorque.basicForce.frame_resolve.R.w[1] = forceAndTorque.basicTorque.frame_resolve.R.w[1];
//   forceAndTorque.basicForce.frame_resolve.R.w[1] = forceAndTorque.frame_resolve.R.w[1];
//   forceAndTorque.basicForce.frame_resolve.R.w[2] = forceAndTorque.basicTorque.frame_resolve.R.w[2];
//   forceAndTorque.basicForce.frame_resolve.R.w[2] = forceAndTorque.frame_resolve.R.w[2];
//   forceAndTorque.basicForce.frame_resolve.R.w[3] = forceAndTorque.basicTorque.frame_resolve.R.w[3];
//   forceAndTorque.basicForce.frame_resolve.R.w[3] = forceAndTorque.frame_resolve.R.w[3];
//   revolute2.frame_a.t[1] + revolute1.frame_b.t[1] = 0.0;
//   revolute2.frame_a.t[2] + revolute1.frame_b.t[2] = 0.0;
//   revolute2.frame_a.t[3] + revolute1.frame_b.t[3] = 0.0;
//   revolute2.frame_a.f[1] + revolute1.frame_b.f[1] = 0.0;
//   revolute2.frame_a.f[2] + revolute1.frame_b.f[2] = 0.0;
//   revolute2.frame_a.f[3] + revolute1.frame_b.f[3] = 0.0;
//   revolute2.fixed.flange.tau = 0.0;
//   revolute2.constantTorque.flange.tau + revolute2.internalAxis.flange.tau = 0.0;
//   revolute2.constantTorque.flange.phi = revolute2.internalAxis.flange.phi;
//   revolute1.fixed.flange.tau = 0.0;
//   revolute1.constantTorque.flange.tau + revolute1.internalAxis.flange.tau = 0.0;
//   revolute1.constantTorque.flange.phi = revolute1.internalAxis.flange.phi;
//   body.frame_a.r_0[1] = revolute2.frame_b.r_0[1];
//   body.frame_a.r_0[2] = revolute2.frame_b.r_0[2];
//   body.frame_a.r_0[3] = revolute2.frame_b.r_0[3];
//   body.frame_a.R.T[1,1] = revolute2.frame_b.R.T[1,1];
//   body.frame_a.R.T[2,1] = revolute2.frame_b.R.T[2,1];
//   body.frame_a.R.T[3,1] = revolute2.frame_b.R.T[3,1];
//   body.frame_a.R.T[1,2] = revolute2.frame_b.R.T[1,2];
//   body.frame_a.R.T[2,2] = revolute2.frame_b.R.T[2,2];
//   body.frame_a.R.T[3,2] = revolute2.frame_b.R.T[3,2];
//   body.frame_a.R.T[1,3] = revolute2.frame_b.R.T[1,3];
//   body.frame_a.R.T[2,3] = revolute2.frame_b.R.T[2,3];
//   body.frame_a.R.T[3,3] = revolute2.frame_b.R.T[3,3];
//   body.frame_a.R.w[1] = revolute2.frame_b.R.w[1];
//   body.frame_a.R.w[2] = revolute2.frame_b.R.w[2];
//   body.frame_a.R.w[3] = revolute2.frame_b.R.w[3];
//   body.frame_b.r_0[1] = forceAndTorque.frame_b.r_0[1];
//   body.frame_b.r_0[2] = forceAndTorque.frame_b.r_0[2];
//   body.frame_b.r_0[3] = forceAndTorque.frame_b.r_0[3];
//   body.frame_b.R.T[1,1] = forceAndTorque.frame_b.R.T[1,1];
//   body.frame_b.R.T[2,1] = forceAndTorque.frame_b.R.T[2,1];
//   body.frame_b.R.T[3,1] = forceAndTorque.frame_b.R.T[3,1];
//   body.frame_b.R.T[1,2] = forceAndTorque.frame_b.R.T[1,2];
//   body.frame_b.R.T[2,2] = forceAndTorque.frame_b.R.T[2,2];
//   body.frame_b.R.T[3,2] = forceAndTorque.frame_b.R.T[3,2];
//   body.frame_b.R.T[1,3] = forceAndTorque.frame_b.R.T[1,3];
//   body.frame_b.R.T[2,3] = forceAndTorque.frame_b.R.T[2,3];
//   body.frame_b.R.T[3,3] = forceAndTorque.frame_b.R.T[3,3];
//   body.frame_b.R.w[1] = forceAndTorque.frame_b.R.w[1];
//   body.frame_b.R.w[2] = forceAndTorque.frame_b.R.w[2];
//   body.frame_b.R.w[3] = forceAndTorque.frame_b.R.w[3];
//   fixed1.frame_b.r_0[1] = fixedRotation.frame_a.r_0[1];
//   fixed1.frame_b.r_0[1] = revolute1.frame_a.r_0[1];
//   fixed1.frame_b.r_0[2] = fixedRotation.frame_a.r_0[2];
//   fixed1.frame_b.r_0[2] = revolute1.frame_a.r_0[2];
//   fixed1.frame_b.r_0[3] = fixedRotation.frame_a.r_0[3];
//   fixed1.frame_b.r_0[3] = revolute1.frame_a.r_0[3];
//   fixed1.frame_b.R.T[1,1] = fixedRotation.frame_a.R.T[1,1];
//   fixed1.frame_b.R.T[1,1] = revolute1.frame_a.R.T[1,1];
//   fixed1.frame_b.R.T[2,1] = fixedRotation.frame_a.R.T[2,1];
//   fixed1.frame_b.R.T[2,1] = revolute1.frame_a.R.T[2,1];
//   fixed1.frame_b.R.T[3,1] = fixedRotation.frame_a.R.T[3,1];
//   fixed1.frame_b.R.T[3,1] = revolute1.frame_a.R.T[3,1];
//   fixed1.frame_b.R.T[1,2] = fixedRotation.frame_a.R.T[1,2];
//   fixed1.frame_b.R.T[1,2] = revolute1.frame_a.R.T[1,2];
//   fixed1.frame_b.R.T[2,2] = fixedRotation.frame_a.R.T[2,2];
//   fixed1.frame_b.R.T[2,2] = revolute1.frame_a.R.T[2,2];
//   fixed1.frame_b.R.T[3,2] = fixedRotation.frame_a.R.T[3,2];
//   fixed1.frame_b.R.T[3,2] = revolute1.frame_a.R.T[3,2];
//   fixed1.frame_b.R.T[1,3] = fixedRotation.frame_a.R.T[1,3];
//   fixed1.frame_b.R.T[1,3] = revolute1.frame_a.R.T[1,3];
//   fixed1.frame_b.R.T[2,3] = fixedRotation.frame_a.R.T[2,3];
//   fixed1.frame_b.R.T[2,3] = revolute1.frame_a.R.T[2,3];
//   fixed1.frame_b.R.T[3,3] = fixedRotation.frame_a.R.T[3,3];
//   fixed1.frame_b.R.T[3,3] = revolute1.frame_a.R.T[3,3];
//   fixed1.frame_b.R.w[1] = fixedRotation.frame_a.R.w[1];
//   fixed1.frame_b.R.w[1] = revolute1.frame_a.R.w[1];
//   fixed1.frame_b.R.w[2] = fixedRotation.frame_a.R.w[2];
//   fixed1.frame_b.R.w[2] = revolute1.frame_a.R.w[2];
//   fixed1.frame_b.R.w[3] = fixedRotation.frame_a.R.w[3];
//   fixed1.frame_b.R.w[3] = revolute1.frame_a.R.w[3];
//   revolute1.frame_b.r_0[1] = revolute2.frame_a.r_0[1];
//   revolute1.frame_b.r_0[2] = revolute2.frame_a.r_0[2];
//   revolute1.frame_b.r_0[3] = revolute2.frame_a.r_0[3];
//   revolute1.frame_b.R.T[1,1] = revolute2.frame_a.R.T[1,1];
//   revolute1.frame_b.R.T[2,1] = revolute2.frame_a.R.T[2,1];
//   revolute1.frame_b.R.T[3,1] = revolute2.frame_a.R.T[3,1];
//   revolute1.frame_b.R.T[1,2] = revolute2.frame_a.R.T[1,2];
//   revolute1.frame_b.R.T[2,2] = revolute2.frame_a.R.T[2,2];
//   revolute1.frame_b.R.T[3,2] = revolute2.frame_a.R.T[3,2];
//   revolute1.frame_b.R.T[1,3] = revolute2.frame_a.R.T[1,3];
//   revolute1.frame_b.R.T[2,3] = revolute2.frame_a.R.T[2,3];
//   revolute1.frame_b.R.T[3,3] = revolute2.frame_a.R.T[3,3];
//   revolute1.frame_b.R.w[1] = revolute2.frame_a.R.w[1];
//   revolute1.frame_b.R.w[2] = revolute2.frame_a.R.w[2];
//   revolute1.frame_b.R.w[3] = revolute2.frame_a.R.w[3];
//   fixed2.frame_b.r_0[1] = forceAndTorque.frame_a.r_0[1];
//   fixed2.frame_b.r_0[2] = forceAndTorque.frame_a.r_0[2];
//   fixed2.frame_b.r_0[3] = forceAndTorque.frame_a.r_0[3];
//   fixed2.frame_b.R.T[1,1] = forceAndTorque.frame_a.R.T[1,1];
//   fixed2.frame_b.R.T[2,1] = forceAndTorque.frame_a.R.T[2,1];
//   fixed2.frame_b.R.T[3,1] = forceAndTorque.frame_a.R.T[3,1];
//   fixed2.frame_b.R.T[1,2] = forceAndTorque.frame_a.R.T[1,2];
//   fixed2.frame_b.R.T[2,2] = forceAndTorque.frame_a.R.T[2,2];
//   fixed2.frame_b.R.T[3,2] = forceAndTorque.frame_a.R.T[3,2];
//   fixed2.frame_b.R.T[1,3] = forceAndTorque.frame_a.R.T[1,3];
//   fixed2.frame_b.R.T[2,3] = forceAndTorque.frame_a.R.T[2,3];
//   fixed2.frame_b.R.T[3,3] = forceAndTorque.frame_a.R.T[3,3];
//   fixed2.frame_b.R.w[1] = forceAndTorque.frame_a.R.w[1];
//   fixed2.frame_b.R.w[2] = forceAndTorque.frame_a.R.w[2];
//   fixed2.frame_b.R.w[3] = forceAndTorque.frame_a.R.w[3];
//   fixedRotation.frame_b.r_0[1] = forceAndTorque.frame_resolve.r_0[1];
//   fixedRotation.frame_b.r_0[2] = forceAndTorque.frame_resolve.r_0[2];
//   fixedRotation.frame_b.r_0[3] = forceAndTorque.frame_resolve.r_0[3];
//   fixedRotation.frame_b.R.T[1,1] = forceAndTorque.frame_resolve.R.T[1,1];
//   fixedRotation.frame_b.R.T[2,1] = forceAndTorque.frame_resolve.R.T[2,1];
//   fixedRotation.frame_b.R.T[3,1] = forceAndTorque.frame_resolve.R.T[3,1];
//   fixedRotation.frame_b.R.T[1,2] = forceAndTorque.frame_resolve.R.T[1,2];
//   fixedRotation.frame_b.R.T[2,2] = forceAndTorque.frame_resolve.R.T[2,2];
//   fixedRotation.frame_b.R.T[3,2] = forceAndTorque.frame_resolve.R.T[3,2];
//   fixedRotation.frame_b.R.T[1,3] = forceAndTorque.frame_resolve.R.T[1,3];
//   fixedRotation.frame_b.R.T[2,3] = forceAndTorque.frame_resolve.R.T[2,3];
//   fixedRotation.frame_b.R.T[3,3] = forceAndTorque.frame_resolve.R.T[3,3];
//   fixedRotation.frame_b.R.w[1] = forceAndTorque.frame_resolve.R.w[1];
//   fixedRotation.frame_b.R.w[2] = forceAndTorque.frame_resolve.R.w[2];
//   fixedRotation.frame_b.R.w[3] = forceAndTorque.frame_resolve.R.w[3];
//   forceAndTorque.force[1] = force[1].y;
//   forceAndTorque.force[2] = force[2].y;
//   forceAndTorque.force[3] = force[3].y;
//   forceAndTorque.torque[1] = torque[1].y;
//   forceAndTorque.torque[2] = torque[2].y;
//   forceAndTorque.torque[3] = torque[3].y;
// end Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque has 2337 equation(s) and 2337 variable(s).
// 1467 of these are trivial equation(s).
// "
// ""
// endResult
