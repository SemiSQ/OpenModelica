// name:     Modelica3.x.Mechanics.MultiBody.Examples.Loops.Engine1b
// keywords: multibody, balancing, instantiation
// status:   correct
// teardown_command: rm -f *.so *.dll *.log *.c* *.makefile *.libs
// 
//  Modelica MultiBody 3.x: instantiation and balance checking
//

loadFile("_LoopsTotal.mo");
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b);
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b);
getErrorString();

// Result:
// true
// ""
// "function Modelica.Math.Vectors.length
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
// input Real[3, 3] T;
// input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
// output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint \"Inline before index reduction\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Real[3] residue \"The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)\";
// algorithm
//   residue := {atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3],R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]),atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3],R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]),atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3],R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[4] der_Q(unit = \"1/s\") \"Derivative of Q\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {2.0 * (Q[4] * der_Q[1] + Q[3] * der_Q[2] + -Q[2] * der_Q[3] + -Q[1] * der_Q[4]),2.0 * (-Q[3] * der_Q[1] + Q[4] * der_Q[2] + Q[1] * der_Q[3] + -Q[2] * der_Q[4]),2.0 * (Q[2] * der_Q[1] + -Q[1] * der_Q[2] + Q[4] * der_Q[3] + -Q[3] * der_Q[4])};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for Q (there are 2 solutions; the one close to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)\";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04;
// algorithm
//   c1 := (1.0 + T[1,1]) - T[2,2] - T[3,3];
//   c2 := (1.0 + T[2,2]) - T[1,1] - T[3,3];
//   c3 := (1.0 + T[3,3]) - T[1,1] - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04 OR c4 > c1 AND c4 > c2 AND c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4,(T[1,2] - T[2,1]) / paux4,paux};
//   elseif c1 > c2 AND c1 > c3 AND c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux,(T[1,2] + T[2,1]) / paux4,(T[1,3] + T[3,1]) / paux4,(T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 AND c2 > c3 AND c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4,paux,(T[2,3] + T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4,(T[2,3] + T[3,2]) / paux4,paux,(T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1],Q[2],Q[3],Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := {0.0,0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint \"Inline before index reduction\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   output Real[1] residue \"Residue constraint (shall be zero)\";
// algorithm
//   residue := {(Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation
//   input Real[3, 3] T1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Real[3, 3] T_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3, 3] T2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   T2 := <matrix>[T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1],T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2],T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3];T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1],T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2],T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3];T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1],T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2],T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation
//   input Integer axis(min = 1, max = 3) \"Rotate around 'axis' of frame 1\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := if axis == 1 then <matrix>[1.0,0.0,0.0;0.0,cos(angle),sin(angle);0.0,-sin(angle),cos(angle)] else if axis == 2 then <matrix>[cos(angle),0.0,-sin(angle);0.0,1.0,0.0;sin(angle),0.0,cos(angle)] else <matrix>[cos(angle),sin(angle),0.0;-sin(angle),cos(angle),0.0;0.0,0.0,1.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else DAE.CAST(/tp:REAL[3]/, if abs(e_x[1]) > 1e-06 then {0,1,0} else {1,0,0});
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   T := <matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := <matrix>[e[1] ^ 2.0 + cos(angle) * (1.0 - e[1] ^ 2.0),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] ^ 2.0 + cos(angle) * (1.0 - e[2] ^ 2.0),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] ^ 2.0 + cos(angle) * (1.0 - e[3] ^ 2.0)];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3],T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3],T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1],R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2],R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3];R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1],R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2],R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3];R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1],R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2],R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]],Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel,{R1.w[1],R1.w[2],R1.w[3]}) + {R_rel.w[1],R_rel.w[2],R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 \"Inline before index reduction\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {R.w[1],R.w[2],R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence'\";
//   input Real[3] der_angles(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angles)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1],angles[1]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real guessAngle1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Select angles[1] such that |angles[1] - guessAngle1| is a minimum\";
//   output Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi\";
//   protected Real[3] e1_1(unit = \"1\") \"First rotation axis, resolved in frame 1\";
//   protected Real[3] e2_1a(unit = \"1\") \"Second rotation axis, resolved in frame 1a\";
//   protected Real[3] e3_1(unit = \"1\") \"Third rotation axis, resolved in frame 1\";
//   protected Real[3] e3_2(unit = \"1\") \"Third rotation axis, resolved in frame 2\";
//   protected Real A \"Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real B \"Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real angle_1a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 1 for angles[1]\";
//   protected Real angle_1b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 2 for angles[1]\";
//   protected Real[3, 3] T_1a \"Orientation object to rotate frame 1 into frame 1a\";
// algorithm
//   assert( sequence[1] <> sequence[2] AND sequence[2] <> sequence[3], \"input argument 'sequence[1:3]' is not valid\");
//   e1_1 := /*/tp:REAL[3]/*/(if sequence[1] == 1 then {1,0,0} else if sequence[1] == 2 then {0,1,0} else {0,0,1});
//   e2_1a := /*/tp:REAL[3]/*/(if sequence[2] == 1 then {1,0,0} else if sequence[2] == 2 then {0,1,0} else {0,0,1});
//   e3_1 := {R.T[sequence[3],1],R.T[sequence[3],2],R.T[sequence[3],3]};
//   e3_2 := /*/tp:REAL[3]/*/(if sequence[3] == 1 then {1,0,0} else if sequence[3] == 2 then {0,1,0} else {0,0,1});
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 1e-12 AND abs(B) <= 1e-12 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := atan2(A,-B);
//     angle_1b := atan2(-A,B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1],e1_1[2],e1_1[3]},angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e3_1[1],e3_1[2],e3_1[3]}),{e3_2[1],e3_2[2],e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1],e3_2[2],e3_2[3]},{e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e2_1a[1],e2_1a[2],e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis
//   input Integer axis(min = 1, max = 3) \"Axis vector to be returned\";
//   output Real[3] e(unit = \"1\") \"Unit axis vector\";
// algorithm
//   e := /*/tp:REAL[3]/*/(if axis == 1 then {1,0,0} else if axis == 2 then {0,1,0} else {0,0,1});
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[2.0 * (Q[1] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[1] * Q[2] + Q[3] * Q[4]),2.0 * (Q[1] * Q[3] - Q[2] * Q[4]);2.0 * (Q[2] * Q[1] - Q[3] * Q[4]),2.0 * (Q[2] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[2] * Q[3] + Q[1] * Q[4]);2.0 * (Q[3] * Q[1] + Q[2] * Q[4]),2.0 * (Q[3] * Q[2] - Q[1] * Q[4]),2.0 * (Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_nxy
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else DAE.CAST(/tp:REAL[3]/, if abs(e_x[1]) > 1e-06 then {0,1,0} else {1,0,0});
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] ^ 2.0 + cos(angle) * (1.0 - e[1] ^ 2.0),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] ^ 2.0 + cos(angle) * (1.0 - e[2] ^ 2.0),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] ^ 2.0 + cos(angle) * (1.0 - e[3] ^ 2.0)],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)\";
//   input Real[3] v1 \"A vector v resolved in frame 1 (shall not be parallel to e)\";
//   input Real[3] v2 \"Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)\";
//   output Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi\";
// algorithm
//   angle := atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3],(v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3]) - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.relativeRotation
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R_rel \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R_rel := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R2.T[1,1] * R1.T[1,1] + R2.T[1,2] * R1.T[1,2] + R2.T[1,3] * R1.T[1,3],R2.T[1,1] * R1.T[2,1] + R2.T[1,2] * R1.T[2,2] + R2.T[1,3] * R1.T[2,3],R2.T[1,1] * R1.T[3,1] + R2.T[1,2] * R1.T[3,2] + R2.T[1,3] * R1.T[3,3];R2.T[2,1] * R1.T[1,1] + R2.T[2,2] * R1.T[1,2] + R2.T[2,3] * R1.T[1,3],R2.T[2,1] * R1.T[2,1] + R2.T[2,2] * R1.T[2,2] + R2.T[2,3] * R1.T[2,3],R2.T[2,1] * R1.T[3,1] + R2.T[2,2] * R1.T[3,2] + R2.T[2,3] * R1.T[3,3];R2.T[3,1] * R1.T[1,1] + R2.T[3,2] * R1.T[1,2] + R2.T[3,3] * R1.T[1,3],R2.T[3,1] * R1.T[2,1] + R2.T[3,2] * R1.T[2,2] + R2.T[3,3] * R1.T[2,3],R2.T[3,1] * R1.T[3,1] + R2.T[3,2] * R1.T[3,2] + R2.T[3,3] * R1.T[3,3]],{R2.w[1],R2.w[2],R2.w[3]} - Modelica.Mechanics.MultiBody.Frames.resolve2(R2,Modelica.Mechanics.MultiBody.Frames.resolve1(R1,{R1.w[1],R1.w[2],R1.w[3]})));
// end Modelica.Mechanics.MultiBody.Frames.relativeRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3],R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3],R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3],R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3],R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolveDyade1
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3, 3] D2 \"Second order tensor resolved in frame 2\";
//   output Real[3, 3] D1 \"Second order tensor resolved in frame 1\";
// algorithm
//   D1 := <matrix>[(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,1] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,1] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,1],(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,2] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,2] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,2],(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,3] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,3] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,3];(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,1] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,1] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,1],(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,2] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,2] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,2],(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,3] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,3] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,3];(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,1] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,1] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,1],(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,2] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,2] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,2],(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,3] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,3] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.resolveDyade1;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],{Q_guess[1],Q_guess[2],Q_guess[3],Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration
//   input Real[3] r(quantity = \"Length\", unit = \"m\") \"Position vector from world frame to actual point, resolved in world frame\";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType \"Type of gravity field\";
//   input Real[3] g(quantity = \"Acceleration\", unit = \"m/s2\") \"Constant gravity acceleration, resolved in world frame, if gravityType=1\";
//   input Real mue(unit = \"m3/s2\") \"Field constant of point gravity field, if gravityType=2\";
//   output Real[3] gravity(quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration at point r, resolved in world frame\";
// algorithm
//   gravity := if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity then -{(mue * r[1]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[2]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[3]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial
//   input Real material1;
//   input Real material2;
//   input Real material3;
//   input Real sp;
//   output Real mat;
// algorithm
//   mat := material1 + material2 + material3 + sp;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b
//   Real world.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean world.enableAnimation = true \"= true, if animation of all components is enabled\";
//   parameter Boolean world.animateWorld = true \"= true, if world coordinate system shall be visualized\";
//   parameter Boolean world.animateGravity = true \"= true, if gravity field shall be visualized (acceleration vector or field center)\";
//   parameter String world.label1 = \"x\" \"Label of horizontal axis in icon\";
//   parameter String world.label2 = \"y\" \"Label of vertical axis in icon\";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity \"Type of gravity field\";
//   parameter Real world.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.81 \"Constant gravity acceleration\";
//   parameter Real world.n[1](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[2](unit = \"1\") = -1.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[3](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.mue(unit = \"m3/s2\", min = 0.0) = 398600000000000.0 \"Gravity field constant (default = field constant of earth)\";
//   parameter Boolean world.driveTrainMechanics3D = true \"= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account\";
//   parameter Real world.axisLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.nominalLength / 2.0 \"Length of world axes arrows\";
//   parameter Real world.axisDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction \"Diameter of world axes arrows\";
//   parameter Boolean world.axisShowLabels = true \"= true, if labels shall be shown\";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of z-arrow\";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of z-arrow\";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of z-arrow\";
//   parameter Real world.gravityArrowTail[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowLength(quantity = \"Length\", unit = \"m\") = world.axisLength / 2.0 \"Length of gravity arrow\";
//   parameter Real world.gravityArrowDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction \"Diameter of gravity arrow\";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   parameter Real world.gravitySphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 12742000.0 \"Diameter of sphere representing gravity center (default = mean diameter of earth)\";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   parameter Real world.nominalLength(quantity = \"Length\", unit = \"m\") = 1.0 \"\\\"Nominal\\\" length of multi-body system\";
//   parameter Real world.defaultAxisLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 5.0 \"Default for length of a frame axis (but not world frame)\";
//   parameter Real world.defaultJointLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a joint\";
//   parameter Real world.defaultJointWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape representing a joint\";
//   parameter Real world.defaultForceLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a force (e.g. damper)\";
//   parameter Real world.defaultForceWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape represening a force (e.g. spring, bushing)\";
//   parameter Real world.defaultBodyDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 9.0 \"Default for diameter of sphere representing the center of mass of a body\";
//   parameter Real world.defaultWidthFraction = 20.0 \"Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)\";
//   parameter Real world.defaultArrowDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 40.0 \"Default for arrow diameter (e.g., of forces, torques, sensors)\";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 \"Default for arrow diameter of a coordinate system as a fraction of axis length\";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 \"Default reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real world.defaultN_to_m(unit = \"N/m\", min = 0.0) = 1000.0 \"Default scaling of force arrows (length = force/defaultN_to_m)\";
//   parameter Real world.defaultNm_to_m(unit = \"N.m/m\", min = 0.0) = 1000.0 \"Default scaling of torque arrows (length = torque/defaultNm_to_m)\";
//   protected parameter Integer world.ndim = if world.enableAnimation AND world.animateWorld then 1 else 0;
//   protected parameter Integer world.ndim2 = if world.enableAnimation AND world.animateWorld AND world.axisShowLabels then 1 else 0;
//   protected parameter Real world.headLength(quantity = \"Length\", unit = \"m\") = min(world.axisLength,5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.axisLength - world.headLength);
//   protected parameter Real world.lineWidth(quantity = \"Length\", unit = \"m\") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   protected parameter Real world.labelStart(quantity = \"Length\", unit = \"m\") = 1.05 * world.axisLength;
//   protected parameter Real world.gravityHeadLength(quantity = \"Length\", unit = \"m\") = min(world.gravityArrowLength,4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.gravityArrowLength - world.gravityHeadLength);
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation AND world.animateGravity AND world.gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then 1 else 0;
//   parameter String world.x_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.x_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.x_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.x_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1],world.x_arrowLine.lengthDirection[2],world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = \"1\") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = \"1\") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = \"1\") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.x_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.x_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.x_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1],world.x_arrowHead.lengthDirection[2],world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = \"1\") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = \"1\") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = \"1\") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   input Real world.x_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r_lines[1](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[1](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of cylinders\";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of cylinders\";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of cylinders\";
//   input Real world.x_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected parameter Integer world.x_label.n = 2 \"Number of cylinders\";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][3];
//   protected Real world.x_label.r_abs[1](quantity = \"Length\", unit = \"m\") = world.x_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[1];
//   protected Real world.x_label.r_abs[2](quantity = \"Length\", unit = \"m\") = world.x_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[2];
//   protected Real world.x_label.r_abs[3](quantity = \"Length\", unit = \"m\") = world.x_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[3];
//   parameter String world.x_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[1].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1],world.x_label.cylinders[1].lengthDirection[2],world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[2].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1],world.x_label.cylinders[2].lengthDirection[2],world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   parameter String world.y_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.y_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.y_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.y_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1],world.y_arrowLine.lengthDirection[2],world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = \"1\") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = \"1\") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = \"1\") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.y_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.y_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.y_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1],world.y_arrowHead.lengthDirection[2],world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = \"1\") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = \"1\") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = \"1\") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   input Real world.y_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[2](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[2](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[1](unit = \"1\") = -1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[2](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = 0.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.75 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] \"Color of cylinders\";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] \"Color of cylinders\";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] \"Color of cylinders\";
//   input Real world.y_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected parameter Integer world.y_label.n = 2 \"Number of cylinders\";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][3];
//   protected Real world.y_label.r_abs[1](quantity = \"Length\", unit = \"m\") = world.y_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[1];
//   protected Real world.y_label.r_abs[2](quantity = \"Length\", unit = \"m\") = world.y_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[2];
//   protected Real world.y_label.r_abs[3](quantity = \"Length\", unit = \"m\") = world.y_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[3];
//   parameter String world.y_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[1].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1],world.y_label.cylinders[1].lengthDirection[2],world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[2].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1],world.y_label.cylinders[2].lengthDirection[2],world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   parameter String world.z_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.z_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.z_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.z_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1],world.z_arrowLine.lengthDirection[2],world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = \"1\") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = \"1\") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = \"1\") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.z_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.z_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.z_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1],world.z_arrowHead.lengthDirection[2],world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = \"1\") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = \"1\") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = \"1\") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   input Real world.z_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[3](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[3](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] \"Color of cylinders\";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] \"Color of cylinders\";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] \"Color of cylinders\";
//   input Real world.z_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected parameter Integer world.z_label.n = 3 \"Number of cylinders\";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][3];
//   protected Real world.z_label.r_abs[1](quantity = \"Length\", unit = \"m\") = world.z_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[1];
//   protected Real world.z_label.r_abs[2](quantity = \"Length\", unit = \"m\") = world.z_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[2];
//   protected Real world.z_label.r_abs[3](quantity = \"Length\", unit = \"m\") = world.z_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[3];
//   parameter String world.z_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[1].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1],world.z_label.cylinders[1].lengthDirection[2],world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[2].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1],world.z_label.cylinders[2].lengthDirection[2],world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[3].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].r[1](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[2](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[3](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[3].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[3].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[3].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1],world.z_label.cylinders[3].lengthDirection[2],world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   parameter String world.gravityArrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.length(quantity = \"Length\", unit = \"m\") = world.gravityLineLength \"Length of visual object\";
//   input Real world.gravityArrowLine.width(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Width of visual object\";
//   input Real world.gravityArrowLine.height(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Height of visual object\";
//   input Real world.gravityArrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowLine.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowLine.lengthDirection[1],world.gravityArrowLine.lengthDirection[2],world.gravityArrowLine.lengthDirection[3]});
//   protected Real world.gravityArrowLine.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 1.0 else world.gravityArrowLine.lengthDirection[1] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[2] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[3] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.n_z_aux[1](unit = \"1\") = world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[3] - world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[2];
//   protected Real world.gravityArrowLine.n_z_aux[2](unit = \"1\") = world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[1] - world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[3];
//   protected Real world.gravityArrowLine.n_z_aux[3](unit = \"1\") = world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[2] - world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[1];
//   protected Real world.gravityArrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[1];
//   protected Real world.gravityArrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[2];
//   protected Real world.gravityArrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[3];
//   protected output Real world.gravityArrowLine.Form;
//   output Real world.gravityArrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.Material;
//   protected output Real world.gravityArrowLine.Extra;
//   parameter String world.gravityArrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[1] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[1] * world.gravityLineLength \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[2] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[2] * world.gravityLineLength \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[3] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[3] * world.gravityLineLength \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.length(quantity = \"Length\", unit = \"m\") = world.gravityHeadLength \"Length of visual object\";
//   input Real world.gravityArrowHead.width(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Width of visual object\";
//   input Real world.gravityArrowHead.height(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Height of visual object\";
//   input Real world.gravityArrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowHead.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowHead.lengthDirection[1],world.gravityArrowHead.lengthDirection[2],world.gravityArrowHead.lengthDirection[3]});
//   protected Real world.gravityArrowHead.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 1.0 else world.gravityArrowHead.lengthDirection[1] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[2] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[3] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.n_z_aux[1](unit = \"1\") = world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[3] - world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[2];
//   protected Real world.gravityArrowHead.n_z_aux[2](unit = \"1\") = world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[1] - world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[3];
//   protected Real world.gravityArrowHead.n_z_aux[3](unit = \"1\") = world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[2] - world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[1];
//   protected Real world.gravityArrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[1];
//   protected Real world.gravityArrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[2];
//   protected Real world.gravityArrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[3];
//   protected output Real world.gravityArrowHead.Form;
//   output Real world.gravityArrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.Material;
//   protected output Real world.gravityArrowHead.Extra;
//   Real Piston.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Piston.animation = true \"= true, if animation shall be enabled (show cylinder between frame_a and frame_b)\";
//   parameter Real Piston.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Piston.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = -0.1 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Piston.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Piston.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Piston.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Piston.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Piston.lengthDirection[1](unit = \"1\") = Piston.r[1] - Piston.r_shape[1] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Piston.lengthDirection[2](unit = \"1\") = Piston.r[2] - Piston.r_shape[2] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Piston.lengthDirection[3](unit = \"1\") = Piston.r[3] - Piston.r_shape[3] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Piston.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Piston.r[1] - Piston.r_shape[1],Piston.r[2] - Piston.r_shape[2],Piston.r[3] - Piston.r_shape[3]}) \"Length of cylinder\";
//   parameter Real Piston.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Diameter of cylinder\";
//   parameter Real Piston.innerDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Inner diameter of cylinder (0 <= innerDiameter <= Diameter)\";
//   parameter Real Piston.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer Piston.color[1](min = 0, max = 255) = 0 \"Color of cylinder\";
//   input Integer Piston.color[2](min = 0, max = 255) = 128 \"Color of cylinder\";
//   input Integer Piston.color[3](min = 0, max = 255) = 255 \"Color of cylinder\";
//   input Real Piston.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Piston.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Piston.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Piston.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Piston.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Piston.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Piston.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Piston.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Piston.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Piston.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Piston.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Piston.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Piston.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Piston.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Piston.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Piston.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Piston.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Piston.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Piston.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Piston.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Piston.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Piston.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Piston.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Piston.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Piston.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean Piston.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Piston.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Piston.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Piston.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Piston.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   constant Real Piston.pi = 3.14159265358979;
//   parameter Real Piston.radius(quantity = \"Length\", unit = \"m\", min = 0.0) = Piston.diameter / 2.0 \"Radius of cylinder\";
//   parameter Real Piston.innerRadius(quantity = \"Length\", unit = \"m\", min = 0.0) = Piston.innerDiameter / 2.0 \"Inner-Radius of cylinder\";
//   parameter Real Piston.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.14159265358979 * (Piston.density * (Piston.length * Piston.radius ^ 2.0)) \"Mass of cylinder without hole\";
//   parameter Real Piston.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.14159265358979 * (Piston.density * (Piston.length * Piston.innerRadius ^ 2.0)) \"Mass of hole of cylinder\";
//   parameter Real Piston.I22(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.mo * (Piston.length ^ 2.0 + 3.0 * Piston.radius ^ 2.0) / 12.0 - Piston.mi * (Piston.length ^ 2.0 + 3.0 * Piston.innerRadius ^ 2.0) / 12.0 \"Inertia with respect to axis through center of mass, perpendicular to cylinder axis\";
//   parameter Real Piston.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Piston.mo - Piston.mi \"Mass of cylinder\";
//   parameter Real Piston.R.T[1,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[1,2] = -1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[2,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[2,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[3,1] = -0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Piston.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Piston.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Piston.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Piston.r[1],Piston.r[2],Piston.r[3]},1e-13)[1] * Piston.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Piston.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Piston.r[1],Piston.r[2],Piston.r[3]},1e-13)[2] * Piston.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Piston.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Piston.r[1],Piston.r[2],Piston.r[3]},1e-13)[3] * Piston.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Piston.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[1][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[1][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[1][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[2][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[2][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[2][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[3][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[3][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Piston.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Piston.R,{{Piston.mo * Piston.radius ^ 2.0 / 2.0 - Piston.mi * Piston.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Piston.I22,0.0},{0.0,0.0,Piston.I22}})[3][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   Real Piston.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Piston.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real Piston.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Piston.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Piston.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Piston.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Piston.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Piston.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Piston.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = Piston.m \"Mass of rigid body\";
//   parameter Real Piston.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Piston.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real Piston.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Piston.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real Piston.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Piston.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real Piston.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Piston.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real Piston.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Piston.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real Piston.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Piston.I[3,2] \" (3,2) element of inertia tensor\";
//   Real Piston.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Piston.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Piston.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Piston.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Piston.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Piston.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Piston.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Piston.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Piston.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Piston.body.angles_fixed = Piston.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Piston.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Piston.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Piston.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Piston.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Piston.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Piston.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Piston.body.sequence_start[1](min = 1, max = 3) = Piston.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Piston.body.sequence_start[2](min = 1, max = 3) = Piston.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Piston.body.sequence_start[3](min = 1, max = 3) = Piston.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Piston.body.w_0_fixed = Piston.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Piston.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = Piston.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Piston.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = Piston.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Piston.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = Piston.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Piston.body.z_0_fixed = Piston.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Piston.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Piston.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Piston.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Piston.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Piston.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Piston.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Piston.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer Piston.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer Piston.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer Piston.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   parameter Real Piston.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = Piston.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   input Integer Piston.body.cylinderColor[1](min = 0, max = 255) = Piston.body.sphereColor[1] \"Color of cylinder\";
//   input Integer Piston.body.cylinderColor[2](min = 0, max = 255) = Piston.body.sphereColor[2] \"Color of cylinder\";
//   input Integer Piston.body.cylinderColor[3](min = 0, max = 255) = Piston.body.sphereColor[3] \"Color of cylinder\";
//   input Real Piston.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean Piston.body.enforceStates = Piston.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Piston.body.useQuaternions = Piston.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Piston.body.sequence_angleStates[1](min = 1, max = 3) = Piston.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Piston.body.sequence_angleStates[2](min = 1, max = 3) = Piston.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Piston.body.sequence_angleStates[3](min = 1, max = 3) = Piston.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Piston.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_11 \"inertia tensor\";
//   parameter Real Piston.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_21 \"inertia tensor\";
//   parameter Real Piston.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_31 \"inertia tensor\";
//   parameter Real Piston.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_21 \"inertia tensor\";
//   parameter Real Piston.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_22 \"inertia tensor\";
//   parameter Real Piston.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_32 \"inertia tensor\";
//   parameter Real Piston.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_31 \"inertia tensor\";
//   parameter Real Piston.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_32 \"inertia tensor\";
//   parameter Real Piston.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Piston.body.I_33 \"inertia tensor\";
//   parameter Real Piston.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Piston.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Piston.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Piston.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Piston.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.z_0_start[1],Piston.body.z_0_start[2],Piston.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Piston.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.z_0_start[1],Piston.body.z_0_start[2],Piston.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Piston.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.z_0_start[1],Piston.body.z_0_start[2],Piston.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real Piston.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.w_0_start[1],Piston.body.w_0_start[2],Piston.body.w_0_start[3]})[1], fixed = Piston.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Piston.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.w_0_start[1],Piston.body.w_0_start[2],Piston.body.w_0_start[3]})[2], fixed = Piston.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Piston.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.w_0_start[1],Piston.body.w_0_start[2],Piston.body.w_0_start[3]})[3], fixed = Piston.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Piston.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.z_0_start[1],Piston.body.z_0_start[2],Piston.body.z_0_start[3]})[1], fixed = Piston.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Piston.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.z_0_start[1],Piston.body.z_0_start[2],Piston.body.z_0_start[3]})[2], fixed = Piston.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Piston.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.R_start,{Piston.body.z_0_start[1],Piston.body.z_0_start[2],Piston.body.z_0_start[3]})[3], fixed = Piston.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Piston.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Piston.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Piston.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected parameter Real Piston.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(Piston.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Piston.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(Piston.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Piston.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(Piston.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Piston.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(Piston.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected Real Piston.body.Q[1](start = Piston.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Piston.body.Q[2](start = Piston.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Piston.body.Q[3](start = Piston.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Piston.body.Q[4](start = Piston.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real Piston.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Piston.body.sequence_start[1] == Piston.body.sequence_angleStates[1] AND Piston.body.sequence_start[2] == Piston.body.sequence_angleStates[2] AND Piston.body.sequence_start[3] == Piston.body.sequence_angleStates[3] then Piston.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Piston.body.R_start,{Piston.body.sequence_angleStates[1],Piston.body.sequence_angleStates[2],Piston.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real Piston.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Piston.body.sequence_start[1] == Piston.body.sequence_angleStates[1] AND Piston.body.sequence_start[2] == Piston.body.sequence_angleStates[2] AND Piston.body.sequence_start[3] == Piston.body.sequence_angleStates[3] then Piston.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Piston.body.R_start,{Piston.body.sequence_angleStates[1],Piston.body.sequence_angleStates[2],Piston.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real Piston.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Piston.body.sequence_start[1] == Piston.body.sequence_angleStates[1] AND Piston.body.sequence_start[2] == Piston.body.sequence_angleStates[2] AND Piston.body.sequence_start[3] == Piston.body.sequence_angleStates[3] then Piston.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Piston.body.R_start,{Piston.body.sequence_angleStates[1],Piston.body.sequence_angleStates[2],Piston.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   protected Real Piston.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Piston.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Piston.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Piston.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Piston.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Piston.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Piston.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Piston.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Piston.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Piston.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Piston.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Piston.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   Real Piston.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Piston.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Piston.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Piston.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Piston.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Piston.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Piston.frameTranslation.animation = Piston.animation \"= true, if animation shall be enabled\";
//   parameter Real Piston.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Piston.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Piston.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Piston.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Piston.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Piston.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Piston.frameTranslation.shapeType = \"pipecylinder\" \" Type of shape\";
//   parameter Real Piston.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = Piston.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = Piston.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = Piston.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.lengthDirection[1](unit = \"1\") = Piston.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.lengthDirection[2](unit = \"1\") = Piston.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.lengthDirection[3](unit = \"1\") = Piston.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Piston.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Piston.length \" Length of shape\";
//   parameter Real Piston.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Piston.diameter \" Width of shape\";
//   parameter Real Piston.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Piston.diameter \" Height of shape.\";
//   parameter Real Piston.frameTranslation.extra = Piston.innerDiameter / Piston.diameter \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Piston.frameTranslation.color[1](min = 0, max = 255) = Piston.color[1] \" Color of shape\";
//   input Integer Piston.frameTranslation.color[2](min = 0, max = 255) = Piston.color[2] \" Color of shape\";
//   input Integer Piston.frameTranslation.color[3](min = 0, max = 255) = Piston.color[3] \" Color of shape\";
//   input Real Piston.frameTranslation.specularCoefficient = Piston.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Piston.frameTranslation.shape.shapeType = Piston.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Piston.frameTranslation.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Piston.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Piston.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Piston.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Piston.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Piston.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Piston.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Piston.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.lengthDirection[1](unit = \"1\") = Piston.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.lengthDirection[2](unit = \"1\") = Piston.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.lengthDirection[3](unit = \"1\") = Piston.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.widthDirection[1](unit = \"1\") = Piston.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.widthDirection[2](unit = \"1\") = Piston.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.widthDirection[3](unit = \"1\") = Piston.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Piston.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.length \"Length of visual object\";
//   input Real Piston.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.width \"Width of visual object\";
//   input Real Piston.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = Piston.frameTranslation.height \"Height of visual object\";
//   input Real Piston.frameTranslation.shape.extra = Piston.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real Piston.frameTranslation.shape.color[1] = Real(Piston.frameTranslation.color[1]) \"Color of shape\";
//   input Real Piston.frameTranslation.shape.color[2] = Real(Piston.frameTranslation.color[2]) \"Color of shape\";
//   input Real Piston.frameTranslation.shape.color[3] = Real(Piston.frameTranslation.color[3]) \"Color of shape\";
//   input Real Piston.frameTranslation.shape.specularCoefficient = Piston.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Piston.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Piston.frameTranslation.shape.lengthDirection[1],Piston.frameTranslation.shape.lengthDirection[2],Piston.frameTranslation.shape.lengthDirection[3]});
//   protected Real Piston.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(Piston.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else Piston.frameTranslation.shape.lengthDirection[1] / Piston.frameTranslation.shape.abs_n_x;
//   protected Real Piston.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(Piston.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Piston.frameTranslation.shape.lengthDirection[2] / Piston.frameTranslation.shape.abs_n_x;
//   protected Real Piston.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(Piston.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Piston.frameTranslation.shape.lengthDirection[3] / Piston.frameTranslation.shape.abs_n_x;
//   protected Real Piston.frameTranslation.shape.n_z_aux[1](unit = \"1\") = Piston.frameTranslation.shape.e_x[2] * Piston.frameTranslation.shape.widthDirection[3] - Piston.frameTranslation.shape.e_x[3] * Piston.frameTranslation.shape.widthDirection[2];
//   protected Real Piston.frameTranslation.shape.n_z_aux[2](unit = \"1\") = Piston.frameTranslation.shape.e_x[3] * Piston.frameTranslation.shape.widthDirection[1] - Piston.frameTranslation.shape.e_x[1] * Piston.frameTranslation.shape.widthDirection[3];
//   protected Real Piston.frameTranslation.shape.n_z_aux[3](unit = \"1\") = Piston.frameTranslation.shape.e_x[1] * Piston.frameTranslation.shape.widthDirection[2] - Piston.frameTranslation.shape.e_x[2] * Piston.frameTranslation.shape.widthDirection[1];
//   protected Real Piston.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Piston.frameTranslation.shape.e_x[1],Piston.frameTranslation.shape.e_x[2],Piston.frameTranslation.shape.e_x[3]},if noEvent(Piston.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Piston.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Piston.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Piston.frameTranslation.shape.widthDirection[1],Piston.frameTranslation.shape.widthDirection[2],Piston.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Piston.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Piston.frameTranslation.shape.e_x[1],Piston.frameTranslation.shape.e_x[2],Piston.frameTranslation.shape.e_x[3]})[1];
//   protected Real Piston.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Piston.frameTranslation.shape.e_x[1],Piston.frameTranslation.shape.e_x[2],Piston.frameTranslation.shape.e_x[3]},if noEvent(Piston.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Piston.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Piston.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Piston.frameTranslation.shape.widthDirection[1],Piston.frameTranslation.shape.widthDirection[2],Piston.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Piston.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Piston.frameTranslation.shape.e_x[1],Piston.frameTranslation.shape.e_x[2],Piston.frameTranslation.shape.e_x[3]})[2];
//   protected Real Piston.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Piston.frameTranslation.shape.e_x[1],Piston.frameTranslation.shape.e_x[2],Piston.frameTranslation.shape.e_x[3]},if noEvent(Piston.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Piston.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Piston.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Piston.frameTranslation.shape.widthDirection[1],Piston.frameTranslation.shape.widthDirection[2],Piston.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Piston.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Piston.frameTranslation.shape.e_x[1],Piston.frameTranslation.shape.e_x[2],Piston.frameTranslation.shape.e_x[3]})[3];
//   protected output Real Piston.frameTranslation.shape.Form;
//   output Real Piston.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Piston.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Piston.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Piston.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Piston.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Piston.frameTranslation.shape.Material;
//   protected output Real Piston.frameTranslation.shape.Extra;
//   Real Rod2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Rod2.animation = true \"= true, if animation shall be enabled (show box between frame_a and frame_b)\";
//   parameter Real Rod2.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.2 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Rod2.lengthDirection[1](unit = \"1\") = Rod2.r[1] - Rod2.r_shape[1] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Rod2.lengthDirection[2](unit = \"1\") = Rod2.r[2] - Rod2.r_shape[2] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Rod2.lengthDirection[3](unit = \"1\") = Rod2.r[3] - Rod2.r_shape[3] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Rod2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Rod2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Rod2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Rod2.r[1] - Rod2.r_shape[1],Rod2.r[2] - Rod2.r_shape[2],Rod2.r[3] - Rod2.r_shape[3]}) \"Length of box\";
//   parameter Real Rod2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Width of box\";
//   parameter Real Rod2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.06 \"Height of box\";
//   parameter Real Rod2.innerWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Width of inner box surface (0 <= innerWidth <= width)\";
//   parameter Real Rod2.innerHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod2.innerWidth \"Height of inner box surface (0 <= innerHeight <= height)\";
//   parameter Real Rod2.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer Rod2.color[1](min = 0, max = 255) = 0 \"Color of box\";
//   input Integer Rod2.color[2](min = 0, max = 255) = 0 \"Color of box\";
//   input Integer Rod2.color[3](min = 0, max = 255) = 200 \"Color of box\";
//   input Real Rod2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Rod2.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Rod2.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Rod2.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Rod2.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Rod2.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Rod2.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Rod2.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Rod2.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Rod2.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Rod2.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Rod2.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Rod2.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Rod2.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Rod2.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Rod2.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Rod2.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Rod2.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Rod2.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Rod2.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Rod2.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Rod2.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Rod2.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Rod2.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Rod2.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean Rod2.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Rod2.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Rod2.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Rod2.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Rod2.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Rod2.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Rod2.density * (Rod2.length * (Rod2.width * Rod2.height)) \"Mass of box without hole\";
//   parameter Real Rod2.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Rod2.density * (Rod2.length * (Rod2.innerWidth * Rod2.innerHeight)) \"Mass of hole of box\";
//   parameter Real Rod2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Rod2.mo - Rod2.mi \"Mass of box\";
//   parameter Real Rod2.R.T[1,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[1,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[2,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[2,2] = -0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.T[3,3] = -1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Rod2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Rod2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Rod2.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Rod2.r[1],Rod2.r[2],Rod2.r[3]},1e-13)[1] * Rod2.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Rod2.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Rod2.r[1],Rod2.r[2],Rod2.r[3]},1e-13)[2] * Rod2.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Rod2.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Rod2.r[1],Rod2.r[2],Rod2.r[3]},1e-13)[3] * Rod2.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Rod2.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[1][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[1][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[1][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[2][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[2][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[2][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[3][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[3][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Rod2.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Rod2.R,{{Rod2.mo * (Rod2.width ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.innerWidth ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.height ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Rod2.mo * (Rod2.length ^ 2.0 / 12.0 + Rod2.width ^ 2.0 / 12.0) - Rod2.mi * (Rod2.length ^ 2.0 / 12.0 + Rod2.innerWidth ^ 2.0 / 12.0)}})[3][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   Real Rod2.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Rod2.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real Rod2.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Rod2.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Rod2.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Rod2.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Rod2.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Rod2.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Rod2.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = Rod2.m \"Mass of rigid body\";
//   parameter Real Rod2.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Rod2.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real Rod2.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Rod2.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real Rod2.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Rod2.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real Rod2.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Rod2.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real Rod2.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Rod2.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real Rod2.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Rod2.I[3,2] \" (3,2) element of inertia tensor\";
//   Real Rod2.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Rod2.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Rod2.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Rod2.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Rod2.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Rod2.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Rod2.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Rod2.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Rod2.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Rod2.body.angles_fixed = Rod2.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Rod2.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Rod2.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Rod2.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Rod2.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Rod2.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Rod2.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Rod2.body.sequence_start[1](min = 1, max = 3) = Rod2.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Rod2.body.sequence_start[2](min = 1, max = 3) = Rod2.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Rod2.body.sequence_start[3](min = 1, max = 3) = Rod2.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Rod2.body.w_0_fixed = Rod2.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Rod2.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = Rod2.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Rod2.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = Rod2.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Rod2.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = Rod2.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Rod2.body.z_0_fixed = Rod2.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Rod2.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Rod2.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Rod2.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Rod2.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Rod2.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Rod2.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Rod2.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer Rod2.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer Rod2.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer Rod2.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   parameter Real Rod2.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod2.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   input Integer Rod2.body.cylinderColor[1](min = 0, max = 255) = Rod2.body.sphereColor[1] \"Color of cylinder\";
//   input Integer Rod2.body.cylinderColor[2](min = 0, max = 255) = Rod2.body.sphereColor[2] \"Color of cylinder\";
//   input Integer Rod2.body.cylinderColor[3](min = 0, max = 255) = Rod2.body.sphereColor[3] \"Color of cylinder\";
//   input Real Rod2.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean Rod2.body.enforceStates = Rod2.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Rod2.body.useQuaternions = Rod2.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Rod2.body.sequence_angleStates[1](min = 1, max = 3) = Rod2.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Rod2.body.sequence_angleStates[2](min = 1, max = 3) = Rod2.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Rod2.body.sequence_angleStates[3](min = 1, max = 3) = Rod2.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Rod2.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_11 \"inertia tensor\";
//   parameter Real Rod2.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_21 \"inertia tensor\";
//   parameter Real Rod2.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_31 \"inertia tensor\";
//   parameter Real Rod2.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_21 \"inertia tensor\";
//   parameter Real Rod2.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_22 \"inertia tensor\";
//   parameter Real Rod2.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_32 \"inertia tensor\";
//   parameter Real Rod2.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_31 \"inertia tensor\";
//   parameter Real Rod2.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_32 \"inertia tensor\";
//   parameter Real Rod2.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Rod2.body.I_33 \"inertia tensor\";
//   parameter Real Rod2.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Rod2.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Rod2.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Rod2.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Rod2.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.z_0_start[1],Rod2.body.z_0_start[2],Rod2.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Rod2.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.z_0_start[1],Rod2.body.z_0_start[2],Rod2.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Rod2.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.z_0_start[1],Rod2.body.z_0_start[2],Rod2.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real Rod2.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.w_0_start[1],Rod2.body.w_0_start[2],Rod2.body.w_0_start[3]})[1], fixed = Rod2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Rod2.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.w_0_start[1],Rod2.body.w_0_start[2],Rod2.body.w_0_start[3]})[2], fixed = Rod2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Rod2.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.w_0_start[1],Rod2.body.w_0_start[2],Rod2.body.w_0_start[3]})[3], fixed = Rod2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Rod2.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.z_0_start[1],Rod2.body.z_0_start[2],Rod2.body.z_0_start[3]})[1], fixed = Rod2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Rod2.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.z_0_start[1],Rod2.body.z_0_start[2],Rod2.body.z_0_start[3]})[2], fixed = Rod2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Rod2.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.R_start,{Rod2.body.z_0_start[1],Rod2.body.z_0_start[2],Rod2.body.z_0_start[3]})[3], fixed = Rod2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Rod2.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Rod2.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Rod2.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected parameter Real Rod2.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(Rod2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Rod2.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(Rod2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Rod2.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(Rod2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Rod2.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(Rod2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected Real Rod2.body.Q[1](start = Rod2.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Rod2.body.Q[2](start = Rod2.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Rod2.body.Q[3](start = Rod2.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Rod2.body.Q[4](start = Rod2.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real Rod2.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Rod2.body.sequence_start[1] == Rod2.body.sequence_angleStates[1] AND Rod2.body.sequence_start[2] == Rod2.body.sequence_angleStates[2] AND Rod2.body.sequence_start[3] == Rod2.body.sequence_angleStates[3] then Rod2.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Rod2.body.R_start,{Rod2.body.sequence_angleStates[1],Rod2.body.sequence_angleStates[2],Rod2.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real Rod2.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Rod2.body.sequence_start[1] == Rod2.body.sequence_angleStates[1] AND Rod2.body.sequence_start[2] == Rod2.body.sequence_angleStates[2] AND Rod2.body.sequence_start[3] == Rod2.body.sequence_angleStates[3] then Rod2.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Rod2.body.R_start,{Rod2.body.sequence_angleStates[1],Rod2.body.sequence_angleStates[2],Rod2.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real Rod2.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Rod2.body.sequence_start[1] == Rod2.body.sequence_angleStates[1] AND Rod2.body.sequence_start[2] == Rod2.body.sequence_angleStates[2] AND Rod2.body.sequence_start[3] == Rod2.body.sequence_angleStates[3] then Rod2.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Rod2.body.R_start,{Rod2.body.sequence_angleStates[1],Rod2.body.sequence_angleStates[2],Rod2.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   protected Real Rod2.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Rod2.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Rod2.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Rod2.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Rod2.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Rod2.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Rod2.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Rod2.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Rod2.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Rod2.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Rod2.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Rod2.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   Real Rod2.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod2.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod2.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod2.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Rod2.frameTranslation.animation = Rod2.animation \"= true, if animation shall be enabled\";
//   parameter Real Rod2.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Rod2.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Rod2.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Rod2.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Rod2.frameTranslation.shapeType = \"box\" \" Type of shape\";
//   parameter Real Rod2.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = Rod2.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = Rod2.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = Rod2.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.lengthDirection[1](unit = \"1\") = Rod2.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.lengthDirection[2](unit = \"1\") = Rod2.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.lengthDirection[3](unit = \"1\") = Rod2.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.widthDirection[1](unit = \"1\") = Rod2.widthDirection[1] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.widthDirection[2](unit = \"1\") = Rod2.widthDirection[2] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.widthDirection[3](unit = \"1\") = Rod2.widthDirection[3] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod2.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Rod2.length \" Length of shape\";
//   parameter Real Rod2.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod2.width \" Width of shape\";
//   parameter Real Rod2.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod2.height \" Height of shape.\";
//   parameter Real Rod2.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Rod2.frameTranslation.color[1](min = 0, max = 255) = Rod2.color[1] \" Color of shape\";
//   input Integer Rod2.frameTranslation.color[2](min = 0, max = 255) = Rod2.color[2] \" Color of shape\";
//   input Integer Rod2.frameTranslation.color[3](min = 0, max = 255) = Rod2.color[3] \" Color of shape\";
//   input Real Rod2.frameTranslation.specularCoefficient = Rod2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Rod2.frameTranslation.shape.shapeType = Rod2.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Rod2.frameTranslation.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Rod2.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Rod2.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Rod2.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Rod2.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Rod2.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Rod2.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Rod2.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.lengthDirection[1](unit = \"1\") = Rod2.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.lengthDirection[2](unit = \"1\") = Rod2.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.lengthDirection[3](unit = \"1\") = Rod2.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.widthDirection[1](unit = \"1\") = Rod2.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.widthDirection[2](unit = \"1\") = Rod2.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.widthDirection[3](unit = \"1\") = Rod2.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Rod2.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.length \"Length of visual object\";
//   input Real Rod2.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.width \"Width of visual object\";
//   input Real Rod2.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = Rod2.frameTranslation.height \"Height of visual object\";
//   input Real Rod2.frameTranslation.shape.extra = Rod2.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real Rod2.frameTranslation.shape.color[1] = Real(Rod2.frameTranslation.color[1]) \"Color of shape\";
//   input Real Rod2.frameTranslation.shape.color[2] = Real(Rod2.frameTranslation.color[2]) \"Color of shape\";
//   input Real Rod2.frameTranslation.shape.color[3] = Real(Rod2.frameTranslation.color[3]) \"Color of shape\";
//   input Real Rod2.frameTranslation.shape.specularCoefficient = Rod2.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Rod2.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Rod2.frameTranslation.shape.lengthDirection[1],Rod2.frameTranslation.shape.lengthDirection[2],Rod2.frameTranslation.shape.lengthDirection[3]});
//   protected Real Rod2.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(Rod2.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else Rod2.frameTranslation.shape.lengthDirection[1] / Rod2.frameTranslation.shape.abs_n_x;
//   protected Real Rod2.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(Rod2.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Rod2.frameTranslation.shape.lengthDirection[2] / Rod2.frameTranslation.shape.abs_n_x;
//   protected Real Rod2.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(Rod2.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Rod2.frameTranslation.shape.lengthDirection[3] / Rod2.frameTranslation.shape.abs_n_x;
//   protected Real Rod2.frameTranslation.shape.n_z_aux[1](unit = \"1\") = Rod2.frameTranslation.shape.e_x[2] * Rod2.frameTranslation.shape.widthDirection[3] - Rod2.frameTranslation.shape.e_x[3] * Rod2.frameTranslation.shape.widthDirection[2];
//   protected Real Rod2.frameTranslation.shape.n_z_aux[2](unit = \"1\") = Rod2.frameTranslation.shape.e_x[3] * Rod2.frameTranslation.shape.widthDirection[1] - Rod2.frameTranslation.shape.e_x[1] * Rod2.frameTranslation.shape.widthDirection[3];
//   protected Real Rod2.frameTranslation.shape.n_z_aux[3](unit = \"1\") = Rod2.frameTranslation.shape.e_x[1] * Rod2.frameTranslation.shape.widthDirection[2] - Rod2.frameTranslation.shape.e_x[2] * Rod2.frameTranslation.shape.widthDirection[1];
//   protected Real Rod2.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Rod2.frameTranslation.shape.e_x[1],Rod2.frameTranslation.shape.e_x[2],Rod2.frameTranslation.shape.e_x[3]},if noEvent(Rod2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Rod2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Rod2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Rod2.frameTranslation.shape.widthDirection[1],Rod2.frameTranslation.shape.widthDirection[2],Rod2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Rod2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Rod2.frameTranslation.shape.e_x[1],Rod2.frameTranslation.shape.e_x[2],Rod2.frameTranslation.shape.e_x[3]})[1];
//   protected Real Rod2.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Rod2.frameTranslation.shape.e_x[1],Rod2.frameTranslation.shape.e_x[2],Rod2.frameTranslation.shape.e_x[3]},if noEvent(Rod2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Rod2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Rod2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Rod2.frameTranslation.shape.widthDirection[1],Rod2.frameTranslation.shape.widthDirection[2],Rod2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Rod2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Rod2.frameTranslation.shape.e_x[1],Rod2.frameTranslation.shape.e_x[2],Rod2.frameTranslation.shape.e_x[3]})[2];
//   protected Real Rod2.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Rod2.frameTranslation.shape.e_x[1],Rod2.frameTranslation.shape.e_x[2],Rod2.frameTranslation.shape.e_x[3]},if noEvent(Rod2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Rod2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Rod2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Rod2.frameTranslation.shape.widthDirection[1],Rod2.frameTranslation.shape.widthDirection[2],Rod2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Rod2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Rod2.frameTranslation.shape.e_x[1],Rod2.frameTranslation.shape.e_x[2],Rod2.frameTranslation.shape.e_x[3]})[3];
//   protected output Real Rod2.frameTranslation.shape.Form;
//   output Real Rod2.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Rod2.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Rod2.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Rod2.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Rod2.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Rod2.frameTranslation.shape.Material;
//   protected output Real Rod2.frameTranslation.shape.Extra;
//   Real Bearing.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Bearing.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Bearing.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Bearing.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Bearing.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Bearing.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Bearing.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Bearing.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Bearing.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Bearing.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Bearing.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Bearing.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Bearing.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Bearing.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Bearing.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Bearing.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Bearing.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Bearing.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Bearing.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean Bearing.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real Bearing.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real Bearing.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real Bearing.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real Bearing.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real Bearing.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Length of cylinder representing the joint axis\";
//   parameter Real Bearing.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \"Diameter of cylinder representing the joint axis\";
//   input Integer Bearing.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer Bearing.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer Bearing.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real Bearing.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) Bearing.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real Bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real Bearing.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real Bearing.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real Bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real Bearing.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   protected parameter Real Bearing.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({Bearing.n[1],Bearing.n[2],Bearing.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real Bearing.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({Bearing.n[1],Bearing.n[2],Bearing.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real Bearing.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({Bearing.n[1],Bearing.n[2],Bearing.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real Bearing.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Bearing.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Bearing.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Bearing.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real Bearing.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real Bearing.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real Bearing.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = Bearing.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real Bearing.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real Bearing.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real Bearing.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real Bearing.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real Bearing.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real Bearing.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real Bearing.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String Bearing.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Bearing.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Bearing.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Bearing.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Bearing.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Bearing.cylinder.r[1](quantity = \"Length\", unit = \"m\") = Bearing.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Bearing.cylinder.r[2](quantity = \"Length\", unit = \"m\") = Bearing.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Bearing.cylinder.r[3](quantity = \"Length\", unit = \"m\") = Bearing.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Bearing.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = (-Bearing.cylinderLength) * Bearing.e[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Bearing.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-Bearing.cylinderLength) * Bearing.e[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Bearing.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = (-Bearing.cylinderLength) * Bearing.e[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Bearing.cylinder.lengthDirection[1](unit = \"1\") = Bearing.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real Bearing.cylinder.lengthDirection[2](unit = \"1\") = Bearing.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real Bearing.cylinder.lengthDirection[3](unit = \"1\") = Bearing.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real Bearing.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real Bearing.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real Bearing.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real Bearing.cylinder.length(quantity = \"Length\", unit = \"m\") = Bearing.cylinderLength \"Length of visual object\";
//   input Real Bearing.cylinder.width(quantity = \"Length\", unit = \"m\") = Bearing.cylinderDiameter \"Width of visual object\";
//   input Real Bearing.cylinder.height(quantity = \"Length\", unit = \"m\") = Bearing.cylinderDiameter \"Height of visual object\";
//   input Real Bearing.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real Bearing.cylinder.color[1] = Real(Bearing.cylinderColor[1]) \"Color of shape\";
//   input Real Bearing.cylinder.color[2] = Real(Bearing.cylinderColor[2]) \"Color of shape\";
//   input Real Bearing.cylinder.color[3] = Real(Bearing.cylinderColor[3]) \"Color of shape\";
//   input Real Bearing.cylinder.specularCoefficient = Bearing.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Bearing.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Bearing.cylinder.lengthDirection[1],Bearing.cylinder.lengthDirection[2],Bearing.cylinder.lengthDirection[3]});
//   protected Real Bearing.cylinder.e_x[1](unit = \"1\") = if noEvent(Bearing.cylinder.abs_n_x < 1e-10) then 1.0 else Bearing.cylinder.lengthDirection[1] / Bearing.cylinder.abs_n_x;
//   protected Real Bearing.cylinder.e_x[2](unit = \"1\") = if noEvent(Bearing.cylinder.abs_n_x < 1e-10) then 0.0 else Bearing.cylinder.lengthDirection[2] / Bearing.cylinder.abs_n_x;
//   protected Real Bearing.cylinder.e_x[3](unit = \"1\") = if noEvent(Bearing.cylinder.abs_n_x < 1e-10) then 0.0 else Bearing.cylinder.lengthDirection[3] / Bearing.cylinder.abs_n_x;
//   protected Real Bearing.cylinder.n_z_aux[1](unit = \"1\") = Bearing.cylinder.e_x[2] * Bearing.cylinder.widthDirection[3] - Bearing.cylinder.e_x[3] * Bearing.cylinder.widthDirection[2];
//   protected Real Bearing.cylinder.n_z_aux[2](unit = \"1\") = Bearing.cylinder.e_x[3] * Bearing.cylinder.widthDirection[1] - Bearing.cylinder.e_x[1] * Bearing.cylinder.widthDirection[3];
//   protected Real Bearing.cylinder.n_z_aux[3](unit = \"1\") = Bearing.cylinder.e_x[1] * Bearing.cylinder.widthDirection[2] - Bearing.cylinder.e_x[2] * Bearing.cylinder.widthDirection[1];
//   protected Real Bearing.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Bearing.cylinder.e_x[1],Bearing.cylinder.e_x[2],Bearing.cylinder.e_x[3]},if noEvent(Bearing.cylinder.n_z_aux[1] ^ 2.0 + (Bearing.cylinder.n_z_aux[2] ^ 2.0 + Bearing.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {Bearing.cylinder.widthDirection[1],Bearing.cylinder.widthDirection[2],Bearing.cylinder.widthDirection[3]} else if noEvent(abs(Bearing.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Bearing.cylinder.e_x[1],Bearing.cylinder.e_x[2],Bearing.cylinder.e_x[3]})[1];
//   protected Real Bearing.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Bearing.cylinder.e_x[1],Bearing.cylinder.e_x[2],Bearing.cylinder.e_x[3]},if noEvent(Bearing.cylinder.n_z_aux[1] ^ 2.0 + (Bearing.cylinder.n_z_aux[2] ^ 2.0 + Bearing.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {Bearing.cylinder.widthDirection[1],Bearing.cylinder.widthDirection[2],Bearing.cylinder.widthDirection[3]} else if noEvent(abs(Bearing.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Bearing.cylinder.e_x[1],Bearing.cylinder.e_x[2],Bearing.cylinder.e_x[3]})[2];
//   protected Real Bearing.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Bearing.cylinder.e_x[1],Bearing.cylinder.e_x[2],Bearing.cylinder.e_x[3]},if noEvent(Bearing.cylinder.n_z_aux[1] ^ 2.0 + (Bearing.cylinder.n_z_aux[2] ^ 2.0 + Bearing.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {Bearing.cylinder.widthDirection[1],Bearing.cylinder.widthDirection[2],Bearing.cylinder.widthDirection[3]} else if noEvent(abs(Bearing.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Bearing.cylinder.e_x[1],Bearing.cylinder.e_x[2],Bearing.cylinder.e_x[3]})[3];
//   protected output Real Bearing.cylinder.Form;
//   output Real Bearing.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Bearing.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Bearing.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Bearing.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Bearing.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Bearing.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Bearing.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Bearing.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Bearing.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Bearing.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Bearing.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Bearing.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Bearing.cylinder.Material;
//   protected output Real Bearing.cylinder.Extra;
//   Real Inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real Inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real Inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real Inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real Inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 0.1 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) Inertia.stateSelect = StateSelect.always \"Priority to use phi and w as states\";
//   Real Inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\", start = 0.001, fixed = true, StateSelect = StateSelect.always) \"Absolute rotation angle of component\";
//   Real Inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", fixed = true, StateSelect = StateSelect.always) \"Absolute angular velocity of component (= der(phi))\";
//   Real Inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real Crank4.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank4.animation = true \"= true, if animation shall be enabled (show box between frame_a and frame_b)\";
//   parameter Real Crank4.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank4.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = -0.1 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank4.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank4.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Crank4.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Crank4.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Crank4.lengthDirection[1](unit = \"1\") = Crank4.r[1] - Crank4.r_shape[1] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Crank4.lengthDirection[2](unit = \"1\") = Crank4.r[2] - Crank4.r_shape[2] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Crank4.lengthDirection[3](unit = \"1\") = Crank4.r[3] - Crank4.r_shape[3] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Crank4.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Crank4.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Crank4.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Crank4.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Crank4.r[1] - Crank4.r_shape[1],Crank4.r[2] - Crank4.r_shape[2],Crank4.r[3] - Crank4.r_shape[3]}) \"Length of box\";
//   parameter Real Crank4.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Width of box\";
//   parameter Real Crank4.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \"Height of box\";
//   parameter Real Crank4.innerWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Width of inner box surface (0 <= innerWidth <= width)\";
//   parameter Real Crank4.innerHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank4.innerWidth \"Height of inner box surface (0 <= innerHeight <= height)\";
//   parameter Real Crank4.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer Crank4.color[1](min = 0, max = 255) = 0 \"Color of box\";
//   input Integer Crank4.color[2](min = 0, max = 255) = 128 \"Color of box\";
//   input Integer Crank4.color[3](min = 0, max = 255) = 255 \"Color of box\";
//   input Real Crank4.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Crank4.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank4.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank4.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank4.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank4.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank4.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank4.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank4.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank4.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank4.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank4.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank4.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank4.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank4.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank4.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank4.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank4.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank4.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank4.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank4.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank4.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank4.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank4.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank4.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean Crank4.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank4.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank4.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank4.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank4.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Crank4.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank4.density * (Crank4.length * (Crank4.width * Crank4.height)) \"Mass of box without hole\";
//   parameter Real Crank4.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank4.density * (Crank4.length * (Crank4.innerWidth * Crank4.innerHeight)) \"Mass of hole of box\";
//   parameter Real Crank4.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank4.mo - Crank4.mi \"Mass of box\";
//   parameter Real Crank4.R.T[1,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[1,2] = -1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[2,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[2,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[3,1] = -0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank4.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank4.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank4.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank4.r[1],Crank4.r[2],Crank4.r[3]},1e-13)[1] * Crank4.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank4.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank4.r[1],Crank4.r[2],Crank4.r[3]},1e-13)[2] * Crank4.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank4.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank4.r[1],Crank4.r[2],Crank4.r[3]},1e-13)[3] * Crank4.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank4.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[1][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[1][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[1][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[2][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[2][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[2][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[3][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[3][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank4.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank4.R,{{Crank4.mo * (Crank4.width ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.innerWidth ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.height ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank4.mo * (Crank4.length ^ 2.0 / 12.0 + Crank4.width ^ 2.0 / 12.0) - Crank4.mi * (Crank4.length ^ 2.0 / 12.0 + Crank4.innerWidth ^ 2.0 / 12.0)}})[3][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   Real Crank4.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank4.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real Crank4.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank4.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank4.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank4.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank4.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank4.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank4.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = Crank4.m \"Mass of rigid body\";
//   parameter Real Crank4.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank4.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real Crank4.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank4.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real Crank4.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank4.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real Crank4.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank4.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real Crank4.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank4.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real Crank4.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank4.I[3,2] \" (3,2) element of inertia tensor\";
//   Real Crank4.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank4.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank4.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank4.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank4.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank4.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank4.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank4.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank4.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank4.body.angles_fixed = Crank4.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank4.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank4.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank4.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank4.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank4.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank4.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank4.body.sequence_start[1](min = 1, max = 3) = Crank4.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank4.body.sequence_start[2](min = 1, max = 3) = Crank4.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank4.body.sequence_start[3](min = 1, max = 3) = Crank4.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank4.body.w_0_fixed = Crank4.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank4.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank4.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank4.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank4.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank4.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank4.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank4.body.z_0_fixed = Crank4.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank4.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank4.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank4.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank4.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank4.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank4.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank4.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer Crank4.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer Crank4.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer Crank4.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   parameter Real Crank4.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank4.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   input Integer Crank4.body.cylinderColor[1](min = 0, max = 255) = Crank4.body.sphereColor[1] \"Color of cylinder\";
//   input Integer Crank4.body.cylinderColor[2](min = 0, max = 255) = Crank4.body.sphereColor[2] \"Color of cylinder\";
//   input Integer Crank4.body.cylinderColor[3](min = 0, max = 255) = Crank4.body.sphereColor[3] \"Color of cylinder\";
//   input Real Crank4.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean Crank4.body.enforceStates = Crank4.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank4.body.useQuaternions = Crank4.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank4.body.sequence_angleStates[1](min = 1, max = 3) = Crank4.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank4.body.sequence_angleStates[2](min = 1, max = 3) = Crank4.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank4.body.sequence_angleStates[3](min = 1, max = 3) = Crank4.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Crank4.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_11 \"inertia tensor\";
//   parameter Real Crank4.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_21 \"inertia tensor\";
//   parameter Real Crank4.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_31 \"inertia tensor\";
//   parameter Real Crank4.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_21 \"inertia tensor\";
//   parameter Real Crank4.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_22 \"inertia tensor\";
//   parameter Real Crank4.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_32 \"inertia tensor\";
//   parameter Real Crank4.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_31 \"inertia tensor\";
//   parameter Real Crank4.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_32 \"inertia tensor\";
//   parameter Real Crank4.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank4.body.I_33 \"inertia tensor\";
//   parameter Real Crank4.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank4.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank4.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank4.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank4.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.z_0_start[1],Crank4.body.z_0_start[2],Crank4.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank4.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.z_0_start[1],Crank4.body.z_0_start[2],Crank4.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank4.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.z_0_start[1],Crank4.body.z_0_start[2],Crank4.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real Crank4.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.w_0_start[1],Crank4.body.w_0_start[2],Crank4.body.w_0_start[3]})[1], fixed = Crank4.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank4.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.w_0_start[1],Crank4.body.w_0_start[2],Crank4.body.w_0_start[3]})[2], fixed = Crank4.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank4.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.w_0_start[1],Crank4.body.w_0_start[2],Crank4.body.w_0_start[3]})[3], fixed = Crank4.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank4.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.z_0_start[1],Crank4.body.z_0_start[2],Crank4.body.z_0_start[3]})[1], fixed = Crank4.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank4.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.z_0_start[1],Crank4.body.z_0_start[2],Crank4.body.z_0_start[3]})[2], fixed = Crank4.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank4.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.R_start,{Crank4.body.z_0_start[1],Crank4.body.z_0_start[2],Crank4.body.z_0_start[3]})[3], fixed = Crank4.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank4.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank4.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank4.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected parameter Real Crank4.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank4.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank4.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank4.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected Real Crank4.body.Q[1](start = Crank4.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank4.body.Q[2](start = Crank4.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank4.body.Q[3](start = Crank4.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank4.body.Q[4](start = Crank4.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real Crank4.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank4.body.sequence_start[1] == Crank4.body.sequence_angleStates[1] AND Crank4.body.sequence_start[2] == Crank4.body.sequence_angleStates[2] AND Crank4.body.sequence_start[3] == Crank4.body.sequence_angleStates[3] then Crank4.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank4.body.R_start,{Crank4.body.sequence_angleStates[1],Crank4.body.sequence_angleStates[2],Crank4.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real Crank4.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank4.body.sequence_start[1] == Crank4.body.sequence_angleStates[1] AND Crank4.body.sequence_start[2] == Crank4.body.sequence_angleStates[2] AND Crank4.body.sequence_start[3] == Crank4.body.sequence_angleStates[3] then Crank4.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank4.body.R_start,{Crank4.body.sequence_angleStates[1],Crank4.body.sequence_angleStates[2],Crank4.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real Crank4.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank4.body.sequence_start[1] == Crank4.body.sequence_angleStates[1] AND Crank4.body.sequence_start[2] == Crank4.body.sequence_angleStates[2] AND Crank4.body.sequence_start[3] == Crank4.body.sequence_angleStates[3] then Crank4.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank4.body.R_start,{Crank4.body.sequence_angleStates[1],Crank4.body.sequence_angleStates[2],Crank4.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   protected Real Crank4.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank4.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank4.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank4.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank4.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank4.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank4.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank4.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank4.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank4.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank4.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank4.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   Real Crank4.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank4.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank4.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank4.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank4.frameTranslation.animation = Crank4.animation \"= true, if animation shall be enabled\";
//   parameter Real Crank4.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank4.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank4.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank4.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Crank4.frameTranslation.shapeType = \"box\" \" Type of shape\";
//   parameter Real Crank4.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank4.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank4.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank4.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.lengthDirection[1](unit = \"1\") = Crank4.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.lengthDirection[2](unit = \"1\") = Crank4.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.lengthDirection[3](unit = \"1\") = Crank4.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.widthDirection[1](unit = \"1\") = Crank4.widthDirection[1] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.widthDirection[2](unit = \"1\") = Crank4.widthDirection[2] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.widthDirection[3](unit = \"1\") = Crank4.widthDirection[3] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank4.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Crank4.length \" Length of shape\";
//   parameter Real Crank4.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank4.width \" Width of shape\";
//   parameter Real Crank4.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank4.height \" Height of shape.\";
//   parameter Real Crank4.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Crank4.frameTranslation.color[1](min = 0, max = 255) = Crank4.color[1] \" Color of shape\";
//   input Integer Crank4.frameTranslation.color[2](min = 0, max = 255) = Crank4.color[2] \" Color of shape\";
//   input Integer Crank4.frameTranslation.color[3](min = 0, max = 255) = Crank4.color[3] \" Color of shape\";
//   input Real Crank4.frameTranslation.specularCoefficient = Crank4.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Crank4.frameTranslation.shape.shapeType = Crank4.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Crank4.frameTranslation.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank4.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank4.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank4.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank4.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank4.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank4.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank4.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.lengthDirection[1](unit = \"1\") = Crank4.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.lengthDirection[2](unit = \"1\") = Crank4.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.lengthDirection[3](unit = \"1\") = Crank4.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.widthDirection[1](unit = \"1\") = Crank4.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.widthDirection[2](unit = \"1\") = Crank4.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.widthDirection[3](unit = \"1\") = Crank4.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Crank4.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.length \"Length of visual object\";
//   input Real Crank4.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.width \"Width of visual object\";
//   input Real Crank4.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = Crank4.frameTranslation.height \"Height of visual object\";
//   input Real Crank4.frameTranslation.shape.extra = Crank4.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real Crank4.frameTranslation.shape.color[1] = Real(Crank4.frameTranslation.color[1]) \"Color of shape\";
//   input Real Crank4.frameTranslation.shape.color[2] = Real(Crank4.frameTranslation.color[2]) \"Color of shape\";
//   input Real Crank4.frameTranslation.shape.color[3] = Real(Crank4.frameTranslation.color[3]) \"Color of shape\";
//   input Real Crank4.frameTranslation.shape.specularCoefficient = Crank4.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Crank4.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Crank4.frameTranslation.shape.lengthDirection[1],Crank4.frameTranslation.shape.lengthDirection[2],Crank4.frameTranslation.shape.lengthDirection[3]});
//   protected Real Crank4.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(Crank4.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else Crank4.frameTranslation.shape.lengthDirection[1] / Crank4.frameTranslation.shape.abs_n_x;
//   protected Real Crank4.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(Crank4.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank4.frameTranslation.shape.lengthDirection[2] / Crank4.frameTranslation.shape.abs_n_x;
//   protected Real Crank4.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(Crank4.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank4.frameTranslation.shape.lengthDirection[3] / Crank4.frameTranslation.shape.abs_n_x;
//   protected Real Crank4.frameTranslation.shape.n_z_aux[1](unit = \"1\") = Crank4.frameTranslation.shape.e_x[2] * Crank4.frameTranslation.shape.widthDirection[3] - Crank4.frameTranslation.shape.e_x[3] * Crank4.frameTranslation.shape.widthDirection[2];
//   protected Real Crank4.frameTranslation.shape.n_z_aux[2](unit = \"1\") = Crank4.frameTranslation.shape.e_x[3] * Crank4.frameTranslation.shape.widthDirection[1] - Crank4.frameTranslation.shape.e_x[1] * Crank4.frameTranslation.shape.widthDirection[3];
//   protected Real Crank4.frameTranslation.shape.n_z_aux[3](unit = \"1\") = Crank4.frameTranslation.shape.e_x[1] * Crank4.frameTranslation.shape.widthDirection[2] - Crank4.frameTranslation.shape.e_x[2] * Crank4.frameTranslation.shape.widthDirection[1];
//   protected Real Crank4.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank4.frameTranslation.shape.e_x[1],Crank4.frameTranslation.shape.e_x[2],Crank4.frameTranslation.shape.e_x[3]},if noEvent(Crank4.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank4.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank4.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank4.frameTranslation.shape.widthDirection[1],Crank4.frameTranslation.shape.widthDirection[2],Crank4.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank4.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank4.frameTranslation.shape.e_x[1],Crank4.frameTranslation.shape.e_x[2],Crank4.frameTranslation.shape.e_x[3]})[1];
//   protected Real Crank4.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank4.frameTranslation.shape.e_x[1],Crank4.frameTranslation.shape.e_x[2],Crank4.frameTranslation.shape.e_x[3]},if noEvent(Crank4.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank4.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank4.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank4.frameTranslation.shape.widthDirection[1],Crank4.frameTranslation.shape.widthDirection[2],Crank4.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank4.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank4.frameTranslation.shape.e_x[1],Crank4.frameTranslation.shape.e_x[2],Crank4.frameTranslation.shape.e_x[3]})[2];
//   protected Real Crank4.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank4.frameTranslation.shape.e_x[1],Crank4.frameTranslation.shape.e_x[2],Crank4.frameTranslation.shape.e_x[3]},if noEvent(Crank4.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank4.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank4.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank4.frameTranslation.shape.widthDirection[1],Crank4.frameTranslation.shape.widthDirection[2],Crank4.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank4.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank4.frameTranslation.shape.e_x[1],Crank4.frameTranslation.shape.e_x[2],Crank4.frameTranslation.shape.e_x[3]})[3];
//   protected output Real Crank4.frameTranslation.shape.Form;
//   output Real Crank4.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank4.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Crank4.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank4.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank4.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank4.frameTranslation.shape.Material;
//   protected output Real Crank4.frameTranslation.shape.Extra;
//   Real Crank3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank3.animation = true \"= true, if animation shall be enabled (show cylinder between frame_a and frame_b)\";
//   parameter Real Crank3.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 0.1 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Crank3.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Crank3.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Crank3.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Crank3.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Crank3.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Crank3.lengthDirection[1](unit = \"1\") = Crank3.r[1] - Crank3.r_shape[1] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Crank3.lengthDirection[2](unit = \"1\") = Crank3.r[2] - Crank3.r_shape[2] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Crank3.lengthDirection[3](unit = \"1\") = Crank3.r[3] - Crank3.r_shape[3] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Crank3.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Crank3.r[1] - Crank3.r_shape[1],Crank3.r[2] - Crank3.r_shape[2],Crank3.r[3] - Crank3.r_shape[3]}) \"Length of cylinder\";
//   parameter Real Crank3.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.03 \"Diameter of cylinder\";
//   parameter Real Crank3.innerDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Inner diameter of cylinder (0 <= innerDiameter <= Diameter)\";
//   parameter Real Crank3.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer Crank3.color[1](min = 0, max = 255) = 0 \"Color of cylinder\";
//   input Integer Crank3.color[2](min = 0, max = 255) = 128 \"Color of cylinder\";
//   input Integer Crank3.color[3](min = 0, max = 255) = 255 \"Color of cylinder\";
//   input Real Crank3.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Crank3.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank3.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank3.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank3.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank3.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank3.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank3.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank3.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank3.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank3.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank3.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank3.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank3.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank3.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank3.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank3.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank3.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank3.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank3.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank3.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank3.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank3.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank3.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank3.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean Crank3.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank3.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank3.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank3.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank3.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   constant Real Crank3.pi = 3.14159265358979;
//   parameter Real Crank3.radius(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank3.diameter / 2.0 \"Radius of cylinder\";
//   parameter Real Crank3.innerRadius(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank3.innerDiameter / 2.0 \"Inner-Radius of cylinder\";
//   parameter Real Crank3.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.14159265358979 * (Crank3.density * (Crank3.length * Crank3.radius ^ 2.0)) \"Mass of cylinder without hole\";
//   parameter Real Crank3.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.14159265358979 * (Crank3.density * (Crank3.length * Crank3.innerRadius ^ 2.0)) \"Mass of hole of cylinder\";
//   parameter Real Crank3.I22(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.mo * (Crank3.length ^ 2.0 + 3.0 * Crank3.radius ^ 2.0) / 12.0 - Crank3.mi * (Crank3.length ^ 2.0 + 3.0 * Crank3.innerRadius ^ 2.0) / 12.0 \"Inertia with respect to axis through center of mass, perpendicular to cylinder axis\";
//   parameter Real Crank3.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank3.mo - Crank3.mi \"Mass of cylinder\";
//   parameter Real Crank3.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank3.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank3.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank3.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank3.r[1],Crank3.r[2],Crank3.r[3]},1e-13)[1] * Crank3.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank3.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank3.r[1],Crank3.r[2],Crank3.r[3]},1e-13)[2] * Crank3.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank3.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank3.r[1],Crank3.r[2],Crank3.r[3]},1e-13)[3] * Crank3.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank3.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[1][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[1][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[1][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[2][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[2][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[2][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[3][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[3][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank3.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank3.R,{{Crank3.mo * Crank3.radius ^ 2.0 / 2.0 - Crank3.mi * Crank3.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank3.I22,0.0},{0.0,0.0,Crank3.I22}})[3][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   Real Crank3.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank3.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real Crank3.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank3.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank3.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank3.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank3.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank3.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank3.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = Crank3.m \"Mass of rigid body\";
//   parameter Real Crank3.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank3.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real Crank3.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank3.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real Crank3.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank3.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real Crank3.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank3.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real Crank3.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank3.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real Crank3.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank3.I[3,2] \" (3,2) element of inertia tensor\";
//   Real Crank3.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank3.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank3.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank3.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank3.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank3.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank3.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank3.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank3.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank3.body.angles_fixed = Crank3.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank3.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank3.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank3.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank3.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank3.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank3.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank3.body.sequence_start[1](min = 1, max = 3) = Crank3.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank3.body.sequence_start[2](min = 1, max = 3) = Crank3.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank3.body.sequence_start[3](min = 1, max = 3) = Crank3.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank3.body.w_0_fixed = Crank3.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank3.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank3.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank3.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank3.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank3.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank3.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank3.body.z_0_fixed = Crank3.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank3.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank3.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank3.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank3.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank3.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank3.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank3.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer Crank3.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer Crank3.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer Crank3.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   parameter Real Crank3.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank3.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   input Integer Crank3.body.cylinderColor[1](min = 0, max = 255) = Crank3.body.sphereColor[1] \"Color of cylinder\";
//   input Integer Crank3.body.cylinderColor[2](min = 0, max = 255) = Crank3.body.sphereColor[2] \"Color of cylinder\";
//   input Integer Crank3.body.cylinderColor[3](min = 0, max = 255) = Crank3.body.sphereColor[3] \"Color of cylinder\";
//   input Real Crank3.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean Crank3.body.enforceStates = Crank3.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank3.body.useQuaternions = Crank3.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank3.body.sequence_angleStates[1](min = 1, max = 3) = Crank3.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank3.body.sequence_angleStates[2](min = 1, max = 3) = Crank3.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank3.body.sequence_angleStates[3](min = 1, max = 3) = Crank3.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Crank3.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_11 \"inertia tensor\";
//   parameter Real Crank3.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_21 \"inertia tensor\";
//   parameter Real Crank3.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_31 \"inertia tensor\";
//   parameter Real Crank3.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_21 \"inertia tensor\";
//   parameter Real Crank3.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_22 \"inertia tensor\";
//   parameter Real Crank3.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_32 \"inertia tensor\";
//   parameter Real Crank3.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_31 \"inertia tensor\";
//   parameter Real Crank3.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_32 \"inertia tensor\";
//   parameter Real Crank3.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank3.body.I_33 \"inertia tensor\";
//   parameter Real Crank3.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank3.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank3.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank3.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank3.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.z_0_start[1],Crank3.body.z_0_start[2],Crank3.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank3.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.z_0_start[1],Crank3.body.z_0_start[2],Crank3.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank3.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.z_0_start[1],Crank3.body.z_0_start[2],Crank3.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real Crank3.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.w_0_start[1],Crank3.body.w_0_start[2],Crank3.body.w_0_start[3]})[1], fixed = Crank3.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank3.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.w_0_start[1],Crank3.body.w_0_start[2],Crank3.body.w_0_start[3]})[2], fixed = Crank3.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank3.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.w_0_start[1],Crank3.body.w_0_start[2],Crank3.body.w_0_start[3]})[3], fixed = Crank3.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank3.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.z_0_start[1],Crank3.body.z_0_start[2],Crank3.body.z_0_start[3]})[1], fixed = Crank3.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank3.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.z_0_start[1],Crank3.body.z_0_start[2],Crank3.body.z_0_start[3]})[2], fixed = Crank3.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank3.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.R_start,{Crank3.body.z_0_start[1],Crank3.body.z_0_start[2],Crank3.body.z_0_start[3]})[3], fixed = Crank3.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank3.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank3.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank3.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected parameter Real Crank3.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank3.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank3.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank3.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected Real Crank3.body.Q[1](start = Crank3.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank3.body.Q[2](start = Crank3.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank3.body.Q[3](start = Crank3.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank3.body.Q[4](start = Crank3.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real Crank3.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank3.body.sequence_start[1] == Crank3.body.sequence_angleStates[1] AND Crank3.body.sequence_start[2] == Crank3.body.sequence_angleStates[2] AND Crank3.body.sequence_start[3] == Crank3.body.sequence_angleStates[3] then Crank3.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank3.body.R_start,{Crank3.body.sequence_angleStates[1],Crank3.body.sequence_angleStates[2],Crank3.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real Crank3.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank3.body.sequence_start[1] == Crank3.body.sequence_angleStates[1] AND Crank3.body.sequence_start[2] == Crank3.body.sequence_angleStates[2] AND Crank3.body.sequence_start[3] == Crank3.body.sequence_angleStates[3] then Crank3.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank3.body.R_start,{Crank3.body.sequence_angleStates[1],Crank3.body.sequence_angleStates[2],Crank3.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real Crank3.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank3.body.sequence_start[1] == Crank3.body.sequence_angleStates[1] AND Crank3.body.sequence_start[2] == Crank3.body.sequence_angleStates[2] AND Crank3.body.sequence_start[3] == Crank3.body.sequence_angleStates[3] then Crank3.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank3.body.R_start,{Crank3.body.sequence_angleStates[1],Crank3.body.sequence_angleStates[2],Crank3.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   protected Real Crank3.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank3.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank3.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank3.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank3.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank3.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank3.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank3.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank3.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank3.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank3.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank3.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   Real Crank3.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank3.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank3.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank3.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank3.frameTranslation.animation = Crank3.animation \"= true, if animation shall be enabled\";
//   parameter Real Crank3.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank3.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank3.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank3.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Crank3.frameTranslation.shapeType = \"pipecylinder\" \" Type of shape\";
//   parameter Real Crank3.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank3.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank3.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank3.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.lengthDirection[1](unit = \"1\") = Crank3.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.lengthDirection[2](unit = \"1\") = Crank3.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.lengthDirection[3](unit = \"1\") = Crank3.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank3.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Crank3.length \" Length of shape\";
//   parameter Real Crank3.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank3.diameter \" Width of shape\";
//   parameter Real Crank3.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank3.diameter \" Height of shape.\";
//   parameter Real Crank3.frameTranslation.extra = Crank3.innerDiameter / Crank3.diameter \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Crank3.frameTranslation.color[1](min = 0, max = 255) = Crank3.color[1] \" Color of shape\";
//   input Integer Crank3.frameTranslation.color[2](min = 0, max = 255) = Crank3.color[2] \" Color of shape\";
//   input Integer Crank3.frameTranslation.color[3](min = 0, max = 255) = Crank3.color[3] \" Color of shape\";
//   input Real Crank3.frameTranslation.specularCoefficient = Crank3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Crank3.frameTranslation.shape.shapeType = Crank3.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Crank3.frameTranslation.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank3.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank3.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank3.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank3.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank3.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank3.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank3.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.lengthDirection[1](unit = \"1\") = Crank3.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.lengthDirection[2](unit = \"1\") = Crank3.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.lengthDirection[3](unit = \"1\") = Crank3.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.widthDirection[1](unit = \"1\") = Crank3.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.widthDirection[2](unit = \"1\") = Crank3.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.widthDirection[3](unit = \"1\") = Crank3.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Crank3.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.length \"Length of visual object\";
//   input Real Crank3.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.width \"Width of visual object\";
//   input Real Crank3.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = Crank3.frameTranslation.height \"Height of visual object\";
//   input Real Crank3.frameTranslation.shape.extra = Crank3.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real Crank3.frameTranslation.shape.color[1] = Real(Crank3.frameTranslation.color[1]) \"Color of shape\";
//   input Real Crank3.frameTranslation.shape.color[2] = Real(Crank3.frameTranslation.color[2]) \"Color of shape\";
//   input Real Crank3.frameTranslation.shape.color[3] = Real(Crank3.frameTranslation.color[3]) \"Color of shape\";
//   input Real Crank3.frameTranslation.shape.specularCoefficient = Crank3.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Crank3.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Crank3.frameTranslation.shape.lengthDirection[1],Crank3.frameTranslation.shape.lengthDirection[2],Crank3.frameTranslation.shape.lengthDirection[3]});
//   protected Real Crank3.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(Crank3.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else Crank3.frameTranslation.shape.lengthDirection[1] / Crank3.frameTranslation.shape.abs_n_x;
//   protected Real Crank3.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(Crank3.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank3.frameTranslation.shape.lengthDirection[2] / Crank3.frameTranslation.shape.abs_n_x;
//   protected Real Crank3.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(Crank3.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank3.frameTranslation.shape.lengthDirection[3] / Crank3.frameTranslation.shape.abs_n_x;
//   protected Real Crank3.frameTranslation.shape.n_z_aux[1](unit = \"1\") = Crank3.frameTranslation.shape.e_x[2] * Crank3.frameTranslation.shape.widthDirection[3] - Crank3.frameTranslation.shape.e_x[3] * Crank3.frameTranslation.shape.widthDirection[2];
//   protected Real Crank3.frameTranslation.shape.n_z_aux[2](unit = \"1\") = Crank3.frameTranslation.shape.e_x[3] * Crank3.frameTranslation.shape.widthDirection[1] - Crank3.frameTranslation.shape.e_x[1] * Crank3.frameTranslation.shape.widthDirection[3];
//   protected Real Crank3.frameTranslation.shape.n_z_aux[3](unit = \"1\") = Crank3.frameTranslation.shape.e_x[1] * Crank3.frameTranslation.shape.widthDirection[2] - Crank3.frameTranslation.shape.e_x[2] * Crank3.frameTranslation.shape.widthDirection[1];
//   protected Real Crank3.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank3.frameTranslation.shape.e_x[1],Crank3.frameTranslation.shape.e_x[2],Crank3.frameTranslation.shape.e_x[3]},if noEvent(Crank3.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank3.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank3.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank3.frameTranslation.shape.widthDirection[1],Crank3.frameTranslation.shape.widthDirection[2],Crank3.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank3.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank3.frameTranslation.shape.e_x[1],Crank3.frameTranslation.shape.e_x[2],Crank3.frameTranslation.shape.e_x[3]})[1];
//   protected Real Crank3.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank3.frameTranslation.shape.e_x[1],Crank3.frameTranslation.shape.e_x[2],Crank3.frameTranslation.shape.e_x[3]},if noEvent(Crank3.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank3.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank3.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank3.frameTranslation.shape.widthDirection[1],Crank3.frameTranslation.shape.widthDirection[2],Crank3.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank3.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank3.frameTranslation.shape.e_x[1],Crank3.frameTranslation.shape.e_x[2],Crank3.frameTranslation.shape.e_x[3]})[2];
//   protected Real Crank3.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank3.frameTranslation.shape.e_x[1],Crank3.frameTranslation.shape.e_x[2],Crank3.frameTranslation.shape.e_x[3]},if noEvent(Crank3.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank3.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank3.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank3.frameTranslation.shape.widthDirection[1],Crank3.frameTranslation.shape.widthDirection[2],Crank3.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank3.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank3.frameTranslation.shape.e_x[1],Crank3.frameTranslation.shape.e_x[2],Crank3.frameTranslation.shape.e_x[3]})[3];
//   protected output Real Crank3.frameTranslation.shape.Form;
//   output Real Crank3.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank3.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Crank3.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank3.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank3.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank3.frameTranslation.shape.Material;
//   protected output Real Crank3.frameTranslation.shape.Extra;
//   Real Crank1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank1.animation = true \"= true, if animation shall be enabled (show cylinder between frame_a and frame_b)\";
//   parameter Real Crank1.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 0.1 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Crank1.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Crank1.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b, resolved in frame_a\";
//   parameter Real Crank1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Crank1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Crank1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to cylinder origin, resolved in frame_a\";
//   parameter Real Crank1.lengthDirection[1](unit = \"1\") = Crank1.r[1] - Crank1.r_shape[1] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Crank1.lengthDirection[2](unit = \"1\") = Crank1.r[2] - Crank1.r_shape[2] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Crank1.lengthDirection[3](unit = \"1\") = Crank1.r[3] - Crank1.r_shape[3] \"Vector in length direction of cylinder, resolved in frame_a\";
//   parameter Real Crank1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Crank1.r[1] - Crank1.r_shape[1],Crank1.r[2] - Crank1.r_shape[2],Crank1.r[3] - Crank1.r_shape[3]}) \"Length of cylinder\";
//   parameter Real Crank1.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \"Diameter of cylinder\";
//   parameter Real Crank1.innerDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Inner diameter of cylinder (0 <= innerDiameter <= Diameter)\";
//   parameter Real Crank1.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer Crank1.color[1](min = 0, max = 255) = 0 \"Color of cylinder\";
//   input Integer Crank1.color[2](min = 0, max = 255) = 128 \"Color of cylinder\";
//   input Integer Crank1.color[3](min = 0, max = 255) = 255 \"Color of cylinder\";
//   input Real Crank1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Crank1.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank1.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank1.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank1.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank1.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank1.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank1.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank1.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank1.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank1.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank1.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank1.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank1.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank1.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank1.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank1.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank1.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank1.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank1.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank1.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank1.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank1.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank1.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank1.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean Crank1.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank1.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank1.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank1.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank1.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   constant Real Crank1.pi = 3.14159265358979;
//   parameter Real Crank1.radius(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank1.diameter / 2.0 \"Radius of cylinder\";
//   parameter Real Crank1.innerRadius(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank1.innerDiameter / 2.0 \"Inner-Radius of cylinder\";
//   parameter Real Crank1.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.14159265358979 * (Crank1.density * (Crank1.length * Crank1.radius ^ 2.0)) \"Mass of cylinder without hole\";
//   parameter Real Crank1.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.14159265358979 * (Crank1.density * (Crank1.length * Crank1.innerRadius ^ 2.0)) \"Mass of hole of cylinder\";
//   parameter Real Crank1.I22(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.mo * (Crank1.length ^ 2.0 + 3.0 * Crank1.radius ^ 2.0) / 12.0 - Crank1.mi * (Crank1.length ^ 2.0 + 3.0 * Crank1.innerRadius ^ 2.0) / 12.0 \"Inertia with respect to axis through center of mass, perpendicular to cylinder axis\";
//   parameter Real Crank1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank1.mo - Crank1.mi \"Mass of cylinder\";
//   parameter Real Crank1.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank1.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank1.r[1],Crank1.r[2],Crank1.r[3]},1e-13)[1] * Crank1.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank1.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank1.r[1],Crank1.r[2],Crank1.r[3]},1e-13)[2] * Crank1.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank1.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank1.r[1],Crank1.r[2],Crank1.r[3]},1e-13)[3] * Crank1.length / 2.0 \"Position vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank1.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[1][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[1][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[1][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[2][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[2][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[2][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[3][1] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[3][2] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   parameter Real Crank1.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank1.R,{{Crank1.mo * Crank1.radius ^ 2.0 / 2.0 - Crank1.mi * Crank1.innerRadius ^ 2.0 / 2.0,0.0,0.0},{0.0,Crank1.I22,0.0},{0.0,0.0,Crank1.I22}})[3][3] \"Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a\";
//   Real Crank1.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank1.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real Crank1.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank1.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank1.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank1.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank1.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank1.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank1.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = Crank1.m \"Mass of rigid body\";
//   parameter Real Crank1.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank1.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real Crank1.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank1.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real Crank1.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank1.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real Crank1.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank1.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real Crank1.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank1.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real Crank1.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank1.I[3,2] \" (3,2) element of inertia tensor\";
//   Real Crank1.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank1.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank1.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank1.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank1.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank1.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank1.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank1.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank1.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank1.body.angles_fixed = Crank1.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank1.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank1.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank1.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank1.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank1.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank1.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank1.body.sequence_start[1](min = 1, max = 3) = Crank1.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank1.body.sequence_start[2](min = 1, max = 3) = Crank1.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank1.body.sequence_start[3](min = 1, max = 3) = Crank1.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank1.body.w_0_fixed = Crank1.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank1.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank1.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank1.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank1.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank1.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank1.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank1.body.z_0_fixed = Crank1.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank1.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank1.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank1.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank1.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank1.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank1.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank1.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer Crank1.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer Crank1.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer Crank1.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   parameter Real Crank1.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank1.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   input Integer Crank1.body.cylinderColor[1](min = 0, max = 255) = Crank1.body.sphereColor[1] \"Color of cylinder\";
//   input Integer Crank1.body.cylinderColor[2](min = 0, max = 255) = Crank1.body.sphereColor[2] \"Color of cylinder\";
//   input Integer Crank1.body.cylinderColor[3](min = 0, max = 255) = Crank1.body.sphereColor[3] \"Color of cylinder\";
//   input Real Crank1.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean Crank1.body.enforceStates = Crank1.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank1.body.useQuaternions = Crank1.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank1.body.sequence_angleStates[1](min = 1, max = 3) = Crank1.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank1.body.sequence_angleStates[2](min = 1, max = 3) = Crank1.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank1.body.sequence_angleStates[3](min = 1, max = 3) = Crank1.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Crank1.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_11 \"inertia tensor\";
//   parameter Real Crank1.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_21 \"inertia tensor\";
//   parameter Real Crank1.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_31 \"inertia tensor\";
//   parameter Real Crank1.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_21 \"inertia tensor\";
//   parameter Real Crank1.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_22 \"inertia tensor\";
//   parameter Real Crank1.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_32 \"inertia tensor\";
//   parameter Real Crank1.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_31 \"inertia tensor\";
//   parameter Real Crank1.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_32 \"inertia tensor\";
//   parameter Real Crank1.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank1.body.I_33 \"inertia tensor\";
//   parameter Real Crank1.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank1.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank1.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank1.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank1.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.z_0_start[1],Crank1.body.z_0_start[2],Crank1.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank1.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.z_0_start[1],Crank1.body.z_0_start[2],Crank1.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank1.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.z_0_start[1],Crank1.body.z_0_start[2],Crank1.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real Crank1.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.w_0_start[1],Crank1.body.w_0_start[2],Crank1.body.w_0_start[3]})[1], fixed = Crank1.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank1.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.w_0_start[1],Crank1.body.w_0_start[2],Crank1.body.w_0_start[3]})[2], fixed = Crank1.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank1.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.w_0_start[1],Crank1.body.w_0_start[2],Crank1.body.w_0_start[3]})[3], fixed = Crank1.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank1.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.z_0_start[1],Crank1.body.z_0_start[2],Crank1.body.z_0_start[3]})[1], fixed = Crank1.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank1.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.z_0_start[1],Crank1.body.z_0_start[2],Crank1.body.z_0_start[3]})[2], fixed = Crank1.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank1.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.R_start,{Crank1.body.z_0_start[1],Crank1.body.z_0_start[2],Crank1.body.z_0_start[3]})[3], fixed = Crank1.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank1.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank1.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank1.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected parameter Real Crank1.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank1.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank1.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank1.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected Real Crank1.body.Q[1](start = Crank1.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank1.body.Q[2](start = Crank1.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank1.body.Q[3](start = Crank1.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank1.body.Q[4](start = Crank1.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real Crank1.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank1.body.sequence_start[1] == Crank1.body.sequence_angleStates[1] AND Crank1.body.sequence_start[2] == Crank1.body.sequence_angleStates[2] AND Crank1.body.sequence_start[3] == Crank1.body.sequence_angleStates[3] then Crank1.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank1.body.R_start,{Crank1.body.sequence_angleStates[1],Crank1.body.sequence_angleStates[2],Crank1.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real Crank1.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank1.body.sequence_start[1] == Crank1.body.sequence_angleStates[1] AND Crank1.body.sequence_start[2] == Crank1.body.sequence_angleStates[2] AND Crank1.body.sequence_start[3] == Crank1.body.sequence_angleStates[3] then Crank1.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank1.body.R_start,{Crank1.body.sequence_angleStates[1],Crank1.body.sequence_angleStates[2],Crank1.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real Crank1.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank1.body.sequence_start[1] == Crank1.body.sequence_angleStates[1] AND Crank1.body.sequence_start[2] == Crank1.body.sequence_angleStates[2] AND Crank1.body.sequence_start[3] == Crank1.body.sequence_angleStates[3] then Crank1.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank1.body.R_start,{Crank1.body.sequence_angleStates[1],Crank1.body.sequence_angleStates[2],Crank1.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   protected Real Crank1.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank1.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank1.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank1.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank1.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank1.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank1.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank1.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank1.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank1.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank1.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank1.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   Real Crank1.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank1.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank1.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank1.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank1.frameTranslation.animation = Crank1.animation \"= true, if animation shall be enabled\";
//   parameter Real Crank1.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank1.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank1.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank1.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Crank1.frameTranslation.shapeType = \"pipecylinder\" \" Type of shape\";
//   parameter Real Crank1.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank1.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank1.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank1.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.lengthDirection[1](unit = \"1\") = Crank1.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.lengthDirection[2](unit = \"1\") = Crank1.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.lengthDirection[3](unit = \"1\") = Crank1.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank1.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Crank1.length \" Length of shape\";
//   parameter Real Crank1.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank1.diameter \" Width of shape\";
//   parameter Real Crank1.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank1.diameter \" Height of shape.\";
//   parameter Real Crank1.frameTranslation.extra = Crank1.innerDiameter / Crank1.diameter \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Crank1.frameTranslation.color[1](min = 0, max = 255) = Crank1.color[1] \" Color of shape\";
//   input Integer Crank1.frameTranslation.color[2](min = 0, max = 255) = Crank1.color[2] \" Color of shape\";
//   input Integer Crank1.frameTranslation.color[3](min = 0, max = 255) = Crank1.color[3] \" Color of shape\";
//   input Real Crank1.frameTranslation.specularCoefficient = Crank1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Crank1.frameTranslation.shape.shapeType = Crank1.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Crank1.frameTranslation.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank1.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank1.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank1.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank1.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank1.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank1.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank1.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.lengthDirection[1](unit = \"1\") = Crank1.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.lengthDirection[2](unit = \"1\") = Crank1.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.lengthDirection[3](unit = \"1\") = Crank1.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.widthDirection[1](unit = \"1\") = Crank1.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.widthDirection[2](unit = \"1\") = Crank1.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.widthDirection[3](unit = \"1\") = Crank1.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Crank1.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.length \"Length of visual object\";
//   input Real Crank1.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.width \"Width of visual object\";
//   input Real Crank1.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = Crank1.frameTranslation.height \"Height of visual object\";
//   input Real Crank1.frameTranslation.shape.extra = Crank1.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real Crank1.frameTranslation.shape.color[1] = Real(Crank1.frameTranslation.color[1]) \"Color of shape\";
//   input Real Crank1.frameTranslation.shape.color[2] = Real(Crank1.frameTranslation.color[2]) \"Color of shape\";
//   input Real Crank1.frameTranslation.shape.color[3] = Real(Crank1.frameTranslation.color[3]) \"Color of shape\";
//   input Real Crank1.frameTranslation.shape.specularCoefficient = Crank1.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Crank1.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Crank1.frameTranslation.shape.lengthDirection[1],Crank1.frameTranslation.shape.lengthDirection[2],Crank1.frameTranslation.shape.lengthDirection[3]});
//   protected Real Crank1.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(Crank1.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else Crank1.frameTranslation.shape.lengthDirection[1] / Crank1.frameTranslation.shape.abs_n_x;
//   protected Real Crank1.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(Crank1.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank1.frameTranslation.shape.lengthDirection[2] / Crank1.frameTranslation.shape.abs_n_x;
//   protected Real Crank1.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(Crank1.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank1.frameTranslation.shape.lengthDirection[3] / Crank1.frameTranslation.shape.abs_n_x;
//   protected Real Crank1.frameTranslation.shape.n_z_aux[1](unit = \"1\") = Crank1.frameTranslation.shape.e_x[2] * Crank1.frameTranslation.shape.widthDirection[3] - Crank1.frameTranslation.shape.e_x[3] * Crank1.frameTranslation.shape.widthDirection[2];
//   protected Real Crank1.frameTranslation.shape.n_z_aux[2](unit = \"1\") = Crank1.frameTranslation.shape.e_x[3] * Crank1.frameTranslation.shape.widthDirection[1] - Crank1.frameTranslation.shape.e_x[1] * Crank1.frameTranslation.shape.widthDirection[3];
//   protected Real Crank1.frameTranslation.shape.n_z_aux[3](unit = \"1\") = Crank1.frameTranslation.shape.e_x[1] * Crank1.frameTranslation.shape.widthDirection[2] - Crank1.frameTranslation.shape.e_x[2] * Crank1.frameTranslation.shape.widthDirection[1];
//   protected Real Crank1.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank1.frameTranslation.shape.e_x[1],Crank1.frameTranslation.shape.e_x[2],Crank1.frameTranslation.shape.e_x[3]},if noEvent(Crank1.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank1.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank1.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank1.frameTranslation.shape.widthDirection[1],Crank1.frameTranslation.shape.widthDirection[2],Crank1.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank1.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank1.frameTranslation.shape.e_x[1],Crank1.frameTranslation.shape.e_x[2],Crank1.frameTranslation.shape.e_x[3]})[1];
//   protected Real Crank1.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank1.frameTranslation.shape.e_x[1],Crank1.frameTranslation.shape.e_x[2],Crank1.frameTranslation.shape.e_x[3]},if noEvent(Crank1.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank1.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank1.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank1.frameTranslation.shape.widthDirection[1],Crank1.frameTranslation.shape.widthDirection[2],Crank1.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank1.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank1.frameTranslation.shape.e_x[1],Crank1.frameTranslation.shape.e_x[2],Crank1.frameTranslation.shape.e_x[3]})[2];
//   protected Real Crank1.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank1.frameTranslation.shape.e_x[1],Crank1.frameTranslation.shape.e_x[2],Crank1.frameTranslation.shape.e_x[3]},if noEvent(Crank1.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank1.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank1.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank1.frameTranslation.shape.widthDirection[1],Crank1.frameTranslation.shape.widthDirection[2],Crank1.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank1.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank1.frameTranslation.shape.e_x[1],Crank1.frameTranslation.shape.e_x[2],Crank1.frameTranslation.shape.e_x[3]})[3];
//   protected output Real Crank1.frameTranslation.shape.Form;
//   output Real Crank1.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank1.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Crank1.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank1.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank1.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank1.frameTranslation.shape.Material;
//   protected output Real Crank1.frameTranslation.shape.Extra;
//   Real Crank2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank2.animation = true \"= true, if animation shall be enabled (show box between frame_a and frame_b)\";
//   parameter Real Crank2.r[1](quantity = \"Length\", unit = \"m\", start = 0.1) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.1 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Crank2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Crank2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Vector from frame_a to box origin, resolved in frame_a\";
//   parameter Real Crank2.lengthDirection[1](unit = \"1\") = Crank2.r[1] - Crank2.r_shape[1] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Crank2.lengthDirection[2](unit = \"1\") = Crank2.r[2] - Crank2.r_shape[2] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Crank2.lengthDirection[3](unit = \"1\") = Crank2.r[3] - Crank2.r_shape[3] \"Vector in length direction of box, resolved in frame_a\";
//   parameter Real Crank2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Crank2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Crank2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Crank2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Crank2.r[1] - Crank2.r_shape[1],Crank2.r[2] - Crank2.r_shape[2],Crank2.r[3] - Crank2.r_shape[3]}) \"Length of box\";
//   parameter Real Crank2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Width of box\";
//   parameter Real Crank2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \"Height of box\";
//   parameter Real Crank2.innerWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Width of inner box surface (0 <= innerWidth <= width)\";
//   parameter Real Crank2.innerHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank2.innerWidth \"Height of inner box surface (0 <= innerHeight <= height)\";
//   parameter Real Crank2.density(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 7700.0 \"Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\";
//   input Integer Crank2.color[1](min = 0, max = 255) = 0 \"Color of box\";
//   input Integer Crank2.color[2](min = 0, max = 255) = 128 \"Color of box\";
//   input Integer Crank2.color[3](min = 0, max = 255) = 255 \"Color of box\";
//   input Real Crank2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Crank2.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank2.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank2.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank2.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank2.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank2.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank2.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank2.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank2.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank2.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank2.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank2.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank2.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank2.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank2.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank2.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank2.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank2.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank2.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank2.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank2.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank2.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank2.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank2.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Boolean Crank2.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank2.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank2.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank2.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank2.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Crank2.mo(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank2.density * (Crank2.length * (Crank2.width * Crank2.height)) \"Mass of box without hole\";
//   parameter Real Crank2.mi(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank2.density * (Crank2.length * (Crank2.innerWidth * Crank2.innerHeight)) \"Mass of hole of box\";
//   parameter Real Crank2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = Crank2.mo - Crank2.mi \"Mass of box\";
//   parameter Real Crank2.R.T[1,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[1,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[2,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[2,2] = -0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.T[3,3] = -1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank2.r_CM[1](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank2.r[1],Crank2.r[2],Crank2.r[3]},1e-13)[1] * Crank2.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank2.r_CM[2](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank2.r[1],Crank2.r[2],Crank2.r[3]},1e-13)[2] * Crank2.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank2.r_CM[3](quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.normalize({Crank2.r[1],Crank2.r[2],Crank2.r[3]},1e-13)[3] * Crank2.length / 2.0 \"Position vector from origin of frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank2.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[1][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[1][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[1][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[2][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[2][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[2][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[3][1] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[3][2] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   parameter Real Crank2.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(Crank2.R,{{Crank2.mo * (Crank2.width ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.innerWidth ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.height ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,Crank2.mo * (Crank2.length ^ 2.0 / 12.0 + Crank2.width ^ 2.0 / 12.0) - Crank2.mi * (Crank2.length ^ 2.0 / 12.0 + Crank2.innerWidth ^ 2.0 / 12.0)}})[3][3] \"Inertia tensor of body box with respect to center of mass, parallel to frame_a\";
//   Real Crank2.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank2.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real Crank2.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank2.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank2.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank2.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank2.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank2.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real Crank2.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = Crank2.m \"Mass of rigid body\";
//   parameter Real Crank2.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank2.I[1,1] \" (1,1) element of inertia tensor\";
//   parameter Real Crank2.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank2.I[2,2] \" (2,2) element of inertia tensor\";
//   parameter Real Crank2.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = Crank2.I[3,3] \" (3,3) element of inertia tensor\";
//   parameter Real Crank2.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank2.I[2,1] \" (2,1) element of inertia tensor\";
//   parameter Real Crank2.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank2.I[3,1] \" (3,1) element of inertia tensor\";
//   parameter Real Crank2.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = Crank2.I[3,2] \" (3,2) element of inertia tensor\";
//   Real Crank2.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank2.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank2.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real Crank2.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank2.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank2.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real Crank2.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank2.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real Crank2.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean Crank2.body.angles_fixed = Crank2.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real Crank2.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank2.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank2.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank2.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real Crank2.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Crank2.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer Crank2.body.sequence_start[1](min = 1, max = 3) = Crank2.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank2.body.sequence_start[2](min = 1, max = 3) = Crank2.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer Crank2.body.sequence_start[3](min = 1, max = 3) = Crank2.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean Crank2.body.w_0_fixed = Crank2.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real Crank2.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank2.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank2.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank2.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real Crank2.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = Crank2.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean Crank2.body.z_0_fixed = Crank2.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real Crank2.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank2.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank2.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank2.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank2.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Crank2.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real Crank2.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer Crank2.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer Crank2.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer Crank2.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   parameter Real Crank2.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank2.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   input Integer Crank2.body.cylinderColor[1](min = 0, max = 255) = Crank2.body.sphereColor[1] \"Color of cylinder\";
//   input Integer Crank2.body.cylinderColor[2](min = 0, max = 255) = Crank2.body.sphereColor[2] \"Color of cylinder\";
//   input Integer Crank2.body.cylinderColor[3](min = 0, max = 255) = Crank2.body.sphereColor[3] \"Color of cylinder\";
//   input Real Crank2.body.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean Crank2.body.enforceStates = Crank2.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean Crank2.body.useQuaternions = Crank2.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer Crank2.body.sequence_angleStates[1](min = 1, max = 3) = Crank2.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank2.body.sequence_angleStates[2](min = 1, max = 3) = Crank2.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer Crank2.body.sequence_angleStates[3](min = 1, max = 3) = Crank2.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Real Crank2.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_11 \"inertia tensor\";
//   parameter Real Crank2.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_21 \"inertia tensor\";
//   parameter Real Crank2.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_31 \"inertia tensor\";
//   parameter Real Crank2.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_21 \"inertia tensor\";
//   parameter Real Crank2.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_22 \"inertia tensor\";
//   parameter Real Crank2.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_32 \"inertia tensor\";
//   parameter Real Crank2.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_31 \"inertia tensor\";
//   parameter Real Crank2.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_32 \"inertia tensor\";
//   parameter Real Crank2.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = Crank2.body.I_33 \"inertia tensor\";
//   parameter Real Crank2.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real Crank2.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank2.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank2.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real Crank2.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.z_0_start[1],Crank2.body.z_0_start[2],Crank2.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank2.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.z_0_start[1],Crank2.body.z_0_start[2],Crank2.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real Crank2.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.z_0_start[1],Crank2.body.z_0_start[2],Crank2.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   Real Crank2.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.w_0_start[1],Crank2.body.w_0_start[2],Crank2.body.w_0_start[3]})[1], fixed = Crank2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank2.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.w_0_start[1],Crank2.body.w_0_start[2],Crank2.body.w_0_start[3]})[2], fixed = Crank2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank2.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.w_0_start[1],Crank2.body.w_0_start[2],Crank2.body.w_0_start[3]})[3], fixed = Crank2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real Crank2.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.z_0_start[1],Crank2.body.z_0_start[2],Crank2.body.z_0_start[3]})[1], fixed = Crank2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank2.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.z_0_start[1],Crank2.body.z_0_start[2],Crank2.body.z_0_start[3]})[2], fixed = Crank2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank2.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.R_start,{Crank2.body.z_0_start[1],Crank2.body.z_0_start[2],Crank2.body.z_0_start[3]})[3], fixed = Crank2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real Crank2.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank2.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real Crank2.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected parameter Real Crank2.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank2.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank2.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real Crank2.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(Crank2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected Real Crank2.body.Q[1](start = Crank2.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank2.body.Q[2](start = Crank2.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank2.body.Q[3](start = Crank2.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real Crank2.body.Q[4](start = Crank2.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected parameter Real Crank2.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank2.body.sequence_start[1] == Crank2.body.sequence_angleStates[1] AND Crank2.body.sequence_start[2] == Crank2.body.sequence_angleStates[2] AND Crank2.body.sequence_start[3] == Crank2.body.sequence_angleStates[3] then Crank2.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank2.body.R_start,{Crank2.body.sequence_angleStates[1],Crank2.body.sequence_angleStates[2],Crank2.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real Crank2.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank2.body.sequence_start[1] == Crank2.body.sequence_angleStates[1] AND Crank2.body.sequence_start[2] == Crank2.body.sequence_angleStates[2] AND Crank2.body.sequence_start[3] == Crank2.body.sequence_angleStates[3] then Crank2.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank2.body.R_start,{Crank2.body.sequence_angleStates[1],Crank2.body.sequence_angleStates[2],Crank2.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real Crank2.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if Crank2.body.sequence_start[1] == Crank2.body.sequence_angleStates[1] AND Crank2.body.sequence_start[2] == Crank2.body.sequence_angleStates[2] AND Crank2.body.sequence_start[3] == Crank2.body.sequence_angleStates[3] then Crank2.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(Crank2.body.R_start,{Crank2.body.sequence_angleStates[1],Crank2.body.sequence_angleStates[2],Crank2.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   protected Real Crank2.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank2.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank2.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank2.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank2.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = Crank2.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real Crank2.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank2.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank2.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real Crank2.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank2.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real Crank2.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   Real Crank2.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Crank2.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Crank2.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Crank2.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Crank2.frameTranslation.animation = Crank2.animation \"= true, if animation shall be enabled\";
//   parameter Real Crank2.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank2.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank2.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = Crank2.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Crank2.frameTranslation.shapeType = \"box\" \" Type of shape\";
//   parameter Real Crank2.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank2.r_shape[1] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank2.r_shape[2] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank2.r_shape[3] \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.lengthDirection[1](unit = \"1\") = Crank2.lengthDirection[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.lengthDirection[2](unit = \"1\") = Crank2.lengthDirection[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.lengthDirection[3](unit = \"1\") = Crank2.lengthDirection[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.widthDirection[1](unit = \"1\") = Crank2.widthDirection[1] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.widthDirection[2](unit = \"1\") = Crank2.widthDirection[2] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.widthDirection[3](unit = \"1\") = Crank2.widthDirection[3] \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Crank2.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Crank2.length \" Length of shape\";
//   parameter Real Crank2.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank2.width \" Width of shape\";
//   parameter Real Crank2.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Crank2.height \" Height of shape.\";
//   parameter Real Crank2.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Crank2.frameTranslation.color[1](min = 0, max = 255) = Crank2.color[1] \" Color of shape\";
//   input Integer Crank2.frameTranslation.color[2](min = 0, max = 255) = Crank2.color[2] \" Color of shape\";
//   input Integer Crank2.frameTranslation.color[3](min = 0, max = 255) = Crank2.color[3] \" Color of shape\";
//   input Real Crank2.frameTranslation.specularCoefficient = Crank2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Crank2.frameTranslation.shape.shapeType = Crank2.frameTranslation.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Crank2.frameTranslation.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Crank2.frameTranslation.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank2.frameTranslation.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank2.frameTranslation.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Crank2.frameTranslation.shape.r[1](quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank2.frameTranslation.shape.r[2](quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank2.frameTranslation.shape.r[3](quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Crank2.frameTranslation.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.lengthDirection[1](unit = \"1\") = Crank2.frameTranslation.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.lengthDirection[2](unit = \"1\") = Crank2.frameTranslation.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.lengthDirection[3](unit = \"1\") = Crank2.frameTranslation.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.widthDirection[1](unit = \"1\") = Crank2.frameTranslation.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.widthDirection[2](unit = \"1\") = Crank2.frameTranslation.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.widthDirection[3](unit = \"1\") = Crank2.frameTranslation.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Crank2.frameTranslation.shape.length(quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.length \"Length of visual object\";
//   input Real Crank2.frameTranslation.shape.width(quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.width \"Width of visual object\";
//   input Real Crank2.frameTranslation.shape.height(quantity = \"Length\", unit = \"m\") = Crank2.frameTranslation.height \"Height of visual object\";
//   input Real Crank2.frameTranslation.shape.extra = Crank2.frameTranslation.extra \"Additional size data for some of the shape types\";
//   input Real Crank2.frameTranslation.shape.color[1] = Real(Crank2.frameTranslation.color[1]) \"Color of shape\";
//   input Real Crank2.frameTranslation.shape.color[2] = Real(Crank2.frameTranslation.color[2]) \"Color of shape\";
//   input Real Crank2.frameTranslation.shape.color[3] = Real(Crank2.frameTranslation.color[3]) \"Color of shape\";
//   input Real Crank2.frameTranslation.shape.specularCoefficient = Crank2.frameTranslation.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Crank2.frameTranslation.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Crank2.frameTranslation.shape.lengthDirection[1],Crank2.frameTranslation.shape.lengthDirection[2],Crank2.frameTranslation.shape.lengthDirection[3]});
//   protected Real Crank2.frameTranslation.shape.e_x[1](unit = \"1\") = if noEvent(Crank2.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else Crank2.frameTranslation.shape.lengthDirection[1] / Crank2.frameTranslation.shape.abs_n_x;
//   protected Real Crank2.frameTranslation.shape.e_x[2](unit = \"1\") = if noEvent(Crank2.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank2.frameTranslation.shape.lengthDirection[2] / Crank2.frameTranslation.shape.abs_n_x;
//   protected Real Crank2.frameTranslation.shape.e_x[3](unit = \"1\") = if noEvent(Crank2.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else Crank2.frameTranslation.shape.lengthDirection[3] / Crank2.frameTranslation.shape.abs_n_x;
//   protected Real Crank2.frameTranslation.shape.n_z_aux[1](unit = \"1\") = Crank2.frameTranslation.shape.e_x[2] * Crank2.frameTranslation.shape.widthDirection[3] - Crank2.frameTranslation.shape.e_x[3] * Crank2.frameTranslation.shape.widthDirection[2];
//   protected Real Crank2.frameTranslation.shape.n_z_aux[2](unit = \"1\") = Crank2.frameTranslation.shape.e_x[3] * Crank2.frameTranslation.shape.widthDirection[1] - Crank2.frameTranslation.shape.e_x[1] * Crank2.frameTranslation.shape.widthDirection[3];
//   protected Real Crank2.frameTranslation.shape.n_z_aux[3](unit = \"1\") = Crank2.frameTranslation.shape.e_x[1] * Crank2.frameTranslation.shape.widthDirection[2] - Crank2.frameTranslation.shape.e_x[2] * Crank2.frameTranslation.shape.widthDirection[1];
//   protected Real Crank2.frameTranslation.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank2.frameTranslation.shape.e_x[1],Crank2.frameTranslation.shape.e_x[2],Crank2.frameTranslation.shape.e_x[3]},if noEvent(Crank2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank2.frameTranslation.shape.widthDirection[1],Crank2.frameTranslation.shape.widthDirection[2],Crank2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank2.frameTranslation.shape.e_x[1],Crank2.frameTranslation.shape.e_x[2],Crank2.frameTranslation.shape.e_x[3]})[1];
//   protected Real Crank2.frameTranslation.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank2.frameTranslation.shape.e_x[1],Crank2.frameTranslation.shape.e_x[2],Crank2.frameTranslation.shape.e_x[3]},if noEvent(Crank2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank2.frameTranslation.shape.widthDirection[1],Crank2.frameTranslation.shape.widthDirection[2],Crank2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank2.frameTranslation.shape.e_x[1],Crank2.frameTranslation.shape.e_x[2],Crank2.frameTranslation.shape.e_x[3]})[2];
//   protected Real Crank2.frameTranslation.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Crank2.frameTranslation.shape.e_x[1],Crank2.frameTranslation.shape.e_x[2],Crank2.frameTranslation.shape.e_x[3]},if noEvent(Crank2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (Crank2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + Crank2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Crank2.frameTranslation.shape.widthDirection[1],Crank2.frameTranslation.shape.widthDirection[2],Crank2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(Crank2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Crank2.frameTranslation.shape.e_x[1],Crank2.frameTranslation.shape.e_x[2],Crank2.frameTranslation.shape.e_x[3]})[3];
//   protected output Real Crank2.frameTranslation.shape.Form;
//   output Real Crank2.frameTranslation.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Crank2.frameTranslation.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Crank2.frameTranslation.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank2.frameTranslation.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank2.frameTranslation.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Crank2.frameTranslation.shape.Material;
//   protected output Real Crank2.frameTranslation.shape.Extra;
//   Real Mid.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Mid.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Mid.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Mid.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Mid.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Mid.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Mid.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Mid.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Mid.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Mid.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Mid.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Mid.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Mid.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Mid.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Mid.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Mid.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Mid.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Mid.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Mid.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Mid.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Mid.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Mid.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Mid.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Mid.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Mid.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Mid.animation = true \"= true, if animation shall be enabled\";
//   parameter Real Mid.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.05 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Mid.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Mid.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Mid.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real Mid.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Mid.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Mid.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Mid.lengthDirection[1](unit = \"1\") = Mid.r[1] - Mid.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Mid.lengthDirection[2](unit = \"1\") = Mid.r[2] - Mid.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Mid.lengthDirection[3](unit = \"1\") = Mid.r[3] - Mid.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Mid.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Mid.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Mid.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Mid.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Mid.r[1] - Mid.r_shape[1],Mid.r[2] - Mid.r_shape[2],Mid.r[3] - Mid.r_shape[3]}) \" Length of shape\";
//   parameter Real Mid.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Mid.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real Mid.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Mid.width \" Height of shape.\";
//   parameter Real Mid.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Mid.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer Mid.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer Mid.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real Mid.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String Mid.shape.shapeType = Mid.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Mid.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Mid.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Mid.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Mid.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Mid.shape.r[1](quantity = \"Length\", unit = \"m\") = Mid.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Mid.shape.r[2](quantity = \"Length\", unit = \"m\") = Mid.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Mid.shape.r[3](quantity = \"Length\", unit = \"m\") = Mid.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Mid.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = Mid.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Mid.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = Mid.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Mid.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = Mid.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Mid.shape.lengthDirection[1](unit = \"1\") = Mid.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real Mid.shape.lengthDirection[2](unit = \"1\") = Mid.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real Mid.shape.lengthDirection[3](unit = \"1\") = Mid.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real Mid.shape.widthDirection[1](unit = \"1\") = Mid.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Mid.shape.widthDirection[2](unit = \"1\") = Mid.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Mid.shape.widthDirection[3](unit = \"1\") = Mid.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Mid.shape.length(quantity = \"Length\", unit = \"m\") = Mid.length \"Length of visual object\";
//   input Real Mid.shape.width(quantity = \"Length\", unit = \"m\") = Mid.width \"Width of visual object\";
//   input Real Mid.shape.height(quantity = \"Length\", unit = \"m\") = Mid.height \"Height of visual object\";
//   input Real Mid.shape.extra = Mid.extra \"Additional size data for some of the shape types\";
//   input Real Mid.shape.color[1] = Real(Mid.color[1]) \"Color of shape\";
//   input Real Mid.shape.color[2] = Real(Mid.color[2]) \"Color of shape\";
//   input Real Mid.shape.color[3] = Real(Mid.color[3]) \"Color of shape\";
//   input Real Mid.shape.specularCoefficient = Mid.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Mid.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Mid.shape.lengthDirection[1],Mid.shape.lengthDirection[2],Mid.shape.lengthDirection[3]});
//   protected Real Mid.shape.e_x[1](unit = \"1\") = if noEvent(Mid.shape.abs_n_x < 1e-10) then 1.0 else Mid.shape.lengthDirection[1] / Mid.shape.abs_n_x;
//   protected Real Mid.shape.e_x[2](unit = \"1\") = if noEvent(Mid.shape.abs_n_x < 1e-10) then 0.0 else Mid.shape.lengthDirection[2] / Mid.shape.abs_n_x;
//   protected Real Mid.shape.e_x[3](unit = \"1\") = if noEvent(Mid.shape.abs_n_x < 1e-10) then 0.0 else Mid.shape.lengthDirection[3] / Mid.shape.abs_n_x;
//   protected Real Mid.shape.n_z_aux[1](unit = \"1\") = Mid.shape.e_x[2] * Mid.shape.widthDirection[3] - Mid.shape.e_x[3] * Mid.shape.widthDirection[2];
//   protected Real Mid.shape.n_z_aux[2](unit = \"1\") = Mid.shape.e_x[3] * Mid.shape.widthDirection[1] - Mid.shape.e_x[1] * Mid.shape.widthDirection[3];
//   protected Real Mid.shape.n_z_aux[3](unit = \"1\") = Mid.shape.e_x[1] * Mid.shape.widthDirection[2] - Mid.shape.e_x[2] * Mid.shape.widthDirection[1];
//   protected Real Mid.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Mid.shape.e_x[1],Mid.shape.e_x[2],Mid.shape.e_x[3]},if noEvent(Mid.shape.n_z_aux[1] ^ 2.0 + (Mid.shape.n_z_aux[2] ^ 2.0 + Mid.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Mid.shape.widthDirection[1],Mid.shape.widthDirection[2],Mid.shape.widthDirection[3]} else if noEvent(abs(Mid.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Mid.shape.e_x[1],Mid.shape.e_x[2],Mid.shape.e_x[3]})[1];
//   protected Real Mid.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Mid.shape.e_x[1],Mid.shape.e_x[2],Mid.shape.e_x[3]},if noEvent(Mid.shape.n_z_aux[1] ^ 2.0 + (Mid.shape.n_z_aux[2] ^ 2.0 + Mid.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Mid.shape.widthDirection[1],Mid.shape.widthDirection[2],Mid.shape.widthDirection[3]} else if noEvent(abs(Mid.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Mid.shape.e_x[1],Mid.shape.e_x[2],Mid.shape.e_x[3]})[2];
//   protected Real Mid.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Mid.shape.e_x[1],Mid.shape.e_x[2],Mid.shape.e_x[3]},if noEvent(Mid.shape.n_z_aux[1] ^ 2.0 + (Mid.shape.n_z_aux[2] ^ 2.0 + Mid.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {Mid.shape.widthDirection[1],Mid.shape.widthDirection[2],Mid.shape.widthDirection[3]} else if noEvent(abs(Mid.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Mid.shape.e_x[1],Mid.shape.e_x[2],Mid.shape.e_x[3]})[3];
//   protected output Real Mid.shape.Form;
//   output Real Mid.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Mid.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Mid.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Mid.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Mid.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Mid.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Mid.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Mid.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Mid.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Mid.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Mid.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Mid.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Mid.shape.Material;
//   protected output Real Mid.shape.Extra;
//   Real cylPosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real cylPosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real cylPosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real cylPosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real cylPosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real cylPosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real cylPosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real cylPosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real cylPosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real cylPosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real cylPosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real cylPosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real cylPosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real cylPosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real cylPosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real cylPosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real cylPosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real cylPosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real cylPosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real cylPosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real cylPosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real cylPosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real cylPosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real cylPosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real cylPosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean cylPosition.animation = false \"= true, if animation shall be enabled\";
//   parameter Real cylPosition.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.15 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real cylPosition.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.55 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real cylPosition.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String cylPosition.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real cylPosition.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real cylPosition.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real cylPosition.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real cylPosition.lengthDirection[1](unit = \"1\") = cylPosition.r[1] - cylPosition.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real cylPosition.lengthDirection[2](unit = \"1\") = cylPosition.r[2] - cylPosition.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real cylPosition.lengthDirection[3](unit = \"1\") = cylPosition.r[3] - cylPosition.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real cylPosition.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real cylPosition.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real cylPosition.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real cylPosition.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({cylPosition.r[1] - cylPosition.r_shape[1],cylPosition.r[2] - cylPosition.r_shape[2],cylPosition.r[3] - cylPosition.r_shape[3]}) \" Length of shape\";
//   parameter Real cylPosition.width(quantity = \"Length\", unit = \"m\", min = 0.0) = cylPosition.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real cylPosition.height(quantity = \"Length\", unit = \"m\", min = 0.0) = cylPosition.width \" Height of shape.\";
//   parameter Real cylPosition.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer cylPosition.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer cylPosition.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer cylPosition.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real cylPosition.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real gasForce.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real gasForce.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real gasForce.flange_b.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real gasForce.flange_b.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real gasForce.s_rel(quantity = \"Length\", unit = \"m\", min = 0.0, start = 0.0) \"relative distance (= flange_b.s - flange_a.s)\";
//   Real gasForce.f(quantity = \"Force\", unit = \"N\") \"force between flanges (positive in direction of flange axis R)\";
//   parameter Real gasForce.L(quantity = \"Length\", unit = \"m\") = 0.35 \"Length of cylinder\";
//   parameter Real gasForce.d(quantity = \"Length\", unit = \"m\") = 0.1 \"diameter of cylinder\";
//   parameter Real gasForce.k0(quantity = \"Volume\", unit = \"m3\") = 0.01 \"Volume V = k0 + k1*(1-x), with x = 1 - s_rel/L\";
//   parameter Real gasForce.k1(quantity = \"Volume\", unit = \"m3\") = 1.0 \"Volume V = k0 + k1*(1-x), with x = 1 - s_rel/L\";
//   parameter Real gasForce.k(quantity = \"HeatCapacity\", unit = \"J/K\") = 1.0 \"Gas constant (p*V = k*T)\";
//   constant Real gasForce.pi = 3.14159265358979;
//   Real gasForce.x \"Normalized position of cylinder (= 1 - s_rel/L)\";
//   Real gasForce.dens(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0);
//   Real gasForce.press(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) \"Cylinder pressure\";
//   Real gasForce.V(quantity = \"Volume\", unit = \"m3\");
//   Real gasForce.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0);
//   Real gasForce.v_rel(quantity = \"Velocity\", unit = \"m/s\");
//   protected Real gasForce.R_air(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") = 287.051224952979;
//   Real B2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean B2.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real B2.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real B2.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real B2.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real B2.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Length of cylinder representing the joint axis\";
//   parameter Real B2.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \"Diameter of cylinder representing the joint axis\";
//   input Integer B2.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer B2.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer B2.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real B2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected parameter Real B2.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({B2.n[1],B2.n[2],B2.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real B2.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({B2.n[1],B2.n[2],B2.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real B2.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({B2.n[1],B2.n[2],B2.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real B2.nnx_a[1](unit = \"1\") = Real(if abs(B2.e[1]) > 0.1 then 0 else if abs(B2.e[2]) > 0.1 then 0 else 1) \"Arbitrary vector that is not aligned with rotation axis n\";
//   protected parameter Real B2.nnx_a[2](unit = \"1\") = Real(if abs(B2.e[1]) > 0.1 then 1 else if abs(B2.e[2]) > 0.1 then 0 else 0) \"Arbitrary vector that is not aligned with rotation axis n\";
//   protected parameter Real B2.nnx_a[3](unit = \"1\") = Real(if abs(B2.e[1]) > 0.1 then 0 else if abs(B2.e[2]) > 0.1 then 1 else 0) \"Arbitrary vector that is not aligned with rotation axis n\";
//   protected parameter Real B2.ey_a[1](unit = \"1\") = Modelica.Math.Vectors.normalize({B2.e[2] * B2.nnx_a[3] - B2.e[3] * B2.nnx_a[2],B2.e[3] * B2.nnx_a[1] - B2.e[1] * B2.nnx_a[3],B2.e[1] * B2.nnx_a[2] - B2.e[2] * B2.nnx_a[1]},1e-13)[1] \"Unit vector orthogonal to axis n of revolute joint, resolved in frame_a\";
//   protected parameter Real B2.ey_a[2](unit = \"1\") = Modelica.Math.Vectors.normalize({B2.e[2] * B2.nnx_a[3] - B2.e[3] * B2.nnx_a[2],B2.e[3] * B2.nnx_a[1] - B2.e[1] * B2.nnx_a[3],B2.e[1] * B2.nnx_a[2] - B2.e[2] * B2.nnx_a[1]},1e-13)[2] \"Unit vector orthogonal to axis n of revolute joint, resolved in frame_a\";
//   protected parameter Real B2.ey_a[3](unit = \"1\") = Modelica.Math.Vectors.normalize({B2.e[2] * B2.nnx_a[3] - B2.e[3] * B2.nnx_a[2],B2.e[3] * B2.nnx_a[1] - B2.e[1] * B2.nnx_a[3],B2.e[1] * B2.nnx_a[2] - B2.e[2] * B2.nnx_a[1]},1e-13)[3] \"Unit vector orthogonal to axis n of revolute joint, resolved in frame_a\";
//   protected parameter Real B2.ex_a[1](unit = \"1\") = B2.ey_a[2] * B2.e[3] - B2.ey_a[3] * B2.e[2] \"Unit vector orthogonal to axis n of revolute joint and to ey_a, resolved in frame_a\";
//   protected parameter Real B2.ex_a[2](unit = \"1\") = B2.ey_a[3] * B2.e[1] - B2.ey_a[1] * B2.e[3] \"Unit vector orthogonal to axis n of revolute joint and to ey_a, resolved in frame_a\";
//   protected parameter Real B2.ex_a[3](unit = \"1\") = B2.ey_a[1] * B2.e[2] - B2.ey_a[2] * B2.e[1] \"Unit vector orthogonal to axis n of revolute joint and to ey_a, resolved in frame_a\";
//   protected Real B2.ey_b[1](unit = \"1\") \"ey_a, resolved in frame_b\";
//   protected Real B2.ey_b[2](unit = \"1\") \"ey_a, resolved in frame_b\";
//   protected Real B2.ey_b[3](unit = \"1\") \"ey_a, resolved in frame_b\";
//   protected Real B2.ex_b[1](unit = \"1\") \"ex_a, resolved in frame_b\";
//   protected Real B2.ex_b[2](unit = \"1\") \"ex_a, resolved in frame_b\";
//   protected Real B2.ex_b[3](unit = \"1\") \"ex_a, resolved in frame_b\";
//   Real B2.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real B2.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B2.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   protected Real B2.r_rel_a[1](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b, resolved in frame_a\";
//   protected Real B2.r_rel_a[2](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b, resolved in frame_a\";
//   protected Real B2.r_rel_a[3](quantity = \"Length\", unit = \"m\") \"Position vector from origin of frame_a to origin of frame_b, resolved in frame_a\";
//   protected Real B2.f_c[1](quantity = \"Force\", unit = \"N\") \"Dummy or constraint forces in direction of ex_a, ey_a\";
//   protected Real B2.f_c[2](quantity = \"Force\", unit = \"N\") \"Dummy or constraint forces in direction of ex_a, ey_a\";
//   parameter String B2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real B2.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real B2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real B2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real B2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real B2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = B2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real B2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = B2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real B2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = B2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real B2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = (-B2.cylinderLength) * B2.e[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real B2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-B2.cylinderLength) * B2.e[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real B2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = (-B2.cylinderLength) * B2.e[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real B2.cylinder.lengthDirection[1](unit = \"1\") = B2.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real B2.cylinder.lengthDirection[2](unit = \"1\") = B2.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real B2.cylinder.lengthDirection[3](unit = \"1\") = B2.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real B2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real B2.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real B2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real B2.cylinder.length(quantity = \"Length\", unit = \"m\") = B2.cylinderLength \"Length of visual object\";
//   input Real B2.cylinder.width(quantity = \"Length\", unit = \"m\") = B2.cylinderDiameter \"Width of visual object\";
//   input Real B2.cylinder.height(quantity = \"Length\", unit = \"m\") = B2.cylinderDiameter \"Height of visual object\";
//   input Real B2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real B2.cylinder.color[1] = Real(B2.cylinderColor[1]) \"Color of shape\";
//   input Real B2.cylinder.color[2] = Real(B2.cylinderColor[2]) \"Color of shape\";
//   input Real B2.cylinder.color[3] = Real(B2.cylinderColor[3]) \"Color of shape\";
//   input Real B2.cylinder.specularCoefficient = B2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real B2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({B2.cylinder.lengthDirection[1],B2.cylinder.lengthDirection[2],B2.cylinder.lengthDirection[3]});
//   protected Real B2.cylinder.e_x[1](unit = \"1\") = if noEvent(B2.cylinder.abs_n_x < 1e-10) then 1.0 else B2.cylinder.lengthDirection[1] / B2.cylinder.abs_n_x;
//   protected Real B2.cylinder.e_x[2](unit = \"1\") = if noEvent(B2.cylinder.abs_n_x < 1e-10) then 0.0 else B2.cylinder.lengthDirection[2] / B2.cylinder.abs_n_x;
//   protected Real B2.cylinder.e_x[3](unit = \"1\") = if noEvent(B2.cylinder.abs_n_x < 1e-10) then 0.0 else B2.cylinder.lengthDirection[3] / B2.cylinder.abs_n_x;
//   protected Real B2.cylinder.n_z_aux[1](unit = \"1\") = B2.cylinder.e_x[2] * B2.cylinder.widthDirection[3] - B2.cylinder.e_x[3] * B2.cylinder.widthDirection[2];
//   protected Real B2.cylinder.n_z_aux[2](unit = \"1\") = B2.cylinder.e_x[3] * B2.cylinder.widthDirection[1] - B2.cylinder.e_x[1] * B2.cylinder.widthDirection[3];
//   protected Real B2.cylinder.n_z_aux[3](unit = \"1\") = B2.cylinder.e_x[1] * B2.cylinder.widthDirection[2] - B2.cylinder.e_x[2] * B2.cylinder.widthDirection[1];
//   protected Real B2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({B2.cylinder.e_x[1],B2.cylinder.e_x[2],B2.cylinder.e_x[3]},if noEvent(B2.cylinder.n_z_aux[1] ^ 2.0 + (B2.cylinder.n_z_aux[2] ^ 2.0 + B2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {B2.cylinder.widthDirection[1],B2.cylinder.widthDirection[2],B2.cylinder.widthDirection[3]} else if noEvent(abs(B2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{B2.cylinder.e_x[1],B2.cylinder.e_x[2],B2.cylinder.e_x[3]})[1];
//   protected Real B2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({B2.cylinder.e_x[1],B2.cylinder.e_x[2],B2.cylinder.e_x[3]},if noEvent(B2.cylinder.n_z_aux[1] ^ 2.0 + (B2.cylinder.n_z_aux[2] ^ 2.0 + B2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {B2.cylinder.widthDirection[1],B2.cylinder.widthDirection[2],B2.cylinder.widthDirection[3]} else if noEvent(abs(B2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{B2.cylinder.e_x[1],B2.cylinder.e_x[2],B2.cylinder.e_x[3]})[2];
//   protected Real B2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({B2.cylinder.e_x[1],B2.cylinder.e_x[2],B2.cylinder.e_x[3]},if noEvent(B2.cylinder.n_z_aux[1] ^ 2.0 + (B2.cylinder.n_z_aux[2] ^ 2.0 + B2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {B2.cylinder.widthDirection[1],B2.cylinder.widthDirection[2],B2.cylinder.widthDirection[3]} else if noEvent(abs(B2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{B2.cylinder.e_x[1],B2.cylinder.e_x[2],B2.cylinder.e_x[3]})[3];
//   protected output Real B2.cylinder.Form;
//   output Real B2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real B2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real B2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real B2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real B2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real B2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real B2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real B2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real B2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real B2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real B2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real B2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real B2.cylinder.Material;
//   protected output Real B2.cylinder.Extra;
//   Real B1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real B1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real B1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real B1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean B1.useAxisFlange = false \"= true, if axis flange is enabled\";
//   parameter Boolean B1.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real B1.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real B1.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real B1.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real B1.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real B1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Length of cylinder representing the joint axis\";
//   parameter Real B1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \"Diameter of cylinder representing the joint axis\";
//   input Integer B1.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer B1.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer B1.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real B1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) B1.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real B1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real B1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real B1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real B1.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real B1.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   protected parameter Real B1.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({B1.n[1],B1.n[2],B1.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real B1.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({B1.n[1],B1.n[2],B1.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real B1.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({B1.n[1],B1.n[2],B1.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real B1.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real B1.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real B1.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real B1.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real B1.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real B1.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real B1.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = B1.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real B1.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real B1.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real B1.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String B1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real B1.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real B1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real B1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real B1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real B1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = B1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real B1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = B1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real B1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = B1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real B1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = (-B1.cylinderLength) * B1.e[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real B1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-B1.cylinderLength) * B1.e[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real B1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = (-B1.cylinderLength) * B1.e[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real B1.cylinder.lengthDirection[1](unit = \"1\") = B1.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real B1.cylinder.lengthDirection[2](unit = \"1\") = B1.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real B1.cylinder.lengthDirection[3](unit = \"1\") = B1.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real B1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real B1.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real B1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real B1.cylinder.length(quantity = \"Length\", unit = \"m\") = B1.cylinderLength \"Length of visual object\";
//   input Real B1.cylinder.width(quantity = \"Length\", unit = \"m\") = B1.cylinderDiameter \"Width of visual object\";
//   input Real B1.cylinder.height(quantity = \"Length\", unit = \"m\") = B1.cylinderDiameter \"Height of visual object\";
//   input Real B1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real B1.cylinder.color[1] = Real(B1.cylinderColor[1]) \"Color of shape\";
//   input Real B1.cylinder.color[2] = Real(B1.cylinderColor[2]) \"Color of shape\";
//   input Real B1.cylinder.color[3] = Real(B1.cylinderColor[3]) \"Color of shape\";
//   input Real B1.cylinder.specularCoefficient = B1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real B1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({B1.cylinder.lengthDirection[1],B1.cylinder.lengthDirection[2],B1.cylinder.lengthDirection[3]});
//   protected Real B1.cylinder.e_x[1](unit = \"1\") = if noEvent(B1.cylinder.abs_n_x < 1e-10) then 1.0 else B1.cylinder.lengthDirection[1] / B1.cylinder.abs_n_x;
//   protected Real B1.cylinder.e_x[2](unit = \"1\") = if noEvent(B1.cylinder.abs_n_x < 1e-10) then 0.0 else B1.cylinder.lengthDirection[2] / B1.cylinder.abs_n_x;
//   protected Real B1.cylinder.e_x[3](unit = \"1\") = if noEvent(B1.cylinder.abs_n_x < 1e-10) then 0.0 else B1.cylinder.lengthDirection[3] / B1.cylinder.abs_n_x;
//   protected Real B1.cylinder.n_z_aux[1](unit = \"1\") = B1.cylinder.e_x[2] * B1.cylinder.widthDirection[3] - B1.cylinder.e_x[3] * B1.cylinder.widthDirection[2];
//   protected Real B1.cylinder.n_z_aux[2](unit = \"1\") = B1.cylinder.e_x[3] * B1.cylinder.widthDirection[1] - B1.cylinder.e_x[1] * B1.cylinder.widthDirection[3];
//   protected Real B1.cylinder.n_z_aux[3](unit = \"1\") = B1.cylinder.e_x[1] * B1.cylinder.widthDirection[2] - B1.cylinder.e_x[2] * B1.cylinder.widthDirection[1];
//   protected Real B1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({B1.cylinder.e_x[1],B1.cylinder.e_x[2],B1.cylinder.e_x[3]},if noEvent(B1.cylinder.n_z_aux[1] ^ 2.0 + (B1.cylinder.n_z_aux[2] ^ 2.0 + B1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {B1.cylinder.widthDirection[1],B1.cylinder.widthDirection[2],B1.cylinder.widthDirection[3]} else if noEvent(abs(B1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{B1.cylinder.e_x[1],B1.cylinder.e_x[2],B1.cylinder.e_x[3]})[1];
//   protected Real B1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({B1.cylinder.e_x[1],B1.cylinder.e_x[2],B1.cylinder.e_x[3]},if noEvent(B1.cylinder.n_z_aux[1] ^ 2.0 + (B1.cylinder.n_z_aux[2] ^ 2.0 + B1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {B1.cylinder.widthDirection[1],B1.cylinder.widthDirection[2],B1.cylinder.widthDirection[3]} else if noEvent(abs(B1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{B1.cylinder.e_x[1],B1.cylinder.e_x[2],B1.cylinder.e_x[3]})[2];
//   protected Real B1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({B1.cylinder.e_x[1],B1.cylinder.e_x[2],B1.cylinder.e_x[3]},if noEvent(B1.cylinder.n_z_aux[1] ^ 2.0 + (B1.cylinder.n_z_aux[2] ^ 2.0 + B1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {B1.cylinder.widthDirection[1],B1.cylinder.widthDirection[2],B1.cylinder.widthDirection[3]} else if noEvent(abs(B1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{B1.cylinder.e_x[1],B1.cylinder.e_x[2],B1.cylinder.e_x[3]})[3];
//   protected output Real B1.cylinder.Form;
//   output Real B1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real B1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real B1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real B1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real B1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real B1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real B1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real B1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real B1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real B1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real B1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real B1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real B1.cylinder.Material;
//   protected output Real B1.cylinder.Extra;
//   parameter Boolean B1.constantTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real B1.constantTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real B1.constantTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real B1.constantTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real B1.constantTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real B1.constantTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 0.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real B1.constantTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real Cylinder.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Cylinder.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Cylinder.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Cylinder.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Cylinder.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Cylinder.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Cylinder.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Cylinder.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Cylinder.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Cylinder.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Cylinder.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Cylinder.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Cylinder.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Cylinder.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Cylinder.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Cylinder.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Cylinder.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Cylinder.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Cylinder.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Cylinder.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Cylinder.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Cylinder.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Cylinder.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Cylinder.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Cylinder.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Cylinder.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean Cylinder.animation = true \"= true, if animation shall be enabled\";
//   parameter Real Cylinder.n[1](unit = \"1\") = 0.0 \"Axis of translation resolved in frame_a (= same as in frame_b)\";
//   parameter Real Cylinder.n[2](unit = \"1\") = -1.0 \"Axis of translation resolved in frame_a (= same as in frame_b)\";
//   parameter Real Cylinder.n[3](unit = \"1\") = 0.0 \"Axis of translation resolved in frame_a (= same as in frame_b)\";
//   constant Real Cylinder.s_offset(quantity = \"Length\", unit = \"m\") = 0.0 \"Relative distance offset (distance between frame_a and frame_b = s_offset + s)\";
//   parameter Real Cylinder.boxWidthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Cylinder.boxWidthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Cylinder.boxWidthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction of box, resolved in frame_a\";
//   parameter Real Cylinder.boxWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.02 \"Width of prismatic joint box\";
//   parameter Real Cylinder.boxHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = Cylinder.boxWidth \"Height of prismatic joint box\";
//   input Integer Cylinder.boxColor[1](min = 0, max = 255) = 255 \"Color of prismatic joint box\";
//   input Integer Cylinder.boxColor[2](min = 0, max = 255) = 0 \"Color of prismatic joint box\";
//   input Integer Cylinder.boxColor[3](min = 0, max = 255) = 0 \"Color of prismatic joint box\";
//   input Real Cylinder.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) Cylinder.stateSelect = StateSelect.prefer \"Priority to use distance s and v=der(s) as states\";
//   parameter Real Cylinder.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({Cylinder.n[1],Cylinder.n[2],Cylinder.n[3]},1e-13)[1] \"Unit vector in direction of prismatic axis n\";
//   parameter Real Cylinder.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({Cylinder.n[1],Cylinder.n[2],Cylinder.n[3]},1e-13)[2] \"Unit vector in direction of prismatic axis n\";
//   parameter Real Cylinder.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({Cylinder.n[1],Cylinder.n[2],Cylinder.n[3]},1e-13)[3] \"Unit vector in direction of prismatic axis n\";
//   Real Cylinder.s(quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative distance between frame_a and frame_b\";
//   Real Cylinder.v(quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of s (relative velocity)\";
//   Real Cylinder.a(quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Second derivative of s (relative acceleration)\";
//   Real Cylinder.f(quantity = \"Force\", unit = \"N\") \"Actuation force in direction of joint axis\";
//   parameter Real Cylinder.fixed.s0(quantity = \"Length\", unit = \"m\") = 0.0 \"fixed offset position of housing\";
//   Real Cylinder.fixed.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real Cylinder.fixed.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   input Real Cylinder.internalAxis.f(quantity = \"Force\", unit = \"N\") = Cylinder.f \"External support force (must be computed via force balance in model where InternalSupport is used; = flange.f)\";
//   Real Cylinder.internalAxis.s(quantity = \"Length\", unit = \"m\") \"External support position (= flange.s)\";
//   Real Cylinder.internalAxis.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real Cylinder.internalAxis.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real Cylinder.axis.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real Cylinder.axis.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real Cylinder.support.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real Cylinder.support.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   parameter String Cylinder.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real Cylinder.box.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real Cylinder.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Cylinder.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Cylinder.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real Cylinder.box.r[1](quantity = \"Length\", unit = \"m\") = Cylinder.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Cylinder.box.r[2](quantity = \"Length\", unit = \"m\") = Cylinder.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Cylinder.box.r[3](quantity = \"Length\", unit = \"m\") = Cylinder.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real Cylinder.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Cylinder.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Cylinder.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real Cylinder.box.lengthDirection[1](unit = \"1\") = Cylinder.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real Cylinder.box.lengthDirection[2](unit = \"1\") = Cylinder.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real Cylinder.box.lengthDirection[3](unit = \"1\") = Cylinder.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real Cylinder.box.widthDirection[1](unit = \"1\") = Cylinder.boxWidthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real Cylinder.box.widthDirection[2](unit = \"1\") = Cylinder.boxWidthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real Cylinder.box.widthDirection[3](unit = \"1\") = Cylinder.boxWidthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real Cylinder.box.length(quantity = \"Length\", unit = \"m\") = if noEvent(abs(Cylinder.s) > 1e-06) then Cylinder.s else 1e-06 \"Length of visual object\";
//   input Real Cylinder.box.width(quantity = \"Length\", unit = \"m\") = Cylinder.boxWidth \"Width of visual object\";
//   input Real Cylinder.box.height(quantity = \"Length\", unit = \"m\") = Cylinder.boxHeight \"Height of visual object\";
//   input Real Cylinder.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real Cylinder.box.color[1] = Real(Cylinder.boxColor[1]) \"Color of shape\";
//   input Real Cylinder.box.color[2] = Real(Cylinder.boxColor[2]) \"Color of shape\";
//   input Real Cylinder.box.color[3] = Real(Cylinder.boxColor[3]) \"Color of shape\";
//   input Real Cylinder.box.specularCoefficient = Cylinder.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real Cylinder.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({Cylinder.box.lengthDirection[1],Cylinder.box.lengthDirection[2],Cylinder.box.lengthDirection[3]});
//   protected Real Cylinder.box.e_x[1](unit = \"1\") = if noEvent(Cylinder.box.abs_n_x < 1e-10) then 1.0 else Cylinder.box.lengthDirection[1] / Cylinder.box.abs_n_x;
//   protected Real Cylinder.box.e_x[2](unit = \"1\") = if noEvent(Cylinder.box.abs_n_x < 1e-10) then 0.0 else Cylinder.box.lengthDirection[2] / Cylinder.box.abs_n_x;
//   protected Real Cylinder.box.e_x[3](unit = \"1\") = if noEvent(Cylinder.box.abs_n_x < 1e-10) then 0.0 else Cylinder.box.lengthDirection[3] / Cylinder.box.abs_n_x;
//   protected Real Cylinder.box.n_z_aux[1](unit = \"1\") = Cylinder.box.e_x[2] * Cylinder.box.widthDirection[3] - Cylinder.box.e_x[3] * Cylinder.box.widthDirection[2];
//   protected Real Cylinder.box.n_z_aux[2](unit = \"1\") = Cylinder.box.e_x[3] * Cylinder.box.widthDirection[1] - Cylinder.box.e_x[1] * Cylinder.box.widthDirection[3];
//   protected Real Cylinder.box.n_z_aux[3](unit = \"1\") = Cylinder.box.e_x[1] * Cylinder.box.widthDirection[2] - Cylinder.box.e_x[2] * Cylinder.box.widthDirection[1];
//   protected Real Cylinder.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Cylinder.box.e_x[1],Cylinder.box.e_x[2],Cylinder.box.e_x[3]},if noEvent(Cylinder.box.n_z_aux[1] ^ 2.0 + (Cylinder.box.n_z_aux[2] ^ 2.0 + Cylinder.box.n_z_aux[3] ^ 2.0) > 1e-06) then {Cylinder.box.widthDirection[1],Cylinder.box.widthDirection[2],Cylinder.box.widthDirection[3]} else if noEvent(abs(Cylinder.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Cylinder.box.e_x[1],Cylinder.box.e_x[2],Cylinder.box.e_x[3]})[1];
//   protected Real Cylinder.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Cylinder.box.e_x[1],Cylinder.box.e_x[2],Cylinder.box.e_x[3]},if noEvent(Cylinder.box.n_z_aux[1] ^ 2.0 + (Cylinder.box.n_z_aux[2] ^ 2.0 + Cylinder.box.n_z_aux[3] ^ 2.0) > 1e-06) then {Cylinder.box.widthDirection[1],Cylinder.box.widthDirection[2],Cylinder.box.widthDirection[3]} else if noEvent(abs(Cylinder.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Cylinder.box.e_x[1],Cylinder.box.e_x[2],Cylinder.box.e_x[3]})[2];
//   protected Real Cylinder.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({Cylinder.box.e_x[1],Cylinder.box.e_x[2],Cylinder.box.e_x[3]},if noEvent(Cylinder.box.n_z_aux[1] ^ 2.0 + (Cylinder.box.n_z_aux[2] ^ 2.0 + Cylinder.box.n_z_aux[3] ^ 2.0) > 1e-06) then {Cylinder.box.widthDirection[1],Cylinder.box.widthDirection[2],Cylinder.box.widthDirection[3]} else if noEvent(abs(Cylinder.box.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{Cylinder.box.e_x[1],Cylinder.box.e_x[2],Cylinder.box.e_x[3]})[3];
//   protected output Real Cylinder.box.Form;
//   output Real Cylinder.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Cylinder.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Cylinder.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real Cylinder.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Cylinder.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Cylinder.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real Cylinder.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Cylinder.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real Cylinder.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real Cylinder.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Cylinder.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Cylinder.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real Cylinder.box.Material;
//   protected output Real Cylinder.box.Extra;
//   Real Rod1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Rod1.animation = false \"= true, if animation shall be enabled\";
//   parameter Real Rod1.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod1.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.2 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod1.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Rod1.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real Rod1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod1.lengthDirection[1](unit = \"1\") = Rod1.r[1] - Rod1.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod1.lengthDirection[2](unit = \"1\") = Rod1.r[2] - Rod1.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod1.lengthDirection[3](unit = \"1\") = Rod1.r[3] - Rod1.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod1.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod1.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod1.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Rod1.r[1] - Rod1.r_shape[1],Rod1.r[2] - Rod1.r_shape[2],Rod1.r[3] - Rod1.r_shape[3]}) \" Length of shape\";
//   parameter Real Rod1.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod1.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real Rod1.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod1.width \" Height of shape.\";
//   parameter Real Rod1.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Rod1.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer Rod1.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer Rod1.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real Rod1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   Real Rod3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod3.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod3.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod3.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real Rod3.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real Rod3.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod3.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod3.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real Rod3.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod3.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod3.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real Rod3.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod3.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real Rod3.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean Rod3.animation = false \"= true, if animation shall be enabled\";
//   parameter Real Rod3.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod3.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = -0.1 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real Rod3.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String Rod3.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real Rod3.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod3.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod3.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real Rod3.lengthDirection[1](unit = \"1\") = Rod3.r[1] - Rod3.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod3.lengthDirection[2](unit = \"1\") = Rod3.r[2] - Rod3.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod3.lengthDirection[3](unit = \"1\") = Rod3.r[3] - Rod3.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real Rod3.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod3.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod3.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real Rod3.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({Rod3.r[1] - Rod3.r_shape[1],Rod3.r[2] - Rod3.r_shape[2],Rod3.r[3] - Rod3.r_shape[3]}) \" Length of shape\";
//   parameter Real Rod3.width(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod3.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real Rod3.height(quantity = \"Length\", unit = \"m\", min = 0.0) = Rod3.width \" Height of shape.\";
//   parameter Real Rod3.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer Rod3.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer Rod3.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer Rod3.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real Rod3.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
// equation
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1],world.x_arrowLine.R.T[1,2],world.x_arrowLine.R.T[1,3]},{world.x_arrowLine.R.T[2,1],world.x_arrowLine.R.T[2,2],world.x_arrowLine.R.T[2,3]},{world.x_arrowLine.R.T[3,1],world.x_arrowLine.R.T[3,2],world.x_arrowLine.R.T[3,3]}},{world.x_arrowLine.r_shape[1],world.x_arrowLine.r_shape[2],world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0,world.x_arrowLine.color[2] / 255.0,world.x_arrowLine.color[3] / 255.0,world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1],world.x_arrowHead.R.T[1,2],world.x_arrowHead.R.T[1,3]},{world.x_arrowHead.R.T[2,1],world.x_arrowHead.R.T[2,2],world.x_arrowHead.R.T[2,3]},{world.x_arrowHead.R.T[3,1],world.x_arrowHead.R.T[3,2],world.x_arrowHead.R.T[3,3]}},{world.x_arrowHead.r_shape[1],world.x_arrowHead.r_shape[2],world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0,world.x_arrowHead.color[2] / 255.0,world.x_arrowHead.color[3] / 255.0,world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[1].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[1].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[1].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1],world.x_label.cylinders[1].R.T[1,2],world.x_label.cylinders[1].R.T[1,3]},{world.x_label.cylinders[1].R.T[2,1],world.x_label.cylinders[1].R.T[2,2],world.x_label.cylinders[1].R.T[2,3]},{world.x_label.cylinders[1].R.T[3,1],world.x_label.cylinders[1].R.T[3,2],world.x_label.cylinders[1].R.T[3,3]}},{world.x_label.cylinders[1].r_shape[1],world.x_label.cylinders[1].r_shape[2],world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0,world.x_label.cylinders[1].color[2] / 255.0,world.x_label.cylinders[1].color[3] / 255.0,world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[2].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[2].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[2].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1],world.x_label.cylinders[2].R.T[1,2],world.x_label.cylinders[2].R.T[1,3]},{world.x_label.cylinders[2].R.T[2,1],world.x_label.cylinders[2].R.T[2,2],world.x_label.cylinders[2].R.T[2,3]},{world.x_label.cylinders[2].R.T[3,1],world.x_label.cylinders[2].R.T[3,2],world.x_label.cylinders[2].R.T[3,3]}},{world.x_label.cylinders[2].r_shape[1],world.x_label.cylinders[2].r_shape[2],world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0,world.x_label.cylinders[2].color[2] / 255.0,world.x_label.cylinders[2].color[3] / 255.0,world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1],world.y_arrowLine.R.T[1,2],world.y_arrowLine.R.T[1,3]},{world.y_arrowLine.R.T[2,1],world.y_arrowLine.R.T[2,2],world.y_arrowLine.R.T[2,3]},{world.y_arrowLine.R.T[3,1],world.y_arrowLine.R.T[3,2],world.y_arrowLine.R.T[3,3]}},{world.y_arrowLine.r_shape[1],world.y_arrowLine.r_shape[2],world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0,world.y_arrowLine.color[2] / 255.0,world.y_arrowLine.color[3] / 255.0,world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1],world.y_arrowHead.R.T[1,2],world.y_arrowHead.R.T[1,3]},{world.y_arrowHead.R.T[2,1],world.y_arrowHead.R.T[2,2],world.y_arrowHead.R.T[2,3]},{world.y_arrowHead.R.T[3,1],world.y_arrowHead.R.T[3,2],world.y_arrowHead.R.T[3,3]}},{world.y_arrowHead.r_shape[1],world.y_arrowHead.r_shape[2],world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0,world.y_arrowHead.color[2] / 255.0,world.y_arrowHead.color[3] / 255.0,world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[1].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[1].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[1].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1],world.y_label.cylinders[1].R.T[1,2],world.y_label.cylinders[1].R.T[1,3]},{world.y_label.cylinders[1].R.T[2,1],world.y_label.cylinders[1].R.T[2,2],world.y_label.cylinders[1].R.T[2,3]},{world.y_label.cylinders[1].R.T[3,1],world.y_label.cylinders[1].R.T[3,2],world.y_label.cylinders[1].R.T[3,3]}},{world.y_label.cylinders[1].r_shape[1],world.y_label.cylinders[1].r_shape[2],world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0,world.y_label.cylinders[1].color[2] / 255.0,world.y_label.cylinders[1].color[3] / 255.0,world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[2].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[2].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[2].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1],world.y_label.cylinders[2].R.T[1,2],world.y_label.cylinders[2].R.T[1,3]},{world.y_label.cylinders[2].R.T[2,1],world.y_label.cylinders[2].R.T[2,2],world.y_label.cylinders[2].R.T[2,3]},{world.y_label.cylinders[2].R.T[3,1],world.y_label.cylinders[2].R.T[3,2],world.y_label.cylinders[2].R.T[3,3]}},{world.y_label.cylinders[2].r_shape[1],world.y_label.cylinders[2].r_shape[2],world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0,world.y_label.cylinders[2].color[2] / 255.0,world.y_label.cylinders[2].color[3] / 255.0,world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1],world.z_arrowLine.R.T[1,2],world.z_arrowLine.R.T[1,3]},{world.z_arrowLine.R.T[2,1],world.z_arrowLine.R.T[2,2],world.z_arrowLine.R.T[2,3]},{world.z_arrowLine.R.T[3,1],world.z_arrowLine.R.T[3,2],world.z_arrowLine.R.T[3,3]}},{world.z_arrowLine.r_shape[1],world.z_arrowLine.r_shape[2],world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0,world.z_arrowLine.color[2] / 255.0,world.z_arrowLine.color[3] / 255.0,world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1],world.z_arrowHead.R.T[1,2],world.z_arrowHead.R.T[1,3]},{world.z_arrowHead.R.T[2,1],world.z_arrowHead.R.T[2,2],world.z_arrowHead.R.T[2,3]},{world.z_arrowHead.R.T[3,1],world.z_arrowHead.R.T[3,2],world.z_arrowHead.R.T[3,3]}},{world.z_arrowHead.r_shape[1],world.z_arrowHead.r_shape[2],world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0,world.z_arrowHead.color[2] / 255.0,world.z_arrowHead.color[3] / 255.0,world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[1].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[1].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[1].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1],world.z_label.cylinders[1].R.T[1,2],world.z_label.cylinders[1].R.T[1,3]},{world.z_label.cylinders[1].R.T[2,1],world.z_label.cylinders[1].R.T[2,2],world.z_label.cylinders[1].R.T[2,3]},{world.z_label.cylinders[1].R.T[3,1],world.z_label.cylinders[1].R.T[3,2],world.z_label.cylinders[1].R.T[3,3]}},{world.z_label.cylinders[1].r_shape[1],world.z_label.cylinders[1].r_shape[2],world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0,world.z_label.cylinders[1].color[2] / 255.0,world.z_label.cylinders[1].color[3] / 255.0,world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[2].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[2].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[2].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1],world.z_label.cylinders[2].R.T[1,2],world.z_label.cylinders[2].R.T[1,3]},{world.z_label.cylinders[2].R.T[2,1],world.z_label.cylinders[2].R.T[2,2],world.z_label.cylinders[2].R.T[2,3]},{world.z_label.cylinders[2].R.T[3,1],world.z_label.cylinders[2].R.T[3,2],world.z_label.cylinders[2].R.T[3,3]}},{world.z_label.cylinders[2].r_shape[1],world.z_label.cylinders[2].r_shape[2],world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0,world.z_label.cylinders[2].color[2] / 255.0,world.z_label.cylinders[2].color[3] / 255.0,world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[3].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[3].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[3].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1],world.z_label.cylinders[3].R.T[1,2],world.z_label.cylinders[3].R.T[1,3]},{world.z_label.cylinders[3].R.T[2,1],world.z_label.cylinders[3].R.T[2,2],world.z_label.cylinders[3].R.T[2,3]},{world.z_label.cylinders[3].R.T[3,1],world.z_label.cylinders[3].R.T[3,2],world.z_label.cylinders[3].R.T[3,3]}},{world.z_label.cylinders[3].r_shape[1],world.z_label.cylinders[3].r_shape[2],world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0,world.z_label.cylinders[3].color[2] / 255.0,world.z_label.cylinders[3].color[3] / 255.0,world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   world.gravityArrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowLine.shapeType);
//   world.gravityArrowLine.rxvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.rxvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.rxvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.ryvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.ryvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.ryvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.rvisobj = world.gravityArrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowLine.R.T[1,1],world.gravityArrowLine.R.T[1,2],world.gravityArrowLine.R.T[1,3]},{world.gravityArrowLine.R.T[2,1],world.gravityArrowLine.R.T[2,2],world.gravityArrowLine.R.T[2,3]},{world.gravityArrowLine.R.T[3,1],world.gravityArrowLine.R.T[3,2],world.gravityArrowLine.R.T[3,3]}},{world.gravityArrowLine.r_shape[1],world.gravityArrowLine.r_shape[2],world.gravityArrowLine.r_shape[3]});
//   world.gravityArrowLine.size[1] = world.gravityArrowLine.length;
//   world.gravityArrowLine.size[2] = world.gravityArrowLine.width;
//   world.gravityArrowLine.size[3] = world.gravityArrowLine.height;
//   world.gravityArrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowLine.color[1] / 255.0,world.gravityArrowLine.color[2] / 255.0,world.gravityArrowLine.color[3] / 255.0,world.gravityArrowLine.specularCoefficient);
//   world.gravityArrowLine.Extra = world.gravityArrowLine.extra;
//   world.gravityArrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowHead.shapeType);
//   world.gravityArrowHead.rxvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.rxvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.rxvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.ryvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.ryvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.ryvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.rvisobj = world.gravityArrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowHead.R.T[1,1],world.gravityArrowHead.R.T[1,2],world.gravityArrowHead.R.T[1,3]},{world.gravityArrowHead.R.T[2,1],world.gravityArrowHead.R.T[2,2],world.gravityArrowHead.R.T[2,3]},{world.gravityArrowHead.R.T[3,1],world.gravityArrowHead.R.T[3,2],world.gravityArrowHead.R.T[3,3]}},{world.gravityArrowHead.r_shape[1],world.gravityArrowHead.r_shape[2],world.gravityArrowHead.r_shape[3]});
//   world.gravityArrowHead.size[1] = world.gravityArrowHead.length;
//   world.gravityArrowHead.size[2] = world.gravityArrowHead.width;
//   world.gravityArrowHead.size[3] = world.gravityArrowHead.height;
//   world.gravityArrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowHead.color[1] / 255.0,world.gravityArrowHead.color[2] / 255.0,world.gravityArrowHead.color[3] / 255.0,world.gravityArrowHead.specularCoefficient);
//   world.gravityArrowHead.Extra = world.gravityArrowHead.extra;
//   assert(Modelica.Math.Vectors.length({world.n[1],world.n[2],world.n[3]}) > 1e-10,\"Parameter n of World object is wrong (lenght(n) > 0 required)\");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   Piston.body.r_0[1] = Piston.body.frame_a.r_0[1];
//   Piston.body.r_0[2] = Piston.body.frame_a.r_0[2];
//   Piston.body.r_0[3] = Piston.body.frame_a.r_0[3];
//   if true then
//   Piston.body.Q[1] = 0.0;
//   Piston.body.Q[2] = 0.0;
//   Piston.body.Q[3] = 0.0;
//   Piston.body.Q[4] = 1.0;
//   Piston.body.phi[1] = 0.0;
//   Piston.body.phi[2] = 0.0;
//   Piston.body.phi[3] = 0.0;
//   Piston.body.phi_d[1] = 0.0;
//   Piston.body.phi_d[2] = 0.0;
//   Piston.body.phi_d[3] = 0.0;
//   Piston.body.phi_dd[1] = 0.0;
//   Piston.body.phi_dd[2] = 0.0;
//   Piston.body.phi_dd[3] = 0.0;
//   elseif Piston.body.useQuaternions then
//   Piston.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({Piston.body.Q[1],Piston.body.Q[2],Piston.body.Q[3],Piston.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({Piston.body.Q[1],Piston.body.Q[2],Piston.body.Q[3],Piston.body.Q[4]},{der(Piston.body.Q[1]),der(Piston.body.Q[2]),der(Piston.body.Q[3]),der(Piston.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({Piston.body.Q[1],Piston.body.Q[2],Piston.body.Q[3],Piston.body.Q[4]});
//   Piston.body.phi[1] = 0.0;
//   Piston.body.phi[2] = 0.0;
//   Piston.body.phi[3] = 0.0;
//   Piston.body.phi_d[1] = 0.0;
//   Piston.body.phi_d[2] = 0.0;
//   Piston.body.phi_d[3] = 0.0;
//   Piston.body.phi_dd[1] = 0.0;
//   Piston.body.phi_dd[2] = 0.0;
//   Piston.body.phi_dd[3] = 0.0;
//   else
//   Piston.body.phi_d[1] = der(Piston.body.phi[1]);
//   Piston.body.phi_d[2] = der(Piston.body.phi[2]);
//   Piston.body.phi_d[3] = der(Piston.body.phi[3]);
//   Piston.body.phi_dd[1] = der(Piston.body.phi_d[1]);
//   Piston.body.phi_dd[2] = der(Piston.body.phi_d[2]);
//   Piston.body.phi_dd[3] = der(Piston.body.phi_d[3]);
//   Piston.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({Piston.body.sequence_angleStates[1],Piston.body.sequence_angleStates[2],Piston.body.sequence_angleStates[3]},{Piston.body.phi[1],Piston.body.phi[2],Piston.body.phi[3]},{Piston.body.phi_d[1],Piston.body.phi_d[2],Piston.body.phi_d[3]});
//   Piston.body.Q[1] = 0.0;
//   Piston.body.Q[2] = 0.0;
//   Piston.body.Q[3] = 0.0;
//   Piston.body.Q[4] = 1.0;
//   end if;
//   Piston.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({Piston.body.frame_a.r_0[1],Piston.body.frame_a.r_0[2],Piston.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(Piston.body.frame_a.R,{Piston.body.r_CM[1],Piston.body.r_CM[2],Piston.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   Piston.body.v_0[1] = der(Piston.body.frame_a.r_0[1]);
//   Piston.body.v_0[2] = der(Piston.body.frame_a.r_0[2]);
//   Piston.body.v_0[3] = der(Piston.body.frame_a.r_0[3]);
//   Piston.body.a_0[1] = der(Piston.body.v_0[1]);
//   Piston.body.a_0[2] = der(Piston.body.v_0[2]);
//   Piston.body.a_0[3] = der(Piston.body.v_0[3]);
//   Piston.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(Piston.body.frame_a.R);
//   Piston.body.z_a[1] = der(Piston.body.w_a[1]);
//   Piston.body.z_a[2] = der(Piston.body.w_a[2]);
//   Piston.body.z_a[3] = der(Piston.body.w_a[3]);
//   Piston.body.frame_a.f = Piston.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(Piston.body.frame_a.R,{Piston.body.a_0[1] - Piston.body.g_0[1],Piston.body.a_0[2] - Piston.body.g_0[2],Piston.body.a_0[3] - Piston.body.g_0[3]}) + {Piston.body.z_a[2] * Piston.body.r_CM[3] - Piston.body.z_a[3] * Piston.body.r_CM[2],Piston.body.z_a[3] * Piston.body.r_CM[1] - Piston.body.z_a[1] * Piston.body.r_CM[3],Piston.body.z_a[1] * Piston.body.r_CM[2] - Piston.body.z_a[2] * Piston.body.r_CM[1]} + {Piston.body.w_a[2] * (Piston.body.w_a[1] * Piston.body.r_CM[2] - Piston.body.w_a[2] * Piston.body.r_CM[1]) - Piston.body.w_a[3] * (Piston.body.w_a[3] * Piston.body.r_CM[1] - Piston.body.w_a[1] * Piston.body.r_CM[3]),Piston.body.w_a[3] * (Piston.body.w_a[2] * Piston.body.r_CM[3] - Piston.body.w_a[3] * Piston.body.r_CM[2]) - Piston.body.w_a[1] * (Piston.body.w_a[1] * Piston.body.r_CM[2] - Piston.body.w_a[2] * Piston.body.r_CM[1]),Piston.body.w_a[1] * (Piston.body.w_a[3] * Piston.body.r_CM[1] - Piston.body.w_a[1] * Piston.body.r_CM[3]) - Piston.body.w_a[2] * (Piston.body.w_a[2] * Piston.body.r_CM[3] - Piston.body.w_a[3] * Piston.body.r_CM[2])});
//   Piston.body.frame_a.t[1] = Piston.body.I[1,1] * Piston.body.z_a[1] + (Piston.body.I[1,2] * Piston.body.z_a[2] + (Piston.body.I[1,3] * Piston.body.z_a[3] + (Piston.body.w_a[2] * (Piston.body.I[3,1] * Piston.body.w_a[1] + (Piston.body.I[3,2] * Piston.body.w_a[2] + Piston.body.I[3,3] * Piston.body.w_a[3])) + ((-Piston.body.w_a[3] * (Piston.body.I[2,1] * Piston.body.w_a[1] + (Piston.body.I[2,2] * Piston.body.w_a[2] + Piston.body.I[2,3] * Piston.body.w_a[3]))) + (Piston.body.r_CM[2] * Piston.body.frame_a.f[3] + (-Piston.body.r_CM[3] * Piston.body.frame_a.f[2]))))));
//   Piston.body.frame_a.t[2] = Piston.body.I[2,1] * Piston.body.z_a[1] + (Piston.body.I[2,2] * Piston.body.z_a[2] + (Piston.body.I[2,3] * Piston.body.z_a[3] + (Piston.body.w_a[3] * (Piston.body.I[1,1] * Piston.body.w_a[1] + (Piston.body.I[1,2] * Piston.body.w_a[2] + Piston.body.I[1,3] * Piston.body.w_a[3])) + ((-Piston.body.w_a[1] * (Piston.body.I[3,1] * Piston.body.w_a[1] + (Piston.body.I[3,2] * Piston.body.w_a[2] + Piston.body.I[3,3] * Piston.body.w_a[3]))) + (Piston.body.r_CM[3] * Piston.body.frame_a.f[1] + (-Piston.body.r_CM[1] * Piston.body.frame_a.f[3]))))));
//   Piston.body.frame_a.t[3] = Piston.body.I[3,1] * Piston.body.z_a[1] + (Piston.body.I[3,2] * Piston.body.z_a[2] + (Piston.body.I[3,3] * Piston.body.z_a[3] + (Piston.body.w_a[1] * (Piston.body.I[2,1] * Piston.body.w_a[1] + (Piston.body.I[2,2] * Piston.body.w_a[2] + Piston.body.I[2,3] * Piston.body.w_a[3])) + ((-Piston.body.w_a[2] * (Piston.body.I[1,1] * Piston.body.w_a[1] + (Piston.body.I[1,2] * Piston.body.w_a[2] + Piston.body.I[1,3] * Piston.body.w_a[3]))) + (Piston.body.r_CM[1] * Piston.body.frame_a.f[2] + (-Piston.body.r_CM[2] * Piston.body.frame_a.f[1]))))));
//   Piston.frameTranslation.shape.R.T[1,1] = Piston.frameTranslation.frame_a.R.T[1,1];
//   Piston.frameTranslation.shape.R.T[1,2] = Piston.frameTranslation.frame_a.R.T[1,2];
//   Piston.frameTranslation.shape.R.T[1,3] = Piston.frameTranslation.frame_a.R.T[1,3];
//   Piston.frameTranslation.shape.R.T[2,1] = Piston.frameTranslation.frame_a.R.T[2,1];
//   Piston.frameTranslation.shape.R.T[2,2] = Piston.frameTranslation.frame_a.R.T[2,2];
//   Piston.frameTranslation.shape.R.T[2,3] = Piston.frameTranslation.frame_a.R.T[2,3];
//   Piston.frameTranslation.shape.R.T[3,1] = Piston.frameTranslation.frame_a.R.T[3,1];
//   Piston.frameTranslation.shape.R.T[3,2] = Piston.frameTranslation.frame_a.R.T[3,2];
//   Piston.frameTranslation.shape.R.T[3,3] = Piston.frameTranslation.frame_a.R.T[3,3];
//   Piston.frameTranslation.shape.R.w[1] = Piston.frameTranslation.frame_a.R.w[1];
//   Piston.frameTranslation.shape.R.w[2] = Piston.frameTranslation.frame_a.R.w[2];
//   Piston.frameTranslation.shape.R.w[3] = Piston.frameTranslation.frame_a.R.w[3];
//   Piston.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Piston.frameTranslation.shape.shapeType);
//   Piston.frameTranslation.shape.rxvisobj[1] = Piston.frameTranslation.shape.R.T[1,1] * Piston.frameTranslation.shape.e_x[1] + (Piston.frameTranslation.shape.R.T[2,1] * Piston.frameTranslation.shape.e_x[2] + Piston.frameTranslation.shape.R.T[3,1] * Piston.frameTranslation.shape.e_x[3]);
//   Piston.frameTranslation.shape.rxvisobj[2] = Piston.frameTranslation.shape.R.T[1,2] * Piston.frameTranslation.shape.e_x[1] + (Piston.frameTranslation.shape.R.T[2,2] * Piston.frameTranslation.shape.e_x[2] + Piston.frameTranslation.shape.R.T[3,2] * Piston.frameTranslation.shape.e_x[3]);
//   Piston.frameTranslation.shape.rxvisobj[3] = Piston.frameTranslation.shape.R.T[1,3] * Piston.frameTranslation.shape.e_x[1] + (Piston.frameTranslation.shape.R.T[2,3] * Piston.frameTranslation.shape.e_x[2] + Piston.frameTranslation.shape.R.T[3,3] * Piston.frameTranslation.shape.e_x[3]);
//   Piston.frameTranslation.shape.ryvisobj[1] = Piston.frameTranslation.shape.R.T[1,1] * Piston.frameTranslation.shape.e_y[1] + (Piston.frameTranslation.shape.R.T[2,1] * Piston.frameTranslation.shape.e_y[2] + Piston.frameTranslation.shape.R.T[3,1] * Piston.frameTranslation.shape.e_y[3]);
//   Piston.frameTranslation.shape.ryvisobj[2] = Piston.frameTranslation.shape.R.T[1,2] * Piston.frameTranslation.shape.e_y[1] + (Piston.frameTranslation.shape.R.T[2,2] * Piston.frameTranslation.shape.e_y[2] + Piston.frameTranslation.shape.R.T[3,2] * Piston.frameTranslation.shape.e_y[3]);
//   Piston.frameTranslation.shape.ryvisobj[3] = Piston.frameTranslation.shape.R.T[1,3] * Piston.frameTranslation.shape.e_y[1] + (Piston.frameTranslation.shape.R.T[2,3] * Piston.frameTranslation.shape.e_y[2] + Piston.frameTranslation.shape.R.T[3,3] * Piston.frameTranslation.shape.e_y[3]);
//   Piston.frameTranslation.shape.rvisobj = Piston.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Piston.frameTranslation.shape.R.T[1,1],Piston.frameTranslation.shape.R.T[1,2],Piston.frameTranslation.shape.R.T[1,3]},{Piston.frameTranslation.shape.R.T[2,1],Piston.frameTranslation.shape.R.T[2,2],Piston.frameTranslation.shape.R.T[2,3]},{Piston.frameTranslation.shape.R.T[3,1],Piston.frameTranslation.shape.R.T[3,2],Piston.frameTranslation.shape.R.T[3,3]}},{Piston.frameTranslation.shape.r_shape[1],Piston.frameTranslation.shape.r_shape[2],Piston.frameTranslation.shape.r_shape[3]});
//   Piston.frameTranslation.shape.size[1] = Piston.frameTranslation.shape.length;
//   Piston.frameTranslation.shape.size[2] = Piston.frameTranslation.shape.width;
//   Piston.frameTranslation.shape.size[3] = Piston.frameTranslation.shape.height;
//   Piston.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Piston.frameTranslation.shape.color[1] / 255.0,Piston.frameTranslation.shape.color[2] / 255.0,Piston.frameTranslation.shape.color[3] / 255.0,Piston.frameTranslation.shape.specularCoefficient);
//   Piston.frameTranslation.shape.Extra = Piston.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Piston.frameTranslation.frame_b.r_0 = Piston.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Piston.frameTranslation.frame_a.R,{Piston.frameTranslation.r[1],Piston.frameTranslation.r[2],Piston.frameTranslation.r[3]});
//   Piston.frameTranslation.frame_b.R.T[1,1] = Piston.frameTranslation.frame_a.R.T[1,1];
//   Piston.frameTranslation.frame_b.R.T[1,2] = Piston.frameTranslation.frame_a.R.T[1,2];
//   Piston.frameTranslation.frame_b.R.T[1,3] = Piston.frameTranslation.frame_a.R.T[1,3];
//   Piston.frameTranslation.frame_b.R.T[2,1] = Piston.frameTranslation.frame_a.R.T[2,1];
//   Piston.frameTranslation.frame_b.R.T[2,2] = Piston.frameTranslation.frame_a.R.T[2,2];
//   Piston.frameTranslation.frame_b.R.T[2,3] = Piston.frameTranslation.frame_a.R.T[2,3];
//   Piston.frameTranslation.frame_b.R.T[3,1] = Piston.frameTranslation.frame_a.R.T[3,1];
//   Piston.frameTranslation.frame_b.R.T[3,2] = Piston.frameTranslation.frame_a.R.T[3,2];
//   Piston.frameTranslation.frame_b.R.T[3,3] = Piston.frameTranslation.frame_a.R.T[3,3];
//   Piston.frameTranslation.frame_b.R.w[1] = Piston.frameTranslation.frame_a.R.w[1];
//   Piston.frameTranslation.frame_b.R.w[2] = Piston.frameTranslation.frame_a.R.w[2];
//   Piston.frameTranslation.frame_b.R.w[3] = Piston.frameTranslation.frame_a.R.w[3];
//   0.0 = Piston.frameTranslation.frame_a.f[1] + Piston.frameTranslation.frame_b.f[1];
//   0.0 = Piston.frameTranslation.frame_a.f[2] + Piston.frameTranslation.frame_b.f[2];
//   0.0 = Piston.frameTranslation.frame_a.f[3] + Piston.frameTranslation.frame_b.f[3];
//   0.0 = Piston.frameTranslation.frame_a.t[1] + (Piston.frameTranslation.frame_b.t[1] + (Piston.frameTranslation.r[2] * Piston.frameTranslation.frame_b.f[3] + (-Piston.frameTranslation.r[3] * Piston.frameTranslation.frame_b.f[2])));
//   0.0 = Piston.frameTranslation.frame_a.t[2] + (Piston.frameTranslation.frame_b.t[2] + (Piston.frameTranslation.r[3] * Piston.frameTranslation.frame_b.f[1] + (-Piston.frameTranslation.r[1] * Piston.frameTranslation.frame_b.f[3])));
//   0.0 = Piston.frameTranslation.frame_a.t[3] + (Piston.frameTranslation.frame_b.t[3] + (Piston.frameTranslation.r[1] * Piston.frameTranslation.frame_b.f[2] + (-Piston.frameTranslation.r[2] * Piston.frameTranslation.frame_b.f[1])));
//   Piston.r_0[1] = Piston.frame_a.r_0[1];
//   Piston.r_0[2] = Piston.frame_a.r_0[2];
//   Piston.r_0[3] = Piston.frame_a.r_0[3];
//   Piston.v_0[1] = der(Piston.r_0[1]);
//   Piston.v_0[2] = der(Piston.r_0[2]);
//   Piston.v_0[3] = der(Piston.r_0[3]);
//   Piston.a_0[1] = der(Piston.v_0[1]);
//   Piston.a_0[2] = der(Piston.v_0[2]);
//   Piston.a_0[3] = der(Piston.v_0[3]);
//   assert(Piston.innerDiameter < Piston.diameter,\"parameter innerDiameter is greater as parameter diameter.\");
//   Rod2.body.r_0[1] = Rod2.body.frame_a.r_0[1];
//   Rod2.body.r_0[2] = Rod2.body.frame_a.r_0[2];
//   Rod2.body.r_0[3] = Rod2.body.frame_a.r_0[3];
//   if true then
//   Rod2.body.Q[1] = 0.0;
//   Rod2.body.Q[2] = 0.0;
//   Rod2.body.Q[3] = 0.0;
//   Rod2.body.Q[4] = 1.0;
//   Rod2.body.phi[1] = 0.0;
//   Rod2.body.phi[2] = 0.0;
//   Rod2.body.phi[3] = 0.0;
//   Rod2.body.phi_d[1] = 0.0;
//   Rod2.body.phi_d[2] = 0.0;
//   Rod2.body.phi_d[3] = 0.0;
//   Rod2.body.phi_dd[1] = 0.0;
//   Rod2.body.phi_dd[2] = 0.0;
//   Rod2.body.phi_dd[3] = 0.0;
//   elseif Rod2.body.useQuaternions then
//   Rod2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({Rod2.body.Q[1],Rod2.body.Q[2],Rod2.body.Q[3],Rod2.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({Rod2.body.Q[1],Rod2.body.Q[2],Rod2.body.Q[3],Rod2.body.Q[4]},{der(Rod2.body.Q[1]),der(Rod2.body.Q[2]),der(Rod2.body.Q[3]),der(Rod2.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({Rod2.body.Q[1],Rod2.body.Q[2],Rod2.body.Q[3],Rod2.body.Q[4]});
//   Rod2.body.phi[1] = 0.0;
//   Rod2.body.phi[2] = 0.0;
//   Rod2.body.phi[3] = 0.0;
//   Rod2.body.phi_d[1] = 0.0;
//   Rod2.body.phi_d[2] = 0.0;
//   Rod2.body.phi_d[3] = 0.0;
//   Rod2.body.phi_dd[1] = 0.0;
//   Rod2.body.phi_dd[2] = 0.0;
//   Rod2.body.phi_dd[3] = 0.0;
//   else
//   Rod2.body.phi_d[1] = der(Rod2.body.phi[1]);
//   Rod2.body.phi_d[2] = der(Rod2.body.phi[2]);
//   Rod2.body.phi_d[3] = der(Rod2.body.phi[3]);
//   Rod2.body.phi_dd[1] = der(Rod2.body.phi_d[1]);
//   Rod2.body.phi_dd[2] = der(Rod2.body.phi_d[2]);
//   Rod2.body.phi_dd[3] = der(Rod2.body.phi_d[3]);
//   Rod2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({Rod2.body.sequence_angleStates[1],Rod2.body.sequence_angleStates[2],Rod2.body.sequence_angleStates[3]},{Rod2.body.phi[1],Rod2.body.phi[2],Rod2.body.phi[3]},{Rod2.body.phi_d[1],Rod2.body.phi_d[2],Rod2.body.phi_d[3]});
//   Rod2.body.Q[1] = 0.0;
//   Rod2.body.Q[2] = 0.0;
//   Rod2.body.Q[3] = 0.0;
//   Rod2.body.Q[4] = 1.0;
//   end if;
//   Rod2.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({Rod2.body.frame_a.r_0[1],Rod2.body.frame_a.r_0[2],Rod2.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(Rod2.body.frame_a.R,{Rod2.body.r_CM[1],Rod2.body.r_CM[2],Rod2.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   Rod2.body.v_0[1] = der(Rod2.body.frame_a.r_0[1]);
//   Rod2.body.v_0[2] = der(Rod2.body.frame_a.r_0[2]);
//   Rod2.body.v_0[3] = der(Rod2.body.frame_a.r_0[3]);
//   Rod2.body.a_0[1] = der(Rod2.body.v_0[1]);
//   Rod2.body.a_0[2] = der(Rod2.body.v_0[2]);
//   Rod2.body.a_0[3] = der(Rod2.body.v_0[3]);
//   Rod2.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(Rod2.body.frame_a.R);
//   Rod2.body.z_a[1] = der(Rod2.body.w_a[1]);
//   Rod2.body.z_a[2] = der(Rod2.body.w_a[2]);
//   Rod2.body.z_a[3] = der(Rod2.body.w_a[3]);
//   Rod2.body.frame_a.f = Rod2.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(Rod2.body.frame_a.R,{Rod2.body.a_0[1] - Rod2.body.g_0[1],Rod2.body.a_0[2] - Rod2.body.g_0[2],Rod2.body.a_0[3] - Rod2.body.g_0[3]}) + {Rod2.body.z_a[2] * Rod2.body.r_CM[3] - Rod2.body.z_a[3] * Rod2.body.r_CM[2],Rod2.body.z_a[3] * Rod2.body.r_CM[1] - Rod2.body.z_a[1] * Rod2.body.r_CM[3],Rod2.body.z_a[1] * Rod2.body.r_CM[2] - Rod2.body.z_a[2] * Rod2.body.r_CM[1]} + {Rod2.body.w_a[2] * (Rod2.body.w_a[1] * Rod2.body.r_CM[2] - Rod2.body.w_a[2] * Rod2.body.r_CM[1]) - Rod2.body.w_a[3] * (Rod2.body.w_a[3] * Rod2.body.r_CM[1] - Rod2.body.w_a[1] * Rod2.body.r_CM[3]),Rod2.body.w_a[3] * (Rod2.body.w_a[2] * Rod2.body.r_CM[3] - Rod2.body.w_a[3] * Rod2.body.r_CM[2]) - Rod2.body.w_a[1] * (Rod2.body.w_a[1] * Rod2.body.r_CM[2] - Rod2.body.w_a[2] * Rod2.body.r_CM[1]),Rod2.body.w_a[1] * (Rod2.body.w_a[3] * Rod2.body.r_CM[1] - Rod2.body.w_a[1] * Rod2.body.r_CM[3]) - Rod2.body.w_a[2] * (Rod2.body.w_a[2] * Rod2.body.r_CM[3] - Rod2.body.w_a[3] * Rod2.body.r_CM[2])});
//   Rod2.body.frame_a.t[1] = Rod2.body.I[1,1] * Rod2.body.z_a[1] + (Rod2.body.I[1,2] * Rod2.body.z_a[2] + (Rod2.body.I[1,3] * Rod2.body.z_a[3] + (Rod2.body.w_a[2] * (Rod2.body.I[3,1] * Rod2.body.w_a[1] + (Rod2.body.I[3,2] * Rod2.body.w_a[2] + Rod2.body.I[3,3] * Rod2.body.w_a[3])) + ((-Rod2.body.w_a[3] * (Rod2.body.I[2,1] * Rod2.body.w_a[1] + (Rod2.body.I[2,2] * Rod2.body.w_a[2] + Rod2.body.I[2,3] * Rod2.body.w_a[3]))) + (Rod2.body.r_CM[2] * Rod2.body.frame_a.f[3] + (-Rod2.body.r_CM[3] * Rod2.body.frame_a.f[2]))))));
//   Rod2.body.frame_a.t[2] = Rod2.body.I[2,1] * Rod2.body.z_a[1] + (Rod2.body.I[2,2] * Rod2.body.z_a[2] + (Rod2.body.I[2,3] * Rod2.body.z_a[3] + (Rod2.body.w_a[3] * (Rod2.body.I[1,1] * Rod2.body.w_a[1] + (Rod2.body.I[1,2] * Rod2.body.w_a[2] + Rod2.body.I[1,3] * Rod2.body.w_a[3])) + ((-Rod2.body.w_a[1] * (Rod2.body.I[3,1] * Rod2.body.w_a[1] + (Rod2.body.I[3,2] * Rod2.body.w_a[2] + Rod2.body.I[3,3] * Rod2.body.w_a[3]))) + (Rod2.body.r_CM[3] * Rod2.body.frame_a.f[1] + (-Rod2.body.r_CM[1] * Rod2.body.frame_a.f[3]))))));
//   Rod2.body.frame_a.t[3] = Rod2.body.I[3,1] * Rod2.body.z_a[1] + (Rod2.body.I[3,2] * Rod2.body.z_a[2] + (Rod2.body.I[3,3] * Rod2.body.z_a[3] + (Rod2.body.w_a[1] * (Rod2.body.I[2,1] * Rod2.body.w_a[1] + (Rod2.body.I[2,2] * Rod2.body.w_a[2] + Rod2.body.I[2,3] * Rod2.body.w_a[3])) + ((-Rod2.body.w_a[2] * (Rod2.body.I[1,1] * Rod2.body.w_a[1] + (Rod2.body.I[1,2] * Rod2.body.w_a[2] + Rod2.body.I[1,3] * Rod2.body.w_a[3]))) + (Rod2.body.r_CM[1] * Rod2.body.frame_a.f[2] + (-Rod2.body.r_CM[2] * Rod2.body.frame_a.f[1]))))));
//   Rod2.frameTranslation.shape.R.T[1,1] = Rod2.frameTranslation.frame_a.R.T[1,1];
//   Rod2.frameTranslation.shape.R.T[1,2] = Rod2.frameTranslation.frame_a.R.T[1,2];
//   Rod2.frameTranslation.shape.R.T[1,3] = Rod2.frameTranslation.frame_a.R.T[1,3];
//   Rod2.frameTranslation.shape.R.T[2,1] = Rod2.frameTranslation.frame_a.R.T[2,1];
//   Rod2.frameTranslation.shape.R.T[2,2] = Rod2.frameTranslation.frame_a.R.T[2,2];
//   Rod2.frameTranslation.shape.R.T[2,3] = Rod2.frameTranslation.frame_a.R.T[2,3];
//   Rod2.frameTranslation.shape.R.T[3,1] = Rod2.frameTranslation.frame_a.R.T[3,1];
//   Rod2.frameTranslation.shape.R.T[3,2] = Rod2.frameTranslation.frame_a.R.T[3,2];
//   Rod2.frameTranslation.shape.R.T[3,3] = Rod2.frameTranslation.frame_a.R.T[3,3];
//   Rod2.frameTranslation.shape.R.w[1] = Rod2.frameTranslation.frame_a.R.w[1];
//   Rod2.frameTranslation.shape.R.w[2] = Rod2.frameTranslation.frame_a.R.w[2];
//   Rod2.frameTranslation.shape.R.w[3] = Rod2.frameTranslation.frame_a.R.w[3];
//   Rod2.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Rod2.frameTranslation.shape.shapeType);
//   Rod2.frameTranslation.shape.rxvisobj[1] = Rod2.frameTranslation.shape.R.T[1,1] * Rod2.frameTranslation.shape.e_x[1] + (Rod2.frameTranslation.shape.R.T[2,1] * Rod2.frameTranslation.shape.e_x[2] + Rod2.frameTranslation.shape.R.T[3,1] * Rod2.frameTranslation.shape.e_x[3]);
//   Rod2.frameTranslation.shape.rxvisobj[2] = Rod2.frameTranslation.shape.R.T[1,2] * Rod2.frameTranslation.shape.e_x[1] + (Rod2.frameTranslation.shape.R.T[2,2] * Rod2.frameTranslation.shape.e_x[2] + Rod2.frameTranslation.shape.R.T[3,2] * Rod2.frameTranslation.shape.e_x[3]);
//   Rod2.frameTranslation.shape.rxvisobj[3] = Rod2.frameTranslation.shape.R.T[1,3] * Rod2.frameTranslation.shape.e_x[1] + (Rod2.frameTranslation.shape.R.T[2,3] * Rod2.frameTranslation.shape.e_x[2] + Rod2.frameTranslation.shape.R.T[3,3] * Rod2.frameTranslation.shape.e_x[3]);
//   Rod2.frameTranslation.shape.ryvisobj[1] = Rod2.frameTranslation.shape.R.T[1,1] * Rod2.frameTranslation.shape.e_y[1] + (Rod2.frameTranslation.shape.R.T[2,1] * Rod2.frameTranslation.shape.e_y[2] + Rod2.frameTranslation.shape.R.T[3,1] * Rod2.frameTranslation.shape.e_y[3]);
//   Rod2.frameTranslation.shape.ryvisobj[2] = Rod2.frameTranslation.shape.R.T[1,2] * Rod2.frameTranslation.shape.e_y[1] + (Rod2.frameTranslation.shape.R.T[2,2] * Rod2.frameTranslation.shape.e_y[2] + Rod2.frameTranslation.shape.R.T[3,2] * Rod2.frameTranslation.shape.e_y[3]);
//   Rod2.frameTranslation.shape.ryvisobj[3] = Rod2.frameTranslation.shape.R.T[1,3] * Rod2.frameTranslation.shape.e_y[1] + (Rod2.frameTranslation.shape.R.T[2,3] * Rod2.frameTranslation.shape.e_y[2] + Rod2.frameTranslation.shape.R.T[3,3] * Rod2.frameTranslation.shape.e_y[3]);
//   Rod2.frameTranslation.shape.rvisobj = Rod2.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Rod2.frameTranslation.shape.R.T[1,1],Rod2.frameTranslation.shape.R.T[1,2],Rod2.frameTranslation.shape.R.T[1,3]},{Rod2.frameTranslation.shape.R.T[2,1],Rod2.frameTranslation.shape.R.T[2,2],Rod2.frameTranslation.shape.R.T[2,3]},{Rod2.frameTranslation.shape.R.T[3,1],Rod2.frameTranslation.shape.R.T[3,2],Rod2.frameTranslation.shape.R.T[3,3]}},{Rod2.frameTranslation.shape.r_shape[1],Rod2.frameTranslation.shape.r_shape[2],Rod2.frameTranslation.shape.r_shape[3]});
//   Rod2.frameTranslation.shape.size[1] = Rod2.frameTranslation.shape.length;
//   Rod2.frameTranslation.shape.size[2] = Rod2.frameTranslation.shape.width;
//   Rod2.frameTranslation.shape.size[3] = Rod2.frameTranslation.shape.height;
//   Rod2.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Rod2.frameTranslation.shape.color[1] / 255.0,Rod2.frameTranslation.shape.color[2] / 255.0,Rod2.frameTranslation.shape.color[3] / 255.0,Rod2.frameTranslation.shape.specularCoefficient);
//   Rod2.frameTranslation.shape.Extra = Rod2.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Rod2.frameTranslation.frame_b.r_0 = Rod2.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Rod2.frameTranslation.frame_a.R,{Rod2.frameTranslation.r[1],Rod2.frameTranslation.r[2],Rod2.frameTranslation.r[3]});
//   Rod2.frameTranslation.frame_b.R.T[1,1] = Rod2.frameTranslation.frame_a.R.T[1,1];
//   Rod2.frameTranslation.frame_b.R.T[1,2] = Rod2.frameTranslation.frame_a.R.T[1,2];
//   Rod2.frameTranslation.frame_b.R.T[1,3] = Rod2.frameTranslation.frame_a.R.T[1,3];
//   Rod2.frameTranslation.frame_b.R.T[2,1] = Rod2.frameTranslation.frame_a.R.T[2,1];
//   Rod2.frameTranslation.frame_b.R.T[2,2] = Rod2.frameTranslation.frame_a.R.T[2,2];
//   Rod2.frameTranslation.frame_b.R.T[2,3] = Rod2.frameTranslation.frame_a.R.T[2,3];
//   Rod2.frameTranslation.frame_b.R.T[3,1] = Rod2.frameTranslation.frame_a.R.T[3,1];
//   Rod2.frameTranslation.frame_b.R.T[3,2] = Rod2.frameTranslation.frame_a.R.T[3,2];
//   Rod2.frameTranslation.frame_b.R.T[3,3] = Rod2.frameTranslation.frame_a.R.T[3,3];
//   Rod2.frameTranslation.frame_b.R.w[1] = Rod2.frameTranslation.frame_a.R.w[1];
//   Rod2.frameTranslation.frame_b.R.w[2] = Rod2.frameTranslation.frame_a.R.w[2];
//   Rod2.frameTranslation.frame_b.R.w[3] = Rod2.frameTranslation.frame_a.R.w[3];
//   0.0 = Rod2.frameTranslation.frame_a.f[1] + Rod2.frameTranslation.frame_b.f[1];
//   0.0 = Rod2.frameTranslation.frame_a.f[2] + Rod2.frameTranslation.frame_b.f[2];
//   0.0 = Rod2.frameTranslation.frame_a.f[3] + Rod2.frameTranslation.frame_b.f[3];
//   0.0 = Rod2.frameTranslation.frame_a.t[1] + (Rod2.frameTranslation.frame_b.t[1] + (Rod2.frameTranslation.r[2] * Rod2.frameTranslation.frame_b.f[3] + (-Rod2.frameTranslation.r[3] * Rod2.frameTranslation.frame_b.f[2])));
//   0.0 = Rod2.frameTranslation.frame_a.t[2] + (Rod2.frameTranslation.frame_b.t[2] + (Rod2.frameTranslation.r[3] * Rod2.frameTranslation.frame_b.f[1] + (-Rod2.frameTranslation.r[1] * Rod2.frameTranslation.frame_b.f[3])));
//   0.0 = Rod2.frameTranslation.frame_a.t[3] + (Rod2.frameTranslation.frame_b.t[3] + (Rod2.frameTranslation.r[1] * Rod2.frameTranslation.frame_b.f[2] + (-Rod2.frameTranslation.r[2] * Rod2.frameTranslation.frame_b.f[1])));
//   Rod2.r_0[1] = Rod2.frame_a.r_0[1];
//   Rod2.r_0[2] = Rod2.frame_a.r_0[2];
//   Rod2.r_0[3] = Rod2.frame_a.r_0[3];
//   Rod2.v_0[1] = der(Rod2.r_0[1]);
//   Rod2.v_0[2] = der(Rod2.r_0[2]);
//   Rod2.v_0[3] = der(Rod2.r_0[3]);
//   Rod2.a_0[1] = der(Rod2.v_0[1]);
//   Rod2.a_0[2] = der(Rod2.v_0[2]);
//   Rod2.a_0[3] = der(Rod2.v_0[3]);
//   assert(Rod2.innerWidth <= Rod2.width,\"parameter innerWidth is greater as parameter width\");
//   assert(Rod2.innerHeight <= Rod2.height,\"parameter innerHeight is greater as paraemter height\");
//   Bearing.fixed.flange.phi = Bearing.fixed.phi0;
//   Bearing.internalAxis.flange.tau = Bearing.internalAxis.tau;
//   Bearing.internalAxis.flange.phi = Bearing.internalAxis.phi;
//   Bearing.cylinder.R.T[1,1] = Bearing.frame_a.R.T[1,1];
//   Bearing.cylinder.R.T[1,2] = Bearing.frame_a.R.T[1,2];
//   Bearing.cylinder.R.T[1,3] = Bearing.frame_a.R.T[1,3];
//   Bearing.cylinder.R.T[2,1] = Bearing.frame_a.R.T[2,1];
//   Bearing.cylinder.R.T[2,2] = Bearing.frame_a.R.T[2,2];
//   Bearing.cylinder.R.T[2,3] = Bearing.frame_a.R.T[2,3];
//   Bearing.cylinder.R.T[3,1] = Bearing.frame_a.R.T[3,1];
//   Bearing.cylinder.R.T[3,2] = Bearing.frame_a.R.T[3,2];
//   Bearing.cylinder.R.T[3,3] = Bearing.frame_a.R.T[3,3];
//   Bearing.cylinder.R.w[1] = Bearing.frame_a.R.w[1];
//   Bearing.cylinder.R.w[2] = Bearing.frame_a.R.w[2];
//   Bearing.cylinder.R.w[3] = Bearing.frame_a.R.w[3];
//   Bearing.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Bearing.cylinder.shapeType);
//   Bearing.cylinder.rxvisobj[1] = Bearing.cylinder.R.T[1,1] * Bearing.cylinder.e_x[1] + (Bearing.cylinder.R.T[2,1] * Bearing.cylinder.e_x[2] + Bearing.cylinder.R.T[3,1] * Bearing.cylinder.e_x[3]);
//   Bearing.cylinder.rxvisobj[2] = Bearing.cylinder.R.T[1,2] * Bearing.cylinder.e_x[1] + (Bearing.cylinder.R.T[2,2] * Bearing.cylinder.e_x[2] + Bearing.cylinder.R.T[3,2] * Bearing.cylinder.e_x[3]);
//   Bearing.cylinder.rxvisobj[3] = Bearing.cylinder.R.T[1,3] * Bearing.cylinder.e_x[1] + (Bearing.cylinder.R.T[2,3] * Bearing.cylinder.e_x[2] + Bearing.cylinder.R.T[3,3] * Bearing.cylinder.e_x[3]);
//   Bearing.cylinder.ryvisobj[1] = Bearing.cylinder.R.T[1,1] * Bearing.cylinder.e_y[1] + (Bearing.cylinder.R.T[2,1] * Bearing.cylinder.e_y[2] + Bearing.cylinder.R.T[3,1] * Bearing.cylinder.e_y[3]);
//   Bearing.cylinder.ryvisobj[2] = Bearing.cylinder.R.T[1,2] * Bearing.cylinder.e_y[1] + (Bearing.cylinder.R.T[2,2] * Bearing.cylinder.e_y[2] + Bearing.cylinder.R.T[3,2] * Bearing.cylinder.e_y[3]);
//   Bearing.cylinder.ryvisobj[3] = Bearing.cylinder.R.T[1,3] * Bearing.cylinder.e_y[1] + (Bearing.cylinder.R.T[2,3] * Bearing.cylinder.e_y[2] + Bearing.cylinder.R.T[3,3] * Bearing.cylinder.e_y[3]);
//   Bearing.cylinder.rvisobj = Bearing.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Bearing.cylinder.R.T[1,1],Bearing.cylinder.R.T[1,2],Bearing.cylinder.R.T[1,3]},{Bearing.cylinder.R.T[2,1],Bearing.cylinder.R.T[2,2],Bearing.cylinder.R.T[2,3]},{Bearing.cylinder.R.T[3,1],Bearing.cylinder.R.T[3,2],Bearing.cylinder.R.T[3,3]}},{Bearing.cylinder.r_shape[1],Bearing.cylinder.r_shape[2],Bearing.cylinder.r_shape[3]});
//   Bearing.cylinder.size[1] = Bearing.cylinder.length;
//   Bearing.cylinder.size[2] = Bearing.cylinder.width;
//   Bearing.cylinder.size[3] = Bearing.cylinder.height;
//   Bearing.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Bearing.cylinder.color[1] / 255.0,Bearing.cylinder.color[2] / 255.0,Bearing.cylinder.color[3] / 255.0,Bearing.cylinder.specularCoefficient);
//   Bearing.cylinder.Extra = Bearing.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   Bearing.angle = Bearing.phi;
//   Bearing.w = der(Bearing.phi);
//   Bearing.a = der(Bearing.w);
//   Bearing.frame_b.r_0[1] = Bearing.frame_a.r_0[1];
//   Bearing.frame_b.r_0[2] = Bearing.frame_a.r_0[2];
//   Bearing.frame_b.r_0[3] = Bearing.frame_a.r_0[3];
//   Bearing.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({Bearing.e[1],Bearing.e[2],Bearing.e[3]},Bearing.phi,Bearing.w);
//   Bearing.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(Bearing.frame_a.R,Bearing.R_rel);
//   Bearing.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(Bearing.R_rel,{Bearing.frame_b.f[1],Bearing.frame_b.f[2],Bearing.frame_b.f[3]});
//   Bearing.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(Bearing.R_rel,{Bearing.frame_b.t[1],Bearing.frame_b.t[2],Bearing.frame_b.t[3]});
//   Bearing.tau = (-Bearing.frame_b.t[1]) * Bearing.e[1] + ((-Bearing.frame_b.t[2]) * Bearing.e[2] + (-Bearing.frame_b.t[3]) * Bearing.e[3]);
//   Bearing.phi = Bearing.internalAxis.phi;
//   Inertia.phi = Inertia.flange_a.phi;
//   Inertia.phi = Inertia.flange_b.phi;
//   Inertia.w = der(Inertia.phi);
//   Inertia.a = der(Inertia.w);
//   Inertia.J * Inertia.a = Inertia.flange_a.tau + Inertia.flange_b.tau;
//   Crank4.body.r_0[1] = Crank4.body.frame_a.r_0[1];
//   Crank4.body.r_0[2] = Crank4.body.frame_a.r_0[2];
//   Crank4.body.r_0[3] = Crank4.body.frame_a.r_0[3];
//   if true then
//   Crank4.body.Q[1] = 0.0;
//   Crank4.body.Q[2] = 0.0;
//   Crank4.body.Q[3] = 0.0;
//   Crank4.body.Q[4] = 1.0;
//   Crank4.body.phi[1] = 0.0;
//   Crank4.body.phi[2] = 0.0;
//   Crank4.body.phi[3] = 0.0;
//   Crank4.body.phi_d[1] = 0.0;
//   Crank4.body.phi_d[2] = 0.0;
//   Crank4.body.phi_d[3] = 0.0;
//   Crank4.body.phi_dd[1] = 0.0;
//   Crank4.body.phi_dd[2] = 0.0;
//   Crank4.body.phi_dd[3] = 0.0;
//   elseif Crank4.body.useQuaternions then
//   Crank4.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({Crank4.body.Q[1],Crank4.body.Q[2],Crank4.body.Q[3],Crank4.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({Crank4.body.Q[1],Crank4.body.Q[2],Crank4.body.Q[3],Crank4.body.Q[4]},{der(Crank4.body.Q[1]),der(Crank4.body.Q[2]),der(Crank4.body.Q[3]),der(Crank4.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({Crank4.body.Q[1],Crank4.body.Q[2],Crank4.body.Q[3],Crank4.body.Q[4]});
//   Crank4.body.phi[1] = 0.0;
//   Crank4.body.phi[2] = 0.0;
//   Crank4.body.phi[3] = 0.0;
//   Crank4.body.phi_d[1] = 0.0;
//   Crank4.body.phi_d[2] = 0.0;
//   Crank4.body.phi_d[3] = 0.0;
//   Crank4.body.phi_dd[1] = 0.0;
//   Crank4.body.phi_dd[2] = 0.0;
//   Crank4.body.phi_dd[3] = 0.0;
//   else
//   Crank4.body.phi_d[1] = der(Crank4.body.phi[1]);
//   Crank4.body.phi_d[2] = der(Crank4.body.phi[2]);
//   Crank4.body.phi_d[3] = der(Crank4.body.phi[3]);
//   Crank4.body.phi_dd[1] = der(Crank4.body.phi_d[1]);
//   Crank4.body.phi_dd[2] = der(Crank4.body.phi_d[2]);
//   Crank4.body.phi_dd[3] = der(Crank4.body.phi_d[3]);
//   Crank4.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({Crank4.body.sequence_angleStates[1],Crank4.body.sequence_angleStates[2],Crank4.body.sequence_angleStates[3]},{Crank4.body.phi[1],Crank4.body.phi[2],Crank4.body.phi[3]},{Crank4.body.phi_d[1],Crank4.body.phi_d[2],Crank4.body.phi_d[3]});
//   Crank4.body.Q[1] = 0.0;
//   Crank4.body.Q[2] = 0.0;
//   Crank4.body.Q[3] = 0.0;
//   Crank4.body.Q[4] = 1.0;
//   end if;
//   Crank4.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({Crank4.body.frame_a.r_0[1],Crank4.body.frame_a.r_0[2],Crank4.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank4.body.frame_a.R,{Crank4.body.r_CM[1],Crank4.body.r_CM[2],Crank4.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   Crank4.body.v_0[1] = der(Crank4.body.frame_a.r_0[1]);
//   Crank4.body.v_0[2] = der(Crank4.body.frame_a.r_0[2]);
//   Crank4.body.v_0[3] = der(Crank4.body.frame_a.r_0[3]);
//   Crank4.body.a_0[1] = der(Crank4.body.v_0[1]);
//   Crank4.body.a_0[2] = der(Crank4.body.v_0[2]);
//   Crank4.body.a_0[3] = der(Crank4.body.v_0[3]);
//   Crank4.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(Crank4.body.frame_a.R);
//   Crank4.body.z_a[1] = der(Crank4.body.w_a[1]);
//   Crank4.body.z_a[2] = der(Crank4.body.w_a[2]);
//   Crank4.body.z_a[3] = der(Crank4.body.w_a[3]);
//   Crank4.body.frame_a.f = Crank4.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(Crank4.body.frame_a.R,{Crank4.body.a_0[1] - Crank4.body.g_0[1],Crank4.body.a_0[2] - Crank4.body.g_0[2],Crank4.body.a_0[3] - Crank4.body.g_0[3]}) + {Crank4.body.z_a[2] * Crank4.body.r_CM[3] - Crank4.body.z_a[3] * Crank4.body.r_CM[2],Crank4.body.z_a[3] * Crank4.body.r_CM[1] - Crank4.body.z_a[1] * Crank4.body.r_CM[3],Crank4.body.z_a[1] * Crank4.body.r_CM[2] - Crank4.body.z_a[2] * Crank4.body.r_CM[1]} + {Crank4.body.w_a[2] * (Crank4.body.w_a[1] * Crank4.body.r_CM[2] - Crank4.body.w_a[2] * Crank4.body.r_CM[1]) - Crank4.body.w_a[3] * (Crank4.body.w_a[3] * Crank4.body.r_CM[1] - Crank4.body.w_a[1] * Crank4.body.r_CM[3]),Crank4.body.w_a[3] * (Crank4.body.w_a[2] * Crank4.body.r_CM[3] - Crank4.body.w_a[3] * Crank4.body.r_CM[2]) - Crank4.body.w_a[1] * (Crank4.body.w_a[1] * Crank4.body.r_CM[2] - Crank4.body.w_a[2] * Crank4.body.r_CM[1]),Crank4.body.w_a[1] * (Crank4.body.w_a[3] * Crank4.body.r_CM[1] - Crank4.body.w_a[1] * Crank4.body.r_CM[3]) - Crank4.body.w_a[2] * (Crank4.body.w_a[2] * Crank4.body.r_CM[3] - Crank4.body.w_a[3] * Crank4.body.r_CM[2])});
//   Crank4.body.frame_a.t[1] = Crank4.body.I[1,1] * Crank4.body.z_a[1] + (Crank4.body.I[1,2] * Crank4.body.z_a[2] + (Crank4.body.I[1,3] * Crank4.body.z_a[3] + (Crank4.body.w_a[2] * (Crank4.body.I[3,1] * Crank4.body.w_a[1] + (Crank4.body.I[3,2] * Crank4.body.w_a[2] + Crank4.body.I[3,3] * Crank4.body.w_a[3])) + ((-Crank4.body.w_a[3] * (Crank4.body.I[2,1] * Crank4.body.w_a[1] + (Crank4.body.I[2,2] * Crank4.body.w_a[2] + Crank4.body.I[2,3] * Crank4.body.w_a[3]))) + (Crank4.body.r_CM[2] * Crank4.body.frame_a.f[3] + (-Crank4.body.r_CM[3] * Crank4.body.frame_a.f[2]))))));
//   Crank4.body.frame_a.t[2] = Crank4.body.I[2,1] * Crank4.body.z_a[1] + (Crank4.body.I[2,2] * Crank4.body.z_a[2] + (Crank4.body.I[2,3] * Crank4.body.z_a[3] + (Crank4.body.w_a[3] * (Crank4.body.I[1,1] * Crank4.body.w_a[1] + (Crank4.body.I[1,2] * Crank4.body.w_a[2] + Crank4.body.I[1,3] * Crank4.body.w_a[3])) + ((-Crank4.body.w_a[1] * (Crank4.body.I[3,1] * Crank4.body.w_a[1] + (Crank4.body.I[3,2] * Crank4.body.w_a[2] + Crank4.body.I[3,3] * Crank4.body.w_a[3]))) + (Crank4.body.r_CM[3] * Crank4.body.frame_a.f[1] + (-Crank4.body.r_CM[1] * Crank4.body.frame_a.f[3]))))));
//   Crank4.body.frame_a.t[3] = Crank4.body.I[3,1] * Crank4.body.z_a[1] + (Crank4.body.I[3,2] * Crank4.body.z_a[2] + (Crank4.body.I[3,3] * Crank4.body.z_a[3] + (Crank4.body.w_a[1] * (Crank4.body.I[2,1] * Crank4.body.w_a[1] + (Crank4.body.I[2,2] * Crank4.body.w_a[2] + Crank4.body.I[2,3] * Crank4.body.w_a[3])) + ((-Crank4.body.w_a[2] * (Crank4.body.I[1,1] * Crank4.body.w_a[1] + (Crank4.body.I[1,2] * Crank4.body.w_a[2] + Crank4.body.I[1,3] * Crank4.body.w_a[3]))) + (Crank4.body.r_CM[1] * Crank4.body.frame_a.f[2] + (-Crank4.body.r_CM[2] * Crank4.body.frame_a.f[1]))))));
//   Crank4.frameTranslation.shape.R.T[1,1] = Crank4.frameTranslation.frame_a.R.T[1,1];
//   Crank4.frameTranslation.shape.R.T[1,2] = Crank4.frameTranslation.frame_a.R.T[1,2];
//   Crank4.frameTranslation.shape.R.T[1,3] = Crank4.frameTranslation.frame_a.R.T[1,3];
//   Crank4.frameTranslation.shape.R.T[2,1] = Crank4.frameTranslation.frame_a.R.T[2,1];
//   Crank4.frameTranslation.shape.R.T[2,2] = Crank4.frameTranslation.frame_a.R.T[2,2];
//   Crank4.frameTranslation.shape.R.T[2,3] = Crank4.frameTranslation.frame_a.R.T[2,3];
//   Crank4.frameTranslation.shape.R.T[3,1] = Crank4.frameTranslation.frame_a.R.T[3,1];
//   Crank4.frameTranslation.shape.R.T[3,2] = Crank4.frameTranslation.frame_a.R.T[3,2];
//   Crank4.frameTranslation.shape.R.T[3,3] = Crank4.frameTranslation.frame_a.R.T[3,3];
//   Crank4.frameTranslation.shape.R.w[1] = Crank4.frameTranslation.frame_a.R.w[1];
//   Crank4.frameTranslation.shape.R.w[2] = Crank4.frameTranslation.frame_a.R.w[2];
//   Crank4.frameTranslation.shape.R.w[3] = Crank4.frameTranslation.frame_a.R.w[3];
//   Crank4.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Crank4.frameTranslation.shape.shapeType);
//   Crank4.frameTranslation.shape.rxvisobj[1] = Crank4.frameTranslation.shape.R.T[1,1] * Crank4.frameTranslation.shape.e_x[1] + (Crank4.frameTranslation.shape.R.T[2,1] * Crank4.frameTranslation.shape.e_x[2] + Crank4.frameTranslation.shape.R.T[3,1] * Crank4.frameTranslation.shape.e_x[3]);
//   Crank4.frameTranslation.shape.rxvisobj[2] = Crank4.frameTranslation.shape.R.T[1,2] * Crank4.frameTranslation.shape.e_x[1] + (Crank4.frameTranslation.shape.R.T[2,2] * Crank4.frameTranslation.shape.e_x[2] + Crank4.frameTranslation.shape.R.T[3,2] * Crank4.frameTranslation.shape.e_x[3]);
//   Crank4.frameTranslation.shape.rxvisobj[3] = Crank4.frameTranslation.shape.R.T[1,3] * Crank4.frameTranslation.shape.e_x[1] + (Crank4.frameTranslation.shape.R.T[2,3] * Crank4.frameTranslation.shape.e_x[2] + Crank4.frameTranslation.shape.R.T[3,3] * Crank4.frameTranslation.shape.e_x[3]);
//   Crank4.frameTranslation.shape.ryvisobj[1] = Crank4.frameTranslation.shape.R.T[1,1] * Crank4.frameTranslation.shape.e_y[1] + (Crank4.frameTranslation.shape.R.T[2,1] * Crank4.frameTranslation.shape.e_y[2] + Crank4.frameTranslation.shape.R.T[3,1] * Crank4.frameTranslation.shape.e_y[3]);
//   Crank4.frameTranslation.shape.ryvisobj[2] = Crank4.frameTranslation.shape.R.T[1,2] * Crank4.frameTranslation.shape.e_y[1] + (Crank4.frameTranslation.shape.R.T[2,2] * Crank4.frameTranslation.shape.e_y[2] + Crank4.frameTranslation.shape.R.T[3,2] * Crank4.frameTranslation.shape.e_y[3]);
//   Crank4.frameTranslation.shape.ryvisobj[3] = Crank4.frameTranslation.shape.R.T[1,3] * Crank4.frameTranslation.shape.e_y[1] + (Crank4.frameTranslation.shape.R.T[2,3] * Crank4.frameTranslation.shape.e_y[2] + Crank4.frameTranslation.shape.R.T[3,3] * Crank4.frameTranslation.shape.e_y[3]);
//   Crank4.frameTranslation.shape.rvisobj = Crank4.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Crank4.frameTranslation.shape.R.T[1,1],Crank4.frameTranslation.shape.R.T[1,2],Crank4.frameTranslation.shape.R.T[1,3]},{Crank4.frameTranslation.shape.R.T[2,1],Crank4.frameTranslation.shape.R.T[2,2],Crank4.frameTranslation.shape.R.T[2,3]},{Crank4.frameTranslation.shape.R.T[3,1],Crank4.frameTranslation.shape.R.T[3,2],Crank4.frameTranslation.shape.R.T[3,3]}},{Crank4.frameTranslation.shape.r_shape[1],Crank4.frameTranslation.shape.r_shape[2],Crank4.frameTranslation.shape.r_shape[3]});
//   Crank4.frameTranslation.shape.size[1] = Crank4.frameTranslation.shape.length;
//   Crank4.frameTranslation.shape.size[2] = Crank4.frameTranslation.shape.width;
//   Crank4.frameTranslation.shape.size[3] = Crank4.frameTranslation.shape.height;
//   Crank4.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Crank4.frameTranslation.shape.color[1] / 255.0,Crank4.frameTranslation.shape.color[2] / 255.0,Crank4.frameTranslation.shape.color[3] / 255.0,Crank4.frameTranslation.shape.specularCoefficient);
//   Crank4.frameTranslation.shape.Extra = Crank4.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Crank4.frameTranslation.frame_b.r_0 = Crank4.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank4.frameTranslation.frame_a.R,{Crank4.frameTranslation.r[1],Crank4.frameTranslation.r[2],Crank4.frameTranslation.r[3]});
//   Crank4.frameTranslation.frame_b.R.T[1,1] = Crank4.frameTranslation.frame_a.R.T[1,1];
//   Crank4.frameTranslation.frame_b.R.T[1,2] = Crank4.frameTranslation.frame_a.R.T[1,2];
//   Crank4.frameTranslation.frame_b.R.T[1,3] = Crank4.frameTranslation.frame_a.R.T[1,3];
//   Crank4.frameTranslation.frame_b.R.T[2,1] = Crank4.frameTranslation.frame_a.R.T[2,1];
//   Crank4.frameTranslation.frame_b.R.T[2,2] = Crank4.frameTranslation.frame_a.R.T[2,2];
//   Crank4.frameTranslation.frame_b.R.T[2,3] = Crank4.frameTranslation.frame_a.R.T[2,3];
//   Crank4.frameTranslation.frame_b.R.T[3,1] = Crank4.frameTranslation.frame_a.R.T[3,1];
//   Crank4.frameTranslation.frame_b.R.T[3,2] = Crank4.frameTranslation.frame_a.R.T[3,2];
//   Crank4.frameTranslation.frame_b.R.T[3,3] = Crank4.frameTranslation.frame_a.R.T[3,3];
//   Crank4.frameTranslation.frame_b.R.w[1] = Crank4.frameTranslation.frame_a.R.w[1];
//   Crank4.frameTranslation.frame_b.R.w[2] = Crank4.frameTranslation.frame_a.R.w[2];
//   Crank4.frameTranslation.frame_b.R.w[3] = Crank4.frameTranslation.frame_a.R.w[3];
//   0.0 = Crank4.frameTranslation.frame_a.f[1] + Crank4.frameTranslation.frame_b.f[1];
//   0.0 = Crank4.frameTranslation.frame_a.f[2] + Crank4.frameTranslation.frame_b.f[2];
//   0.0 = Crank4.frameTranslation.frame_a.f[3] + Crank4.frameTranslation.frame_b.f[3];
//   0.0 = Crank4.frameTranslation.frame_a.t[1] + (Crank4.frameTranslation.frame_b.t[1] + (Crank4.frameTranslation.r[2] * Crank4.frameTranslation.frame_b.f[3] + (-Crank4.frameTranslation.r[3] * Crank4.frameTranslation.frame_b.f[2])));
//   0.0 = Crank4.frameTranslation.frame_a.t[2] + (Crank4.frameTranslation.frame_b.t[2] + (Crank4.frameTranslation.r[3] * Crank4.frameTranslation.frame_b.f[1] + (-Crank4.frameTranslation.r[1] * Crank4.frameTranslation.frame_b.f[3])));
//   0.0 = Crank4.frameTranslation.frame_a.t[3] + (Crank4.frameTranslation.frame_b.t[3] + (Crank4.frameTranslation.r[1] * Crank4.frameTranslation.frame_b.f[2] + (-Crank4.frameTranslation.r[2] * Crank4.frameTranslation.frame_b.f[1])));
//   Crank4.r_0[1] = Crank4.frame_a.r_0[1];
//   Crank4.r_0[2] = Crank4.frame_a.r_0[2];
//   Crank4.r_0[3] = Crank4.frame_a.r_0[3];
//   Crank4.v_0[1] = der(Crank4.r_0[1]);
//   Crank4.v_0[2] = der(Crank4.r_0[2]);
//   Crank4.v_0[3] = der(Crank4.r_0[3]);
//   Crank4.a_0[1] = der(Crank4.v_0[1]);
//   Crank4.a_0[2] = der(Crank4.v_0[2]);
//   Crank4.a_0[3] = der(Crank4.v_0[3]);
//   assert(Crank4.innerWidth <= Crank4.width,\"parameter innerWidth is greater as parameter width\");
//   assert(Crank4.innerHeight <= Crank4.height,\"parameter innerHeight is greater as paraemter height\");
//   Crank3.body.r_0[1] = Crank3.body.frame_a.r_0[1];
//   Crank3.body.r_0[2] = Crank3.body.frame_a.r_0[2];
//   Crank3.body.r_0[3] = Crank3.body.frame_a.r_0[3];
//   if true then
//   Crank3.body.Q[1] = 0.0;
//   Crank3.body.Q[2] = 0.0;
//   Crank3.body.Q[3] = 0.0;
//   Crank3.body.Q[4] = 1.0;
//   Crank3.body.phi[1] = 0.0;
//   Crank3.body.phi[2] = 0.0;
//   Crank3.body.phi[3] = 0.0;
//   Crank3.body.phi_d[1] = 0.0;
//   Crank3.body.phi_d[2] = 0.0;
//   Crank3.body.phi_d[3] = 0.0;
//   Crank3.body.phi_dd[1] = 0.0;
//   Crank3.body.phi_dd[2] = 0.0;
//   Crank3.body.phi_dd[3] = 0.0;
//   elseif Crank3.body.useQuaternions then
//   Crank3.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({Crank3.body.Q[1],Crank3.body.Q[2],Crank3.body.Q[3],Crank3.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({Crank3.body.Q[1],Crank3.body.Q[2],Crank3.body.Q[3],Crank3.body.Q[4]},{der(Crank3.body.Q[1]),der(Crank3.body.Q[2]),der(Crank3.body.Q[3]),der(Crank3.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({Crank3.body.Q[1],Crank3.body.Q[2],Crank3.body.Q[3],Crank3.body.Q[4]});
//   Crank3.body.phi[1] = 0.0;
//   Crank3.body.phi[2] = 0.0;
//   Crank3.body.phi[3] = 0.0;
//   Crank3.body.phi_d[1] = 0.0;
//   Crank3.body.phi_d[2] = 0.0;
//   Crank3.body.phi_d[3] = 0.0;
//   Crank3.body.phi_dd[1] = 0.0;
//   Crank3.body.phi_dd[2] = 0.0;
//   Crank3.body.phi_dd[3] = 0.0;
//   else
//   Crank3.body.phi_d[1] = der(Crank3.body.phi[1]);
//   Crank3.body.phi_d[2] = der(Crank3.body.phi[2]);
//   Crank3.body.phi_d[3] = der(Crank3.body.phi[3]);
//   Crank3.body.phi_dd[1] = der(Crank3.body.phi_d[1]);
//   Crank3.body.phi_dd[2] = der(Crank3.body.phi_d[2]);
//   Crank3.body.phi_dd[3] = der(Crank3.body.phi_d[3]);
//   Crank3.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({Crank3.body.sequence_angleStates[1],Crank3.body.sequence_angleStates[2],Crank3.body.sequence_angleStates[3]},{Crank3.body.phi[1],Crank3.body.phi[2],Crank3.body.phi[3]},{Crank3.body.phi_d[1],Crank3.body.phi_d[2],Crank3.body.phi_d[3]});
//   Crank3.body.Q[1] = 0.0;
//   Crank3.body.Q[2] = 0.0;
//   Crank3.body.Q[3] = 0.0;
//   Crank3.body.Q[4] = 1.0;
//   end if;
//   Crank3.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({Crank3.body.frame_a.r_0[1],Crank3.body.frame_a.r_0[2],Crank3.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank3.body.frame_a.R,{Crank3.body.r_CM[1],Crank3.body.r_CM[2],Crank3.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   Crank3.body.v_0[1] = der(Crank3.body.frame_a.r_0[1]);
//   Crank3.body.v_0[2] = der(Crank3.body.frame_a.r_0[2]);
//   Crank3.body.v_0[3] = der(Crank3.body.frame_a.r_0[3]);
//   Crank3.body.a_0[1] = der(Crank3.body.v_0[1]);
//   Crank3.body.a_0[2] = der(Crank3.body.v_0[2]);
//   Crank3.body.a_0[3] = der(Crank3.body.v_0[3]);
//   Crank3.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(Crank3.body.frame_a.R);
//   Crank3.body.z_a[1] = der(Crank3.body.w_a[1]);
//   Crank3.body.z_a[2] = der(Crank3.body.w_a[2]);
//   Crank3.body.z_a[3] = der(Crank3.body.w_a[3]);
//   Crank3.body.frame_a.f = Crank3.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(Crank3.body.frame_a.R,{Crank3.body.a_0[1] - Crank3.body.g_0[1],Crank3.body.a_0[2] - Crank3.body.g_0[2],Crank3.body.a_0[3] - Crank3.body.g_0[3]}) + {Crank3.body.z_a[2] * Crank3.body.r_CM[3] - Crank3.body.z_a[3] * Crank3.body.r_CM[2],Crank3.body.z_a[3] * Crank3.body.r_CM[1] - Crank3.body.z_a[1] * Crank3.body.r_CM[3],Crank3.body.z_a[1] * Crank3.body.r_CM[2] - Crank3.body.z_a[2] * Crank3.body.r_CM[1]} + {Crank3.body.w_a[2] * (Crank3.body.w_a[1] * Crank3.body.r_CM[2] - Crank3.body.w_a[2] * Crank3.body.r_CM[1]) - Crank3.body.w_a[3] * (Crank3.body.w_a[3] * Crank3.body.r_CM[1] - Crank3.body.w_a[1] * Crank3.body.r_CM[3]),Crank3.body.w_a[3] * (Crank3.body.w_a[2] * Crank3.body.r_CM[3] - Crank3.body.w_a[3] * Crank3.body.r_CM[2]) - Crank3.body.w_a[1] * (Crank3.body.w_a[1] * Crank3.body.r_CM[2] - Crank3.body.w_a[2] * Crank3.body.r_CM[1]),Crank3.body.w_a[1] * (Crank3.body.w_a[3] * Crank3.body.r_CM[1] - Crank3.body.w_a[1] * Crank3.body.r_CM[3]) - Crank3.body.w_a[2] * (Crank3.body.w_a[2] * Crank3.body.r_CM[3] - Crank3.body.w_a[3] * Crank3.body.r_CM[2])});
//   Crank3.body.frame_a.t[1] = Crank3.body.I[1,1] * Crank3.body.z_a[1] + (Crank3.body.I[1,2] * Crank3.body.z_a[2] + (Crank3.body.I[1,3] * Crank3.body.z_a[3] + (Crank3.body.w_a[2] * (Crank3.body.I[3,1] * Crank3.body.w_a[1] + (Crank3.body.I[3,2] * Crank3.body.w_a[2] + Crank3.body.I[3,3] * Crank3.body.w_a[3])) + ((-Crank3.body.w_a[3] * (Crank3.body.I[2,1] * Crank3.body.w_a[1] + (Crank3.body.I[2,2] * Crank3.body.w_a[2] + Crank3.body.I[2,3] * Crank3.body.w_a[3]))) + (Crank3.body.r_CM[2] * Crank3.body.frame_a.f[3] + (-Crank3.body.r_CM[3] * Crank3.body.frame_a.f[2]))))));
//   Crank3.body.frame_a.t[2] = Crank3.body.I[2,1] * Crank3.body.z_a[1] + (Crank3.body.I[2,2] * Crank3.body.z_a[2] + (Crank3.body.I[2,3] * Crank3.body.z_a[3] + (Crank3.body.w_a[3] * (Crank3.body.I[1,1] * Crank3.body.w_a[1] + (Crank3.body.I[1,2] * Crank3.body.w_a[2] + Crank3.body.I[1,3] * Crank3.body.w_a[3])) + ((-Crank3.body.w_a[1] * (Crank3.body.I[3,1] * Crank3.body.w_a[1] + (Crank3.body.I[3,2] * Crank3.body.w_a[2] + Crank3.body.I[3,3] * Crank3.body.w_a[3]))) + (Crank3.body.r_CM[3] * Crank3.body.frame_a.f[1] + (-Crank3.body.r_CM[1] * Crank3.body.frame_a.f[3]))))));
//   Crank3.body.frame_a.t[3] = Crank3.body.I[3,1] * Crank3.body.z_a[1] + (Crank3.body.I[3,2] * Crank3.body.z_a[2] + (Crank3.body.I[3,3] * Crank3.body.z_a[3] + (Crank3.body.w_a[1] * (Crank3.body.I[2,1] * Crank3.body.w_a[1] + (Crank3.body.I[2,2] * Crank3.body.w_a[2] + Crank3.body.I[2,3] * Crank3.body.w_a[3])) + ((-Crank3.body.w_a[2] * (Crank3.body.I[1,1] * Crank3.body.w_a[1] + (Crank3.body.I[1,2] * Crank3.body.w_a[2] + Crank3.body.I[1,3] * Crank3.body.w_a[3]))) + (Crank3.body.r_CM[1] * Crank3.body.frame_a.f[2] + (-Crank3.body.r_CM[2] * Crank3.body.frame_a.f[1]))))));
//   Crank3.frameTranslation.shape.R.T[1,1] = Crank3.frameTranslation.frame_a.R.T[1,1];
//   Crank3.frameTranslation.shape.R.T[1,2] = Crank3.frameTranslation.frame_a.R.T[1,2];
//   Crank3.frameTranslation.shape.R.T[1,3] = Crank3.frameTranslation.frame_a.R.T[1,3];
//   Crank3.frameTranslation.shape.R.T[2,1] = Crank3.frameTranslation.frame_a.R.T[2,1];
//   Crank3.frameTranslation.shape.R.T[2,2] = Crank3.frameTranslation.frame_a.R.T[2,2];
//   Crank3.frameTranslation.shape.R.T[2,3] = Crank3.frameTranslation.frame_a.R.T[2,3];
//   Crank3.frameTranslation.shape.R.T[3,1] = Crank3.frameTranslation.frame_a.R.T[3,1];
//   Crank3.frameTranslation.shape.R.T[3,2] = Crank3.frameTranslation.frame_a.R.T[3,2];
//   Crank3.frameTranslation.shape.R.T[3,3] = Crank3.frameTranslation.frame_a.R.T[3,3];
//   Crank3.frameTranslation.shape.R.w[1] = Crank3.frameTranslation.frame_a.R.w[1];
//   Crank3.frameTranslation.shape.R.w[2] = Crank3.frameTranslation.frame_a.R.w[2];
//   Crank3.frameTranslation.shape.R.w[3] = Crank3.frameTranslation.frame_a.R.w[3];
//   Crank3.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Crank3.frameTranslation.shape.shapeType);
//   Crank3.frameTranslation.shape.rxvisobj[1] = Crank3.frameTranslation.shape.R.T[1,1] * Crank3.frameTranslation.shape.e_x[1] + (Crank3.frameTranslation.shape.R.T[2,1] * Crank3.frameTranslation.shape.e_x[2] + Crank3.frameTranslation.shape.R.T[3,1] * Crank3.frameTranslation.shape.e_x[3]);
//   Crank3.frameTranslation.shape.rxvisobj[2] = Crank3.frameTranslation.shape.R.T[1,2] * Crank3.frameTranslation.shape.e_x[1] + (Crank3.frameTranslation.shape.R.T[2,2] * Crank3.frameTranslation.shape.e_x[2] + Crank3.frameTranslation.shape.R.T[3,2] * Crank3.frameTranslation.shape.e_x[3]);
//   Crank3.frameTranslation.shape.rxvisobj[3] = Crank3.frameTranslation.shape.R.T[1,3] * Crank3.frameTranslation.shape.e_x[1] + (Crank3.frameTranslation.shape.R.T[2,3] * Crank3.frameTranslation.shape.e_x[2] + Crank3.frameTranslation.shape.R.T[3,3] * Crank3.frameTranslation.shape.e_x[3]);
//   Crank3.frameTranslation.shape.ryvisobj[1] = Crank3.frameTranslation.shape.R.T[1,1] * Crank3.frameTranslation.shape.e_y[1] + (Crank3.frameTranslation.shape.R.T[2,1] * Crank3.frameTranslation.shape.e_y[2] + Crank3.frameTranslation.shape.R.T[3,1] * Crank3.frameTranslation.shape.e_y[3]);
//   Crank3.frameTranslation.shape.ryvisobj[2] = Crank3.frameTranslation.shape.R.T[1,2] * Crank3.frameTranslation.shape.e_y[1] + (Crank3.frameTranslation.shape.R.T[2,2] * Crank3.frameTranslation.shape.e_y[2] + Crank3.frameTranslation.shape.R.T[3,2] * Crank3.frameTranslation.shape.e_y[3]);
//   Crank3.frameTranslation.shape.ryvisobj[3] = Crank3.frameTranslation.shape.R.T[1,3] * Crank3.frameTranslation.shape.e_y[1] + (Crank3.frameTranslation.shape.R.T[2,3] * Crank3.frameTranslation.shape.e_y[2] + Crank3.frameTranslation.shape.R.T[3,3] * Crank3.frameTranslation.shape.e_y[3]);
//   Crank3.frameTranslation.shape.rvisobj = Crank3.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Crank3.frameTranslation.shape.R.T[1,1],Crank3.frameTranslation.shape.R.T[1,2],Crank3.frameTranslation.shape.R.T[1,3]},{Crank3.frameTranslation.shape.R.T[2,1],Crank3.frameTranslation.shape.R.T[2,2],Crank3.frameTranslation.shape.R.T[2,3]},{Crank3.frameTranslation.shape.R.T[3,1],Crank3.frameTranslation.shape.R.T[3,2],Crank3.frameTranslation.shape.R.T[3,3]}},{Crank3.frameTranslation.shape.r_shape[1],Crank3.frameTranslation.shape.r_shape[2],Crank3.frameTranslation.shape.r_shape[3]});
//   Crank3.frameTranslation.shape.size[1] = Crank3.frameTranslation.shape.length;
//   Crank3.frameTranslation.shape.size[2] = Crank3.frameTranslation.shape.width;
//   Crank3.frameTranslation.shape.size[3] = Crank3.frameTranslation.shape.height;
//   Crank3.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Crank3.frameTranslation.shape.color[1] / 255.0,Crank3.frameTranslation.shape.color[2] / 255.0,Crank3.frameTranslation.shape.color[3] / 255.0,Crank3.frameTranslation.shape.specularCoefficient);
//   Crank3.frameTranslation.shape.Extra = Crank3.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Crank3.frameTranslation.frame_b.r_0 = Crank3.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank3.frameTranslation.frame_a.R,{Crank3.frameTranslation.r[1],Crank3.frameTranslation.r[2],Crank3.frameTranslation.r[3]});
//   Crank3.frameTranslation.frame_b.R.T[1,1] = Crank3.frameTranslation.frame_a.R.T[1,1];
//   Crank3.frameTranslation.frame_b.R.T[1,2] = Crank3.frameTranslation.frame_a.R.T[1,2];
//   Crank3.frameTranslation.frame_b.R.T[1,3] = Crank3.frameTranslation.frame_a.R.T[1,3];
//   Crank3.frameTranslation.frame_b.R.T[2,1] = Crank3.frameTranslation.frame_a.R.T[2,1];
//   Crank3.frameTranslation.frame_b.R.T[2,2] = Crank3.frameTranslation.frame_a.R.T[2,2];
//   Crank3.frameTranslation.frame_b.R.T[2,3] = Crank3.frameTranslation.frame_a.R.T[2,3];
//   Crank3.frameTranslation.frame_b.R.T[3,1] = Crank3.frameTranslation.frame_a.R.T[3,1];
//   Crank3.frameTranslation.frame_b.R.T[3,2] = Crank3.frameTranslation.frame_a.R.T[3,2];
//   Crank3.frameTranslation.frame_b.R.T[3,3] = Crank3.frameTranslation.frame_a.R.T[3,3];
//   Crank3.frameTranslation.frame_b.R.w[1] = Crank3.frameTranslation.frame_a.R.w[1];
//   Crank3.frameTranslation.frame_b.R.w[2] = Crank3.frameTranslation.frame_a.R.w[2];
//   Crank3.frameTranslation.frame_b.R.w[3] = Crank3.frameTranslation.frame_a.R.w[3];
//   0.0 = Crank3.frameTranslation.frame_a.f[1] + Crank3.frameTranslation.frame_b.f[1];
//   0.0 = Crank3.frameTranslation.frame_a.f[2] + Crank3.frameTranslation.frame_b.f[2];
//   0.0 = Crank3.frameTranslation.frame_a.f[3] + Crank3.frameTranslation.frame_b.f[3];
//   0.0 = Crank3.frameTranslation.frame_a.t[1] + (Crank3.frameTranslation.frame_b.t[1] + (Crank3.frameTranslation.r[2] * Crank3.frameTranslation.frame_b.f[3] + (-Crank3.frameTranslation.r[3] * Crank3.frameTranslation.frame_b.f[2])));
//   0.0 = Crank3.frameTranslation.frame_a.t[2] + (Crank3.frameTranslation.frame_b.t[2] + (Crank3.frameTranslation.r[3] * Crank3.frameTranslation.frame_b.f[1] + (-Crank3.frameTranslation.r[1] * Crank3.frameTranslation.frame_b.f[3])));
//   0.0 = Crank3.frameTranslation.frame_a.t[3] + (Crank3.frameTranslation.frame_b.t[3] + (Crank3.frameTranslation.r[1] * Crank3.frameTranslation.frame_b.f[2] + (-Crank3.frameTranslation.r[2] * Crank3.frameTranslation.frame_b.f[1])));
//   Crank3.r_0[1] = Crank3.frame_a.r_0[1];
//   Crank3.r_0[2] = Crank3.frame_a.r_0[2];
//   Crank3.r_0[3] = Crank3.frame_a.r_0[3];
//   Crank3.v_0[1] = der(Crank3.r_0[1]);
//   Crank3.v_0[2] = der(Crank3.r_0[2]);
//   Crank3.v_0[3] = der(Crank3.r_0[3]);
//   Crank3.a_0[1] = der(Crank3.v_0[1]);
//   Crank3.a_0[2] = der(Crank3.v_0[2]);
//   Crank3.a_0[3] = der(Crank3.v_0[3]);
//   assert(Crank3.innerDiameter < Crank3.diameter,\"parameter innerDiameter is greater as parameter diameter.\");
//   Crank1.body.r_0[1] = Crank1.body.frame_a.r_0[1];
//   Crank1.body.r_0[2] = Crank1.body.frame_a.r_0[2];
//   Crank1.body.r_0[3] = Crank1.body.frame_a.r_0[3];
//   if true then
//   Crank1.body.Q[1] = 0.0;
//   Crank1.body.Q[2] = 0.0;
//   Crank1.body.Q[3] = 0.0;
//   Crank1.body.Q[4] = 1.0;
//   Crank1.body.phi[1] = 0.0;
//   Crank1.body.phi[2] = 0.0;
//   Crank1.body.phi[3] = 0.0;
//   Crank1.body.phi_d[1] = 0.0;
//   Crank1.body.phi_d[2] = 0.0;
//   Crank1.body.phi_d[3] = 0.0;
//   Crank1.body.phi_dd[1] = 0.0;
//   Crank1.body.phi_dd[2] = 0.0;
//   Crank1.body.phi_dd[3] = 0.0;
//   elseif Crank1.body.useQuaternions then
//   Crank1.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({Crank1.body.Q[1],Crank1.body.Q[2],Crank1.body.Q[3],Crank1.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({Crank1.body.Q[1],Crank1.body.Q[2],Crank1.body.Q[3],Crank1.body.Q[4]},{der(Crank1.body.Q[1]),der(Crank1.body.Q[2]),der(Crank1.body.Q[3]),der(Crank1.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({Crank1.body.Q[1],Crank1.body.Q[2],Crank1.body.Q[3],Crank1.body.Q[4]});
//   Crank1.body.phi[1] = 0.0;
//   Crank1.body.phi[2] = 0.0;
//   Crank1.body.phi[3] = 0.0;
//   Crank1.body.phi_d[1] = 0.0;
//   Crank1.body.phi_d[2] = 0.0;
//   Crank1.body.phi_d[3] = 0.0;
//   Crank1.body.phi_dd[1] = 0.0;
//   Crank1.body.phi_dd[2] = 0.0;
//   Crank1.body.phi_dd[3] = 0.0;
//   else
//   Crank1.body.phi_d[1] = der(Crank1.body.phi[1]);
//   Crank1.body.phi_d[2] = der(Crank1.body.phi[2]);
//   Crank1.body.phi_d[3] = der(Crank1.body.phi[3]);
//   Crank1.body.phi_dd[1] = der(Crank1.body.phi_d[1]);
//   Crank1.body.phi_dd[2] = der(Crank1.body.phi_d[2]);
//   Crank1.body.phi_dd[3] = der(Crank1.body.phi_d[3]);
//   Crank1.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({Crank1.body.sequence_angleStates[1],Crank1.body.sequence_angleStates[2],Crank1.body.sequence_angleStates[3]},{Crank1.body.phi[1],Crank1.body.phi[2],Crank1.body.phi[3]},{Crank1.body.phi_d[1],Crank1.body.phi_d[2],Crank1.body.phi_d[3]});
//   Crank1.body.Q[1] = 0.0;
//   Crank1.body.Q[2] = 0.0;
//   Crank1.body.Q[3] = 0.0;
//   Crank1.body.Q[4] = 1.0;
//   end if;
//   Crank1.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({Crank1.body.frame_a.r_0[1],Crank1.body.frame_a.r_0[2],Crank1.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank1.body.frame_a.R,{Crank1.body.r_CM[1],Crank1.body.r_CM[2],Crank1.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   Crank1.body.v_0[1] = der(Crank1.body.frame_a.r_0[1]);
//   Crank1.body.v_0[2] = der(Crank1.body.frame_a.r_0[2]);
//   Crank1.body.v_0[3] = der(Crank1.body.frame_a.r_0[3]);
//   Crank1.body.a_0[1] = der(Crank1.body.v_0[1]);
//   Crank1.body.a_0[2] = der(Crank1.body.v_0[2]);
//   Crank1.body.a_0[3] = der(Crank1.body.v_0[3]);
//   Crank1.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(Crank1.body.frame_a.R);
//   Crank1.body.z_a[1] = der(Crank1.body.w_a[1]);
//   Crank1.body.z_a[2] = der(Crank1.body.w_a[2]);
//   Crank1.body.z_a[3] = der(Crank1.body.w_a[3]);
//   Crank1.body.frame_a.f = Crank1.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(Crank1.body.frame_a.R,{Crank1.body.a_0[1] - Crank1.body.g_0[1],Crank1.body.a_0[2] - Crank1.body.g_0[2],Crank1.body.a_0[3] - Crank1.body.g_0[3]}) + {Crank1.body.z_a[2] * Crank1.body.r_CM[3] - Crank1.body.z_a[3] * Crank1.body.r_CM[2],Crank1.body.z_a[3] * Crank1.body.r_CM[1] - Crank1.body.z_a[1] * Crank1.body.r_CM[3],Crank1.body.z_a[1] * Crank1.body.r_CM[2] - Crank1.body.z_a[2] * Crank1.body.r_CM[1]} + {Crank1.body.w_a[2] * (Crank1.body.w_a[1] * Crank1.body.r_CM[2] - Crank1.body.w_a[2] * Crank1.body.r_CM[1]) - Crank1.body.w_a[3] * (Crank1.body.w_a[3] * Crank1.body.r_CM[1] - Crank1.body.w_a[1] * Crank1.body.r_CM[3]),Crank1.body.w_a[3] * (Crank1.body.w_a[2] * Crank1.body.r_CM[3] - Crank1.body.w_a[3] * Crank1.body.r_CM[2]) - Crank1.body.w_a[1] * (Crank1.body.w_a[1] * Crank1.body.r_CM[2] - Crank1.body.w_a[2] * Crank1.body.r_CM[1]),Crank1.body.w_a[1] * (Crank1.body.w_a[3] * Crank1.body.r_CM[1] - Crank1.body.w_a[1] * Crank1.body.r_CM[3]) - Crank1.body.w_a[2] * (Crank1.body.w_a[2] * Crank1.body.r_CM[3] - Crank1.body.w_a[3] * Crank1.body.r_CM[2])});
//   Crank1.body.frame_a.t[1] = Crank1.body.I[1,1] * Crank1.body.z_a[1] + (Crank1.body.I[1,2] * Crank1.body.z_a[2] + (Crank1.body.I[1,3] * Crank1.body.z_a[3] + (Crank1.body.w_a[2] * (Crank1.body.I[3,1] * Crank1.body.w_a[1] + (Crank1.body.I[3,2] * Crank1.body.w_a[2] + Crank1.body.I[3,3] * Crank1.body.w_a[3])) + ((-Crank1.body.w_a[3] * (Crank1.body.I[2,1] * Crank1.body.w_a[1] + (Crank1.body.I[2,2] * Crank1.body.w_a[2] + Crank1.body.I[2,3] * Crank1.body.w_a[3]))) + (Crank1.body.r_CM[2] * Crank1.body.frame_a.f[3] + (-Crank1.body.r_CM[3] * Crank1.body.frame_a.f[2]))))));
//   Crank1.body.frame_a.t[2] = Crank1.body.I[2,1] * Crank1.body.z_a[1] + (Crank1.body.I[2,2] * Crank1.body.z_a[2] + (Crank1.body.I[2,3] * Crank1.body.z_a[3] + (Crank1.body.w_a[3] * (Crank1.body.I[1,1] * Crank1.body.w_a[1] + (Crank1.body.I[1,2] * Crank1.body.w_a[2] + Crank1.body.I[1,3] * Crank1.body.w_a[3])) + ((-Crank1.body.w_a[1] * (Crank1.body.I[3,1] * Crank1.body.w_a[1] + (Crank1.body.I[3,2] * Crank1.body.w_a[2] + Crank1.body.I[3,3] * Crank1.body.w_a[3]))) + (Crank1.body.r_CM[3] * Crank1.body.frame_a.f[1] + (-Crank1.body.r_CM[1] * Crank1.body.frame_a.f[3]))))));
//   Crank1.body.frame_a.t[3] = Crank1.body.I[3,1] * Crank1.body.z_a[1] + (Crank1.body.I[3,2] * Crank1.body.z_a[2] + (Crank1.body.I[3,3] * Crank1.body.z_a[3] + (Crank1.body.w_a[1] * (Crank1.body.I[2,1] * Crank1.body.w_a[1] + (Crank1.body.I[2,2] * Crank1.body.w_a[2] + Crank1.body.I[2,3] * Crank1.body.w_a[3])) + ((-Crank1.body.w_a[2] * (Crank1.body.I[1,1] * Crank1.body.w_a[1] + (Crank1.body.I[1,2] * Crank1.body.w_a[2] + Crank1.body.I[1,3] * Crank1.body.w_a[3]))) + (Crank1.body.r_CM[1] * Crank1.body.frame_a.f[2] + (-Crank1.body.r_CM[2] * Crank1.body.frame_a.f[1]))))));
//   Crank1.frameTranslation.shape.R.T[1,1] = Crank1.frameTranslation.frame_a.R.T[1,1];
//   Crank1.frameTranslation.shape.R.T[1,2] = Crank1.frameTranslation.frame_a.R.T[1,2];
//   Crank1.frameTranslation.shape.R.T[1,3] = Crank1.frameTranslation.frame_a.R.T[1,3];
//   Crank1.frameTranslation.shape.R.T[2,1] = Crank1.frameTranslation.frame_a.R.T[2,1];
//   Crank1.frameTranslation.shape.R.T[2,2] = Crank1.frameTranslation.frame_a.R.T[2,2];
//   Crank1.frameTranslation.shape.R.T[2,3] = Crank1.frameTranslation.frame_a.R.T[2,3];
//   Crank1.frameTranslation.shape.R.T[3,1] = Crank1.frameTranslation.frame_a.R.T[3,1];
//   Crank1.frameTranslation.shape.R.T[3,2] = Crank1.frameTranslation.frame_a.R.T[3,2];
//   Crank1.frameTranslation.shape.R.T[3,3] = Crank1.frameTranslation.frame_a.R.T[3,3];
//   Crank1.frameTranslation.shape.R.w[1] = Crank1.frameTranslation.frame_a.R.w[1];
//   Crank1.frameTranslation.shape.R.w[2] = Crank1.frameTranslation.frame_a.R.w[2];
//   Crank1.frameTranslation.shape.R.w[3] = Crank1.frameTranslation.frame_a.R.w[3];
//   Crank1.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Crank1.frameTranslation.shape.shapeType);
//   Crank1.frameTranslation.shape.rxvisobj[1] = Crank1.frameTranslation.shape.R.T[1,1] * Crank1.frameTranslation.shape.e_x[1] + (Crank1.frameTranslation.shape.R.T[2,1] * Crank1.frameTranslation.shape.e_x[2] + Crank1.frameTranslation.shape.R.T[3,1] * Crank1.frameTranslation.shape.e_x[3]);
//   Crank1.frameTranslation.shape.rxvisobj[2] = Crank1.frameTranslation.shape.R.T[1,2] * Crank1.frameTranslation.shape.e_x[1] + (Crank1.frameTranslation.shape.R.T[2,2] * Crank1.frameTranslation.shape.e_x[2] + Crank1.frameTranslation.shape.R.T[3,2] * Crank1.frameTranslation.shape.e_x[3]);
//   Crank1.frameTranslation.shape.rxvisobj[3] = Crank1.frameTranslation.shape.R.T[1,3] * Crank1.frameTranslation.shape.e_x[1] + (Crank1.frameTranslation.shape.R.T[2,3] * Crank1.frameTranslation.shape.e_x[2] + Crank1.frameTranslation.shape.R.T[3,3] * Crank1.frameTranslation.shape.e_x[3]);
//   Crank1.frameTranslation.shape.ryvisobj[1] = Crank1.frameTranslation.shape.R.T[1,1] * Crank1.frameTranslation.shape.e_y[1] + (Crank1.frameTranslation.shape.R.T[2,1] * Crank1.frameTranslation.shape.e_y[2] + Crank1.frameTranslation.shape.R.T[3,1] * Crank1.frameTranslation.shape.e_y[3]);
//   Crank1.frameTranslation.shape.ryvisobj[2] = Crank1.frameTranslation.shape.R.T[1,2] * Crank1.frameTranslation.shape.e_y[1] + (Crank1.frameTranslation.shape.R.T[2,2] * Crank1.frameTranslation.shape.e_y[2] + Crank1.frameTranslation.shape.R.T[3,2] * Crank1.frameTranslation.shape.e_y[3]);
//   Crank1.frameTranslation.shape.ryvisobj[3] = Crank1.frameTranslation.shape.R.T[1,3] * Crank1.frameTranslation.shape.e_y[1] + (Crank1.frameTranslation.shape.R.T[2,3] * Crank1.frameTranslation.shape.e_y[2] + Crank1.frameTranslation.shape.R.T[3,3] * Crank1.frameTranslation.shape.e_y[3]);
//   Crank1.frameTranslation.shape.rvisobj = Crank1.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Crank1.frameTranslation.shape.R.T[1,1],Crank1.frameTranslation.shape.R.T[1,2],Crank1.frameTranslation.shape.R.T[1,3]},{Crank1.frameTranslation.shape.R.T[2,1],Crank1.frameTranslation.shape.R.T[2,2],Crank1.frameTranslation.shape.R.T[2,3]},{Crank1.frameTranslation.shape.R.T[3,1],Crank1.frameTranslation.shape.R.T[3,2],Crank1.frameTranslation.shape.R.T[3,3]}},{Crank1.frameTranslation.shape.r_shape[1],Crank1.frameTranslation.shape.r_shape[2],Crank1.frameTranslation.shape.r_shape[3]});
//   Crank1.frameTranslation.shape.size[1] = Crank1.frameTranslation.shape.length;
//   Crank1.frameTranslation.shape.size[2] = Crank1.frameTranslation.shape.width;
//   Crank1.frameTranslation.shape.size[3] = Crank1.frameTranslation.shape.height;
//   Crank1.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Crank1.frameTranslation.shape.color[1] / 255.0,Crank1.frameTranslation.shape.color[2] / 255.0,Crank1.frameTranslation.shape.color[3] / 255.0,Crank1.frameTranslation.shape.specularCoefficient);
//   Crank1.frameTranslation.shape.Extra = Crank1.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Crank1.frameTranslation.frame_b.r_0 = Crank1.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank1.frameTranslation.frame_a.R,{Crank1.frameTranslation.r[1],Crank1.frameTranslation.r[2],Crank1.frameTranslation.r[3]});
//   Crank1.frameTranslation.frame_b.R.T[1,1] = Crank1.frameTranslation.frame_a.R.T[1,1];
//   Crank1.frameTranslation.frame_b.R.T[1,2] = Crank1.frameTranslation.frame_a.R.T[1,2];
//   Crank1.frameTranslation.frame_b.R.T[1,3] = Crank1.frameTranslation.frame_a.R.T[1,3];
//   Crank1.frameTranslation.frame_b.R.T[2,1] = Crank1.frameTranslation.frame_a.R.T[2,1];
//   Crank1.frameTranslation.frame_b.R.T[2,2] = Crank1.frameTranslation.frame_a.R.T[2,2];
//   Crank1.frameTranslation.frame_b.R.T[2,3] = Crank1.frameTranslation.frame_a.R.T[2,3];
//   Crank1.frameTranslation.frame_b.R.T[3,1] = Crank1.frameTranslation.frame_a.R.T[3,1];
//   Crank1.frameTranslation.frame_b.R.T[3,2] = Crank1.frameTranslation.frame_a.R.T[3,2];
//   Crank1.frameTranslation.frame_b.R.T[3,3] = Crank1.frameTranslation.frame_a.R.T[3,3];
//   Crank1.frameTranslation.frame_b.R.w[1] = Crank1.frameTranslation.frame_a.R.w[1];
//   Crank1.frameTranslation.frame_b.R.w[2] = Crank1.frameTranslation.frame_a.R.w[2];
//   Crank1.frameTranslation.frame_b.R.w[3] = Crank1.frameTranslation.frame_a.R.w[3];
//   0.0 = Crank1.frameTranslation.frame_a.f[1] + Crank1.frameTranslation.frame_b.f[1];
//   0.0 = Crank1.frameTranslation.frame_a.f[2] + Crank1.frameTranslation.frame_b.f[2];
//   0.0 = Crank1.frameTranslation.frame_a.f[3] + Crank1.frameTranslation.frame_b.f[3];
//   0.0 = Crank1.frameTranslation.frame_a.t[1] + (Crank1.frameTranslation.frame_b.t[1] + (Crank1.frameTranslation.r[2] * Crank1.frameTranslation.frame_b.f[3] + (-Crank1.frameTranslation.r[3] * Crank1.frameTranslation.frame_b.f[2])));
//   0.0 = Crank1.frameTranslation.frame_a.t[2] + (Crank1.frameTranslation.frame_b.t[2] + (Crank1.frameTranslation.r[3] * Crank1.frameTranslation.frame_b.f[1] + (-Crank1.frameTranslation.r[1] * Crank1.frameTranslation.frame_b.f[3])));
//   0.0 = Crank1.frameTranslation.frame_a.t[3] + (Crank1.frameTranslation.frame_b.t[3] + (Crank1.frameTranslation.r[1] * Crank1.frameTranslation.frame_b.f[2] + (-Crank1.frameTranslation.r[2] * Crank1.frameTranslation.frame_b.f[1])));
//   Crank1.r_0[1] = Crank1.frame_a.r_0[1];
//   Crank1.r_0[2] = Crank1.frame_a.r_0[2];
//   Crank1.r_0[3] = Crank1.frame_a.r_0[3];
//   Crank1.v_0[1] = der(Crank1.r_0[1]);
//   Crank1.v_0[2] = der(Crank1.r_0[2]);
//   Crank1.v_0[3] = der(Crank1.r_0[3]);
//   Crank1.a_0[1] = der(Crank1.v_0[1]);
//   Crank1.a_0[2] = der(Crank1.v_0[2]);
//   Crank1.a_0[3] = der(Crank1.v_0[3]);
//   assert(Crank1.innerDiameter < Crank1.diameter,\"parameter innerDiameter is greater as parameter diameter.\");
//   Crank2.body.r_0[1] = Crank2.body.frame_a.r_0[1];
//   Crank2.body.r_0[2] = Crank2.body.frame_a.r_0[2];
//   Crank2.body.r_0[3] = Crank2.body.frame_a.r_0[3];
//   if true then
//   Crank2.body.Q[1] = 0.0;
//   Crank2.body.Q[2] = 0.0;
//   Crank2.body.Q[3] = 0.0;
//   Crank2.body.Q[4] = 1.0;
//   Crank2.body.phi[1] = 0.0;
//   Crank2.body.phi[2] = 0.0;
//   Crank2.body.phi[3] = 0.0;
//   Crank2.body.phi_d[1] = 0.0;
//   Crank2.body.phi_d[2] = 0.0;
//   Crank2.body.phi_d[3] = 0.0;
//   Crank2.body.phi_dd[1] = 0.0;
//   Crank2.body.phi_dd[2] = 0.0;
//   Crank2.body.phi_dd[3] = 0.0;
//   elseif Crank2.body.useQuaternions then
//   Crank2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({Crank2.body.Q[1],Crank2.body.Q[2],Crank2.body.Q[3],Crank2.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({Crank2.body.Q[1],Crank2.body.Q[2],Crank2.body.Q[3],Crank2.body.Q[4]},{der(Crank2.body.Q[1]),der(Crank2.body.Q[2]),der(Crank2.body.Q[3]),der(Crank2.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({Crank2.body.Q[1],Crank2.body.Q[2],Crank2.body.Q[3],Crank2.body.Q[4]});
//   Crank2.body.phi[1] = 0.0;
//   Crank2.body.phi[2] = 0.0;
//   Crank2.body.phi[3] = 0.0;
//   Crank2.body.phi_d[1] = 0.0;
//   Crank2.body.phi_d[2] = 0.0;
//   Crank2.body.phi_d[3] = 0.0;
//   Crank2.body.phi_dd[1] = 0.0;
//   Crank2.body.phi_dd[2] = 0.0;
//   Crank2.body.phi_dd[3] = 0.0;
//   else
//   Crank2.body.phi_d[1] = der(Crank2.body.phi[1]);
//   Crank2.body.phi_d[2] = der(Crank2.body.phi[2]);
//   Crank2.body.phi_d[3] = der(Crank2.body.phi[3]);
//   Crank2.body.phi_dd[1] = der(Crank2.body.phi_d[1]);
//   Crank2.body.phi_dd[2] = der(Crank2.body.phi_d[2]);
//   Crank2.body.phi_dd[3] = der(Crank2.body.phi_d[3]);
//   Crank2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({Crank2.body.sequence_angleStates[1],Crank2.body.sequence_angleStates[2],Crank2.body.sequence_angleStates[3]},{Crank2.body.phi[1],Crank2.body.phi[2],Crank2.body.phi[3]},{Crank2.body.phi_d[1],Crank2.body.phi_d[2],Crank2.body.phi_d[3]});
//   Crank2.body.Q[1] = 0.0;
//   Crank2.body.Q[2] = 0.0;
//   Crank2.body.Q[3] = 0.0;
//   Crank2.body.Q[4] = 1.0;
//   end if;
//   Crank2.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({Crank2.body.frame_a.r_0[1],Crank2.body.frame_a.r_0[2],Crank2.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank2.body.frame_a.R,{Crank2.body.r_CM[1],Crank2.body.r_CM[2],Crank2.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   Crank2.body.v_0[1] = der(Crank2.body.frame_a.r_0[1]);
//   Crank2.body.v_0[2] = der(Crank2.body.frame_a.r_0[2]);
//   Crank2.body.v_0[3] = der(Crank2.body.frame_a.r_0[3]);
//   Crank2.body.a_0[1] = der(Crank2.body.v_0[1]);
//   Crank2.body.a_0[2] = der(Crank2.body.v_0[2]);
//   Crank2.body.a_0[3] = der(Crank2.body.v_0[3]);
//   Crank2.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(Crank2.body.frame_a.R);
//   Crank2.body.z_a[1] = der(Crank2.body.w_a[1]);
//   Crank2.body.z_a[2] = der(Crank2.body.w_a[2]);
//   Crank2.body.z_a[3] = der(Crank2.body.w_a[3]);
//   Crank2.body.frame_a.f = Crank2.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(Crank2.body.frame_a.R,{Crank2.body.a_0[1] - Crank2.body.g_0[1],Crank2.body.a_0[2] - Crank2.body.g_0[2],Crank2.body.a_0[3] - Crank2.body.g_0[3]}) + {Crank2.body.z_a[2] * Crank2.body.r_CM[3] - Crank2.body.z_a[3] * Crank2.body.r_CM[2],Crank2.body.z_a[3] * Crank2.body.r_CM[1] - Crank2.body.z_a[1] * Crank2.body.r_CM[3],Crank2.body.z_a[1] * Crank2.body.r_CM[2] - Crank2.body.z_a[2] * Crank2.body.r_CM[1]} + {Crank2.body.w_a[2] * (Crank2.body.w_a[1] * Crank2.body.r_CM[2] - Crank2.body.w_a[2] * Crank2.body.r_CM[1]) - Crank2.body.w_a[3] * (Crank2.body.w_a[3] * Crank2.body.r_CM[1] - Crank2.body.w_a[1] * Crank2.body.r_CM[3]),Crank2.body.w_a[3] * (Crank2.body.w_a[2] * Crank2.body.r_CM[3] - Crank2.body.w_a[3] * Crank2.body.r_CM[2]) - Crank2.body.w_a[1] * (Crank2.body.w_a[1] * Crank2.body.r_CM[2] - Crank2.body.w_a[2] * Crank2.body.r_CM[1]),Crank2.body.w_a[1] * (Crank2.body.w_a[3] * Crank2.body.r_CM[1] - Crank2.body.w_a[1] * Crank2.body.r_CM[3]) - Crank2.body.w_a[2] * (Crank2.body.w_a[2] * Crank2.body.r_CM[3] - Crank2.body.w_a[3] * Crank2.body.r_CM[2])});
//   Crank2.body.frame_a.t[1] = Crank2.body.I[1,1] * Crank2.body.z_a[1] + (Crank2.body.I[1,2] * Crank2.body.z_a[2] + (Crank2.body.I[1,3] * Crank2.body.z_a[3] + (Crank2.body.w_a[2] * (Crank2.body.I[3,1] * Crank2.body.w_a[1] + (Crank2.body.I[3,2] * Crank2.body.w_a[2] + Crank2.body.I[3,3] * Crank2.body.w_a[3])) + ((-Crank2.body.w_a[3] * (Crank2.body.I[2,1] * Crank2.body.w_a[1] + (Crank2.body.I[2,2] * Crank2.body.w_a[2] + Crank2.body.I[2,3] * Crank2.body.w_a[3]))) + (Crank2.body.r_CM[2] * Crank2.body.frame_a.f[3] + (-Crank2.body.r_CM[3] * Crank2.body.frame_a.f[2]))))));
//   Crank2.body.frame_a.t[2] = Crank2.body.I[2,1] * Crank2.body.z_a[1] + (Crank2.body.I[2,2] * Crank2.body.z_a[2] + (Crank2.body.I[2,3] * Crank2.body.z_a[3] + (Crank2.body.w_a[3] * (Crank2.body.I[1,1] * Crank2.body.w_a[1] + (Crank2.body.I[1,2] * Crank2.body.w_a[2] + Crank2.body.I[1,3] * Crank2.body.w_a[3])) + ((-Crank2.body.w_a[1] * (Crank2.body.I[3,1] * Crank2.body.w_a[1] + (Crank2.body.I[3,2] * Crank2.body.w_a[2] + Crank2.body.I[3,3] * Crank2.body.w_a[3]))) + (Crank2.body.r_CM[3] * Crank2.body.frame_a.f[1] + (-Crank2.body.r_CM[1] * Crank2.body.frame_a.f[3]))))));
//   Crank2.body.frame_a.t[3] = Crank2.body.I[3,1] * Crank2.body.z_a[1] + (Crank2.body.I[3,2] * Crank2.body.z_a[2] + (Crank2.body.I[3,3] * Crank2.body.z_a[3] + (Crank2.body.w_a[1] * (Crank2.body.I[2,1] * Crank2.body.w_a[1] + (Crank2.body.I[2,2] * Crank2.body.w_a[2] + Crank2.body.I[2,3] * Crank2.body.w_a[3])) + ((-Crank2.body.w_a[2] * (Crank2.body.I[1,1] * Crank2.body.w_a[1] + (Crank2.body.I[1,2] * Crank2.body.w_a[2] + Crank2.body.I[1,3] * Crank2.body.w_a[3]))) + (Crank2.body.r_CM[1] * Crank2.body.frame_a.f[2] + (-Crank2.body.r_CM[2] * Crank2.body.frame_a.f[1]))))));
//   Crank2.frameTranslation.shape.R.T[1,1] = Crank2.frameTranslation.frame_a.R.T[1,1];
//   Crank2.frameTranslation.shape.R.T[1,2] = Crank2.frameTranslation.frame_a.R.T[1,2];
//   Crank2.frameTranslation.shape.R.T[1,3] = Crank2.frameTranslation.frame_a.R.T[1,3];
//   Crank2.frameTranslation.shape.R.T[2,1] = Crank2.frameTranslation.frame_a.R.T[2,1];
//   Crank2.frameTranslation.shape.R.T[2,2] = Crank2.frameTranslation.frame_a.R.T[2,2];
//   Crank2.frameTranslation.shape.R.T[2,3] = Crank2.frameTranslation.frame_a.R.T[2,3];
//   Crank2.frameTranslation.shape.R.T[3,1] = Crank2.frameTranslation.frame_a.R.T[3,1];
//   Crank2.frameTranslation.shape.R.T[3,2] = Crank2.frameTranslation.frame_a.R.T[3,2];
//   Crank2.frameTranslation.shape.R.T[3,3] = Crank2.frameTranslation.frame_a.R.T[3,3];
//   Crank2.frameTranslation.shape.R.w[1] = Crank2.frameTranslation.frame_a.R.w[1];
//   Crank2.frameTranslation.shape.R.w[2] = Crank2.frameTranslation.frame_a.R.w[2];
//   Crank2.frameTranslation.shape.R.w[3] = Crank2.frameTranslation.frame_a.R.w[3];
//   Crank2.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Crank2.frameTranslation.shape.shapeType);
//   Crank2.frameTranslation.shape.rxvisobj[1] = Crank2.frameTranslation.shape.R.T[1,1] * Crank2.frameTranslation.shape.e_x[1] + (Crank2.frameTranslation.shape.R.T[2,1] * Crank2.frameTranslation.shape.e_x[2] + Crank2.frameTranslation.shape.R.T[3,1] * Crank2.frameTranslation.shape.e_x[3]);
//   Crank2.frameTranslation.shape.rxvisobj[2] = Crank2.frameTranslation.shape.R.T[1,2] * Crank2.frameTranslation.shape.e_x[1] + (Crank2.frameTranslation.shape.R.T[2,2] * Crank2.frameTranslation.shape.e_x[2] + Crank2.frameTranslation.shape.R.T[3,2] * Crank2.frameTranslation.shape.e_x[3]);
//   Crank2.frameTranslation.shape.rxvisobj[3] = Crank2.frameTranslation.shape.R.T[1,3] * Crank2.frameTranslation.shape.e_x[1] + (Crank2.frameTranslation.shape.R.T[2,3] * Crank2.frameTranslation.shape.e_x[2] + Crank2.frameTranslation.shape.R.T[3,3] * Crank2.frameTranslation.shape.e_x[3]);
//   Crank2.frameTranslation.shape.ryvisobj[1] = Crank2.frameTranslation.shape.R.T[1,1] * Crank2.frameTranslation.shape.e_y[1] + (Crank2.frameTranslation.shape.R.T[2,1] * Crank2.frameTranslation.shape.e_y[2] + Crank2.frameTranslation.shape.R.T[3,1] * Crank2.frameTranslation.shape.e_y[3]);
//   Crank2.frameTranslation.shape.ryvisobj[2] = Crank2.frameTranslation.shape.R.T[1,2] * Crank2.frameTranslation.shape.e_y[1] + (Crank2.frameTranslation.shape.R.T[2,2] * Crank2.frameTranslation.shape.e_y[2] + Crank2.frameTranslation.shape.R.T[3,2] * Crank2.frameTranslation.shape.e_y[3]);
//   Crank2.frameTranslation.shape.ryvisobj[3] = Crank2.frameTranslation.shape.R.T[1,3] * Crank2.frameTranslation.shape.e_y[1] + (Crank2.frameTranslation.shape.R.T[2,3] * Crank2.frameTranslation.shape.e_y[2] + Crank2.frameTranslation.shape.R.T[3,3] * Crank2.frameTranslation.shape.e_y[3]);
//   Crank2.frameTranslation.shape.rvisobj = Crank2.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Crank2.frameTranslation.shape.R.T[1,1],Crank2.frameTranslation.shape.R.T[1,2],Crank2.frameTranslation.shape.R.T[1,3]},{Crank2.frameTranslation.shape.R.T[2,1],Crank2.frameTranslation.shape.R.T[2,2],Crank2.frameTranslation.shape.R.T[2,3]},{Crank2.frameTranslation.shape.R.T[3,1],Crank2.frameTranslation.shape.R.T[3,2],Crank2.frameTranslation.shape.R.T[3,3]}},{Crank2.frameTranslation.shape.r_shape[1],Crank2.frameTranslation.shape.r_shape[2],Crank2.frameTranslation.shape.r_shape[3]});
//   Crank2.frameTranslation.shape.size[1] = Crank2.frameTranslation.shape.length;
//   Crank2.frameTranslation.shape.size[2] = Crank2.frameTranslation.shape.width;
//   Crank2.frameTranslation.shape.size[3] = Crank2.frameTranslation.shape.height;
//   Crank2.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Crank2.frameTranslation.shape.color[1] / 255.0,Crank2.frameTranslation.shape.color[2] / 255.0,Crank2.frameTranslation.shape.color[3] / 255.0,Crank2.frameTranslation.shape.specularCoefficient);
//   Crank2.frameTranslation.shape.Extra = Crank2.frameTranslation.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Crank2.frameTranslation.frame_b.r_0 = Crank2.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Crank2.frameTranslation.frame_a.R,{Crank2.frameTranslation.r[1],Crank2.frameTranslation.r[2],Crank2.frameTranslation.r[3]});
//   Crank2.frameTranslation.frame_b.R.T[1,1] = Crank2.frameTranslation.frame_a.R.T[1,1];
//   Crank2.frameTranslation.frame_b.R.T[1,2] = Crank2.frameTranslation.frame_a.R.T[1,2];
//   Crank2.frameTranslation.frame_b.R.T[1,3] = Crank2.frameTranslation.frame_a.R.T[1,3];
//   Crank2.frameTranslation.frame_b.R.T[2,1] = Crank2.frameTranslation.frame_a.R.T[2,1];
//   Crank2.frameTranslation.frame_b.R.T[2,2] = Crank2.frameTranslation.frame_a.R.T[2,2];
//   Crank2.frameTranslation.frame_b.R.T[2,3] = Crank2.frameTranslation.frame_a.R.T[2,3];
//   Crank2.frameTranslation.frame_b.R.T[3,1] = Crank2.frameTranslation.frame_a.R.T[3,1];
//   Crank2.frameTranslation.frame_b.R.T[3,2] = Crank2.frameTranslation.frame_a.R.T[3,2];
//   Crank2.frameTranslation.frame_b.R.T[3,3] = Crank2.frameTranslation.frame_a.R.T[3,3];
//   Crank2.frameTranslation.frame_b.R.w[1] = Crank2.frameTranslation.frame_a.R.w[1];
//   Crank2.frameTranslation.frame_b.R.w[2] = Crank2.frameTranslation.frame_a.R.w[2];
//   Crank2.frameTranslation.frame_b.R.w[3] = Crank2.frameTranslation.frame_a.R.w[3];
//   0.0 = Crank2.frameTranslation.frame_a.f[1] + Crank2.frameTranslation.frame_b.f[1];
//   0.0 = Crank2.frameTranslation.frame_a.f[2] + Crank2.frameTranslation.frame_b.f[2];
//   0.0 = Crank2.frameTranslation.frame_a.f[3] + Crank2.frameTranslation.frame_b.f[3];
//   0.0 = Crank2.frameTranslation.frame_a.t[1] + (Crank2.frameTranslation.frame_b.t[1] + (Crank2.frameTranslation.r[2] * Crank2.frameTranslation.frame_b.f[3] + (-Crank2.frameTranslation.r[3] * Crank2.frameTranslation.frame_b.f[2])));
//   0.0 = Crank2.frameTranslation.frame_a.t[2] + (Crank2.frameTranslation.frame_b.t[2] + (Crank2.frameTranslation.r[3] * Crank2.frameTranslation.frame_b.f[1] + (-Crank2.frameTranslation.r[1] * Crank2.frameTranslation.frame_b.f[3])));
//   0.0 = Crank2.frameTranslation.frame_a.t[3] + (Crank2.frameTranslation.frame_b.t[3] + (Crank2.frameTranslation.r[1] * Crank2.frameTranslation.frame_b.f[2] + (-Crank2.frameTranslation.r[2] * Crank2.frameTranslation.frame_b.f[1])));
//   Crank2.r_0[1] = Crank2.frame_a.r_0[1];
//   Crank2.r_0[2] = Crank2.frame_a.r_0[2];
//   Crank2.r_0[3] = Crank2.frame_a.r_0[3];
//   Crank2.v_0[1] = der(Crank2.r_0[1]);
//   Crank2.v_0[2] = der(Crank2.r_0[2]);
//   Crank2.v_0[3] = der(Crank2.r_0[3]);
//   Crank2.a_0[1] = der(Crank2.v_0[1]);
//   Crank2.a_0[2] = der(Crank2.v_0[2]);
//   Crank2.a_0[3] = der(Crank2.v_0[3]);
//   assert(Crank2.innerWidth <= Crank2.width,\"parameter innerWidth is greater as parameter width\");
//   assert(Crank2.innerHeight <= Crank2.height,\"parameter innerHeight is greater as paraemter height\");
//   Mid.shape.R.T[1,1] = Mid.frame_a.R.T[1,1];
//   Mid.shape.R.T[1,2] = Mid.frame_a.R.T[1,2];
//   Mid.shape.R.T[1,3] = Mid.frame_a.R.T[1,3];
//   Mid.shape.R.T[2,1] = Mid.frame_a.R.T[2,1];
//   Mid.shape.R.T[2,2] = Mid.frame_a.R.T[2,2];
//   Mid.shape.R.T[2,3] = Mid.frame_a.R.T[2,3];
//   Mid.shape.R.T[3,1] = Mid.frame_a.R.T[3,1];
//   Mid.shape.R.T[3,2] = Mid.frame_a.R.T[3,2];
//   Mid.shape.R.T[3,3] = Mid.frame_a.R.T[3,3];
//   Mid.shape.R.w[1] = Mid.frame_a.R.w[1];
//   Mid.shape.R.w[2] = Mid.frame_a.R.w[2];
//   Mid.shape.R.w[3] = Mid.frame_a.R.w[3];
//   Mid.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Mid.shape.shapeType);
//   Mid.shape.rxvisobj[1] = Mid.shape.R.T[1,1] * Mid.shape.e_x[1] + (Mid.shape.R.T[2,1] * Mid.shape.e_x[2] + Mid.shape.R.T[3,1] * Mid.shape.e_x[3]);
//   Mid.shape.rxvisobj[2] = Mid.shape.R.T[1,2] * Mid.shape.e_x[1] + (Mid.shape.R.T[2,2] * Mid.shape.e_x[2] + Mid.shape.R.T[3,2] * Mid.shape.e_x[3]);
//   Mid.shape.rxvisobj[3] = Mid.shape.R.T[1,3] * Mid.shape.e_x[1] + (Mid.shape.R.T[2,3] * Mid.shape.e_x[2] + Mid.shape.R.T[3,3] * Mid.shape.e_x[3]);
//   Mid.shape.ryvisobj[1] = Mid.shape.R.T[1,1] * Mid.shape.e_y[1] + (Mid.shape.R.T[2,1] * Mid.shape.e_y[2] + Mid.shape.R.T[3,1] * Mid.shape.e_y[3]);
//   Mid.shape.ryvisobj[2] = Mid.shape.R.T[1,2] * Mid.shape.e_y[1] + (Mid.shape.R.T[2,2] * Mid.shape.e_y[2] + Mid.shape.R.T[3,2] * Mid.shape.e_y[3]);
//   Mid.shape.ryvisobj[3] = Mid.shape.R.T[1,3] * Mid.shape.e_y[1] + (Mid.shape.R.T[2,3] * Mid.shape.e_y[2] + Mid.shape.R.T[3,3] * Mid.shape.e_y[3]);
//   Mid.shape.rvisobj = Mid.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Mid.shape.R.T[1,1],Mid.shape.R.T[1,2],Mid.shape.R.T[1,3]},{Mid.shape.R.T[2,1],Mid.shape.R.T[2,2],Mid.shape.R.T[2,3]},{Mid.shape.R.T[3,1],Mid.shape.R.T[3,2],Mid.shape.R.T[3,3]}},{Mid.shape.r_shape[1],Mid.shape.r_shape[2],Mid.shape.r_shape[3]});
//   Mid.shape.size[1] = Mid.shape.length;
//   Mid.shape.size[2] = Mid.shape.width;
//   Mid.shape.size[3] = Mid.shape.height;
//   Mid.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Mid.shape.color[1] / 255.0,Mid.shape.color[2] / 255.0,Mid.shape.color[3] / 255.0,Mid.shape.specularCoefficient);
//   Mid.shape.Extra = Mid.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Mid.frame_b.r_0 = Mid.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Mid.frame_a.R,{Mid.r[1],Mid.r[2],Mid.r[3]});
//   Mid.frame_b.R.T[1,1] = Mid.frame_a.R.T[1,1];
//   Mid.frame_b.R.T[1,2] = Mid.frame_a.R.T[1,2];
//   Mid.frame_b.R.T[1,3] = Mid.frame_a.R.T[1,3];
//   Mid.frame_b.R.T[2,1] = Mid.frame_a.R.T[2,1];
//   Mid.frame_b.R.T[2,2] = Mid.frame_a.R.T[2,2];
//   Mid.frame_b.R.T[2,3] = Mid.frame_a.R.T[2,3];
//   Mid.frame_b.R.T[3,1] = Mid.frame_a.R.T[3,1];
//   Mid.frame_b.R.T[3,2] = Mid.frame_a.R.T[3,2];
//   Mid.frame_b.R.T[3,3] = Mid.frame_a.R.T[3,3];
//   Mid.frame_b.R.w[1] = Mid.frame_a.R.w[1];
//   Mid.frame_b.R.w[2] = Mid.frame_a.R.w[2];
//   Mid.frame_b.R.w[3] = Mid.frame_a.R.w[3];
//   0.0 = Mid.frame_a.f[1] + Mid.frame_b.f[1];
//   0.0 = Mid.frame_a.f[2] + Mid.frame_b.f[2];
//   0.0 = Mid.frame_a.f[3] + Mid.frame_b.f[3];
//   0.0 = Mid.frame_a.t[1] + (Mid.frame_b.t[1] + (Mid.r[2] * Mid.frame_b.f[3] + (-Mid.r[3] * Mid.frame_b.f[2])));
//   0.0 = Mid.frame_a.t[2] + (Mid.frame_b.t[2] + (Mid.r[3] * Mid.frame_b.f[1] + (-Mid.r[1] * Mid.frame_b.f[3])));
//   0.0 = Mid.frame_a.t[3] + (Mid.frame_b.t[3] + (Mid.r[1] * Mid.frame_b.f[2] + (-Mid.r[2] * Mid.frame_b.f[1])));
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   cylPosition.frame_b.r_0 = cylPosition.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(cylPosition.frame_a.R,{cylPosition.r[1],cylPosition.r[2],cylPosition.r[3]});
//   cylPosition.frame_b.R.T[1,1] = cylPosition.frame_a.R.T[1,1];
//   cylPosition.frame_b.R.T[1,2] = cylPosition.frame_a.R.T[1,2];
//   cylPosition.frame_b.R.T[1,3] = cylPosition.frame_a.R.T[1,3];
//   cylPosition.frame_b.R.T[2,1] = cylPosition.frame_a.R.T[2,1];
//   cylPosition.frame_b.R.T[2,2] = cylPosition.frame_a.R.T[2,2];
//   cylPosition.frame_b.R.T[2,3] = cylPosition.frame_a.R.T[2,3];
//   cylPosition.frame_b.R.T[3,1] = cylPosition.frame_a.R.T[3,1];
//   cylPosition.frame_b.R.T[3,2] = cylPosition.frame_a.R.T[3,2];
//   cylPosition.frame_b.R.T[3,3] = cylPosition.frame_a.R.T[3,3];
//   cylPosition.frame_b.R.w[1] = cylPosition.frame_a.R.w[1];
//   cylPosition.frame_b.R.w[2] = cylPosition.frame_a.R.w[2];
//   cylPosition.frame_b.R.w[3] = cylPosition.frame_a.R.w[3];
//   0.0 = cylPosition.frame_a.f[1] + cylPosition.frame_b.f[1];
//   0.0 = cylPosition.frame_a.f[2] + cylPosition.frame_b.f[2];
//   0.0 = cylPosition.frame_a.f[3] + cylPosition.frame_b.f[3];
//   0.0 = cylPosition.frame_a.t[1] + (cylPosition.frame_b.t[1] + (cylPosition.r[2] * cylPosition.frame_b.f[3] + (-cylPosition.r[3] * cylPosition.frame_b.f[2])));
//   0.0 = cylPosition.frame_a.t[2] + (cylPosition.frame_b.t[2] + (cylPosition.r[3] * cylPosition.frame_b.f[1] + (-cylPosition.r[1] * cylPosition.frame_b.f[3])));
//   0.0 = cylPosition.frame_a.t[3] + (cylPosition.frame_b.t[3] + (cylPosition.r[1] * cylPosition.frame_b.f[2] + (-cylPosition.r[2] * cylPosition.frame_b.f[1])));
//   gasForce.x = 1.0 - gasForce.s_rel / gasForce.L;
//   gasForce.v_rel = der(gasForce.s_rel);
//   gasForce.press = 100000.0 * (if gasForce.v_rel < 0.0 then if gasForce.x < 0.987 then 2.4 + (177.4132 * gasForce.x ^ 4.0 + (-287.2189 * gasForce.x ^ 3.0 + (151.8252 * gasForce.x ^ 2.0 + -24.9973 * gasForce.x))) else 2129670.0 + (2836360.0 * gasForce.x ^ 4.0 + (-10569296.0 * gasForce.x ^ 3.0 + (14761814.0 * gasForce.x ^ 2.0 + -9158505.0 * gasForce.x))) else if gasForce.x > 0.93 then -3929704.0 * gasForce.x ^ 4.0 + (14748765.0 * gasForce.x ^ 3.0 + (-20747000.0 * gasForce.x ^ 2.0 + 12964477.0 * gasForce.x)) - 3036495.0 else 2.4 + (145.93 * gasForce.x ^ 4.0 + (-131.707 * gasForce.x ^ 3.0 + (17.3438 * gasForce.x ^ 2.0 + 17.9272 * gasForce.x))));
//   gasForce.f = -0.785398163397448 * (gasForce.press * gasForce.d ^ 2.0);
//   gasForce.V = gasForce.k0 + gasForce.k1 * (1.0 - gasForce.x);
//   gasForce.dens = gasForce.press * 1.0 / gasForce.T / gasForce.R_air;
//   gasForce.press * gasForce.V = gasForce.k * gasForce.T;
//   assert(gasForce.s_rel >= -1e-12,\"flange_b.s - flange_a.s (= \" + String(gasForce.s_rel,0,true,6) + \") >= 0 required for GasForce component.
// \" + \"Most likely, the component has to be flipped.\");
//   assert(gasForce.s_rel <= 1e-12 + gasForce.L,\" flange_b.s - flange_a.s (= \" + String(gasForce.s_rel,0,true,6) + \" <= L (\" + String(gasForce.L,0,true,6) + \") required for GasForce component.
// \" + \"Most likely, parameter L is not correct.\");
//   gasForce.s_rel = gasForce.flange_b.s - gasForce.flange_a.s;
//   gasForce.flange_b.f = gasForce.f;
//   gasForce.flange_a.f = -gasForce.f;
//   B2.cylinder.R.T[1,1] = B2.frame_a.R.T[1,1];
//   B2.cylinder.R.T[1,2] = B2.frame_a.R.T[1,2];
//   B2.cylinder.R.T[1,3] = B2.frame_a.R.T[1,3];
//   B2.cylinder.R.T[2,1] = B2.frame_a.R.T[2,1];
//   B2.cylinder.R.T[2,2] = B2.frame_a.R.T[2,2];
//   B2.cylinder.R.T[2,3] = B2.frame_a.R.T[2,3];
//   B2.cylinder.R.T[3,1] = B2.frame_a.R.T[3,1];
//   B2.cylinder.R.T[3,2] = B2.frame_a.R.T[3,2];
//   B2.cylinder.R.T[3,3] = B2.frame_a.R.T[3,3];
//   B2.cylinder.R.w[1] = B2.frame_a.R.w[1];
//   B2.cylinder.R.w[2] = B2.frame_a.R.w[2];
//   B2.cylinder.R.w[3] = B2.frame_a.R.w[3];
//   B2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(B2.cylinder.shapeType);
//   B2.cylinder.rxvisobj[1] = B2.cylinder.R.T[1,1] * B2.cylinder.e_x[1] + (B2.cylinder.R.T[2,1] * B2.cylinder.e_x[2] + B2.cylinder.R.T[3,1] * B2.cylinder.e_x[3]);
//   B2.cylinder.rxvisobj[2] = B2.cylinder.R.T[1,2] * B2.cylinder.e_x[1] + (B2.cylinder.R.T[2,2] * B2.cylinder.e_x[2] + B2.cylinder.R.T[3,2] * B2.cylinder.e_x[3]);
//   B2.cylinder.rxvisobj[3] = B2.cylinder.R.T[1,3] * B2.cylinder.e_x[1] + (B2.cylinder.R.T[2,3] * B2.cylinder.e_x[2] + B2.cylinder.R.T[3,3] * B2.cylinder.e_x[3]);
//   B2.cylinder.ryvisobj[1] = B2.cylinder.R.T[1,1] * B2.cylinder.e_y[1] + (B2.cylinder.R.T[2,1] * B2.cylinder.e_y[2] + B2.cylinder.R.T[3,1] * B2.cylinder.e_y[3]);
//   B2.cylinder.ryvisobj[2] = B2.cylinder.R.T[1,2] * B2.cylinder.e_y[1] + (B2.cylinder.R.T[2,2] * B2.cylinder.e_y[2] + B2.cylinder.R.T[3,2] * B2.cylinder.e_y[3]);
//   B2.cylinder.ryvisobj[3] = B2.cylinder.R.T[1,3] * B2.cylinder.e_y[1] + (B2.cylinder.R.T[2,3] * B2.cylinder.e_y[2] + B2.cylinder.R.T[3,3] * B2.cylinder.e_y[3]);
//   B2.cylinder.rvisobj = B2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{B2.cylinder.R.T[1,1],B2.cylinder.R.T[1,2],B2.cylinder.R.T[1,3]},{B2.cylinder.R.T[2,1],B2.cylinder.R.T[2,2],B2.cylinder.R.T[2,3]},{B2.cylinder.R.T[3,1],B2.cylinder.R.T[3,2],B2.cylinder.R.T[3,3]}},{B2.cylinder.r_shape[1],B2.cylinder.r_shape[2],B2.cylinder.r_shape[3]});
//   B2.cylinder.size[1] = B2.cylinder.length;
//   B2.cylinder.size[2] = B2.cylinder.width;
//   B2.cylinder.size[3] = B2.cylinder.height;
//   B2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(B2.cylinder.color[1] / 255.0,B2.cylinder.color[2] / 255.0,B2.cylinder.color[3] / 255.0,B2.cylinder.specularCoefficient);
//   B2.cylinder.Extra = B2.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   B2.R_rel = Modelica.Mechanics.MultiBody.Frames.relativeRotation(B2.frame_a.R,B2.frame_b.R);
//   B2.r_rel_a = Modelica.Mechanics.MultiBody.Frames.resolve2(B2.frame_a.R,{B2.frame_b.r_0[1] - B2.frame_a.r_0[1],B2.frame_b.r_0[2] - B2.frame_a.r_0[2],B2.frame_b.r_0[3] - B2.frame_a.r_0[3]});
//   0.0 = B2.ex_a[1] * B2.r_rel_a[1] + (B2.ex_a[2] * B2.r_rel_a[2] + B2.ex_a[3] * B2.r_rel_a[3]);
//   0.0 = B2.ey_a[1] * B2.r_rel_a[1] + (B2.ey_a[2] * B2.r_rel_a[2] + B2.ey_a[3] * B2.r_rel_a[3]);
//   B2.frame_a.t[1] = 0.0;
//   B2.frame_a.t[2] = 0.0;
//   B2.frame_a.t[3] = 0.0;
//   B2.frame_b.t[1] = 0.0;
//   B2.frame_b.t[2] = 0.0;
//   B2.frame_b.t[3] = 0.0;
//   B2.frame_a.f[1] = B2.ex_a[1] * B2.f_c[1] + B2.ey_a[1] * B2.f_c[2];
//   B2.frame_a.f[2] = B2.ex_a[2] * B2.f_c[1] + B2.ey_a[2] * B2.f_c[2];
//   B2.frame_a.f[3] = B2.ex_a[3] * B2.f_c[1] + B2.ey_a[3] * B2.f_c[2];
//   B2.frame_b.f = -Modelica.Mechanics.MultiBody.Frames.resolve2(B2.R_rel,{B2.frame_a.f[1],B2.frame_a.f[2],B2.frame_a.f[3]});
//   B2.ex_b = Modelica.Mechanics.MultiBody.Frames.resolve2(B2.R_rel,{B2.ex_a[1],B2.ex_a[2],B2.ex_a[3]});
//   B2.ey_b = Modelica.Mechanics.MultiBody.Frames.resolve2(B2.R_rel,{B2.ey_a[1],B2.ey_a[2],B2.ey_a[3]});
//   assert(noEvent(abs(B2.e[1] * B2.r_rel_a[1] + (B2.e[2] * B2.r_rel_a[2] + B2.e[3] * B2.r_rel_a[3])) <= 1e-10) AND noEvent(abs(B2.e[1] * B2.ex_b[1] + (B2.e[2] * B2.ex_b[2] + B2.e[3] * B2.ex_b[3])) <= 1e-10) AND noEvent(abs(B2.e[1] * B2.ey_b[1] + (B2.e[2] * B2.ey_b[2] + B2.e[3] * B2.ey_b[3])) <= 1e-10),\"
// The MultiBody.Joints.RevolutePlanarLoopConstraint joint is used as cut-joint of a
// planar loop. However, the revolute joint is not part of a planar loop where the
// axis of the revolute joint (parameter n) is orthogonal to the possible movements.
// Either use instead joint MultiBody.Joints.Revolute or correct the
// definition of the axes vectors n in the revolute joints of the planar loop.
// \");
//   B1.fixed.flange.phi = B1.fixed.phi0;
//   B1.internalAxis.flange.tau = B1.internalAxis.tau;
//   B1.internalAxis.flange.phi = B1.internalAxis.phi;
//   B1.cylinder.R.T[1,1] = B1.frame_a.R.T[1,1];
//   B1.cylinder.R.T[1,2] = B1.frame_a.R.T[1,2];
//   B1.cylinder.R.T[1,3] = B1.frame_a.R.T[1,3];
//   B1.cylinder.R.T[2,1] = B1.frame_a.R.T[2,1];
//   B1.cylinder.R.T[2,2] = B1.frame_a.R.T[2,2];
//   B1.cylinder.R.T[2,3] = B1.frame_a.R.T[2,3];
//   B1.cylinder.R.T[3,1] = B1.frame_a.R.T[3,1];
//   B1.cylinder.R.T[3,2] = B1.frame_a.R.T[3,2];
//   B1.cylinder.R.T[3,3] = B1.frame_a.R.T[3,3];
//   B1.cylinder.R.w[1] = B1.frame_a.R.w[1];
//   B1.cylinder.R.w[2] = B1.frame_a.R.w[2];
//   B1.cylinder.R.w[3] = B1.frame_a.R.w[3];
//   B1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(B1.cylinder.shapeType);
//   B1.cylinder.rxvisobj[1] = B1.cylinder.R.T[1,1] * B1.cylinder.e_x[1] + (B1.cylinder.R.T[2,1] * B1.cylinder.e_x[2] + B1.cylinder.R.T[3,1] * B1.cylinder.e_x[3]);
//   B1.cylinder.rxvisobj[2] = B1.cylinder.R.T[1,2] * B1.cylinder.e_x[1] + (B1.cylinder.R.T[2,2] * B1.cylinder.e_x[2] + B1.cylinder.R.T[3,2] * B1.cylinder.e_x[3]);
//   B1.cylinder.rxvisobj[3] = B1.cylinder.R.T[1,3] * B1.cylinder.e_x[1] + (B1.cylinder.R.T[2,3] * B1.cylinder.e_x[2] + B1.cylinder.R.T[3,3] * B1.cylinder.e_x[3]);
//   B1.cylinder.ryvisobj[1] = B1.cylinder.R.T[1,1] * B1.cylinder.e_y[1] + (B1.cylinder.R.T[2,1] * B1.cylinder.e_y[2] + B1.cylinder.R.T[3,1] * B1.cylinder.e_y[3]);
//   B1.cylinder.ryvisobj[2] = B1.cylinder.R.T[1,2] * B1.cylinder.e_y[1] + (B1.cylinder.R.T[2,2] * B1.cylinder.e_y[2] + B1.cylinder.R.T[3,2] * B1.cylinder.e_y[3]);
//   B1.cylinder.ryvisobj[3] = B1.cylinder.R.T[1,3] * B1.cylinder.e_y[1] + (B1.cylinder.R.T[2,3] * B1.cylinder.e_y[2] + B1.cylinder.R.T[3,3] * B1.cylinder.e_y[3]);
//   B1.cylinder.rvisobj = B1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{B1.cylinder.R.T[1,1],B1.cylinder.R.T[1,2],B1.cylinder.R.T[1,3]},{B1.cylinder.R.T[2,1],B1.cylinder.R.T[2,2],B1.cylinder.R.T[2,3]},{B1.cylinder.R.T[3,1],B1.cylinder.R.T[3,2],B1.cylinder.R.T[3,3]}},{B1.cylinder.r_shape[1],B1.cylinder.r_shape[2],B1.cylinder.r_shape[3]});
//   B1.cylinder.size[1] = B1.cylinder.length;
//   B1.cylinder.size[2] = B1.cylinder.width;
//   B1.cylinder.size[3] = B1.cylinder.height;
//   B1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(B1.cylinder.color[1] / 255.0,B1.cylinder.color[2] / 255.0,B1.cylinder.color[3] / 255.0,B1.cylinder.specularCoefficient);
//   B1.cylinder.Extra = B1.cylinder.extra;
//   B1.constantTorque.tau = -B1.constantTorque.flange.tau;
//   B1.constantTorque.tau = B1.constantTorque.tau_constant;
//   B1.constantTorque.phi = B1.constantTorque.flange.phi - B1.constantTorque.phi_support;
//   B1.constantTorque.phi_support = 0.0;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   B1.angle = B1.phi;
//   B1.w = der(B1.phi);
//   B1.a = der(B1.w);
//   B1.frame_b.r_0[1] = B1.frame_a.r_0[1];
//   B1.frame_b.r_0[2] = B1.frame_a.r_0[2];
//   B1.frame_b.r_0[3] = B1.frame_a.r_0[3];
//   B1.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({B1.e[1],B1.e[2],B1.e[3]},B1.phi,B1.w);
//   B1.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(B1.frame_a.R,B1.R_rel);
//   B1.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(B1.R_rel,{B1.frame_b.f[1],B1.frame_b.f[2],B1.frame_b.f[3]});
//   B1.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(B1.R_rel,{B1.frame_b.t[1],B1.frame_b.t[2],B1.frame_b.t[3]});
//   B1.tau = (-B1.frame_b.t[1]) * B1.e[1] + ((-B1.frame_b.t[2]) * B1.e[2] + (-B1.frame_b.t[3]) * B1.e[3]);
//   B1.phi = B1.internalAxis.phi;
//   Cylinder.fixed.flange.s = Cylinder.fixed.s0;
//   Cylinder.internalAxis.flange.f = Cylinder.internalAxis.f;
//   Cylinder.internalAxis.flange.s = Cylinder.internalAxis.s;
//   Cylinder.box.R.T[1,1] = Cylinder.frame_a.R.T[1,1];
//   Cylinder.box.R.T[1,2] = Cylinder.frame_a.R.T[1,2];
//   Cylinder.box.R.T[1,3] = Cylinder.frame_a.R.T[1,3];
//   Cylinder.box.R.T[2,1] = Cylinder.frame_a.R.T[2,1];
//   Cylinder.box.R.T[2,2] = Cylinder.frame_a.R.T[2,2];
//   Cylinder.box.R.T[2,3] = Cylinder.frame_a.R.T[2,3];
//   Cylinder.box.R.T[3,1] = Cylinder.frame_a.R.T[3,1];
//   Cylinder.box.R.T[3,2] = Cylinder.frame_a.R.T[3,2];
//   Cylinder.box.R.T[3,3] = Cylinder.frame_a.R.T[3,3];
//   Cylinder.box.R.w[1] = Cylinder.frame_a.R.w[1];
//   Cylinder.box.R.w[2] = Cylinder.frame_a.R.w[2];
//   Cylinder.box.R.w[3] = Cylinder.frame_a.R.w[3];
//   Cylinder.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(Cylinder.box.shapeType);
//   Cylinder.box.rxvisobj[1] = Cylinder.box.R.T[1,1] * Cylinder.box.e_x[1] + (Cylinder.box.R.T[2,1] * Cylinder.box.e_x[2] + Cylinder.box.R.T[3,1] * Cylinder.box.e_x[3]);
//   Cylinder.box.rxvisobj[2] = Cylinder.box.R.T[1,2] * Cylinder.box.e_x[1] + (Cylinder.box.R.T[2,2] * Cylinder.box.e_x[2] + Cylinder.box.R.T[3,2] * Cylinder.box.e_x[3]);
//   Cylinder.box.rxvisobj[3] = Cylinder.box.R.T[1,3] * Cylinder.box.e_x[1] + (Cylinder.box.R.T[2,3] * Cylinder.box.e_x[2] + Cylinder.box.R.T[3,3] * Cylinder.box.e_x[3]);
//   Cylinder.box.ryvisobj[1] = Cylinder.box.R.T[1,1] * Cylinder.box.e_y[1] + (Cylinder.box.R.T[2,1] * Cylinder.box.e_y[2] + Cylinder.box.R.T[3,1] * Cylinder.box.e_y[3]);
//   Cylinder.box.ryvisobj[2] = Cylinder.box.R.T[1,2] * Cylinder.box.e_y[1] + (Cylinder.box.R.T[2,2] * Cylinder.box.e_y[2] + Cylinder.box.R.T[3,2] * Cylinder.box.e_y[3]);
//   Cylinder.box.ryvisobj[3] = Cylinder.box.R.T[1,3] * Cylinder.box.e_y[1] + (Cylinder.box.R.T[2,3] * Cylinder.box.e_y[2] + Cylinder.box.R.T[3,3] * Cylinder.box.e_y[3]);
//   Cylinder.box.rvisobj = Cylinder.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{Cylinder.box.R.T[1,1],Cylinder.box.R.T[1,2],Cylinder.box.R.T[1,3]},{Cylinder.box.R.T[2,1],Cylinder.box.R.T[2,2],Cylinder.box.R.T[2,3]},{Cylinder.box.R.T[3,1],Cylinder.box.R.T[3,2],Cylinder.box.R.T[3,3]}},{Cylinder.box.r_shape[1],Cylinder.box.r_shape[2],Cylinder.box.r_shape[3]});
//   Cylinder.box.size[1] = Cylinder.box.length;
//   Cylinder.box.size[2] = Cylinder.box.width;
//   Cylinder.box.size[3] = Cylinder.box.height;
//   Cylinder.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(Cylinder.box.color[1] / 255.0,Cylinder.box.color[2] / 255.0,Cylinder.box.color[3] / 255.0,Cylinder.box.specularCoefficient);
//   Cylinder.box.Extra = Cylinder.box.extra;
//   Cylinder.v = der(Cylinder.s);
//   Cylinder.a = der(Cylinder.v);
//   Cylinder.frame_b.r_0 = Cylinder.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Cylinder.frame_a.R,{Cylinder.s * Cylinder.e[1],Cylinder.s * Cylinder.e[2],Cylinder.s * Cylinder.e[3]});
//   Cylinder.frame_b.R.T[1,1] = Cylinder.frame_a.R.T[1,1];
//   Cylinder.frame_b.R.T[1,2] = Cylinder.frame_a.R.T[1,2];
//   Cylinder.frame_b.R.T[1,3] = Cylinder.frame_a.R.T[1,3];
//   Cylinder.frame_b.R.T[2,1] = Cylinder.frame_a.R.T[2,1];
//   Cylinder.frame_b.R.T[2,2] = Cylinder.frame_a.R.T[2,2];
//   Cylinder.frame_b.R.T[2,3] = Cylinder.frame_a.R.T[2,3];
//   Cylinder.frame_b.R.T[3,1] = Cylinder.frame_a.R.T[3,1];
//   Cylinder.frame_b.R.T[3,2] = Cylinder.frame_a.R.T[3,2];
//   Cylinder.frame_b.R.T[3,3] = Cylinder.frame_a.R.T[3,3];
//   Cylinder.frame_b.R.w[1] = Cylinder.frame_a.R.w[1];
//   Cylinder.frame_b.R.w[2] = Cylinder.frame_a.R.w[2];
//   Cylinder.frame_b.R.w[3] = Cylinder.frame_a.R.w[3];
//   0.0 = Cylinder.frame_a.f[1] + Cylinder.frame_b.f[1];
//   0.0 = Cylinder.frame_a.f[2] + Cylinder.frame_b.f[2];
//   0.0 = Cylinder.frame_a.f[3] + Cylinder.frame_b.f[3];
//   0.0 = Cylinder.frame_a.t[1] + (Cylinder.frame_b.t[1] + (Cylinder.s * (Cylinder.e[2] * Cylinder.frame_b.f[3]) + (-Cylinder.s * (Cylinder.e[3] * Cylinder.frame_b.f[2]))));
//   0.0 = Cylinder.frame_a.t[2] + (Cylinder.frame_b.t[2] + (Cylinder.s * (Cylinder.e[3] * Cylinder.frame_b.f[1]) + (-Cylinder.s * (Cylinder.e[1] * Cylinder.frame_b.f[3]))));
//   0.0 = Cylinder.frame_a.t[3] + (Cylinder.frame_b.t[3] + (Cylinder.s * (Cylinder.e[1] * Cylinder.frame_b.f[2]) + (-Cylinder.s * (Cylinder.e[2] * Cylinder.frame_b.f[1]))));
//   Cylinder.f = (-Cylinder.e[1]) * Cylinder.frame_b.f[1] + ((-Cylinder.e[2]) * Cylinder.frame_b.f[2] + (-Cylinder.e[3]) * Cylinder.frame_b.f[3]);
//   Cylinder.s = Cylinder.internalAxis.s;
//   assert(true,\"Connector frame_a of joint object is not connected\");
//   assert(true,\"Connector frame_b of joint object is not connected\");
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Rod1.frame_b.r_0 = Rod1.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Rod1.frame_a.R,{Rod1.r[1],Rod1.r[2],Rod1.r[3]});
//   Rod1.frame_b.R.T[1,1] = Rod1.frame_a.R.T[1,1];
//   Rod1.frame_b.R.T[1,2] = Rod1.frame_a.R.T[1,2];
//   Rod1.frame_b.R.T[1,3] = Rod1.frame_a.R.T[1,3];
//   Rod1.frame_b.R.T[2,1] = Rod1.frame_a.R.T[2,1];
//   Rod1.frame_b.R.T[2,2] = Rod1.frame_a.R.T[2,2];
//   Rod1.frame_b.R.T[2,3] = Rod1.frame_a.R.T[2,3];
//   Rod1.frame_b.R.T[3,1] = Rod1.frame_a.R.T[3,1];
//   Rod1.frame_b.R.T[3,2] = Rod1.frame_a.R.T[3,2];
//   Rod1.frame_b.R.T[3,3] = Rod1.frame_a.R.T[3,3];
//   Rod1.frame_b.R.w[1] = Rod1.frame_a.R.w[1];
//   Rod1.frame_b.R.w[2] = Rod1.frame_a.R.w[2];
//   Rod1.frame_b.R.w[3] = Rod1.frame_a.R.w[3];
//   0.0 = Rod1.frame_a.f[1] + Rod1.frame_b.f[1];
//   0.0 = Rod1.frame_a.f[2] + Rod1.frame_b.f[2];
//   0.0 = Rod1.frame_a.f[3] + Rod1.frame_b.f[3];
//   0.0 = Rod1.frame_a.t[1] + (Rod1.frame_b.t[1] + (Rod1.r[2] * Rod1.frame_b.f[3] + (-Rod1.r[3] * Rod1.frame_b.f[2])));
//   0.0 = Rod1.frame_a.t[2] + (Rod1.frame_b.t[2] + (Rod1.r[3] * Rod1.frame_b.f[1] + (-Rod1.r[1] * Rod1.frame_b.f[3])));
//   0.0 = Rod1.frame_a.t[3] + (Rod1.frame_b.t[3] + (Rod1.r[1] * Rod1.frame_b.f[2] + (-Rod1.r[2] * Rod1.frame_b.f[1])));
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   Rod3.frame_b.r_0 = Rod3.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(Rod3.frame_a.R,{Rod3.r[1],Rod3.r[2],Rod3.r[3]});
//   Rod3.frame_b.R.T[1,1] = Rod3.frame_a.R.T[1,1];
//   Rod3.frame_b.R.T[1,2] = Rod3.frame_a.R.T[1,2];
//   Rod3.frame_b.R.T[1,3] = Rod3.frame_a.R.T[1,3];
//   Rod3.frame_b.R.T[2,1] = Rod3.frame_a.R.T[2,1];
//   Rod3.frame_b.R.T[2,2] = Rod3.frame_a.R.T[2,2];
//   Rod3.frame_b.R.T[2,3] = Rod3.frame_a.R.T[2,3];
//   Rod3.frame_b.R.T[3,1] = Rod3.frame_a.R.T[3,1];
//   Rod3.frame_b.R.T[3,2] = Rod3.frame_a.R.T[3,2];
//   Rod3.frame_b.R.T[3,3] = Rod3.frame_a.R.T[3,3];
//   Rod3.frame_b.R.w[1] = Rod3.frame_a.R.w[1];
//   Rod3.frame_b.R.w[2] = Rod3.frame_a.R.w[2];
//   Rod3.frame_b.R.w[3] = Rod3.frame_a.R.w[3];
//   0.0 = Rod3.frame_a.f[1] + Rod3.frame_b.f[1];
//   0.0 = Rod3.frame_a.f[2] + Rod3.frame_b.f[2];
//   0.0 = Rod3.frame_a.f[3] + Rod3.frame_b.f[3];
//   0.0 = Rod3.frame_a.t[1] + (Rod3.frame_b.t[1] + (Rod3.r[2] * Rod3.frame_b.f[3] + (-Rod3.r[3] * Rod3.frame_b.f[2])));
//   0.0 = Rod3.frame_a.t[2] + (Rod3.frame_b.t[2] + (Rod3.r[3] * Rod3.frame_b.f[1] + (-Rod3.r[1] * Rod3.frame_b.f[3])));
//   0.0 = Rod3.frame_a.t[3] + (Rod3.frame_b.t[3] + (Rod3.r[1] * Rod3.frame_b.f[2] + (-Rod3.r[2] * Rod3.frame_b.f[1])));
//   Mid.frame_a.t[1] + (Crank2.frame_b.t[1] + Crank3.frame_a.t[1]) = 0.0;
//   Mid.frame_a.t[2] + (Crank2.frame_b.t[2] + Crank3.frame_a.t[2]) = 0.0;
//   Mid.frame_a.t[3] + (Crank2.frame_b.t[3] + Crank3.frame_a.t[3]) = 0.0;
//   Mid.frame_a.f[1] + (Crank2.frame_b.f[1] + Crank3.frame_a.f[1]) = 0.0;
//   Mid.frame_a.f[2] + (Crank2.frame_b.f[2] + Crank3.frame_a.f[2]) = 0.0;
//   Mid.frame_a.f[3] + (Crank2.frame_b.f[3] + Crank3.frame_a.f[3]) = 0.0;
//   Crank2.frame_b.R.w[1] = Crank3.frame_a.R.w[1];
//   Crank2.frame_b.R.w[1] = Mid.frame_a.R.w[1];
//   Crank2.frame_b.R.w[2] = Crank3.frame_a.R.w[2];
//   Crank2.frame_b.R.w[2] = Mid.frame_a.R.w[2];
//   Crank2.frame_b.R.w[3] = Crank3.frame_a.R.w[3];
//   Crank2.frame_b.R.w[3] = Mid.frame_a.R.w[3];
//   Crank2.frame_b.R.T[1,1] = Crank3.frame_a.R.T[1,1];
//   Crank2.frame_b.R.T[1,1] = Mid.frame_a.R.T[1,1];
//   Crank2.frame_b.R.T[1,2] = Crank3.frame_a.R.T[1,2];
//   Crank2.frame_b.R.T[1,2] = Mid.frame_a.R.T[1,2];
//   Crank2.frame_b.R.T[1,3] = Crank3.frame_a.R.T[1,3];
//   Crank2.frame_b.R.T[1,3] = Mid.frame_a.R.T[1,3];
//   Crank2.frame_b.R.T[2,1] = Crank3.frame_a.R.T[2,1];
//   Crank2.frame_b.R.T[2,1] = Mid.frame_a.R.T[2,1];
//   Crank2.frame_b.R.T[2,2] = Crank3.frame_a.R.T[2,2];
//   Crank2.frame_b.R.T[2,2] = Mid.frame_a.R.T[2,2];
//   Crank2.frame_b.R.T[2,3] = Crank3.frame_a.R.T[2,3];
//   Crank2.frame_b.R.T[2,3] = Mid.frame_a.R.T[2,3];
//   Crank2.frame_b.R.T[3,1] = Crank3.frame_a.R.T[3,1];
//   Crank2.frame_b.R.T[3,1] = Mid.frame_a.R.T[3,1];
//   Crank2.frame_b.R.T[3,2] = Crank3.frame_a.R.T[3,2];
//   Crank2.frame_b.R.T[3,2] = Mid.frame_a.R.T[3,2];
//   Crank2.frame_b.R.T[3,3] = Crank3.frame_a.R.T[3,3];
//   Crank2.frame_b.R.T[3,3] = Mid.frame_a.R.T[3,3];
//   Crank2.frame_b.r_0[1] = Crank3.frame_a.r_0[1];
//   Crank2.frame_b.r_0[1] = Mid.frame_a.r_0[1];
//   Crank2.frame_b.r_0[2] = Crank3.frame_a.r_0[2];
//   Crank2.frame_b.r_0[2] = Mid.frame_a.r_0[2];
//   Crank2.frame_b.r_0[3] = Crank3.frame_a.r_0[3];
//   Crank2.frame_b.r_0[3] = Mid.frame_a.r_0[3];
//   Inertia.flange_b.tau + Bearing.axis.tau = 0.0;
//   Bearing.axis.phi = Inertia.flange_b.phi;
//   Crank3.frame_b.t[1] + Crank4.frame_a.t[1] = 0.0;
//   Crank3.frame_b.t[2] + Crank4.frame_a.t[2] = 0.0;
//   Crank3.frame_b.t[3] + Crank4.frame_a.t[3] = 0.0;
//   Crank3.frame_b.f[1] + Crank4.frame_a.f[1] = 0.0;
//   Crank3.frame_b.f[2] + Crank4.frame_a.f[2] = 0.0;
//   Crank3.frame_b.f[3] + Crank4.frame_a.f[3] = 0.0;
//   Crank3.frame_b.R.w[1] = Crank4.frame_a.R.w[1];
//   Crank3.frame_b.R.w[2] = Crank4.frame_a.R.w[2];
//   Crank3.frame_b.R.w[3] = Crank4.frame_a.R.w[3];
//   Crank3.frame_b.R.T[1,1] = Crank4.frame_a.R.T[1,1];
//   Crank3.frame_b.R.T[1,2] = Crank4.frame_a.R.T[1,2];
//   Crank3.frame_b.R.T[1,3] = Crank4.frame_a.R.T[1,3];
//   Crank3.frame_b.R.T[2,1] = Crank4.frame_a.R.T[2,1];
//   Crank3.frame_b.R.T[2,2] = Crank4.frame_a.R.T[2,2];
//   Crank3.frame_b.R.T[2,3] = Crank4.frame_a.R.T[2,3];
//   Crank3.frame_b.R.T[3,1] = Crank4.frame_a.R.T[3,1];
//   Crank3.frame_b.R.T[3,2] = Crank4.frame_a.R.T[3,2];
//   Crank3.frame_b.R.T[3,3] = Crank4.frame_a.R.T[3,3];
//   Crank3.frame_b.r_0[1] = Crank4.frame_a.r_0[1];
//   Crank3.frame_b.r_0[2] = Crank4.frame_a.r_0[2];
//   Crank3.frame_b.r_0[3] = Crank4.frame_a.r_0[3];
//   world.frame_b.t[1] + (Bearing.frame_a.t[1] + cylPosition.frame_a.t[1]) = 0.0;
//   world.frame_b.t[2] + (Bearing.frame_a.t[2] + cylPosition.frame_a.t[2]) = 0.0;
//   world.frame_b.t[3] + (Bearing.frame_a.t[3] + cylPosition.frame_a.t[3]) = 0.0;
//   world.frame_b.f[1] + (Bearing.frame_a.f[1] + cylPosition.frame_a.f[1]) = 0.0;
//   world.frame_b.f[2] + (Bearing.frame_a.f[2] + cylPosition.frame_a.f[2]) = 0.0;
//   world.frame_b.f[3] + (Bearing.frame_a.f[3] + cylPosition.frame_a.f[3]) = 0.0;
//   Bearing.frame_a.R.w[1] = cylPosition.frame_a.R.w[1];
//   Bearing.frame_a.R.w[1] = world.frame_b.R.w[1];
//   Bearing.frame_a.R.w[2] = cylPosition.frame_a.R.w[2];
//   Bearing.frame_a.R.w[2] = world.frame_b.R.w[2];
//   Bearing.frame_a.R.w[3] = cylPosition.frame_a.R.w[3];
//   Bearing.frame_a.R.w[3] = world.frame_b.R.w[3];
//   Bearing.frame_a.R.T[1,1] = cylPosition.frame_a.R.T[1,1];
//   Bearing.frame_a.R.T[1,1] = world.frame_b.R.T[1,1];
//   Bearing.frame_a.R.T[1,2] = cylPosition.frame_a.R.T[1,2];
//   Bearing.frame_a.R.T[1,2] = world.frame_b.R.T[1,2];
//   Bearing.frame_a.R.T[1,3] = cylPosition.frame_a.R.T[1,3];
//   Bearing.frame_a.R.T[1,3] = world.frame_b.R.T[1,3];
//   Bearing.frame_a.R.T[2,1] = cylPosition.frame_a.R.T[2,1];
//   Bearing.frame_a.R.T[2,1] = world.frame_b.R.T[2,1];
//   Bearing.frame_a.R.T[2,2] = cylPosition.frame_a.R.T[2,2];
//   Bearing.frame_a.R.T[2,2] = world.frame_b.R.T[2,2];
//   Bearing.frame_a.R.T[2,3] = cylPosition.frame_a.R.T[2,3];
//   Bearing.frame_a.R.T[2,3] = world.frame_b.R.T[2,3];
//   Bearing.frame_a.R.T[3,1] = cylPosition.frame_a.R.T[3,1];
//   Bearing.frame_a.R.T[3,1] = world.frame_b.R.T[3,1];
//   Bearing.frame_a.R.T[3,2] = cylPosition.frame_a.R.T[3,2];
//   Bearing.frame_a.R.T[3,2] = world.frame_b.R.T[3,2];
//   Bearing.frame_a.R.T[3,3] = cylPosition.frame_a.R.T[3,3];
//   Bearing.frame_a.R.T[3,3] = world.frame_b.R.T[3,3];
//   Bearing.frame_a.r_0[1] = cylPosition.frame_a.r_0[1];
//   Bearing.frame_a.r_0[1] = world.frame_b.r_0[1];
//   Bearing.frame_a.r_0[2] = cylPosition.frame_a.r_0[2];
//   Bearing.frame_a.r_0[2] = world.frame_b.r_0[2];
//   Bearing.frame_a.r_0[3] = cylPosition.frame_a.r_0[3];
//   Bearing.frame_a.r_0[3] = world.frame_b.r_0[3];
//   Bearing.frame_b.t[1] + Crank1.frame_a.t[1] = 0.0;
//   Bearing.frame_b.t[2] + Crank1.frame_a.t[2] = 0.0;
//   Bearing.frame_b.t[3] + Crank1.frame_a.t[3] = 0.0;
//   Bearing.frame_b.f[1] + Crank1.frame_a.f[1] = 0.0;
//   Bearing.frame_b.f[2] + Crank1.frame_a.f[2] = 0.0;
//   Bearing.frame_b.f[3] + Crank1.frame_a.f[3] = 0.0;
//   Bearing.frame_b.R.w[1] = Crank1.frame_a.R.w[1];
//   Bearing.frame_b.R.w[2] = Crank1.frame_a.R.w[2];
//   Bearing.frame_b.R.w[3] = Crank1.frame_a.R.w[3];
//   Bearing.frame_b.R.T[1,1] = Crank1.frame_a.R.T[1,1];
//   Bearing.frame_b.R.T[1,2] = Crank1.frame_a.R.T[1,2];
//   Bearing.frame_b.R.T[1,3] = Crank1.frame_a.R.T[1,3];
//   Bearing.frame_b.R.T[2,1] = Crank1.frame_a.R.T[2,1];
//   Bearing.frame_b.R.T[2,2] = Crank1.frame_a.R.T[2,2];
//   Bearing.frame_b.R.T[2,3] = Crank1.frame_a.R.T[2,3];
//   Bearing.frame_b.R.T[3,1] = Crank1.frame_a.R.T[3,1];
//   Bearing.frame_b.R.T[3,2] = Crank1.frame_a.R.T[3,2];
//   Bearing.frame_b.R.T[3,3] = Crank1.frame_a.R.T[3,3];
//   Bearing.frame_b.r_0[1] = Crank1.frame_a.r_0[1];
//   Bearing.frame_b.r_0[2] = Crank1.frame_a.r_0[2];
//   Bearing.frame_b.r_0[3] = Crank1.frame_a.r_0[3];
//   Crank2.frame_a.t[1] + Crank1.frame_b.t[1] = 0.0;
//   Crank2.frame_a.t[2] + Crank1.frame_b.t[2] = 0.0;
//   Crank2.frame_a.t[3] + Crank1.frame_b.t[3] = 0.0;
//   Crank2.frame_a.f[1] + Crank1.frame_b.f[1] = 0.0;
//   Crank2.frame_a.f[2] + Crank1.frame_b.f[2] = 0.0;
//   Crank2.frame_a.f[3] + Crank1.frame_b.f[3] = 0.0;
//   Crank1.frame_b.R.w[1] = Crank2.frame_a.R.w[1];
//   Crank1.frame_b.R.w[2] = Crank2.frame_a.R.w[2];
//   Crank1.frame_b.R.w[3] = Crank2.frame_a.R.w[3];
//   Crank1.frame_b.R.T[1,1] = Crank2.frame_a.R.T[1,1];
//   Crank1.frame_b.R.T[1,2] = Crank2.frame_a.R.T[1,2];
//   Crank1.frame_b.R.T[1,3] = Crank2.frame_a.R.T[1,3];
//   Crank1.frame_b.R.T[2,1] = Crank2.frame_a.R.T[2,1];
//   Crank1.frame_b.R.T[2,2] = Crank2.frame_a.R.T[2,2];
//   Crank1.frame_b.R.T[2,3] = Crank2.frame_a.R.T[2,3];
//   Crank1.frame_b.R.T[3,1] = Crank2.frame_a.R.T[3,1];
//   Crank1.frame_b.R.T[3,2] = Crank2.frame_a.R.T[3,2];
//   Crank1.frame_b.R.T[3,3] = Crank2.frame_a.R.T[3,3];
//   Crank1.frame_b.r_0[1] = Crank2.frame_a.r_0[1];
//   Crank1.frame_b.r_0[2] = Crank2.frame_a.r_0[2];
//   Crank1.frame_b.r_0[3] = Crank2.frame_a.r_0[3];
//   Mid.frame_b.t[1] + B1.frame_a.t[1] = 0.0;
//   Mid.frame_b.t[2] + B1.frame_a.t[2] = 0.0;
//   Mid.frame_b.t[3] + B1.frame_a.t[3] = 0.0;
//   Mid.frame_b.f[1] + B1.frame_a.f[1] = 0.0;
//   Mid.frame_b.f[2] + B1.frame_a.f[2] = 0.0;
//   Mid.frame_b.f[3] + B1.frame_a.f[3] = 0.0;
//   B1.frame_a.R.w[1] = Mid.frame_b.R.w[1];
//   B1.frame_a.R.w[2] = Mid.frame_b.R.w[2];
//   B1.frame_a.R.w[3] = Mid.frame_b.R.w[3];
//   B1.frame_a.R.T[1,1] = Mid.frame_b.R.T[1,1];
//   B1.frame_a.R.T[1,2] = Mid.frame_b.R.T[1,2];
//   B1.frame_a.R.T[1,3] = Mid.frame_b.R.T[1,3];
//   B1.frame_a.R.T[2,1] = Mid.frame_b.R.T[2,1];
//   B1.frame_a.R.T[2,2] = Mid.frame_b.R.T[2,2];
//   B1.frame_a.R.T[2,3] = Mid.frame_b.R.T[2,3];
//   B1.frame_a.R.T[3,1] = Mid.frame_b.R.T[3,1];
//   B1.frame_a.R.T[3,2] = Mid.frame_b.R.T[3,2];
//   B1.frame_a.R.T[3,3] = Mid.frame_b.R.T[3,3];
//   B1.frame_a.r_0[1] = Mid.frame_b.r_0[1];
//   B1.frame_a.r_0[2] = Mid.frame_b.r_0[2];
//   B1.frame_a.r_0[3] = Mid.frame_b.r_0[3];
//   B1.frame_b.t[1] + (Rod1.frame_a.t[1] + Rod2.frame_a.t[1]) = 0.0;
//   B1.frame_b.t[2] + (Rod1.frame_a.t[2] + Rod2.frame_a.t[2]) = 0.0;
//   B1.frame_b.t[3] + (Rod1.frame_a.t[3] + Rod2.frame_a.t[3]) = 0.0;
//   B1.frame_b.f[1] + (Rod1.frame_a.f[1] + Rod2.frame_a.f[1]) = 0.0;
//   B1.frame_b.f[2] + (Rod1.frame_a.f[2] + Rod2.frame_a.f[2]) = 0.0;
//   B1.frame_b.f[3] + (Rod1.frame_a.f[3] + Rod2.frame_a.f[3]) = 0.0;
//   B1.frame_b.R.w[1] = Rod1.frame_a.R.w[1];
//   B1.frame_b.R.w[1] = Rod2.frame_a.R.w[1];
//   B1.frame_b.R.w[2] = Rod1.frame_a.R.w[2];
//   B1.frame_b.R.w[2] = Rod2.frame_a.R.w[2];
//   B1.frame_b.R.w[3] = Rod1.frame_a.R.w[3];
//   B1.frame_b.R.w[3] = Rod2.frame_a.R.w[3];
//   B1.frame_b.R.T[1,1] = Rod1.frame_a.R.T[1,1];
//   B1.frame_b.R.T[1,1] = Rod2.frame_a.R.T[1,1];
//   B1.frame_b.R.T[1,2] = Rod1.frame_a.R.T[1,2];
//   B1.frame_b.R.T[1,2] = Rod2.frame_a.R.T[1,2];
//   B1.frame_b.R.T[1,3] = Rod1.frame_a.R.T[1,3];
//   B1.frame_b.R.T[1,3] = Rod2.frame_a.R.T[1,3];
//   B1.frame_b.R.T[2,1] = Rod1.frame_a.R.T[2,1];
//   B1.frame_b.R.T[2,1] = Rod2.frame_a.R.T[2,1];
//   B1.frame_b.R.T[2,2] = Rod1.frame_a.R.T[2,2];
//   B1.frame_b.R.T[2,2] = Rod2.frame_a.R.T[2,2];
//   B1.frame_b.R.T[2,3] = Rod1.frame_a.R.T[2,3];
//   B1.frame_b.R.T[2,3] = Rod2.frame_a.R.T[2,3];
//   B1.frame_b.R.T[3,1] = Rod1.frame_a.R.T[3,1];
//   B1.frame_b.R.T[3,1] = Rod2.frame_a.R.T[3,1];
//   B1.frame_b.R.T[3,2] = Rod1.frame_a.R.T[3,2];
//   B1.frame_b.R.T[3,2] = Rod2.frame_a.R.T[3,2];
//   B1.frame_b.R.T[3,3] = Rod1.frame_a.R.T[3,3];
//   B1.frame_b.R.T[3,3] = Rod2.frame_a.R.T[3,3];
//   B1.frame_b.r_0[1] = Rod1.frame_a.r_0[1];
//   B1.frame_b.r_0[1] = Rod2.frame_a.r_0[1];
//   B1.frame_b.r_0[2] = Rod1.frame_a.r_0[2];
//   B1.frame_b.r_0[2] = Rod2.frame_a.r_0[2];
//   B1.frame_b.r_0[3] = Rod1.frame_a.r_0[3];
//   B1.frame_b.r_0[3] = Rod2.frame_a.r_0[3];
//   Piston.frame_a.t[1] + (Cylinder.frame_b.t[1] + Rod3.frame_a.t[1]) = 0.0;
//   Piston.frame_a.t[2] + (Cylinder.frame_b.t[2] + Rod3.frame_a.t[2]) = 0.0;
//   Piston.frame_a.t[3] + (Cylinder.frame_b.t[3] + Rod3.frame_a.t[3]) = 0.0;
//   Piston.frame_a.f[1] + (Cylinder.frame_b.f[1] + Rod3.frame_a.f[1]) = 0.0;
//   Piston.frame_a.f[2] + (Cylinder.frame_b.f[2] + Rod3.frame_a.f[2]) = 0.0;
//   Piston.frame_a.f[3] + (Cylinder.frame_b.f[3] + Rod3.frame_a.f[3]) = 0.0;
//   Cylinder.frame_b.R.w[1] = Piston.frame_a.R.w[1];
//   Cylinder.frame_b.R.w[1] = Rod3.frame_a.R.w[1];
//   Cylinder.frame_b.R.w[2] = Piston.frame_a.R.w[2];
//   Cylinder.frame_b.R.w[2] = Rod3.frame_a.R.w[2];
//   Cylinder.frame_b.R.w[3] = Piston.frame_a.R.w[3];
//   Cylinder.frame_b.R.w[3] = Rod3.frame_a.R.w[3];
//   Cylinder.frame_b.R.T[1,1] = Piston.frame_a.R.T[1,1];
//   Cylinder.frame_b.R.T[1,1] = Rod3.frame_a.R.T[1,1];
//   Cylinder.frame_b.R.T[1,2] = Piston.frame_a.R.T[1,2];
//   Cylinder.frame_b.R.T[1,2] = Rod3.frame_a.R.T[1,2];
//   Cylinder.frame_b.R.T[1,3] = Piston.frame_a.R.T[1,3];
//   Cylinder.frame_b.R.T[1,3] = Rod3.frame_a.R.T[1,3];
//   Cylinder.frame_b.R.T[2,1] = Piston.frame_a.R.T[2,1];
//   Cylinder.frame_b.R.T[2,1] = Rod3.frame_a.R.T[2,1];
//   Cylinder.frame_b.R.T[2,2] = Piston.frame_a.R.T[2,2];
//   Cylinder.frame_b.R.T[2,2] = Rod3.frame_a.R.T[2,2];
//   Cylinder.frame_b.R.T[2,3] = Piston.frame_a.R.T[2,3];
//   Cylinder.frame_b.R.T[2,3] = Rod3.frame_a.R.T[2,3];
//   Cylinder.frame_b.R.T[3,1] = Piston.frame_a.R.T[3,1];
//   Cylinder.frame_b.R.T[3,1] = Rod3.frame_a.R.T[3,1];
//   Cylinder.frame_b.R.T[3,2] = Piston.frame_a.R.T[3,2];
//   Cylinder.frame_b.R.T[3,2] = Rod3.frame_a.R.T[3,2];
//   Cylinder.frame_b.R.T[3,3] = Piston.frame_a.R.T[3,3];
//   Cylinder.frame_b.R.T[3,3] = Rod3.frame_a.R.T[3,3];
//   Cylinder.frame_b.r_0[1] = Piston.frame_a.r_0[1];
//   Cylinder.frame_b.r_0[1] = Rod3.frame_a.r_0[1];
//   Cylinder.frame_b.r_0[2] = Piston.frame_a.r_0[2];
//   Cylinder.frame_b.r_0[2] = Rod3.frame_a.r_0[2];
//   Cylinder.frame_b.r_0[3] = Piston.frame_a.r_0[3];
//   Cylinder.frame_b.r_0[3] = Rod3.frame_a.r_0[3];
//   Cylinder.axis.f + gasForce.flange_b.f = 0.0;
//   Cylinder.axis.s = gasForce.flange_b.s;
//   gasForce.flange_a.f + Cylinder.support.f = 0.0;
//   Cylinder.support.s = gasForce.flange_a.s;
//   cylPosition.frame_b.t[1] + Cylinder.frame_a.t[1] = 0.0;
//   cylPosition.frame_b.t[2] + Cylinder.frame_a.t[2] = 0.0;
//   cylPosition.frame_b.t[3] + Cylinder.frame_a.t[3] = 0.0;
//   cylPosition.frame_b.f[1] + Cylinder.frame_a.f[1] = 0.0;
//   cylPosition.frame_b.f[2] + Cylinder.frame_a.f[2] = 0.0;
//   cylPosition.frame_b.f[3] + Cylinder.frame_a.f[3] = 0.0;
//   Cylinder.frame_a.R.w[1] = cylPosition.frame_b.R.w[1];
//   Cylinder.frame_a.R.w[2] = cylPosition.frame_b.R.w[2];
//   Cylinder.frame_a.R.w[3] = cylPosition.frame_b.R.w[3];
//   Cylinder.frame_a.R.T[1,1] = cylPosition.frame_b.R.T[1,1];
//   Cylinder.frame_a.R.T[1,2] = cylPosition.frame_b.R.T[1,2];
//   Cylinder.frame_a.R.T[1,3] = cylPosition.frame_b.R.T[1,3];
//   Cylinder.frame_a.R.T[2,1] = cylPosition.frame_b.R.T[2,1];
//   Cylinder.frame_a.R.T[2,2] = cylPosition.frame_b.R.T[2,2];
//   Cylinder.frame_a.R.T[2,3] = cylPosition.frame_b.R.T[2,3];
//   Cylinder.frame_a.R.T[3,1] = cylPosition.frame_b.R.T[3,1];
//   Cylinder.frame_a.R.T[3,2] = cylPosition.frame_b.R.T[3,2];
//   Cylinder.frame_a.R.T[3,3] = cylPosition.frame_b.R.T[3,3];
//   Cylinder.frame_a.r_0[1] = cylPosition.frame_b.r_0[1];
//   Cylinder.frame_a.r_0[2] = cylPosition.frame_b.r_0[2];
//   Cylinder.frame_a.r_0[3] = cylPosition.frame_b.r_0[3];
//   B2.frame_a.t[1] + Rod3.frame_b.t[1] = 0.0;
//   B2.frame_a.t[2] + Rod3.frame_b.t[2] = 0.0;
//   B2.frame_a.t[3] + Rod3.frame_b.t[3] = 0.0;
//   B2.frame_a.f[1] + Rod3.frame_b.f[1] = 0.0;
//   B2.frame_a.f[2] + Rod3.frame_b.f[2] = 0.0;
//   B2.frame_a.f[3] + Rod3.frame_b.f[3] = 0.0;
//   B2.frame_a.R.w[1] = Rod3.frame_b.R.w[1];
//   B2.frame_a.R.w[2] = Rod3.frame_b.R.w[2];
//   B2.frame_a.R.w[3] = Rod3.frame_b.R.w[3];
//   B2.frame_a.R.T[1,1] = Rod3.frame_b.R.T[1,1];
//   B2.frame_a.R.T[1,2] = Rod3.frame_b.R.T[1,2];
//   B2.frame_a.R.T[1,3] = Rod3.frame_b.R.T[1,3];
//   B2.frame_a.R.T[2,1] = Rod3.frame_b.R.T[2,1];
//   B2.frame_a.R.T[2,2] = Rod3.frame_b.R.T[2,2];
//   B2.frame_a.R.T[2,3] = Rod3.frame_b.R.T[2,3];
//   B2.frame_a.R.T[3,1] = Rod3.frame_b.R.T[3,1];
//   B2.frame_a.R.T[3,2] = Rod3.frame_b.R.T[3,2];
//   B2.frame_a.R.T[3,3] = Rod3.frame_b.R.T[3,3];
//   B2.frame_a.r_0[1] = Rod3.frame_b.r_0[1];
//   B2.frame_a.r_0[2] = Rod3.frame_b.r_0[2];
//   B2.frame_a.r_0[3] = Rod3.frame_b.r_0[3];
//   Rod1.frame_b.t[1] + B2.frame_b.t[1] = 0.0;
//   Rod1.frame_b.t[2] + B2.frame_b.t[2] = 0.0;
//   Rod1.frame_b.t[3] + B2.frame_b.t[3] = 0.0;
//   Rod1.frame_b.f[1] + B2.frame_b.f[1] = 0.0;
//   Rod1.frame_b.f[2] + B2.frame_b.f[2] = 0.0;
//   Rod1.frame_b.f[3] + B2.frame_b.f[3] = 0.0;
//   B2.frame_b.R.w[1] = Rod1.frame_b.R.w[1];
//   B2.frame_b.R.w[2] = Rod1.frame_b.R.w[2];
//   B2.frame_b.R.w[3] = Rod1.frame_b.R.w[3];
//   B2.frame_b.R.T[1,1] = Rod1.frame_b.R.T[1,1];
//   B2.frame_b.R.T[1,2] = Rod1.frame_b.R.T[1,2];
//   B2.frame_b.R.T[1,3] = Rod1.frame_b.R.T[1,3];
//   B2.frame_b.R.T[2,1] = Rod1.frame_b.R.T[2,1];
//   B2.frame_b.R.T[2,2] = Rod1.frame_b.R.T[2,2];
//   B2.frame_b.R.T[2,3] = Rod1.frame_b.R.T[2,3];
//   B2.frame_b.R.T[3,1] = Rod1.frame_b.R.T[3,1];
//   B2.frame_b.R.T[3,2] = Rod1.frame_b.R.T[3,2];
//   B2.frame_b.R.T[3,3] = Rod1.frame_b.R.T[3,3];
//   B2.frame_b.r_0[1] = Rod1.frame_b.r_0[1];
//   B2.frame_b.r_0[2] = Rod1.frame_b.r_0[2];
//   B2.frame_b.r_0[3] = Rod1.frame_b.r_0[3];
//   Cylinder.internalAxis.flange.f + (-Cylinder.axis.f) = 0.0;
//   Cylinder.axis.s = Cylinder.internalAxis.flange.s;
//   Cylinder.fixed.flange.f + (-Cylinder.support.f) = 0.0;
//   Cylinder.fixed.flange.s = Cylinder.support.s;
//   B1.constantTorque.flange.tau + B1.internalAxis.flange.tau = 0.0;
//   B1.constantTorque.flange.phi = B1.internalAxis.flange.phi;
//   B1.fixed.flange.tau = 0.0;
//   Crank2.frameTranslation.frame_a.t[1] + ((-Crank2.frame_a.t[1]) + Crank2.body.frame_a.t[1]) = 0.0;
//   Crank2.frameTranslation.frame_a.t[2] + ((-Crank2.frame_a.t[2]) + Crank2.body.frame_a.t[2]) = 0.0;
//   Crank2.frameTranslation.frame_a.t[3] + ((-Crank2.frame_a.t[3]) + Crank2.body.frame_a.t[3]) = 0.0;
//   Crank2.frameTranslation.frame_a.f[1] + ((-Crank2.frame_a.f[1]) + Crank2.body.frame_a.f[1]) = 0.0;
//   Crank2.frameTranslation.frame_a.f[2] + ((-Crank2.frame_a.f[2]) + Crank2.body.frame_a.f[2]) = 0.0;
//   Crank2.frameTranslation.frame_a.f[3] + ((-Crank2.frame_a.f[3]) + Crank2.body.frame_a.f[3]) = 0.0;
//   Crank2.body.frame_a.R.w[1] = Crank2.frameTranslation.frame_a.R.w[1];
//   Crank2.body.frame_a.R.w[1] = Crank2.frame_a.R.w[1];
//   Crank2.body.frame_a.R.w[2] = Crank2.frameTranslation.frame_a.R.w[2];
//   Crank2.body.frame_a.R.w[2] = Crank2.frame_a.R.w[2];
//   Crank2.body.frame_a.R.w[3] = Crank2.frameTranslation.frame_a.R.w[3];
//   Crank2.body.frame_a.R.w[3] = Crank2.frame_a.R.w[3];
//   Crank2.body.frame_a.R.T[1,1] = Crank2.frameTranslation.frame_a.R.T[1,1];
//   Crank2.body.frame_a.R.T[1,1] = Crank2.frame_a.R.T[1,1];
//   Crank2.body.frame_a.R.T[1,2] = Crank2.frameTranslation.frame_a.R.T[1,2];
//   Crank2.body.frame_a.R.T[1,2] = Crank2.frame_a.R.T[1,2];
//   Crank2.body.frame_a.R.T[1,3] = Crank2.frameTranslation.frame_a.R.T[1,3];
//   Crank2.body.frame_a.R.T[1,3] = Crank2.frame_a.R.T[1,3];
//   Crank2.body.frame_a.R.T[2,1] = Crank2.frameTranslation.frame_a.R.T[2,1];
//   Crank2.body.frame_a.R.T[2,1] = Crank2.frame_a.R.T[2,1];
//   Crank2.body.frame_a.R.T[2,2] = Crank2.frameTranslation.frame_a.R.T[2,2];
//   Crank2.body.frame_a.R.T[2,2] = Crank2.frame_a.R.T[2,2];
//   Crank2.body.frame_a.R.T[2,3] = Crank2.frameTranslation.frame_a.R.T[2,3];
//   Crank2.body.frame_a.R.T[2,3] = Crank2.frame_a.R.T[2,3];
//   Crank2.body.frame_a.R.T[3,1] = Crank2.frameTranslation.frame_a.R.T[3,1];
//   Crank2.body.frame_a.R.T[3,1] = Crank2.frame_a.R.T[3,1];
//   Crank2.body.frame_a.R.T[3,2] = Crank2.frameTranslation.frame_a.R.T[3,2];
//   Crank2.body.frame_a.R.T[3,2] = Crank2.frame_a.R.T[3,2];
//   Crank2.body.frame_a.R.T[3,3] = Crank2.frameTranslation.frame_a.R.T[3,3];
//   Crank2.body.frame_a.R.T[3,3] = Crank2.frame_a.R.T[3,3];
//   Crank2.body.frame_a.r_0[1] = Crank2.frameTranslation.frame_a.r_0[1];
//   Crank2.body.frame_a.r_0[1] = Crank2.frame_a.r_0[1];
//   Crank2.body.frame_a.r_0[2] = Crank2.frameTranslation.frame_a.r_0[2];
//   Crank2.body.frame_a.r_0[2] = Crank2.frame_a.r_0[2];
//   Crank2.body.frame_a.r_0[3] = Crank2.frameTranslation.frame_a.r_0[3];
//   Crank2.body.frame_a.r_0[3] = Crank2.frame_a.r_0[3];
//   Crank2.frameTranslation.frame_b.t[1] + (-Crank2.frame_b.t[1]) = 0.0;
//   Crank2.frameTranslation.frame_b.t[2] + (-Crank2.frame_b.t[2]) = 0.0;
//   Crank2.frameTranslation.frame_b.t[3] + (-Crank2.frame_b.t[3]) = 0.0;
//   Crank2.frameTranslation.frame_b.f[1] + (-Crank2.frame_b.f[1]) = 0.0;
//   Crank2.frameTranslation.frame_b.f[2] + (-Crank2.frame_b.f[2]) = 0.0;
//   Crank2.frameTranslation.frame_b.f[3] + (-Crank2.frame_b.f[3]) = 0.0;
//   Crank2.frameTranslation.frame_b.R.w[1] = Crank2.frame_b.R.w[1];
//   Crank2.frameTranslation.frame_b.R.w[2] = Crank2.frame_b.R.w[2];
//   Crank2.frameTranslation.frame_b.R.w[3] = Crank2.frame_b.R.w[3];
//   Crank2.frameTranslation.frame_b.R.T[1,1] = Crank2.frame_b.R.T[1,1];
//   Crank2.frameTranslation.frame_b.R.T[1,2] = Crank2.frame_b.R.T[1,2];
//   Crank2.frameTranslation.frame_b.R.T[1,3] = Crank2.frame_b.R.T[1,3];
//   Crank2.frameTranslation.frame_b.R.T[2,1] = Crank2.frame_b.R.T[2,1];
//   Crank2.frameTranslation.frame_b.R.T[2,2] = Crank2.frame_b.R.T[2,2];
//   Crank2.frameTranslation.frame_b.R.T[2,3] = Crank2.frame_b.R.T[2,3];
//   Crank2.frameTranslation.frame_b.R.T[3,1] = Crank2.frame_b.R.T[3,1];
//   Crank2.frameTranslation.frame_b.R.T[3,2] = Crank2.frame_b.R.T[3,2];
//   Crank2.frameTranslation.frame_b.R.T[3,3] = Crank2.frame_b.R.T[3,3];
//   Crank2.frameTranslation.frame_b.r_0[1] = Crank2.frame_b.r_0[1];
//   Crank2.frameTranslation.frame_b.r_0[2] = Crank2.frame_b.r_0[2];
//   Crank2.frameTranslation.frame_b.r_0[3] = Crank2.frame_b.r_0[3];
//   Crank1.frameTranslation.frame_a.t[1] + ((-Crank1.frame_a.t[1]) + Crank1.body.frame_a.t[1]) = 0.0;
//   Crank1.frameTranslation.frame_a.t[2] + ((-Crank1.frame_a.t[2]) + Crank1.body.frame_a.t[2]) = 0.0;
//   Crank1.frameTranslation.frame_a.t[3] + ((-Crank1.frame_a.t[3]) + Crank1.body.frame_a.t[3]) = 0.0;
//   Crank1.frameTranslation.frame_a.f[1] + ((-Crank1.frame_a.f[1]) + Crank1.body.frame_a.f[1]) = 0.0;
//   Crank1.frameTranslation.frame_a.f[2] + ((-Crank1.frame_a.f[2]) + Crank1.body.frame_a.f[2]) = 0.0;
//   Crank1.frameTranslation.frame_a.f[3] + ((-Crank1.frame_a.f[3]) + Crank1.body.frame_a.f[3]) = 0.0;
//   Crank1.body.frame_a.R.w[1] = Crank1.frameTranslation.frame_a.R.w[1];
//   Crank1.body.frame_a.R.w[1] = Crank1.frame_a.R.w[1];
//   Crank1.body.frame_a.R.w[2] = Crank1.frameTranslation.frame_a.R.w[2];
//   Crank1.body.frame_a.R.w[2] = Crank1.frame_a.R.w[2];
//   Crank1.body.frame_a.R.w[3] = Crank1.frameTranslation.frame_a.R.w[3];
//   Crank1.body.frame_a.R.w[3] = Crank1.frame_a.R.w[3];
//   Crank1.body.frame_a.R.T[1,1] = Crank1.frameTranslation.frame_a.R.T[1,1];
//   Crank1.body.frame_a.R.T[1,1] = Crank1.frame_a.R.T[1,1];
//   Crank1.body.frame_a.R.T[1,2] = Crank1.frameTranslation.frame_a.R.T[1,2];
//   Crank1.body.frame_a.R.T[1,2] = Crank1.frame_a.R.T[1,2];
//   Crank1.body.frame_a.R.T[1,3] = Crank1.frameTranslation.frame_a.R.T[1,3];
//   Crank1.body.frame_a.R.T[1,3] = Crank1.frame_a.R.T[1,3];
//   Crank1.body.frame_a.R.T[2,1] = Crank1.frameTranslation.frame_a.R.T[2,1];
//   Crank1.body.frame_a.R.T[2,1] = Crank1.frame_a.R.T[2,1];
//   Crank1.body.frame_a.R.T[2,2] = Crank1.frameTranslation.frame_a.R.T[2,2];
//   Crank1.body.frame_a.R.T[2,2] = Crank1.frame_a.R.T[2,2];
//   Crank1.body.frame_a.R.T[2,3] = Crank1.frameTranslation.frame_a.R.T[2,3];
//   Crank1.body.frame_a.R.T[2,3] = Crank1.frame_a.R.T[2,3];
//   Crank1.body.frame_a.R.T[3,1] = Crank1.frameTranslation.frame_a.R.T[3,1];
//   Crank1.body.frame_a.R.T[3,1] = Crank1.frame_a.R.T[3,1];
//   Crank1.body.frame_a.R.T[3,2] = Crank1.frameTranslation.frame_a.R.T[3,2];
//   Crank1.body.frame_a.R.T[3,2] = Crank1.frame_a.R.T[3,2];
//   Crank1.body.frame_a.R.T[3,3] = Crank1.frameTranslation.frame_a.R.T[3,3];
//   Crank1.body.frame_a.R.T[3,3] = Crank1.frame_a.R.T[3,3];
//   Crank1.body.frame_a.r_0[1] = Crank1.frameTranslation.frame_a.r_0[1];
//   Crank1.body.frame_a.r_0[1] = Crank1.frame_a.r_0[1];
//   Crank1.body.frame_a.r_0[2] = Crank1.frameTranslation.frame_a.r_0[2];
//   Crank1.body.frame_a.r_0[2] = Crank1.frame_a.r_0[2];
//   Crank1.body.frame_a.r_0[3] = Crank1.frameTranslation.frame_a.r_0[3];
//   Crank1.body.frame_a.r_0[3] = Crank1.frame_a.r_0[3];
//   Crank1.frameTranslation.frame_b.t[1] + (-Crank1.frame_b.t[1]) = 0.0;
//   Crank1.frameTranslation.frame_b.t[2] + (-Crank1.frame_b.t[2]) = 0.0;
//   Crank1.frameTranslation.frame_b.t[3] + (-Crank1.frame_b.t[3]) = 0.0;
//   Crank1.frameTranslation.frame_b.f[1] + (-Crank1.frame_b.f[1]) = 0.0;
//   Crank1.frameTranslation.frame_b.f[2] + (-Crank1.frame_b.f[2]) = 0.0;
//   Crank1.frameTranslation.frame_b.f[3] + (-Crank1.frame_b.f[3]) = 0.0;
//   Crank1.frameTranslation.frame_b.R.w[1] = Crank1.frame_b.R.w[1];
//   Crank1.frameTranslation.frame_b.R.w[2] = Crank1.frame_b.R.w[2];
//   Crank1.frameTranslation.frame_b.R.w[3] = Crank1.frame_b.R.w[3];
//   Crank1.frameTranslation.frame_b.R.T[1,1] = Crank1.frame_b.R.T[1,1];
//   Crank1.frameTranslation.frame_b.R.T[1,2] = Crank1.frame_b.R.T[1,2];
//   Crank1.frameTranslation.frame_b.R.T[1,3] = Crank1.frame_b.R.T[1,3];
//   Crank1.frameTranslation.frame_b.R.T[2,1] = Crank1.frame_b.R.T[2,1];
//   Crank1.frameTranslation.frame_b.R.T[2,2] = Crank1.frame_b.R.T[2,2];
//   Crank1.frameTranslation.frame_b.R.T[2,3] = Crank1.frame_b.R.T[2,3];
//   Crank1.frameTranslation.frame_b.R.T[3,1] = Crank1.frame_b.R.T[3,1];
//   Crank1.frameTranslation.frame_b.R.T[3,2] = Crank1.frame_b.R.T[3,2];
//   Crank1.frameTranslation.frame_b.R.T[3,3] = Crank1.frame_b.R.T[3,3];
//   Crank1.frameTranslation.frame_b.r_0[1] = Crank1.frame_b.r_0[1];
//   Crank1.frameTranslation.frame_b.r_0[2] = Crank1.frame_b.r_0[2];
//   Crank1.frameTranslation.frame_b.r_0[3] = Crank1.frame_b.r_0[3];
//   Crank3.frameTranslation.frame_a.t[1] + ((-Crank3.frame_a.t[1]) + Crank3.body.frame_a.t[1]) = 0.0;
//   Crank3.frameTranslation.frame_a.t[2] + ((-Crank3.frame_a.t[2]) + Crank3.body.frame_a.t[2]) = 0.0;
//   Crank3.frameTranslation.frame_a.t[3] + ((-Crank3.frame_a.t[3]) + Crank3.body.frame_a.t[3]) = 0.0;
//   Crank3.frameTranslation.frame_a.f[1] + ((-Crank3.frame_a.f[1]) + Crank3.body.frame_a.f[1]) = 0.0;
//   Crank3.frameTranslation.frame_a.f[2] + ((-Crank3.frame_a.f[2]) + Crank3.body.frame_a.f[2]) = 0.0;
//   Crank3.frameTranslation.frame_a.f[3] + ((-Crank3.frame_a.f[3]) + Crank3.body.frame_a.f[3]) = 0.0;
//   Crank3.body.frame_a.R.w[1] = Crank3.frameTranslation.frame_a.R.w[1];
//   Crank3.body.frame_a.R.w[1] = Crank3.frame_a.R.w[1];
//   Crank3.body.frame_a.R.w[2] = Crank3.frameTranslation.frame_a.R.w[2];
//   Crank3.body.frame_a.R.w[2] = Crank3.frame_a.R.w[2];
//   Crank3.body.frame_a.R.w[3] = Crank3.frameTranslation.frame_a.R.w[3];
//   Crank3.body.frame_a.R.w[3] = Crank3.frame_a.R.w[3];
//   Crank3.body.frame_a.R.T[1,1] = Crank3.frameTranslation.frame_a.R.T[1,1];
//   Crank3.body.frame_a.R.T[1,1] = Crank3.frame_a.R.T[1,1];
//   Crank3.body.frame_a.R.T[1,2] = Crank3.frameTranslation.frame_a.R.T[1,2];
//   Crank3.body.frame_a.R.T[1,2] = Crank3.frame_a.R.T[1,2];
//   Crank3.body.frame_a.R.T[1,3] = Crank3.frameTranslation.frame_a.R.T[1,3];
//   Crank3.body.frame_a.R.T[1,3] = Crank3.frame_a.R.T[1,3];
//   Crank3.body.frame_a.R.T[2,1] = Crank3.frameTranslation.frame_a.R.T[2,1];
//   Crank3.body.frame_a.R.T[2,1] = Crank3.frame_a.R.T[2,1];
//   Crank3.body.frame_a.R.T[2,2] = Crank3.frameTranslation.frame_a.R.T[2,2];
//   Crank3.body.frame_a.R.T[2,2] = Crank3.frame_a.R.T[2,2];
//   Crank3.body.frame_a.R.T[2,3] = Crank3.frameTranslation.frame_a.R.T[2,3];
//   Crank3.body.frame_a.R.T[2,3] = Crank3.frame_a.R.T[2,3];
//   Crank3.body.frame_a.R.T[3,1] = Crank3.frameTranslation.frame_a.R.T[3,1];
//   Crank3.body.frame_a.R.T[3,1] = Crank3.frame_a.R.T[3,1];
//   Crank3.body.frame_a.R.T[3,2] = Crank3.frameTranslation.frame_a.R.T[3,2];
//   Crank3.body.frame_a.R.T[3,2] = Crank3.frame_a.R.T[3,2];
//   Crank3.body.frame_a.R.T[3,3] = Crank3.frameTranslation.frame_a.R.T[3,3];
//   Crank3.body.frame_a.R.T[3,3] = Crank3.frame_a.R.T[3,3];
//   Crank3.body.frame_a.r_0[1] = Crank3.frameTranslation.frame_a.r_0[1];
//   Crank3.body.frame_a.r_0[1] = Crank3.frame_a.r_0[1];
//   Crank3.body.frame_a.r_0[2] = Crank3.frameTranslation.frame_a.r_0[2];
//   Crank3.body.frame_a.r_0[2] = Crank3.frame_a.r_0[2];
//   Crank3.body.frame_a.r_0[3] = Crank3.frameTranslation.frame_a.r_0[3];
//   Crank3.body.frame_a.r_0[3] = Crank3.frame_a.r_0[3];
//   Crank3.frameTranslation.frame_b.t[1] + (-Crank3.frame_b.t[1]) = 0.0;
//   Crank3.frameTranslation.frame_b.t[2] + (-Crank3.frame_b.t[2]) = 0.0;
//   Crank3.frameTranslation.frame_b.t[3] + (-Crank3.frame_b.t[3]) = 0.0;
//   Crank3.frameTranslation.frame_b.f[1] + (-Crank3.frame_b.f[1]) = 0.0;
//   Crank3.frameTranslation.frame_b.f[2] + (-Crank3.frame_b.f[2]) = 0.0;
//   Crank3.frameTranslation.frame_b.f[3] + (-Crank3.frame_b.f[3]) = 0.0;
//   Crank3.frameTranslation.frame_b.R.w[1] = Crank3.frame_b.R.w[1];
//   Crank3.frameTranslation.frame_b.R.w[2] = Crank3.frame_b.R.w[2];
//   Crank3.frameTranslation.frame_b.R.w[3] = Crank3.frame_b.R.w[3];
//   Crank3.frameTranslation.frame_b.R.T[1,1] = Crank3.frame_b.R.T[1,1];
//   Crank3.frameTranslation.frame_b.R.T[1,2] = Crank3.frame_b.R.T[1,2];
//   Crank3.frameTranslation.frame_b.R.T[1,3] = Crank3.frame_b.R.T[1,3];
//   Crank3.frameTranslation.frame_b.R.T[2,1] = Crank3.frame_b.R.T[2,1];
//   Crank3.frameTranslation.frame_b.R.T[2,2] = Crank3.frame_b.R.T[2,2];
//   Crank3.frameTranslation.frame_b.R.T[2,3] = Crank3.frame_b.R.T[2,3];
//   Crank3.frameTranslation.frame_b.R.T[3,1] = Crank3.frame_b.R.T[3,1];
//   Crank3.frameTranslation.frame_b.R.T[3,2] = Crank3.frame_b.R.T[3,2];
//   Crank3.frameTranslation.frame_b.R.T[3,3] = Crank3.frame_b.R.T[3,3];
//   Crank3.frameTranslation.frame_b.r_0[1] = Crank3.frame_b.r_0[1];
//   Crank3.frameTranslation.frame_b.r_0[2] = Crank3.frame_b.r_0[2];
//   Crank3.frameTranslation.frame_b.r_0[3] = Crank3.frame_b.r_0[3];
//   Crank4.frameTranslation.frame_a.t[1] + ((-Crank4.frame_a.t[1]) + Crank4.body.frame_a.t[1]) = 0.0;
//   Crank4.frameTranslation.frame_a.t[2] + ((-Crank4.frame_a.t[2]) + Crank4.body.frame_a.t[2]) = 0.0;
//   Crank4.frameTranslation.frame_a.t[3] + ((-Crank4.frame_a.t[3]) + Crank4.body.frame_a.t[3]) = 0.0;
//   Crank4.frameTranslation.frame_a.f[1] + ((-Crank4.frame_a.f[1]) + Crank4.body.frame_a.f[1]) = 0.0;
//   Crank4.frameTranslation.frame_a.f[2] + ((-Crank4.frame_a.f[2]) + Crank4.body.frame_a.f[2]) = 0.0;
//   Crank4.frameTranslation.frame_a.f[3] + ((-Crank4.frame_a.f[3]) + Crank4.body.frame_a.f[3]) = 0.0;
//   Crank4.body.frame_a.R.w[1] = Crank4.frameTranslation.frame_a.R.w[1];
//   Crank4.body.frame_a.R.w[1] = Crank4.frame_a.R.w[1];
//   Crank4.body.frame_a.R.w[2] = Crank4.frameTranslation.frame_a.R.w[2];
//   Crank4.body.frame_a.R.w[2] = Crank4.frame_a.R.w[2];
//   Crank4.body.frame_a.R.w[3] = Crank4.frameTranslation.frame_a.R.w[3];
//   Crank4.body.frame_a.R.w[3] = Crank4.frame_a.R.w[3];
//   Crank4.body.frame_a.R.T[1,1] = Crank4.frameTranslation.frame_a.R.T[1,1];
//   Crank4.body.frame_a.R.T[1,1] = Crank4.frame_a.R.T[1,1];
//   Crank4.body.frame_a.R.T[1,2] = Crank4.frameTranslation.frame_a.R.T[1,2];
//   Crank4.body.frame_a.R.T[1,2] = Crank4.frame_a.R.T[1,2];
//   Crank4.body.frame_a.R.T[1,3] = Crank4.frameTranslation.frame_a.R.T[1,3];
//   Crank4.body.frame_a.R.T[1,3] = Crank4.frame_a.R.T[1,3];
//   Crank4.body.frame_a.R.T[2,1] = Crank4.frameTranslation.frame_a.R.T[2,1];
//   Crank4.body.frame_a.R.T[2,1] = Crank4.frame_a.R.T[2,1];
//   Crank4.body.frame_a.R.T[2,2] = Crank4.frameTranslation.frame_a.R.T[2,2];
//   Crank4.body.frame_a.R.T[2,2] = Crank4.frame_a.R.T[2,2];
//   Crank4.body.frame_a.R.T[2,3] = Crank4.frameTranslation.frame_a.R.T[2,3];
//   Crank4.body.frame_a.R.T[2,3] = Crank4.frame_a.R.T[2,3];
//   Crank4.body.frame_a.R.T[3,1] = Crank4.frameTranslation.frame_a.R.T[3,1];
//   Crank4.body.frame_a.R.T[3,1] = Crank4.frame_a.R.T[3,1];
//   Crank4.body.frame_a.R.T[3,2] = Crank4.frameTranslation.frame_a.R.T[3,2];
//   Crank4.body.frame_a.R.T[3,2] = Crank4.frame_a.R.T[3,2];
//   Crank4.body.frame_a.R.T[3,3] = Crank4.frameTranslation.frame_a.R.T[3,3];
//   Crank4.body.frame_a.R.T[3,3] = Crank4.frame_a.R.T[3,3];
//   Crank4.body.frame_a.r_0[1] = Crank4.frameTranslation.frame_a.r_0[1];
//   Crank4.body.frame_a.r_0[1] = Crank4.frame_a.r_0[1];
//   Crank4.body.frame_a.r_0[2] = Crank4.frameTranslation.frame_a.r_0[2];
//   Crank4.body.frame_a.r_0[2] = Crank4.frame_a.r_0[2];
//   Crank4.body.frame_a.r_0[3] = Crank4.frameTranslation.frame_a.r_0[3];
//   Crank4.body.frame_a.r_0[3] = Crank4.frame_a.r_0[3];
//   Crank4.frameTranslation.frame_b.t[1] + (-Crank4.frame_b.t[1]) = 0.0;
//   Crank4.frameTranslation.frame_b.t[2] + (-Crank4.frame_b.t[2]) = 0.0;
//   Crank4.frameTranslation.frame_b.t[3] + (-Crank4.frame_b.t[3]) = 0.0;
//   Crank4.frameTranslation.frame_b.f[1] + (-Crank4.frame_b.f[1]) = 0.0;
//   Crank4.frameTranslation.frame_b.f[2] + (-Crank4.frame_b.f[2]) = 0.0;
//   Crank4.frameTranslation.frame_b.f[3] + (-Crank4.frame_b.f[3]) = 0.0;
//   Crank4.frameTranslation.frame_b.R.w[1] = Crank4.frame_b.R.w[1];
//   Crank4.frameTranslation.frame_b.R.w[2] = Crank4.frame_b.R.w[2];
//   Crank4.frameTranslation.frame_b.R.w[3] = Crank4.frame_b.R.w[3];
//   Crank4.frameTranslation.frame_b.R.T[1,1] = Crank4.frame_b.R.T[1,1];
//   Crank4.frameTranslation.frame_b.R.T[1,2] = Crank4.frame_b.R.T[1,2];
//   Crank4.frameTranslation.frame_b.R.T[1,3] = Crank4.frame_b.R.T[1,3];
//   Crank4.frameTranslation.frame_b.R.T[2,1] = Crank4.frame_b.R.T[2,1];
//   Crank4.frameTranslation.frame_b.R.T[2,2] = Crank4.frame_b.R.T[2,2];
//   Crank4.frameTranslation.frame_b.R.T[2,3] = Crank4.frame_b.R.T[2,3];
//   Crank4.frameTranslation.frame_b.R.T[3,1] = Crank4.frame_b.R.T[3,1];
//   Crank4.frameTranslation.frame_b.R.T[3,2] = Crank4.frame_b.R.T[3,2];
//   Crank4.frameTranslation.frame_b.R.T[3,3] = Crank4.frame_b.R.T[3,3];
//   Crank4.frameTranslation.frame_b.r_0[1] = Crank4.frame_b.r_0[1];
//   Crank4.frameTranslation.frame_b.r_0[2] = Crank4.frame_b.r_0[2];
//   Crank4.frameTranslation.frame_b.r_0[3] = Crank4.frame_b.r_0[3];
//   Crank4.frame_b.t[3] = 0.0;
//   Crank4.frame_b.t[2] = 0.0;
//   Crank4.frame_b.t[1] = 0.0;
//   Crank4.frame_b.f[3] = 0.0;
//   Crank4.frame_b.f[2] = 0.0;
//   Crank4.frame_b.f[1] = 0.0;
//   Inertia.flange_a.tau = 0.0;
//   Bearing.internalAxis.flange.tau + (-Bearing.axis.tau) = 0.0;
//   Bearing.axis.phi = Bearing.internalAxis.flange.phi;
//   Bearing.fixed.flange.tau + (-Bearing.support.tau) = 0.0;
//   Bearing.fixed.flange.phi = Bearing.support.phi;
//   Bearing.support.tau = 0.0;
//   Rod2.frameTranslation.frame_a.t[1] + ((-Rod2.frame_a.t[1]) + Rod2.body.frame_a.t[1]) = 0.0;
//   Rod2.frameTranslation.frame_a.t[2] + ((-Rod2.frame_a.t[2]) + Rod2.body.frame_a.t[2]) = 0.0;
//   Rod2.frameTranslation.frame_a.t[3] + ((-Rod2.frame_a.t[3]) + Rod2.body.frame_a.t[3]) = 0.0;
//   Rod2.frameTranslation.frame_a.f[1] + ((-Rod2.frame_a.f[1]) + Rod2.body.frame_a.f[1]) = 0.0;
//   Rod2.frameTranslation.frame_a.f[2] + ((-Rod2.frame_a.f[2]) + Rod2.body.frame_a.f[2]) = 0.0;
//   Rod2.frameTranslation.frame_a.f[3] + ((-Rod2.frame_a.f[3]) + Rod2.body.frame_a.f[3]) = 0.0;
//   Rod2.body.frame_a.R.w[1] = Rod2.frameTranslation.frame_a.R.w[1];
//   Rod2.body.frame_a.R.w[1] = Rod2.frame_a.R.w[1];
//   Rod2.body.frame_a.R.w[2] = Rod2.frameTranslation.frame_a.R.w[2];
//   Rod2.body.frame_a.R.w[2] = Rod2.frame_a.R.w[2];
//   Rod2.body.frame_a.R.w[3] = Rod2.frameTranslation.frame_a.R.w[3];
//   Rod2.body.frame_a.R.w[3] = Rod2.frame_a.R.w[3];
//   Rod2.body.frame_a.R.T[1,1] = Rod2.frameTranslation.frame_a.R.T[1,1];
//   Rod2.body.frame_a.R.T[1,1] = Rod2.frame_a.R.T[1,1];
//   Rod2.body.frame_a.R.T[1,2] = Rod2.frameTranslation.frame_a.R.T[1,2];
//   Rod2.body.frame_a.R.T[1,2] = Rod2.frame_a.R.T[1,2];
//   Rod2.body.frame_a.R.T[1,3] = Rod2.frameTranslation.frame_a.R.T[1,3];
//   Rod2.body.frame_a.R.T[1,3] = Rod2.frame_a.R.T[1,3];
//   Rod2.body.frame_a.R.T[2,1] = Rod2.frameTranslation.frame_a.R.T[2,1];
//   Rod2.body.frame_a.R.T[2,1] = Rod2.frame_a.R.T[2,1];
//   Rod2.body.frame_a.R.T[2,2] = Rod2.frameTranslation.frame_a.R.T[2,2];
//   Rod2.body.frame_a.R.T[2,2] = Rod2.frame_a.R.T[2,2];
//   Rod2.body.frame_a.R.T[2,3] = Rod2.frameTranslation.frame_a.R.T[2,3];
//   Rod2.body.frame_a.R.T[2,3] = Rod2.frame_a.R.T[2,3];
//   Rod2.body.frame_a.R.T[3,1] = Rod2.frameTranslation.frame_a.R.T[3,1];
//   Rod2.body.frame_a.R.T[3,1] = Rod2.frame_a.R.T[3,1];
//   Rod2.body.frame_a.R.T[3,2] = Rod2.frameTranslation.frame_a.R.T[3,2];
//   Rod2.body.frame_a.R.T[3,2] = Rod2.frame_a.R.T[3,2];
//   Rod2.body.frame_a.R.T[3,3] = Rod2.frameTranslation.frame_a.R.T[3,3];
//   Rod2.body.frame_a.R.T[3,3] = Rod2.frame_a.R.T[3,3];
//   Rod2.body.frame_a.r_0[1] = Rod2.frameTranslation.frame_a.r_0[1];
//   Rod2.body.frame_a.r_0[1] = Rod2.frame_a.r_0[1];
//   Rod2.body.frame_a.r_0[2] = Rod2.frameTranslation.frame_a.r_0[2];
//   Rod2.body.frame_a.r_0[2] = Rod2.frame_a.r_0[2];
//   Rod2.body.frame_a.r_0[3] = Rod2.frameTranslation.frame_a.r_0[3];
//   Rod2.body.frame_a.r_0[3] = Rod2.frame_a.r_0[3];
//   Rod2.frameTranslation.frame_b.t[1] + (-Rod2.frame_b.t[1]) = 0.0;
//   Rod2.frameTranslation.frame_b.t[2] + (-Rod2.frame_b.t[2]) = 0.0;
//   Rod2.frameTranslation.frame_b.t[3] + (-Rod2.frame_b.t[3]) = 0.0;
//   Rod2.frameTranslation.frame_b.f[1] + (-Rod2.frame_b.f[1]) = 0.0;
//   Rod2.frameTranslation.frame_b.f[2] + (-Rod2.frame_b.f[2]) = 0.0;
//   Rod2.frameTranslation.frame_b.f[3] + (-Rod2.frame_b.f[3]) = 0.0;
//   Rod2.frameTranslation.frame_b.R.w[1] = Rod2.frame_b.R.w[1];
//   Rod2.frameTranslation.frame_b.R.w[2] = Rod2.frame_b.R.w[2];
//   Rod2.frameTranslation.frame_b.R.w[3] = Rod2.frame_b.R.w[3];
//   Rod2.frameTranslation.frame_b.R.T[1,1] = Rod2.frame_b.R.T[1,1];
//   Rod2.frameTranslation.frame_b.R.T[1,2] = Rod2.frame_b.R.T[1,2];
//   Rod2.frameTranslation.frame_b.R.T[1,3] = Rod2.frame_b.R.T[1,3];
//   Rod2.frameTranslation.frame_b.R.T[2,1] = Rod2.frame_b.R.T[2,1];
//   Rod2.frameTranslation.frame_b.R.T[2,2] = Rod2.frame_b.R.T[2,2];
//   Rod2.frameTranslation.frame_b.R.T[2,3] = Rod2.frame_b.R.T[2,3];
//   Rod2.frameTranslation.frame_b.R.T[3,1] = Rod2.frame_b.R.T[3,1];
//   Rod2.frameTranslation.frame_b.R.T[3,2] = Rod2.frame_b.R.T[3,2];
//   Rod2.frameTranslation.frame_b.R.T[3,3] = Rod2.frame_b.R.T[3,3];
//   Rod2.frameTranslation.frame_b.r_0[1] = Rod2.frame_b.r_0[1];
//   Rod2.frameTranslation.frame_b.r_0[2] = Rod2.frame_b.r_0[2];
//   Rod2.frameTranslation.frame_b.r_0[3] = Rod2.frame_b.r_0[3];
//   Rod2.frame_b.t[3] = 0.0;
//   Rod2.frame_b.t[2] = 0.0;
//   Rod2.frame_b.t[1] = 0.0;
//   Rod2.frame_b.f[3] = 0.0;
//   Rod2.frame_b.f[2] = 0.0;
//   Rod2.frame_b.f[1] = 0.0;
//   Piston.frameTranslation.frame_a.t[1] + ((-Piston.frame_a.t[1]) + Piston.body.frame_a.t[1]) = 0.0;
//   Piston.frameTranslation.frame_a.t[2] + ((-Piston.frame_a.t[2]) + Piston.body.frame_a.t[2]) = 0.0;
//   Piston.frameTranslation.frame_a.t[3] + ((-Piston.frame_a.t[3]) + Piston.body.frame_a.t[3]) = 0.0;
//   Piston.frameTranslation.frame_a.f[1] + ((-Piston.frame_a.f[1]) + Piston.body.frame_a.f[1]) = 0.0;
//   Piston.frameTranslation.frame_a.f[2] + ((-Piston.frame_a.f[2]) + Piston.body.frame_a.f[2]) = 0.0;
//   Piston.frameTranslation.frame_a.f[3] + ((-Piston.frame_a.f[3]) + Piston.body.frame_a.f[3]) = 0.0;
//   Piston.body.frame_a.R.w[1] = Piston.frameTranslation.frame_a.R.w[1];
//   Piston.body.frame_a.R.w[1] = Piston.frame_a.R.w[1];
//   Piston.body.frame_a.R.w[2] = Piston.frameTranslation.frame_a.R.w[2];
//   Piston.body.frame_a.R.w[2] = Piston.frame_a.R.w[2];
//   Piston.body.frame_a.R.w[3] = Piston.frameTranslation.frame_a.R.w[3];
//   Piston.body.frame_a.R.w[3] = Piston.frame_a.R.w[3];
//   Piston.body.frame_a.R.T[1,1] = Piston.frameTranslation.frame_a.R.T[1,1];
//   Piston.body.frame_a.R.T[1,1] = Piston.frame_a.R.T[1,1];
//   Piston.body.frame_a.R.T[1,2] = Piston.frameTranslation.frame_a.R.T[1,2];
//   Piston.body.frame_a.R.T[1,2] = Piston.frame_a.R.T[1,2];
//   Piston.body.frame_a.R.T[1,3] = Piston.frameTranslation.frame_a.R.T[1,3];
//   Piston.body.frame_a.R.T[1,3] = Piston.frame_a.R.T[1,3];
//   Piston.body.frame_a.R.T[2,1] = Piston.frameTranslation.frame_a.R.T[2,1];
//   Piston.body.frame_a.R.T[2,1] = Piston.frame_a.R.T[2,1];
//   Piston.body.frame_a.R.T[2,2] = Piston.frameTranslation.frame_a.R.T[2,2];
//   Piston.body.frame_a.R.T[2,2] = Piston.frame_a.R.T[2,2];
//   Piston.body.frame_a.R.T[2,3] = Piston.frameTranslation.frame_a.R.T[2,3];
//   Piston.body.frame_a.R.T[2,3] = Piston.frame_a.R.T[2,3];
//   Piston.body.frame_a.R.T[3,1] = Piston.frameTranslation.frame_a.R.T[3,1];
//   Piston.body.frame_a.R.T[3,1] = Piston.frame_a.R.T[3,1];
//   Piston.body.frame_a.R.T[3,2] = Piston.frameTranslation.frame_a.R.T[3,2];
//   Piston.body.frame_a.R.T[3,2] = Piston.frame_a.R.T[3,2];
//   Piston.body.frame_a.R.T[3,3] = Piston.frameTranslation.frame_a.R.T[3,3];
//   Piston.body.frame_a.R.T[3,3] = Piston.frame_a.R.T[3,3];
//   Piston.body.frame_a.r_0[1] = Piston.frameTranslation.frame_a.r_0[1];
//   Piston.body.frame_a.r_0[1] = Piston.frame_a.r_0[1];
//   Piston.body.frame_a.r_0[2] = Piston.frameTranslation.frame_a.r_0[2];
//   Piston.body.frame_a.r_0[2] = Piston.frame_a.r_0[2];
//   Piston.body.frame_a.r_0[3] = Piston.frameTranslation.frame_a.r_0[3];
//   Piston.body.frame_a.r_0[3] = Piston.frame_a.r_0[3];
//   Piston.frameTranslation.frame_b.t[1] + (-Piston.frame_b.t[1]) = 0.0;
//   Piston.frameTranslation.frame_b.t[2] + (-Piston.frame_b.t[2]) = 0.0;
//   Piston.frameTranslation.frame_b.t[3] + (-Piston.frame_b.t[3]) = 0.0;
//   Piston.frameTranslation.frame_b.f[1] + (-Piston.frame_b.f[1]) = 0.0;
//   Piston.frameTranslation.frame_b.f[2] + (-Piston.frame_b.f[2]) = 0.0;
//   Piston.frameTranslation.frame_b.f[3] + (-Piston.frame_b.f[3]) = 0.0;
//   Piston.frameTranslation.frame_b.R.w[1] = Piston.frame_b.R.w[1];
//   Piston.frameTranslation.frame_b.R.w[2] = Piston.frame_b.R.w[2];
//   Piston.frameTranslation.frame_b.R.w[3] = Piston.frame_b.R.w[3];
//   Piston.frameTranslation.frame_b.R.T[1,1] = Piston.frame_b.R.T[1,1];
//   Piston.frameTranslation.frame_b.R.T[1,2] = Piston.frame_b.R.T[1,2];
//   Piston.frameTranslation.frame_b.R.T[1,3] = Piston.frame_b.R.T[1,3];
//   Piston.frameTranslation.frame_b.R.T[2,1] = Piston.frame_b.R.T[2,1];
//   Piston.frameTranslation.frame_b.R.T[2,2] = Piston.frame_b.R.T[2,2];
//   Piston.frameTranslation.frame_b.R.T[2,3] = Piston.frame_b.R.T[2,3];
//   Piston.frameTranslation.frame_b.R.T[3,1] = Piston.frame_b.R.T[3,1];
//   Piston.frameTranslation.frame_b.R.T[3,2] = Piston.frame_b.R.T[3,2];
//   Piston.frameTranslation.frame_b.R.T[3,3] = Piston.frame_b.R.T[3,3];
//   Piston.frameTranslation.frame_b.r_0[1] = Piston.frame_b.r_0[1];
//   Piston.frameTranslation.frame_b.r_0[2] = Piston.frame_b.r_0[2];
//   Piston.frameTranslation.frame_b.r_0[3] = Piston.frame_b.r_0[3];
//   Piston.frame_b.t[3] = 0.0;
//   Piston.frame_b.t[2] = 0.0;
//   Piston.frame_b.t[1] = 0.0;
//   Piston.frame_b.f[3] = 0.0;
//   Piston.frame_b.f[2] = 0.0;
//   Piston.frame_b.f[1] = 0.0;
// end Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b;
// "
// "[_LoopsTotal.mo:1407:15-1414:38:writable] Warning: Component Inertia has the same name as its type Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b.Modelica.Mechanics.Rotational.Components.Inertia.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// "
// "Check of Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b completed successfully.
// 
// [_LoopsTotal.mo:1407:15-1414:38:writable] Warning: Component Inertia has the same name as its type Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b.Modelica.Mechanics.Rotational.Components.Inertia.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// 
// Class Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b has 3136 equation(s) and 3136 variable(s).
// 2003 of these are trivial equation(s).
// "
// ""
// endResult
